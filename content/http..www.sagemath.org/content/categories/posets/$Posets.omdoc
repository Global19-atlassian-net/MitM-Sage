<omdoc xmlns="http://omdoc.org/ns" xmlns:om="http://www.openmath.org/OpenMath"><theory name="Posets" base="http://www.sagemath.org/content/categories/posets" meta="http://www.sagemath.org/?Types"><import from="http://www.sagemath.org/?Axioms"></import><import from="http://www.sagemath.org/?Structures"></import><import from="http://www.sagemath.org/content/categories/sets_cat?Sets"></import><constant name="sage.categories.posets.Posets">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMA>
              <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="apply"></om:OMS>
              <om:OMS base="http://www.sagemath.org/" module="Types" name="structureof"></om:OMS><om:OMS base="http://www.sagemath.org/" module="Structures" name="sage.categories.posets.Posets"></om:OMS>
      </om:OMA></om:OMOBJ></type>
       
       
     </constant><document name="Element Methods"></document><document name="Morphism Methods:"><opaque format="text">
    The category of posets i.e. sets with a partial order structure.

    EXAMPLES::

        sage: Posets()
        Category of posets
        sage: Posets().super_categories()
        [Category of sets]
        sage: P = Posets().example(); P
        An example of a poset: sets ordered by inclusion

    The partial order is implemented by the mandatory method
    :meth:`~Posets.ParentMethods.le`::

        sage: x = P(Set([1,3])); y = P(Set([1,2,3]))
        sage: x, y
        ({1, 3}, {1, 2, 3})
        sage: P.le(x, y)
        True
        sage: P.le(x, x)
        True
        sage: P.le(y, x)
        False

    The other comparison methods are called
    :meth:`~Posets.ParentMethods.lt`, :meth:`~Posets.ParentMethods.ge`,
    :meth:`~Posets.ParentMethods.gt`, following Python's naming
    convention in :mod:`operator`. Default implementations are
    provided::

        sage: P.lt(x, x)
        False
        sage: P.ge(y, x)
        True

    Unless the poset is a facade (see :class:`Sets.Facade`), one can
    compare directly its elements using the usual Python operators::

        sage: D = Poset((divisors(30), attrcall(&quot;divides&quot;)), facade = False)
        sage: D(3) &lt;= D(6)
        True
        sage: D(3) &lt;= D(3)
        True
        sage: D(3) &lt;= D(5)
        False
        sage: D(3) &lt; D(3)
        False
        sage: D(10) &gt;= D(5)
        True

    At this point, this has to be implemented by hand. Once
    :trac:`10130` will be resolved, this will be automatically
    provided by this category::

        sage: x &lt; y      # todo: not implemented
        True
        sage: x &lt; x      # todo: not implemented
        False
        sage: x &lt;= x     # todo: not implemented
        True
        sage: y &gt;= x     # todo: not implemented
        True

    .. seealso:: :func:`Poset`, :class:`FinitePosets`, :class:`LatticePosets`

    TESTS::

        sage: C = Posets()
        sage: TestSuite(C).run()

    </opaque></document><document name="Parent Methods:"><constant name="parent.directed_subset">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return the order filter or the order ideal generated by a
            list of elements.

            If ``direction`` is 'up', the order filter (upper set) is
            being returned.

            If ``direction`` is 'down', the order ideal (lower set) is
            being returned.

            INPUT:

            - elements -- a list of elements.

            - direction -- 'up' or 'down'.

            EXAMPLES::

                sage: B = Posets.BooleanLattice(4)
                sage: B.directed_subset([3, 8], 'up')
                [3, 7, 8, 9, 10, 11, 12, 13, 14, 15]
                sage: B.directed_subset([7, 10], 'down')
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 10]
            </opaque><constant name="parent.ge">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return whether `x \ge y` in the poset ``self``.

            INPUT:

            - ``x``, ``y`` -- elements of ``self``.

            This default implementation delegates the work to :meth:`le`.

            EXAMPLES::

                sage: D = Poset((divisors(30), attrcall(&quot;divides&quot;)))
                sage: D.ge( 6, 3 )
                True
                sage: D.ge( 3, 3 )
                True
                sage: D.ge( 3, 5 )
                False
            </opaque><constant name="parent.gt">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return whether `x &gt; y` in the poset ``self``.

            INPUT:

            - ``x``, ``y`` -- elements of ``self``.

            This default implementation delegates the work to :meth:`lt`.

            EXAMPLES::

                sage: D = Poset((divisors(30), attrcall(&quot;divides&quot;)))
                sage: D.gt( 3, 6 )
                False
                sage: D.gt( 3, 3 )
                False
                sage: D.gt( 3, 5 )
                False
            </opaque><constant name="parent.is_antichain_of_poset">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return whether an iterable ``o`` is an antichain of
            ``self``.

            INPUT:

            - ``o`` -- an iterable (e. g., list, set, or tuple)
              containing some elements of ``self``

            OUTPUT:

            ``True`` if the subset of ``self`` consisting of the entries
            of ``o`` is an antichain of ``self``, and ``False`` otherwise.

            EXAMPLES::

                sage: P = Poset((divisors(12), attrcall(&quot;divides&quot;)), facade=True, linear_extension=True)
                sage: sorted(P.list())
                [1, 2, 3, 4, 6, 12]
                sage: P.is_antichain_of_poset([1, 3])
                False
                sage: P.is_antichain_of_poset([3, 1])
                False
                sage: P.is_antichain_of_poset([1, 1, 3])
                False
                sage: P.is_antichain_of_poset([])
                True
                sage: P.is_antichain_of_poset([1])
                True
                sage: P.is_antichain_of_poset([1, 1])
                True
                sage: P.is_antichain_of_poset([3, 4])
                True
                sage: P.is_antichain_of_poset([3, 4, 12])
                False
                sage: P.is_antichain_of_poset([6, 4])
                True
                sage: P.is_antichain_of_poset(i for i in divisors(12) if (2 &lt; i and i &lt; 6))
                True
                sage: P.is_antichain_of_poset(i for i in divisors(12) if (2 &lt;= i and i &lt; 6))
                False

                sage: Q = Poset({2: [3, 1], 3: [4], 1: [4]})
                sage: Q.is_antichain_of_poset((1, 2))
                False
                sage: Q.is_antichain_of_poset((2, 4))
                False
                sage: Q.is_antichain_of_poset((4, 2))
                False
                sage: Q.is_antichain_of_poset((2, 2))
                True
                sage: Q.is_antichain_of_poset((3, 4))
                False
                sage: Q.is_antichain_of_poset((3, 1))
                True
                sage: Q.is_antichain_of_poset((1, ))
                True
                sage: Q.is_antichain_of_poset(())
                True

            An infinite poset::

                sage: from sage.categories.examples.posets import FiniteSetsOrderedByInclusion
                sage: R = FiniteSetsOrderedByInclusion()
                sage: R.is_antichain_of_poset([R(set([3, 1, 2])), R(set([1, 4])), R(set([4, 5]))])
                True
                sage: R.is_antichain_of_poset([R(set([3, 1, 2, 4])), R(set([1, 4])), R(set([4, 5]))])
                False
            </opaque><constant name="parent.is_chain_of_poset">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return whether an iterable ``o`` is a chain of ``self``,
            including a check for ``o`` being ordered from smallest
            to largest element if the keyword ``ordered`` is set to
            ``True``.

            INPUT:

            - ``o`` -- an iterable (e. g., list, set, or tuple)
              containing some elements of ``self``

            - ``ordered`` -- a Boolean (default: ``False``) which
              decides whether the notion of a chain includes being
              ordered

            OUTPUT:

            If ``ordered`` is set to ``False``, the truth value of
            the following assertion is returned: The subset of ``self``
            formed by the elements of ``o`` is a chain in ``self``.

            If ``ordered`` is set to ``True``, the truth value of
            the following assertion is returned: Every element of the
            list ``o`` is (strictly!) smaller than its successor in
            ``self``. (This makes no sense if ``ordered`` is a set.)

            EXAMPLES::

                sage: P = Poset((divisors(12), attrcall(&quot;divides&quot;)), facade=True, linear_extension=True)
                sage: sorted(P.list())
                [1, 2, 3, 4, 6, 12]
                sage: P.is_chain_of_poset([1, 3])
                True
                sage: P.is_chain_of_poset([3, 1])
                True
                sage: P.is_chain_of_poset([1, 3], ordered=True)
                True
                sage: P.is_chain_of_poset([3, 1], ordered=True)
                False
                sage: P.is_chain_of_poset([])
                True
                sage: P.is_chain_of_poset([], ordered=True)
                True
                sage: P.is_chain_of_poset((2, 12, 6))
                True
                sage: P.is_chain_of_poset((2, 6, 12), ordered=True)
                True
                sage: P.is_chain_of_poset((2, 12, 6), ordered=True)
                False
                sage: P.is_chain_of_poset((2, 12, 6, 3))
                False
                sage: P.is_chain_of_poset((2, 3))
                False

                sage: Q = Poset({2: [3, 1], 3: [4], 1: [4]})
                sage: Q.is_chain_of_poset([1, 2], ordered=True)
                False
                sage: Q.is_chain_of_poset([1, 2])
                True
                sage: Q.is_chain_of_poset([2, 1], ordered=True)
                True
                sage: Q.is_chain_of_poset([2, 1, 1], ordered=True)
                False
                sage: Q.is_chain_of_poset([3])
                True
                sage: Q.is_chain_of_poset([4, 2, 3])
                True
                sage: Q.is_chain_of_poset([4, 2, 3], ordered=True)
                False
                sage: Q.is_chain_of_poset([2, 3, 4], ordered=True)
                True

            Examples with infinite posets::

                sage: from sage.categories.examples.posets import FiniteSetsOrderedByInclusion
                sage: R = FiniteSetsOrderedByInclusion()
                sage: R.is_chain_of_poset([R(set([3, 1, 2])), R(set([1, 4])), R(set([4, 5]))])
                False
                sage: R.is_chain_of_poset([R(set([3, 1, 2])), R(set([1, 2])), R(set([1]))], ordered=True)
                False
                sage: R.is_chain_of_poset([R(set([3, 1, 2])), R(set([1, 2])), R(set([1]))])
                True

                sage: from sage.categories.examples.posets import PositiveIntegersOrderedByDivisibilityFacade
                sage: T = PositiveIntegersOrderedByDivisibilityFacade()
                sage: T.is_chain_of_poset((T(3), T(4), T(7)))
                False
                sage: T.is_chain_of_poset((T(3), T(6), T(3)))
                True
                sage: T.is_chain_of_poset((T(3), T(6), T(3)), ordered=True)
                False
                sage: T.is_chain_of_poset((T(3), T(3), T(6)))
                True
                sage: T.is_chain_of_poset((T(3), T(3), T(6)), ordered=True)
                False
                sage: T.is_chain_of_poset((T(3), T(6)), ordered=True)
                True
                sage: T.is_chain_of_poset((), ordered=True)
                True
                sage: T.is_chain_of_poset((T(3),), ordered=True)
                True
                sage: T.is_chain_of_poset((T(q) for q in divisors(27)))
                True
                sage: T.is_chain_of_poset((T(q) for q in divisors(18)))
                False
            </opaque><constant name="parent.is_order_filter">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return whether ``o`` is an order filter of ``self``, assuming ``self``
            has no infinite ascending path.

            INPUT:

            - ``o`` -- a list (or set, or tuple) containing some elements of ``self``

            EXAMPLES::

                sage: P = Poset((divisors(12), attrcall(&quot;divides&quot;)), facade=True, linear_extension=True)
                sage: sorted(P.list())
                [1, 2, 3, 4, 6, 12]
                sage: P.is_order_filter([4, 12])
                True
                sage: P.is_order_filter([])
                True
                sage: P.is_order_filter({3, 4, 12})
                False
                sage: P.is_order_filter({3, 6, 12})
                True

            </opaque><constant name="parent.is_order_ideal">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return whether ``o`` is an order ideal of ``self``, assuming ``self``
            has no infinite descending path.

            INPUT:

            - ``o`` -- a list (or set, or tuple) containing some elements of ``self``

            EXAMPLES::

                sage: P = Poset((divisors(12), attrcall(&quot;divides&quot;)), facade=True, linear_extension=True)
                sage: sorted(P.list())
                [1, 2, 3, 4, 6, 12]
                sage: P.is_order_ideal([1, 3])
                True
                sage: P.is_order_ideal([])
                True
                sage: P.is_order_ideal({1, 3})
                True
                sage: P.is_order_ideal([1, 3, 4])
                False

            </opaque><constant name="parent.le">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return whether `x \le y` in the poset ``self``.

            INPUT:

            - ``x``, ``y`` -- elements of ``self``.

            EXAMPLES::

                sage: D = Poset((divisors(30), attrcall(&quot;divides&quot;)))
                sage: D.le( 3, 6 )
                True
                sage: D.le( 3, 3 )
                True
                sage: D.le( 3, 5 )
                False
            </opaque><constant name="parent.lower_covers">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return the lower covers of `x`, that is, the elements `y`
            such that `y&lt;x` and there exists no `z` such that `y&lt;z&lt;x`.

            EXAMPLES::

                sage: D = Poset((divisors(30), attrcall(&quot;divides&quot;)))
                sage: D.lower_covers(15)
                [3, 5]
            </opaque><constant name="parent.lt">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return whether `x &lt; y` in the poset ``self``.

            INPUT:

            - ``x``, ``y`` -- elements of ``self``.

            This default implementation delegates the work to :meth:`le`.

            EXAMPLES::

                sage: D = Poset((divisors(30), attrcall(&quot;divides&quot;)))
                sage: D.lt( 3, 6 )
                True
                sage: D.lt( 3, 3 )
                False
                sage: D.lt( 3, 5 )
                False
            </opaque><constant name="parent.order_filter">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return the order filter generated by a list of elements.

            A subset `I` of a poset is said to be an order filter if, for
            any `x` in `I` and `y` such that `y \ge x`, then `y` is in `I`.

            This is also called the upper set generated by these elements.

            EXAMPLES::

                sage: B = Posets.BooleanLattice(4)
                sage: B.order_filter([3,8])
                [3, 7, 8, 9, 10, 11, 12, 13, 14, 15]
            </opaque><constant name="parent.order_ideal">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return the order ideal in ``self`` generated by the elements
            of an iterable ``elements``.

            A subset `I` of a poset is said to be an order ideal if, for
            any `x` in `I` and `y` such that `y \le x`, then `y` is in `I`.

            This is also called the lower set generated by these elements.

            EXAMPLES::

                sage: B = Posets.BooleanLattice(4)
                sage: B.order_ideal([7,10])
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 10]
            </opaque><constant name="parent.order_ideal_toggle">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return the result of toggling the element ``v`` in the
            order ideal ``I``.

            If `v` is an element of a poset `P`, then toggling the
            element `v` is an automorphism of the set `J(P)` of all
            order ideals of `P`. It is defined as follows: If `I`
            is an order ideal of `P`, then the image of `I` under
            toggling the element `v` is

            - the set `I \cup \{ v \}`, if `v \not\in I` but
              every element of `P` smaller than `v` is in `I`;

            - the set `I \setminus \{ v \}`, if `v \in I` but
              no element of `P` greater than `v` is in `I`;

            - `I` otherwise.

            This image always is an order ideal of `P`.

            EXAMPLES::

                sage: P = Poset({1: [2,3], 2: [4], 3: []})
                sage: I = Set({1, 2})
                sage: I in P.order_ideals_lattice()
                True
                sage: P.order_ideal_toggle(I, 1)
                {1, 2}
                sage: P.order_ideal_toggle(I, 2)
                {1}
                sage: P.order_ideal_toggle(I, 3)
                {1, 2, 3}
                sage: P.order_ideal_toggle(I, 4)
                {1, 2, 4}
                sage: P4 = Posets(4)
                sage: all(all(all(P.order_ideal_toggle(P.order_ideal_toggle(I, i), i) == I
                ....:               for i in range(4))
                ....:          for I in P.order_ideals_lattice(facade=True))
                ....:     for P in P4)
                True
            </opaque><constant name="parent.order_ideal_toggles">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return the result of toggling the elements of the list (or
            iterable) ``vs`` (one by one, from left to right) in the order
            ideal ``I``.

            See :meth:`order_ideal_toggle` for a definition of toggling.

            EXAMPLES::

                sage: P = Poset({1: [2,3], 2: [4], 3: []})
                sage: I = Set({1, 2})
                sage: P.order_ideal_toggles(I, [1,2,3,4])
                {1, 3}
                sage: P.order_ideal_toggles(I, (1,2,3,4))
                {1, 3}
            </opaque><constant name="parent.principal_lower_set">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return the order ideal generated by an element ``x``.

            This is also called the lower set generated by this element.

            EXAMPLES::

                sage: B = Posets.BooleanLattice(4)
                sage: B.principal_order_ideal(6)
                [0, 2, 4, 6]
            </opaque><constant name="parent.principal_order_filter">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return the order filter generated by an element ``x``.

            This is also called the upper set generated by this element.

            EXAMPLES::

                sage: B = Posets.BooleanLattice(4)
                sage: B.principal_order_filter(2)
                [2, 3, 6, 7, 10, 11, 14, 15]
            </opaque><constant name="parent.principal_order_ideal">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return the order ideal generated by an element ``x``.

            This is also called the lower set generated by this element.

            EXAMPLES::

                sage: B = Posets.BooleanLattice(4)
                sage: B.principal_order_ideal(6)
                [0, 2, 4, 6]
            </opaque><constant name="parent.principal_upper_set">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return the order filter generated by an element ``x``.

            This is also called the upper set generated by this element.

            EXAMPLES::

                sage: B = Posets.BooleanLattice(4)
                sage: B.principal_order_filter(2)
                [2, 3, 6, 7, 10, 11, 14, 15]
            </opaque><constant name="parent.upper_covers">
       
       <type><om:OMOBJ xmlns:om="http://www.openmath.org/OpenMath"><om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMBIND>
                 <om:OMS base="http://cds.omdoc.org/urtheories" module="LambdaPi" name="Pi"></om:OMS>
                 <om:OMBVAR><om:OMV name="_"><type><om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS></type></om:OMV></om:OMBVAR>
                 <om:OMS base="http://www.sagemath.org/" module="Types" name="object"></om:OMS>
      </om:OMBIND>
      </om:OMBIND></om:OMOBJ></type>
       
       
     </constant><opaque format="text">
            Return the upper covers of `x`, that is, the elements `y`
            such that `x&lt;y` and there exists no `z` such that `x&lt;z&lt;y`.

            EXAMPLES::

                sage: D = Poset((divisors(30), attrcall(&quot;divides&quot;)))
                sage: D.upper_covers(3)
                [6, 15]
            </opaque></document><document name="Subcategory Methods:"></document></theory></omdoc>