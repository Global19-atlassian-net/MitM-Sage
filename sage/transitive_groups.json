{
    "categories": {
        "sage.categories.enumerated_sets.EnumeratedSets": {
            "__doc__": "\n    The category of enumerated sets\n\n    An *enumerated set* is a *finite* or *countable* set or multiset `S`\n    together with a canonical enumeration of its elements;\n    conceptually, this is very similar to an immutable list. The main\n    difference lies in the names and the return type of the methods,\n    and of course the fact that the list of elements is not supposed to\n    be expanded in memory. Whenever possible one should use one of the\n    two sub-categories :class:`FiniteEnumeratedSets` or\n    :class:`InfiniteEnumeratedSets`.\n\n    The purpose of this category is threefold:\n\n     - to fix a common interface for all these sets;\n     - to provide a bunch of default implementations;\n     - to provide consistency tests.\n\n    The standard methods for an enumerated set ``S`` are:\n\n       - ``S.cardinality()``: the number of elements of the set. This\n         is the equivalent for ``len`` on a list except that the\n         return value is specified to be a Sage :class:`Integer` or\n         ``infinity``, instead of a Python ``int``.\n\n       - ``iter(S)``: an iterator for the elements of the set;\n\n       - ``S.list()``: the list of the elements of the set, when\n         possible; raises a NotImplementedError if the list is\n         predictably too large to be expanded in memory.\n\n       - ``S.unrank(n)``: the  ``n-th`` element of the set when ``n`` is a sage\n         ``Integer``. This is the equivalent for ``l[n]`` on a list.\n\n       - ``S.rank(e)``: the position of the element ``e`` in the set;\n         This is equivalent to ``l.index(e)`` for a list except that\n         the return value is specified to be a Sage :class:`Integer`,\n         instead of a Python ``int``.\n\n       - ``S.first()``: the first object of the set; it is equivalent to\n         ``S.unrank(0)``.\n\n       - ``S.next(e)``: the object of the set which follows ``e``; It is\n         equivalent to ``S.unrank(S.rank(e)+1)``.\n\n       - ``S.random_element()``: a random generator for an element of\n         the set. Unless otherwise stated, and for finite enumerated\n         sets, the probability is uniform.\n\n    For examples and tests see:\n\n       - ``FiniteEnumeratedSets().example()``\n       - ``InfiniteEnumeratedSets().example()``\n\n\n    EXAMPLES::\n\n        sage: EnumeratedSets()\n        Category of enumerated sets\n        sage: EnumeratedSets().super_categories()\n        [Category of sets]\n        sage: EnumeratedSets().all_super_categories()\n        [Category of enumerated sets, Category of sets, Category of sets with partial maps, Category of objects]\n\n    TESTS::\n\n        sage: C = EnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
            "axioms": [
                "Enumerated"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "rank": {
                        "__doc__": "\n            Return the rank of ``self`` in its parent.\n\n            See also :meth:`EnumeratedSets.ElementMethods.rank`\n\n            EXAMPLES::\n\n                sage: F = FiniteSemigroups().example(('a','b','c'))\n                sage: L = list(F); L\n                ['a', 'b', 'c', 'ac', 'ab', 'ba', 'bc', 'cb', 'ca',\n                 'acb', 'abc', 'bca', 'cba', 'bac', 'cab']\n                sage: L[7].rank()\n                7\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.enumerated_sets.EnumeratedSets.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.sets_cat.Sets"
            ],
            "mmt": "TODO",
            "morphism_class": {
                "__doc__": "\n    The category of enumerated sets\n\n    An *enumerated set* is a *finite* or *countable* set or multiset `S`\n    together with a canonical enumeration of its elements;\n    conceptually, this is very similar to an immutable list. The main\n    difference lies in the names and the return type of the methods,\n    and of course the fact that the list of elements is not supposed to\n    be expanded in memory. Whenever possible one should use one of the\n    two sub-categories :class:`FiniteEnumeratedSets` or\n    :class:`InfiniteEnumeratedSets`.\n\n    The purpose of this category is threefold:\n\n     - to fix a common interface for all these sets;\n     - to provide a bunch of default implementations;\n     - to provide consistency tests.\n\n    The standard methods for an enumerated set ``S`` are:\n\n       - ``S.cardinality()``: the number of elements of the set. This\n         is the equivalent for ``len`` on a list except that the\n         return value is specified to be a Sage :class:`Integer` or\n         ``infinity``, instead of a Python ``int``.\n\n       - ``iter(S)``: an iterator for the elements of the set;\n\n       - ``S.list()``: the list of the elements of the set, when\n         possible; raises a NotImplementedError if the list is\n         predictably too large to be expanded in memory.\n\n       - ``S.unrank(n)``: the  ``n-th`` element of the set when ``n`` is a sage\n         ``Integer``. This is the equivalent for ``l[n]`` on a list.\n\n       - ``S.rank(e)``: the position of the element ``e`` in the set;\n         This is equivalent to ``l.index(e)`` for a list except that\n         the return value is specified to be a Sage :class:`Integer`,\n         instead of a Python ``int``.\n\n       - ``S.first()``: the first object of the set; it is equivalent to\n         ``S.unrank(0)``.\n\n       - ``S.next(e)``: the object of the set which follows ``e``; It is\n         equivalent to ``S.unrank(S.rank(e)+1)``.\n\n       - ``S.random_element()``: a random generator for an element of\n         the set. Unless otherwise stated, and for finite enumerated\n         sets, the probability is uniform.\n\n    For examples and tests see:\n\n       - ``FiniteEnumeratedSets().example()``\n       - ``InfiniteEnumeratedSets().example()``\n\n\n    EXAMPLES::\n\n        sage: EnumeratedSets()\n        Category of enumerated sets\n        sage: EnumeratedSets().super_categories()\n        [Category of sets]\n        sage: EnumeratedSets().all_super_categories()\n        [Category of enumerated sets, Category of sets, Category of sets with partial maps, Category of objects]\n\n    TESTS::\n\n        sage: C = EnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.enumerated_sets.EnumeratedSets.morphism_class"
            },
            "name": "sage.categories.enumerated_sets.EnumeratedSets",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "__getitem__": {
                        "__doc__": "\n            Return the item indexed by ``i``.\n\n            .. WARNING::\n\n                This method is only meant as a convenience shorthand for\n                ``self.unrank(i)`` and\n                ``self.unrank_range(start, stop, step)`` respectively, for\n                casual use (e.g. in interactive sessions). Subclasses are\n                hereby explicitly permitted to overload ``__getitem__``\n                with a different semantic, typically for enumerated sets\n                that are naturally indexed by some `I` not of the\n                form `\\{0, 1, \\ldots\\}`. In particular, generic code\n                *should not* use this shorthand.\n\n            EXAMPLES::\n\n                sage: P = Partitions()\n                sage: P[:5]\n                [[], [1], [2], [1, 1], [3]]\n                sage: P[0:5]\n                [[], [1], [2], [1, 1], [3]]\n                sage: P[3:5]\n                [[1, 1], [3]]\n                sage: P[3:10]\n                [[1, 1], [3], [2, 1], [1, 1, 1], [4], [3, 1], [2, 2]]\n                sage: P[3:10:2]\n                [[1, 1], [2, 1], [4], [2, 2]]\n                sage: P[3:]\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n                sage: P[3]\n                [1, 1]\n                sage: P[-1]\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n\n            ::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.list()\n                [1, 2, 3]\n                sage: C[1]\n                2\n                sage: C[:]\n                [1, 2, 3]\n                sage: C[1:]\n                [2, 3]\n                sage: C[0:1:2]\n                [1]\n\n                sage: F = FiniteEnumeratedSet([1,2,3])\n                sage: F[1:]\n                [2, 3]\n                sage: F[:2]\n                [1, 2]\n                sage: F[:2:2]\n                [1]\n                sage: F[1::2]\n                [2]\n            ",
                        "args": [
                            "self",
                            "i"
                        ],
                        "argspec": [
                            [
                                "self",
                                "i"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "__iter__": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method __iter__ at 0x7faa353be9b0>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "iter_of_self",
                        "gap_name": "IsIterator",
                        "mmt_name": null
                    },
                    "__len__": {
                        "__doc__": "\n            Return the number of elements of ``self``.\n\n            EXAMPLES::\n\n                sage: len(GF(5))\n                5\n                sage: len(MatrixSpace(GF(2), 3, 3))\n                512\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_an_element_from_iterator": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "_first_from_iterator": {
                        "__doc__": "\n            The \"first\" element of ``self``.\n\n            ``self.first()`` returns the first element of the set\n            ``self``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__`` is\n            provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.first() # indirect doctest\n                1\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_iterator_from_list": {
                        "__doc__": "\n            An iterator for the elements of ``self``.\n\n            ``iter(self)`` returns an iterator for the elements\n            of ``self``. This is a generic implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``list`` is provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: it = C._iterator_from_list()\n                sage: [next(it), next(it), next(it)]\n                [1, 2, 3]\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_iterator_from_next": {
                        "__doc__": "\n            An iterator for the elements of ``self``.\n\n            ``iter(self)`` returns an iterator for the element of\n            the set ``self``. This is a generic implementation from\n            the category ``EnumeratedSets()`` which can be used when\n            the methods ``first`` and ``next`` are provided.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: it = C._iterator_from_next()\n                sage: [next(it), next(it), next(it), next(it), next(it)]\n                [0, 1, 2, 3, 4]\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_iterator_from_unrank": {
                        "__doc__": "\n            An iterator for the elements of ``self``.\n\n            ``iter(self)`` returns an iterator for the elements\n            of the set ``self``. This is a generic implementation from\n            the category ``EnumeratedSets()`` which can be used when\n            the method ``unrank`` is provided.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: it = C._iterator_from_unrank()\n                sage: [next(it), next(it), next(it), next(it), next(it)]\n                [0, 1, 2, 3, 4]\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_list_default": {
                        "__doc__": "\n            Return a list of the elements of ``self``.\n\n            The elements of set ``x`` are created and cached on the fist call\n            of ``x.list()``. Then each call of ``x.list()`` returns a new list\n            from the cached result. Thus in looping, it may be better to do\n            ``for e in x:``, not ``for e in x.list():``.\n\n            If ``x`` is not known to be finite, then an exception is raised.\n\n            EXAMPLES::\n\n                sage: (GF(3)^2).list()\n                [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2)]\n                sage: R = Integers(11)\n                sage: R.list()\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: l = R.list(); l\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: l.remove(0); l\n                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: R.list()\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_list_from_iterator": {
                        "__doc__": "\n            Return a list of the elements of ``self`` after cached.\n\n            TESTS:\n\n            Trying to list an infinite vector space raises an error\n            instead of running forever (see :trac:`10470`)::\n\n                sage: (QQ^2).list()  # indirect test\n                Traceback (most recent call last):\n                ...\n                AttributeError: 'FreeModule_ambient_field_with_category' object has no attribute 'list'\n\n            Here we test that for an object that does not know whether it\n            is finite or not.  Calling ``x.list()`` simply tries to create\n            the list (but here it fails, since the object is not\n            iterable). This was fixed :trac:`11350` ::\n\n                sage: R.<t,p> = QQ[]\n                sage: Q = R.quotient(t^2-t+1)\n                sage: Q.is_finite()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError\n                sage: Q.list()   # indirect test\n                Traceback (most recent call last):\n                ...\n                AttributeError: 'QuotientRing_generic_with_category' object has no attribute 'list'\n\n            Here is another example. We artificially create a version of\n            the ring of integers that does not know whether it is finite\n            or not::\n\n                sage: from sage.rings.integer_ring import IntegerRing_class\n                sage: class MyIntegers_class(IntegerRing_class):\n                ....:      def is_finite(self):\n                ....:          raise NotImplementedError\n                sage: MyIntegers = MyIntegers_class()\n                sage: MyIntegers.is_finite()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError\n\n            Asking for ``list(MyIntegers)`` will also raise an exception::\n\n                sage: list(MyIntegers)  # indirect test\n                Traceback (most recent call last):\n                ...\n                NotImplementedError\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_next_from_iterator": {
                        "__doc__": "\n            The \"next\" element after ``obj`` in ``self``.\n\n            ``self.next(e)`` returns the element of the set ``self`` which\n            follows ``e``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__``\n            is provided.\n\n            Remark: this is the default (brute force) implementation\n            of the category ``EnumeratedSets()``. Its complexity is\n            `O(r)`, where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: C._next_from_iterator(10) # indirect doctest\n                11\n\n            TODO: specify the behavior when ``obj`` is not in ``self``.\n            ",
                        "args": [
                            "self",
                            "obj"
                        ],
                        "argspec": [
                            [
                                "self",
                                "obj"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_rank_from_iterator": {
                        "__doc__": "\n            The rank of an element of ``self``\n\n            ``self.rank(x)`` returns the rank of `x`, that is its\n            position in the enumeration of ``self``. This is an\n            integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``, or None if `x` is not in `self`.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``. For infinite enumerated\n            sets, this won't terminate when `x` is not in ``self``\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: list(C)\n                [1, 2, 3]\n                sage: C.rank(3) # indirect doctest\n                2\n                sage: C.rank(5) # indirect doctest\n            ",
                        "args": [
                            "self",
                            "x"
                        ],
                        "argspec": [
                            [
                                "self",
                                "x"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_some_elements_from_iterator": {
                        "__doc__": "\n            Return some elements in ``self``.\n\n            See :class:`TestSuite` for a typical use case.\n\n            This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method\n            ``__iter__`` is provided. It returns an iterator for up to\n            the first 100 elements of ``self``\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: list(C.some_elements()) # indirect doctest\n                [1, 2, 3]\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_test_enumerated_set_contains": {
                        "__doc__": "\n            Checks that the methods :meth:`.__contains__` and :meth:`.__iter__` are consistent.\n\n            See also :class:`TestSuite`.\n\n            TESTS::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._test_enumerated_set_contains()\n                sage: TestSuite(C).run()\n\n            Let us now break the class::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class CCls(Example):\n                ....:     def __contains__(self, obj):\n                ....:         if obj == 3:\n                ....:             return False\n                ....:         else:\n                ....:             return obj in C\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_contains()\n                Traceback (most recent call last):\n                ...\n                AssertionError: False is not true\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "_test_enumerated_set_iter_list": {
                        "__doc__": "\n            Checks that the methods :meth:`.list` and :meth:`.__iter__` are consistent.\n\n            See also: :class:`TestSuite`.\n\n            .. NOTE::\n\n                This test does nothing if the cardinality of the set\n                is larger than the max_runs argument.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._test_enumerated_set_iter_list()\n                sage: TestSuite(C).run()\n\n            Let us now break the class::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class CCls(Example):\n                ....:     def list(self):\n                ....:         return [1,2,3,4]\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_iter_list()\n                Traceback (most recent call last):\n                ...\n                AssertionError: 3 != 4\n\n            For a large enumerated set this test does nothing:\n            increase tester._max_runs if you want to actually run the\n            test::\n\n                sage: class CCls(Example):\n                ....:     def list(self):\n                ....:         return [1,2,3]\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_iter_list(verbose=True,max_runs=2)\n                Enumerated set too big; skipping test; increase tester._max_runs\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "_unrank_from_iterator": {
                        "__doc__": "\n            The ``r``-th element of ``self``\n\n            ``self.unrank(r)`` returns the ``r``-th element of ``self``, where\n            ``r`` is an integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.unrank(2) # indirect doctest\n                3\n                sage: C._unrank_from_iterator(5)\n                Traceback (most recent call last):\n                ...\n                ValueError: the value must be between 0 and 2 inclusive\n            ",
                        "args": [
                            "self",
                            "r"
                        ],
                        "argspec": [
                            [
                                "self",
                                "r"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "first": {
                        "__doc__": "\n            The \"first\" element of ``self``.\n\n            ``self.first()`` returns the first element of the set\n            ``self``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__`` is\n            provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.first() # indirect doctest\n                1\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "is_empty": {
                        "__doc__": "\n            Return whether this set is empty.\n\n            EXAMPLES::\n\n                sage: F = FiniteEnumeratedSet([1,2,3])\n                sage: F.is_empty()\n                False\n                sage: F = FiniteEnumeratedSet([])\n                sage: F.is_empty()\n                True\n\n            TESTS::\n\n                sage: F.is_empty.__module__\n                'sage.categories.enumerated_sets'\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "iterator_range": {
                        "__doc__": "\n            Iterate over the range of elements of ``self`` starting\n            at ``start``, ending at ``stop``, and stepping by ``step``.\n\n            .. SEEALSO::\n\n                ``unrank()``, ``unrank_range()``\n\n            EXAMPLES::\n\n                sage: P = Partitions()\n                sage: list(P.iterator_range(stop=5))\n                [[], [1], [2], [1, 1], [3]]\n                sage: list(P.iterator_range(0, 5))\n                [[], [1], [2], [1, 1], [3]]\n                sage: list(P.iterator_range(3, 5))\n                [[1, 1], [3]]\n                sage: list(P.iterator_range(3, 10))\n                [[1, 1], [3], [2, 1], [1, 1, 1], [4], [3, 1], [2, 2]]\n                sage: list(P.iterator_range(3, 10, 2))\n                [[1, 1], [2, 1], [4], [2, 2]]\n                sage: it = P.iterator_range(3)\n                sage: [next(it) for x in range(10)]\n                [[1, 1],\n                 [3], [2, 1], [1, 1, 1],\n                 [4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1],\n                 [5]]\n                sage: it = P.iterator_range(3, step=2)\n                sage: [next(it) for x in range(5)]\n                [[1, 1],\n                 [2, 1],\n                 [4], [2, 2], [1, 1, 1, 1]]\n                sage: next(P.iterator_range(stop=-3))\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n                sage: next(P.iterator_range(start=-3))\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n            ",
                        "args": [
                            "self",
                            "start",
                            "stop",
                            "step"
                        ],
                        "argspec": [
                            [
                                "self",
                                "start",
                                "stop",
                                "step"
                            ],
                            null,
                            null,
                            [
                                null,
                                null,
                                null
                            ]
                        ]
                    },
                    "list": {
                        "__doc__": "\n            Return a list of the elements of ``self``.\n\n            The elements of set ``x`` are created and cached on the fist call\n            of ``x.list()``. Then each call of ``x.list()`` returns a new list\n            from the cached result. Thus in looping, it may be better to do\n            ``for e in x:``, not ``for e in x.list():``.\n\n            If ``x`` is not known to be finite, then an exception is raised.\n\n            EXAMPLES::\n\n                sage: (GF(3)^2).list()\n                [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2)]\n                sage: R = Integers(11)\n                sage: R.list()\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: l = R.list(); l\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: l.remove(0); l\n                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: R.list()\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "map": {
                        "__doc__": "\n            Return the image `\\{f(x) | x \\in \\text{self}\\}` of this\n            enumerated set by `f`, as an enumerated set.\n\n            `f` is supposed to be injective.\n\n            EXAMPLES::\n\n                sage: R = SymmetricGroup(3).map(attrcall('reduced_word')); R\n                Image of Symmetric group of order 3! as a permutation group by *.reduced_word()\n                sage: R.cardinality()\n                6\n                sage: R.list()\n                [[], [1], [2, 1], [1, 2], [2], [1, 2, 1]]\n                sage: [ r for r in R]\n                [[], [1], [2, 1], [1, 2], [2], [1, 2, 1]]\n\n            .. warning::\n\n                If the function is not injective, then there may be\n                repeated elements::\n\n                    sage: P = SymmetricGroup(3)\n                    sage: P.list()\n                    [(), (1,2), (1,2,3), (1,3,2), (2,3), (1,3)]\n                    sage: P.map(attrcall('length')).list()\n                    [0, 1, 2, 2, 1, 3]\n\n            .. warning::\n\n                :class:`MapCombinatorialClass` needs to be refactored to use categories::\n\n                    sage: R.category()             # todo: not implemented\n                    Category of enumerated sets\n                    sage: TestSuite(R).run(skip=['_test_an_element', '_test_category', '_test_some_elements'])\n            ",
                        "args": [
                            "self",
                            "f",
                            "name"
                        ],
                        "argspec": [
                            [
                                "self",
                                "f",
                                "name"
                            ],
                            null,
                            null,
                            [
                                null
                            ]
                        ]
                    },
                    "next": {
                        "__doc__": "\n            The \"next\" element after ``obj`` in ``self``.\n\n            ``self.next(e)`` returns the element of the set ``self`` which\n            follows ``e``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__``\n            is provided.\n\n            Remark: this is the default (brute force) implementation\n            of the category ``EnumeratedSets()``. Its complexity is\n            `O(r)`, where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: C._next_from_iterator(10) # indirect doctest\n                11\n\n            TODO: specify the behavior when ``obj`` is not in ``self``.\n            ",
                        "args": [
                            "self",
                            "obj"
                        ],
                        "argspec": [
                            [
                                "self",
                                "obj"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "rank": {
                        "__doc__": "\n            The rank of an element of ``self``\n\n            ``self.rank(x)`` returns the rank of `x`, that is its\n            position in the enumeration of ``self``. This is an\n            integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``, or None if `x` is not in `self`.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``. For infinite enumerated\n            sets, this won't terminate when `x` is not in ``self``\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: list(C)\n                [1, 2, 3]\n                sage: C.rank(3) # indirect doctest\n                2\n                sage: C.rank(5) # indirect doctest\n            ",
                        "args": [
                            "self",
                            "x"
                        ],
                        "argspec": [
                            [
                                "self",
                                "x"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "unrank": {
                        "__doc__": "\n            The ``r``-th element of ``self``\n\n            ``self.unrank(r)`` returns the ``r``-th element of ``self``, where\n            ``r`` is an integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.unrank(2) # indirect doctest\n                3\n                sage: C._unrank_from_iterator(5)\n                Traceback (most recent call last):\n                ...\n                ValueError: the value must be between 0 and 2 inclusive\n            ",
                        "args": [
                            "self",
                            "r"
                        ],
                        "argspec": [
                            [
                                "self",
                                "r"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "unrank_range": {
                        "__doc__": "\n            Return the range of elements of ``self`` starting at ``start``,\n            ending at ``stop``, and stepping by ``step``.\n\n            .. SEEALSO::\n\n                ``unrank()``, ``iterator_range()``\n\n            EXAMPLES::\n\n                sage: P = Partitions()\n                sage: P.unrank_range(stop=5)\n                [[], [1], [2], [1, 1], [3]]\n                sage: P.unrank_range(0, 5)\n                [[], [1], [2], [1, 1], [3]]\n                sage: P.unrank_range(3, 5)\n                [[1, 1], [3]]\n                sage: P.unrank_range(3, 10)\n                [[1, 1], [3], [2, 1], [1, 1, 1], [4], [3, 1], [2, 2]]\n                sage: P.unrank_range(3, 10, 2)\n                [[1, 1], [2, 1], [4], [2, 2]]\n                sage: P.unrank_range(3)\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n                sage: P.unrank_range(stop=-3)\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n                sage: P.unrank_range(start=-3)\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n            ",
                        "args": [
                            "self",
                            "start",
                            "stop",
                            "step"
                        ],
                        "argspec": [
                            [
                                "self",
                                "start",
                                "stop",
                                "step"
                            ],
                            null,
                            null,
                            [
                                null,
                                null,
                                null
                            ]
                        ]
                    }
                },
                "name": "sage.categories.enumerated_sets.EnumeratedSets.parent_class"
            },
            "structure": [
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of enumerated sets\n\n    An *enumerated set* is a *finite* or *countable* set or multiset `S`\n    together with a canonical enumeration of its elements;\n    conceptually, this is very similar to an immutable list. The main\n    difference lies in the names and the return type of the methods,\n    and of course the fact that the list of elements is not supposed to\n    be expanded in memory. Whenever possible one should use one of the\n    two sub-categories :class:`FiniteEnumeratedSets` or\n    :class:`InfiniteEnumeratedSets`.\n\n    The purpose of this category is threefold:\n\n     - to fix a common interface for all these sets;\n     - to provide a bunch of default implementations;\n     - to provide consistency tests.\n\n    The standard methods for an enumerated set ``S`` are:\n\n       - ``S.cardinality()``: the number of elements of the set. This\n         is the equivalent for ``len`` on a list except that the\n         return value is specified to be a Sage :class:`Integer` or\n         ``infinity``, instead of a Python ``int``.\n\n       - ``iter(S)``: an iterator for the elements of the set;\n\n       - ``S.list()``: the list of the elements of the set, when\n         possible; raises a NotImplementedError if the list is\n         predictably too large to be expanded in memory.\n\n       - ``S.unrank(n)``: the  ``n-th`` element of the set when ``n`` is a sage\n         ``Integer``. This is the equivalent for ``l[n]`` on a list.\n\n       - ``S.rank(e)``: the position of the element ``e`` in the set;\n         This is equivalent to ``l.index(e)`` for a list except that\n         the return value is specified to be a Sage :class:`Integer`,\n         instead of a Python ``int``.\n\n       - ``S.first()``: the first object of the set; it is equivalent to\n         ``S.unrank(0)``.\n\n       - ``S.next(e)``: the object of the set which follows ``e``; It is\n         equivalent to ``S.unrank(S.rank(e)+1)``.\n\n       - ``S.random_element()``: a random generator for an element of\n         the set. Unless otherwise stated, and for finite enumerated\n         sets, the probability is uniform.\n\n    For examples and tests see:\n\n       - ``FiniteEnumeratedSets().example()``\n       - ``InfiniteEnumeratedSets().example()``\n\n\n    EXAMPLES::\n\n        sage: EnumeratedSets()\n        Category of enumerated sets\n        sage: EnumeratedSets().super_categories()\n        [Category of sets]\n        sage: EnumeratedSets().all_super_categories()\n        [Category of enumerated sets, Category of sets, Category of sets with partial maps, Category of objects]\n\n    TESTS::\n\n        sage: C = EnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.enumerated_sets.EnumeratedSets.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.facade_sets.FacadeSets": {
            "__doc__": null,
            "axioms": [
                "Facade"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.facade_sets.FacadeSets.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.sets_cat.Sets"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.facade_sets.FacadeSets.morphism_class"
            },
            "name": "sage.categories.facade_sets.FacadeSets",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "facade_for": {
                        "__doc__": "\n            Returns the parents this set is a facade for\n\n            This default implementation assumes that ``self`` has\n            an attribute ``_facade_for``, typically initialized by\n            :meth:`Parent.__init__`. If the attribute is not present, the method\n            raises a NotImplementedError.\n\n            EXAMPLES::\n\n                sage: S = Sets().Facade().example(); S\n                An example of facade set: the monoid of positive integers\n                sage: S.facade_for()\n                (Integer Ring,)\n\n            Check that :trac:`13801` is corrected::\n\n                sage: class A(Parent):\n                ....:     def __init__(self):\n                ....:         Parent.__init__(self, category=Sets(), facade=True)\n                sage: a = A()\n                sage: a.facade_for()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: this parent did not specify which parents it is a facade for\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.facade_sets.FacadeSets.parent_class"
            },
            "structure": [
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.facade_sets.FacadeSets.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets": {
            "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
            "axioms": [
                "Finite",
                "Enumerated"
            ],
            "element_class": {
                "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.enumerated_sets.EnumeratedSets",
                "sage.categories.finite_sets.FiniteSets"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.morphism_class"
            },
            "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "_cardinality_from_iterator": {
                        "__doc__": "\n            Return the cardinality of ``self``.\n\n            This brute force implementation of :meth:`cardinality`\n            iterates through the elements of ``self`` to count them.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example(); C\n                An example of a finite enumerated set: {1,2,3}\n                sage: C._cardinality_from_iterator()\n                3\n\n            TESTS:\n\n            This is the default implementation of :meth:`cardinality`\n            from the category ``FiniteEnumeratedSet()``. To test this,\n            we need a fresh example::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class FreshExample(Example): pass\n                sage: C = FreshExample(); C.rename(\"FreshExample\")\n                sage: C.cardinality\n                <bound method FreshExample_with_category._cardinality_from_iterator of FreshExample>\n\n            This method shall return an ``Integer``; we test this\n            here, because :meth:`_test_enumerated_set_iter_cardinality`\n            does not do it for us::\n\n                sage: type(C._cardinality_from_iterator())\n                <type 'sage.rings.integer.Integer'>\n\n            We ignore additional inputs since during doctests classes which\n            override ``cardinality()`` call up to the category rather than\n            their own ``cardinality()`` method (see :trac:`13688`)::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._cardinality_from_iterator(algorithm='testing')\n                3\n\n            Here is a more complete example::\n\n                sage: class TestParent(Parent):\n                ....:   def __init__(self):\n                ....:       Parent.__init__(self, category=FiniteEnumeratedSets())\n                ....:   def __iter__(self):\n                ....:       yield 1\n                ....:       return\n                ....:   def cardinality(self, dummy_arg):\n                ....:       return 1 # we don't want to change the semantics of cardinality()\n                sage: P = TestParent()\n                sage: P.cardinality(-1)\n                1\n                sage: v = P.list(); v\n                [1]\n                sage: P.cardinality()\n                1\n                sage: P.cardinality('use alt algorithm') # Used to break here: see trac #13688\n                1\n                sage: P.cardinality(dummy_arg='use alg algorithm') # Used to break here: see trac #13688\n                1\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            "ignored_args",
                            "ignored_kwds",
                            null
                        ]
                    },
                    "_cardinality_from_list": {
                        "__doc__": "\n            The cardinality of ``self``.\n\n            This implementation of :meth:`cardinality` computes the\n            cardinality from :meth:`list` (which is\n            cached). Reciprocally, calling ``self.list()`` makes this\n            method the default implementation of :meth:`cardinality`.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._cardinality_from_list()\n                3\n\n            We ignore additional inputs since during doctests classes which\n            override ``cardinality()`` call up to the category rather than\n            their own ``cardinality()`` method (see :trac:`13688`)::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._cardinality_from_list(algorithm='testing')\n                3\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            "ignored_args",
                            "ignored_kwds",
                            null
                        ]
                    },
                    "_last_from_iterator": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "_last_from_unrank": {
                        "__doc__": "\n            The last element of ``self``.\n\n            ``self.last()`` returns the last element of ``self``\n\n            This is a generic implementation from the category\n            ``FiniteEnumeratedSet()`` which can be used when the\n            method ``unrank`` is provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._last_from_unrank()\n                3\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_random_element_from_unrank": {
                        "__doc__": "\n            A random element in ``self``.\n\n            ``self.random_element()`` returns a random element in\n            ``self`` with uniform probability.\n\n            This is the default implementation from the category\n            ``EnumeratedSet()`` which uses the method ``unrank``.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.random_element()\n                1\n                sage: C._random_element_from_unrank()\n                2\n\n            TODO: implement _test_random which checks uniformness\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_test_enumerated_set_iter_cardinality": {
                        "__doc__": "\n            Checks that the methods :meth:`.cardinality` and\n            :meth:`.__iter__` are consistent. Also checks that\n            :meth:`.cardinality` returns an ``Integer``.\n\n            For efficiency reasons, those tests are not run if\n            :meth:`.cardinality` is\n            :meth:`._cardinality_from_iterator`, or if ``self`` is too\n            big.\n\n            .. SEEALSO:: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._test_enumerated_set_iter_cardinality()\n\n            Let us now break the class::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class CCls(Example):\n                ....:     def cardinality(self):\n                ....:         return 4\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_iter_cardinality()\n                Traceback (most recent call last):\n                ...\n                AssertionError: 4 != 3\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "_unrank_from_list": {
                        "__doc__": "\n            The ``r``-th element of ``self``\n\n            INPUT:\n\n              - ``r`` -- an integer between ``0`` and ``n-1``,\n                where ``n`` is the cardinality of ``self``.\n\n            OUTPUT: the ``r``-th element of ``self``\n\n            This implementation of :meth:`unrank` uses the method\n            :meth:`list` (which is cached). Reciprocally, calling\n            ``self.list()`` makes this method the default\n            implementation of :meth:`unrank`.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._unrank_from_list(1)\n                2\n            ",
                        "args": [
                            "self",
                            "r"
                        ],
                        "argspec": [
                            [
                                "self",
                                "r"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "last": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    }
                },
                "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.parent_class"
            },
            "structure": [
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.finite_groups.FiniteGroups": {
            "__doc__": "\n    The category of finite (multiplicative) groups.\n\n    EXAMPLES::\n\n        sage: C = FiniteGroups(); C\n        Category of finite groups\n        sage: C.super_categories()\n        [Category of finite monoids, Category of groups]\n        sage: C.example()\n        General Linear Group of degree 2 over Finite Field of size 3\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "axioms": [
                "Finite",
                "Inverse",
                "Associative",
                "Unital"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_groups.FiniteGroups.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.finite_monoids.FiniteMonoids",
                "sage.categories.groups.Groups"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category of finite (multiplicative) groups.\n\n    EXAMPLES::\n\n        sage: C = FiniteGroups(); C\n        Category of finite groups\n        sage: C.super_categories()\n        [Category of finite monoids, Category of groups]\n        sage: C.example()\n        General Linear Group of degree 2 over Finite Field of size 3\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_groups.FiniteGroups.morphism_class"
            },
            "name": "sage.categories.finite_groups.FiniteGroups",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "cayley_graph_disabled": {
                        "__doc__": "\n\n            AUTHORS:\n\n            - Bobby Moretti (2007-08-10)\n\n            - Robert Miller (2008-05-01): editing\n            ",
                        "args": [
                            "self",
                            "connecting_set"
                        ],
                        "argspec": [
                            [
                                "self",
                                "connecting_set"
                            ],
                            null,
                            null,
                            [
                                null
                            ]
                        ]
                    },
                    "conjugacy_classes": {
                        "__doc__": "\n            Return a list with all the conjugacy classes of the group.\n\n            This will eventually be a fall-back method for groups not defined\n            over GAP. Right now just raises a ``NotImplementedError``, until\n            we include a non-GAP way of listing the conjugacy classes\n            representatives.\n\n            EXAMPLES::\n\n                sage: from sage.groups.group import FiniteGroup\n                sage: G = FiniteGroup()\n                sage: G.conjugacy_classes()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: Listing the conjugacy classes for\n                group <type 'sage.groups.group.FiniteGroup'> is not implemented\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "conjugacy_classes_representatives": {
                        "__doc__": "\n            Return a list of the conjugacy classes representatives of the group.\n\n            EXAMPLES::\n\n                sage: G = SymmetricGroup(3)\n                sage: G.conjugacy_classes_representatives()\n                [(), (1,2), (1,2,3)]\n           ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.finite_groups.FiniteGroups.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.magmas.Magmas.Unital",
                "sage.categories.sets_cat.Sets",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of finite (multiplicative) groups.\n\n    EXAMPLES::\n\n        sage: C = FiniteGroups(); C\n        Category of finite groups\n        sage: C.super_categories()\n        [Category of finite monoids, Category of groups]\n        sage: C.example()\n        General Linear Group of degree 2 over Finite Field of size 3\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_groups.FiniteGroups.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.finite_monoids.FiniteMonoids": {
            "__doc__": "\n    The category of finite (multiplicative) :class:`monoids <Monoids>`.\n\n    A finite monoid is a :class:`finite sets <FiniteSets>` endowed\n    with an associative unital binary operation `*`.\n\n    EXAMPLES::\n\n        sage: FiniteMonoids()\n        Category of finite monoids\n        sage: FiniteMonoids().super_categories()\n        [Category of monoids, Category of finite semigroups]\n\n    TESTS::\n\n        sage: TestSuite(FiniteMonoids()).run()\n    ",
            "axioms": [
                "Finite",
                "Associative",
                "Unital"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "pseudo_order": {
                        "__doc__": "\n            Returns the pair `[k, j]` with `k` minimal and `0\\leq j <k` such\n            that ``self^k == self^j``.\n\n            Note that `j` is uniquely determined.\n\n            EXAMPLES::\n\n                sage: M = FiniteMonoids().example(); M\n                An example of a finite multiplicative monoid: the integers modulo 12\n\n                sage: x = M(2)\n                sage: [ x^i for i in range(7) ]\n                [1, 2, 4, 8, 4, 8, 4]\n                sage: x.pseudo_order()\n                [4, 2]\n\n                sage: x = M(3)\n                sage: [ x^i for i in range(7) ]\n                [1, 3, 9, 3, 9, 3, 9]\n                sage: x.pseudo_order()\n                [3, 1]\n\n                sage: x = M(4)\n                sage: [ x^i for i in range(7) ]\n                [1, 4, 4, 4, 4, 4, 4]\n                sage: x.pseudo_order()\n                [2, 1]\n\n                sage: x = M(5)\n                sage: [ x^i for i in range(7) ]\n                [1, 5, 1, 5, 1, 5, 1]\n                sage: x.pseudo_order()\n                [2, 0]\n\n            TODO: more appropriate name? see, for example, Jean-Eric Pin's\n            lecture notes on semigroups.\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.finite_monoids.FiniteMonoids.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.monoids.Monoids",
                "sage.categories.finite_semigroups.FiniteSemigroups"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category of finite (multiplicative) :class:`monoids <Monoids>`.\n\n    A finite monoid is a :class:`finite sets <FiniteSets>` endowed\n    with an associative unital binary operation `*`.\n\n    EXAMPLES::\n\n        sage: FiniteMonoids()\n        Category of finite monoids\n        sage: FiniteMonoids().super_categories()\n        [Category of monoids, Category of finite semigroups]\n\n    TESTS::\n\n        sage: TestSuite(FiniteMonoids()).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_monoids.FiniteMonoids.morphism_class"
            },
            "name": "sage.categories.finite_monoids.FiniteMonoids",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "nerve": {
                        "__doc__": "\n            The nerve (classifying space) of this monoid.\n\n            OUTPUT: the nerve $BG$ (if $G$ denotes this monoid), as a\n            simplicial set.  The $k$-dimensional simplices of this\n            object are indexed by products of $k$ elements in the\n            monoid:\n\n            .. MATH::\n\n                a_1 * a_2 * \\cdots * a_k\n\n            The 0th face of this is obtained by deleting $a_1$, and\n            the $k$-th face is obtained by deleting $a_k$. The other\n            faces are obtained by multiplying elements: the 1st face\n            is\n\n            .. MATH::\n\n               (a1 * a_2) * \\cdots * a_k\n\n            and so on. See :wikipedia:`Nerve_(category_theory)`, which\n            describes the construction of the nerve as a simplicial\n            set.\n\n            A simplex in this simplicial set will be degenerate if in\n            the corresponding product of $k$ elements, one of those\n            elements is the identity. So we only need to keep track of\n            the products of non-identity elements. Similarly, if a\n            product `a_{i-1} a_i` is the identity element, then the\n            corresponding face of the simplex will be a degenerate\n            simplex.\n\n            EXAMPLES:\n\n            The nerve (classifying space) of the cyclic group of order\n            2 is infinite-dimensional real projective space. ::\n\n                sage: Sigma2 = groups.permutation.Cyclic(2)\n                sage: BSigma2 = Sigma2.nerve()\n                sage: BSigma2.cohomology(4, base_ring=GF(2))\n                Vector space of dimension 1 over Finite Field of size 2\n\n            The `k`-simplices of the nerve are named after the chains\n            of `k` non-unit elements to be multiplied. The group\n            `\\Sigma_2` has two elements, writen ``()`` (the identity\n            element) and ``(1,2)`` in Sage. So the 1-cells and 2-cells\n            in `B\\Sigma_2` are::\n\n                sage: BSigma2.n_cells(1)\n                [(1,2)]\n                sage: BSigma2.n_cells(2)\n                [(1,2) * (1,2)]\n\n            Another construction of the group, with different names\n            for its elements::\n\n                sage: C2 = groups.misc.MultiplicativeAbelian([2])\n                sage: BC2 = C2.nerve()\n                sage: BC2.n_cells(0)\n                [1]\n                sage: BC2.n_cells(1)\n                [f]\n                sage: BC2.n_cells(2)\n                [f * f]\n\n            With mod `p` coefficients, `B \\Sigma_p` should have its\n            first nonvanishing homology group in dimension `p`::\n\n                sage: Sigma3 = groups.permutation.Symmetric(3)\n                sage: BSigma3 = Sigma3.nerve()\n                sage: BSigma3.homology(range(4), base_ring=GF(3))\n                {0: Vector space of dimension 0 over Finite Field of size 3,\n                1: Vector space of dimension 0 over Finite Field of size 3,\n                2: Vector space of dimension 0 over Finite Field of size 3,\n                3: Vector space of dimension 1 over Finite Field of size 3}\n\n            Note that we can construct the `n`-skeleton for\n            `B\\Sigma_2` for relatively large values of `n`, while for\n            `B\\Sigma_3`, the complexes get large pretty quickly::\n\n                sage: Sigma2.nerve().n_skeleton(14)\n                Simplicial set with 15 non-degenerate simplices\n\n                sage: BSigma3 = Sigma3.nerve()\n                sage: BSigma3.n_skeleton(3)\n                Simplicial set with 156 non-degenerate simplices\n                sage: BSigma3.n_skeleton(4)\n                Simplicial set with 781 non-degenerate simplices\n\n            Finally, note that the classifying space of the order `p`\n            cyclic group is smaller than that of the symmetric group\n            on `p` letters, and its first homology group appears\n            earlier::\n\n                sage: C3 = groups.misc.MultiplicativeAbelian([3])\n                sage: list(C3)\n                [1, f, f^2]\n                sage: BC3 = C3.nerve()\n                sage: BC3.n_cells(1)\n                [f, f^2]\n                sage: BC3.n_cells(2)\n                [f * f, f * f^2, f^2 * f, f^2 * f^2]\n                sage: len(BSigma3.n_cells(2))\n                25\n                sage: len(BC3.n_cells(3))\n                8\n                sage: len(BSigma3.n_cells(3))\n                125\n\n                sage: BC3.homology(range(5), base_ring=GF(3))\n                {0: Vector space of dimension 0 over Finite Field of size 3,\n                 1: Vector space of dimension 1 over Finite Field of size 3,\n                 2: Vector space of dimension 1 over Finite Field of size 3,\n                 3: Vector space of dimension 1 over Finite Field of size 3,\n                 4: Vector space of dimension 1 over Finite Field of size 3}\n\n                sage: BC5 = groups.permutation.Cyclic(5).nerve()\n                sage: BC5.homology(range(5), base_ring=GF(5))\n                {0: Vector space of dimension 0 over Finite Field of size 5,\n                1: Vector space of dimension 1 over Finite Field of size 5,\n                2: Vector space of dimension 1 over Finite Field of size 5,\n                3: Vector space of dimension 1 over Finite Field of size 5,\n                4: Vector space of dimension 1 over Finite Field of size 5}\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "rhodes_radical_congruence": {
                        "__doc__": "\n            Return the Rhodes radical congruence of the semigroup.\n\n            The Rhodes radical congruence is the congruence induced on S by the\n            map `S \\rightarrow kS \\rightarrow kS / rad kS` with k a field.\n\n            INPUT:\n\n            - ``base_ring`` (default: `\\QQ`) a field\n\n            OUTPUT:\n\n            - A list of couples (m, n) with `m \\neq n` in the lexicographic\n              order for the enumeration of the monoid ``self``.\n\n            EXAMPLES::\n\n                sage: M = Monoids().Finite().example()\n                sage: M.rhodes_radical_congruence()\n                [(0, 6), (2, 8), (4, 10)]\n                sage: from sage.monoids.hecke_monoid import HeckeMonoid\n                sage: H3 = HeckeMonoid(SymmetricGroup(3))\n                sage: H3.repr_element_method(style=\"reduced\")\n                sage: H3.rhodes_radical_congruence()\n                [([1, 2], [2, 1]), ([1, 2], [1, 2, 1]), ([2, 1], [1, 2, 1])]\n\n            By Maschke's theorem, every group algebra over `\\QQ`\n            is semisimple hence the Rhodes radical of a group must be trivial::\n\n                sage: SymmetricGroup(3).rhodes_radical_congruence()\n                []\n                sage: DihedralGroup(10).rhodes_radical_congruence()\n                []\n\n            REFERENCES:\n\n            - [Rho69]_\n            ",
                        "args": [
                            "self",
                            "base_ring"
                        ],
                        "argspec": [
                            [
                                "self",
                                "base_ring"
                            ],
                            null,
                            null,
                            [
                                null
                            ]
                        ]
                    }
                },
                "name": "sage.categories.finite_monoids.FiniteMonoids.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets",
                "sage.categories.magmas.Magmas.Unital"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of finite (multiplicative) :class:`monoids <Monoids>`.\n\n    A finite monoid is a :class:`finite sets <FiniteSets>` endowed\n    with an associative unital binary operation `*`.\n\n    EXAMPLES::\n\n        sage: FiniteMonoids()\n        Category of finite monoids\n        sage: FiniteMonoids().super_categories()\n        [Category of monoids, Category of finite semigroups]\n\n    TESTS::\n\n        sage: TestSuite(FiniteMonoids()).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_monoids.FiniteMonoids.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.finite_permutation_groups.FinitePermutationGroups": {
            "__doc__": "\n    The category of finite permutation groups, i.e. groups concretely\n    represented as groups of permutations acting on a finite set.\n\n    It is currently assumed that any finite permutation group comes\n    endowed with a distinguished finite set of generators (method\n    ``group_generators``); this is the case for all the existing\n    implementations in Sage.\n\n    EXAMPLES::\n\n        sage: C = PermutationGroups().Finite(); C\n        Category of finite enumerated permutation groups\n        sage: C.super_categories()\n        [Category of permutation groups,\n         Category of finite groups,\n         Category of finite finitely generated semigroups]\n\n        sage: C.example()\n        Dihedral group of order 6 as a permutation group\n\n    TESTS::\n\n        sage: C is FinitePermutationGroups()\n        True\n        sage: TestSuite(C).run()\n\n        sage: G = FinitePermutationGroups().example()\n        sage: TestSuite(G).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_new() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_inverse() . . . pass\n        running ._test_new() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n    ",
            "axioms": [
                "Inverse",
                "Enumerated",
                "FinitelyGeneratedAsMagma",
                "Unital",
                "Finite",
                "Associative"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_permutation_groups.FinitePermutationGroups.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.permutation_groups.PermutationGroups",
                "sage.categories.finite_groups.FiniteGroups",
                "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category of finite permutation groups, i.e. groups concretely\n    represented as groups of permutations acting on a finite set.\n\n    It is currently assumed that any finite permutation group comes\n    endowed with a distinguished finite set of generators (method\n    ``group_generators``); this is the case for all the existing\n    implementations in Sage.\n\n    EXAMPLES::\n\n        sage: C = PermutationGroups().Finite(); C\n        Category of finite enumerated permutation groups\n        sage: C.super_categories()\n        [Category of permutation groups,\n         Category of finite groups,\n         Category of finite finitely generated semigroups]\n\n        sage: C.example()\n        Dihedral group of order 6 as a permutation group\n\n    TESTS::\n\n        sage: C is FinitePermutationGroups()\n        True\n        sage: TestSuite(C).run()\n\n        sage: G = FinitePermutationGroups().example()\n        sage: TestSuite(G).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_new() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_inverse() . . . pass\n        running ._test_new() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_permutation_groups.FinitePermutationGroups.morphism_class"
            },
            "name": "sage.categories.finite_permutation_groups.FinitePermutationGroups",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "cycle_index": {
                        "__doc__": "\n            INPUT:\n\n             - ``self`` - a permutation group `G`\n             - ``parent`` -- a free module with basis indexed by partitions,\n               or behave as such, with a ``term`` and ``sum`` method\n               (default: the symmetric functions over the rational field in the p basis)\n\n            Returns the *cycle index* of `G`, which is a gadget counting\n            the elements of `G` by cycle type, averaged over the group:\n\n            .. MATH::\n\n                P = \\frac{1}{|G|} \\sum_{g\\in G} p_{ \\operatorname{cycle\\ type}(g) }\n\n            EXAMPLES:\n\n            Among the permutations of the symmetric group `S_4`, there is\n            the identity, 6 cycles of length 2, 3 products of two cycles\n            of length 2, 8 cycles of length 3, and 6 cycles of length 4::\n\n                sage: S4 = SymmetricGroup(4)\n                sage: P = S4.cycle_index()\n                sage: 24 * P\n                p[1, 1, 1, 1] + 6*p[2, 1, 1] + 3*p[2, 2] + 8*p[3, 1] + 6*p[4]\n\n            If `l = (l_1,\\dots,l_k)` is a partition, ``|G| P[l]`` is the number\n            of elements of `G` with cycles of length `(p_1,\\dots,p_k)`::\n\n                sage: 24 * P[ Partition([3,1]) ]\n                8\n\n            The cycle index plays an important role in the enumeration of\n            objects modulo the action of a group (Polya enumeration), via\n            the use of symmetric functions and plethysms. It is therefore\n            encoded as a symmetric function, expressed in the powersum\n            basis::\n\n                sage: P.parent()\n                Symmetric Functions over Rational Field in the powersum basis\n\n            This symmetric function can have some nice properties; for\n            example, for the symmetric group `S_n`, we get the complete\n            symmetric function `h_n`::\n\n                sage: S = SymmetricFunctions(QQ); h = S.h()\n                sage: h( P )\n                h[4]\n\n            TODO: add some simple examples of Polya enumeration, once it\n            will be easy to expand symmetric functions on any alphabet.\n\n            Here are the cycle indices of some permutation groups::\n\n                sage: 6 * CyclicPermutationGroup(6).cycle_index()\n                p[1, 1, 1, 1, 1, 1] + p[2, 2, 2] + 2*p[3, 3] + 2*p[6]\n\n                sage: 60 * AlternatingGroup(5).cycle_index()\n                p[1, 1, 1, 1, 1] + 15*p[2, 2, 1] + 20*p[3, 1, 1] + 24*p[5]\n\n                sage: for G in TransitiveGroups(5):               # optional - database_gap # long time\n                ....:     G.cardinality() * G.cycle_index()\n                p[1, 1, 1, 1, 1] + 4*p[5]\n                p[1, 1, 1, 1, 1] + 5*p[2, 2, 1] + 4*p[5]\n                p[1, 1, 1, 1, 1] + 5*p[2, 2, 1] + 10*p[4, 1] + 4*p[5]\n                p[1, 1, 1, 1, 1] + 15*p[2, 2, 1] + 20*p[3, 1, 1] + 24*p[5]\n                p[1, 1, 1, 1, 1] + 10*p[2, 1, 1, 1] + 15*p[2, 2, 1] + 20*p[3, 1, 1] + 20*p[3, 2] + 30*p[4, 1] + 24*p[5]\n\n            One may specify another parent for the result::\n\n                sage: F = CombinatorialFreeModule(QQ, Partitions())\n                sage: P = CyclicPermutationGroup(6).cycle_index(parent = F)\n                sage: 6 * P\n                B[[1, 1, 1, 1, 1, 1]] + B[[2, 2, 2]] + 2*B[[3, 3]] + 2*B[[6]]\n                sage: P.parent() is F\n                True\n\n            This parent should have a ``term`` and ``sum`` method::\n\n                sage: CyclicPermutationGroup(6).cycle_index(parent = QQ)\n                Traceback (most recent call last):\n                  ...\n                AssertionError: `parent` should be (or behave as) a free module with basis indexed by partitions\n\n            REFERENCES:\n\n            - [Ke1991]_\n\n            AUTHORS:\n\n             - Nicolas Borie and Nicolas M. Thiery\n\n            TESTS::\n\n                sage: P = PermutationGroup([]); P\n                Permutation Group with generators [()]\n                sage: P.cycle_index()\n                p[1]\n                sage: P = PermutationGroup([[(1)]]); P\n                Permutation Group with generators [()]\n                sage: P.cycle_index()\n                p[1]\n            ",
                        "args": [
                            "self",
                            "parent"
                        ],
                        "argspec": [
                            [
                                "self",
                                "parent"
                            ],
                            null,
                            null,
                            [
                                null
                            ]
                        ]
                    }
                },
                "name": "sage.categories.finite_permutation_groups.FinitePermutationGroups.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas.Unital",
                "sage.categories.magmas.Magmas",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets",
                "sage.categories.permutation_groups.PermutationGroups"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of finite permutation groups, i.e. groups concretely\n    represented as groups of permutations acting on a finite set.\n\n    It is currently assumed that any finite permutation group comes\n    endowed with a distinguished finite set of generators (method\n    ``group_generators``); this is the case for all the existing\n    implementations in Sage.\n\n    EXAMPLES::\n\n        sage: C = PermutationGroups().Finite(); C\n        Category of finite enumerated permutation groups\n        sage: C.super_categories()\n        [Category of permutation groups,\n         Category of finite groups,\n         Category of finite finitely generated semigroups]\n\n        sage: C.example()\n        Dihedral group of order 6 as a permutation group\n\n    TESTS::\n\n        sage: C is FinitePermutationGroups()\n        True\n        sage: TestSuite(C).run()\n\n        sage: G = FinitePermutationGroups().example()\n        sage: TestSuite(G).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_new() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_inverse() . . . pass\n        running ._test_new() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_permutation_groups.FinitePermutationGroups.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.finite_semigroups.FiniteSemigroups": {
            "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "axioms": [
                "Finite",
                "Associative"
            ],
            "element_class": {
                "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_semigroups.FiniteSemigroups.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.semigroups.Semigroups",
                "sage.categories.finite_sets.FiniteSets"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_semigroups.FiniteSemigroups.morphism_class"
            },
            "name": "sage.categories.finite_semigroups.FiniteSemigroups",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "idempotents": {
                        "__doc__": "\n            Returns the idempotents of the semigroup\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example(alphabet=('x','y'))\n                sage: sorted(S.idempotents())\n                ['x', 'xy', 'y', 'yx']\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "isomorphism_transformation_monoid": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method isomorphism_transformation_monoid at 0x7faa353cf848>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": null,
                        "gap_name": "IsomorphismTransformationMonoid",
                        "mmt_name": null
                    },
                    "j_classes": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "j_classes_of_idempotents": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "j_transversal_of_idempotents": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    }
                },
                "name": "sage.categories.finite_semigroups.FiniteSemigroups.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_semigroups.FiniteSemigroups.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.finite_sets.FiniteSets": {
            "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
            "axioms": [
                "Finite"
            ],
            "element_class": {
                "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_sets.FiniteSets.element_class"
            },
            "gap": "IsFinite",
            "implied": [
                "sage.categories.sets_cat.Sets"
            ],
            "mmt": "TODO",
            "morphism_class": {
                "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_sets.FiniteSets.morphism_class"
            },
            "name": "sage.categories.finite_sets.FiniteSets",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "list": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method list at 0x7faa353be500>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "list_of_self",
                        "gap_name": "List",
                        "mmt_name": null
                    }
                },
                "name": "sage.categories.finite_sets.FiniteSets.parent_class"
            },
            "structure": [
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finite_sets.FiniteSets.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas": {
            "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "axioms": [
                "FinitelyGeneratedAsMagma"
            ],
            "element_class": {
                "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.magmas.Magmas"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.morphism_class"
            },
            "name": "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "magma_generators": {
                        "__doc__": "\n            Return distinguished magma generators for ``self``.\n\n            OUTPUT: a finite family\n\n            This method should be implemented by all\n            :class:`finitely generated magmas <FinitelyGeneratedMagmas>`.\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example()\n                sage: S.magma_generators()\n                Family ('a', 'b', 'c', 'd')\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups": {
            "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Enumerated', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "axioms": [
                "Enumerated",
                "Associative",
                "FinitelyGeneratedAsMagma"
            ],
            "element_class": {
                "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Enumerated', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.semigroups.Semigroups",
                "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas",
                "sage.categories.enumerated_sets.EnumeratedSets"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Enumerated', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.morphism_class"
            },
            "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "ideal": {
                        "__doc__": "\n            Return the ``side``-sided ideal generated by ``gens``.\n\n            This brute force implementation recursively multiplies the\n            elements of ``gens`` by the distinguished generators of\n            this semigroup.\n\n            .. SEEALSO:: :meth:`semigroup_generators`\n\n            INPUT:\n\n            - ``gens`` -- a list (or iterable) of elements of ``self``\n            - ``side`` -- [default: \"twosided\"] \"left\", \"right\" or \"twosided\"\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example()\n                sage: list(S.ideal([S('cab')], side=\"left\"))\n                ['cab', 'acb', 'dcab', 'bca', 'abc', 'adcb', 'bdca',\n                 'cba', 'cdab', 'bac', 'dacb', 'dbca', 'adbc', 'bcda',\n                 'dbac', 'dabc', 'cbda', 'cdba', 'abdc', 'bdac', 'dcba',\n                 'cadb', 'badc', 'acdb', 'abcd', 'cbad', 'bacd', 'acbd',\n                 'bcad', 'cabd']\n                sage: list(S.ideal([S('cab')], side=\"right\"))\n                ['cab', 'cabd']\n                sage: list(S.ideal([S('cab')], side=\"twosided\"))\n                ['cab', 'acb', 'dcab', 'bca', 'cabd', 'abc', 'adcb',\n                 'acbd', 'bdca', 'bcad', 'cba', 'cdab', 'bac', 'dacb',\n                 'dbca', 'abcd', 'cbad', 'bacd', 'bcda', 'dbac', 'dabc',\n                 'cbda', 'cdba', 'abdc', 'adbc', 'bdac', 'dcba', 'cadb',\n                 'badc', 'acdb']\n                sage: list(S.ideal([S('cab')]))\n                ['cab', 'acb', 'dcab', 'bca', 'cabd', 'abc', 'adcb',\n                 'acbd', 'bdca', 'bcad', 'cba', 'cdab', 'bac', 'dacb',\n                 'dbca', 'abcd', 'cbad', 'bacd', 'bcda', 'dbac', 'dabc',\n                 'cbda', 'cdba', 'abdc', 'adbc', 'bdac', 'dcba', 'cadb',\n                 'badc', 'acdb']\n            ",
                        "args": [
                            "self",
                            "gens",
                            "side"
                        ],
                        "argspec": [
                            [
                                "self",
                                "gens",
                                "side"
                            ],
                            null,
                            null,
                            [
                                "twosided"
                            ]
                        ]
                    },
                    "succ_generators": {
                        "__doc__": "\n            Return the successor function of the ``side``-sided Cayley\n            graph of ``self``.\n\n            This is a function that maps an element of ``self`` to all\n            the products of ``x`` by a generator of this semigroup,\n            where the product is taken on the left, right, or both\n            sides.\n\n            INPUT:\n\n            - ``side``: \"left\", \"right\", or \"twosided\"\n\n            .. TODO:: Design choice:\n\n               - find a better name for this method\n               - should we return a set? a family?\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example()\n                sage: S.succ_generators(\"left\" )(S('ca'))\n                ('ac', 'bca', 'ca', 'dca')\n                sage: S.succ_generators(\"right\")(S('ca'))\n                ('ca', 'cab', 'ca', 'cad')\n                sage: S.succ_generators(\"twosided\" )(S('ca'))\n                ('ac', 'bca', 'ca', 'dca', 'ca', 'cab', 'ca', 'cad')\n\n            ",
                        "args": [
                            "self",
                            "side"
                        ],
                        "argspec": [
                            [
                                "self",
                                "side"
                            ],
                            null,
                            null,
                            [
                                "twosided"
                            ]
                        ]
                    }
                },
                "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Enumerated', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite": {
            "__doc__": null,
            "axioms": [
                "Finite",
                "Enumerated",
                "Associative",
                "FinitelyGeneratedAsMagma"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups",
                "sage.categories.finite_semigroups.FiniteSemigroups",
                "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.morphism_class"
            },
            "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.groups.Groups": {
            "__doc__": "\n    The category of (multiplicative) groups, i.e. monoids with\n    inverses.\n\n    EXAMPLES::\n\n        sage: Groups()\n        Category of groups\n        sage: Groups().super_categories()\n        [Category of monoids, Category of inverse unital magmas]\n\n    TESTS::\n\n        sage: TestSuite(Groups()).run()\n    ",
            "axioms": [
                "Inverse",
                "Associative",
                "Unital"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "conjugacy_class": {
                        "__doc__": "\n            Return the conjugacy class of ``self``.\n\n            EXAMPLES::\n\n                sage: D = DihedralGroup(5)\n                sage: g = D((1,3,5,2,4))\n                sage: g.conjugacy_class()\n                Conjugacy class of (1,3,5,2,4) in Dihedral group of order 10 as a permutation group\n\n                sage: H = MatrixGroup([matrix(GF(5),2,[1,2, -1, 1]), matrix(GF(5),2, [1,1, 0,1])])\n                sage: h = H(matrix(GF(5),2,[1,2, -1, 1]))\n                sage: h.conjugacy_class()\n                Conjugacy class of [1 2]\n                [4 1] in Matrix group over Finite Field of size 5 with 2 generators (\n                [1 2]  [1 1]\n                [4 1], [0 1]\n                )\n\n                sage: G = SL(2, GF(2))\n                sage: g = G.gens()[0]\n                sage: g.conjugacy_class()\n                Conjugacy class of [1 1]\n                [0 1] in Special Linear Group of degree 2 over Finite Field of size 2\n\n                sage: G = SL(2, QQ)\n                sage: g = G([[1,1],[0,1]])\n                sage: g.conjugacy_class()\n                Conjugacy class of [1 1]\n                [0 1] in Special Linear Group of degree 2 over Rational Field\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.groups.Groups.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.monoids.Monoids",
                "sage.categories.magmas.Magmas.Unital.Inverse"
            ],
            "mmt": "Group",
            "morphism_class": {
                "__doc__": "\n    The category of (multiplicative) groups, i.e. monoids with\n    inverses.\n\n    EXAMPLES::\n\n        sage: Groups()\n        Category of groups\n        sage: Groups().super_categories()\n        [Category of monoids, Category of inverse unital magmas]\n\n    TESTS::\n\n        sage: TestSuite(Groups()).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.groups.Groups.morphism_class"
            },
            "name": "sage.categories.groups.Groups",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "_test_inverse": {
                        "__doc__": "\n            Run generic tests on the method :meth:`.__invert__`.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: G = SymmetricGroup(3)\n                sage: G._test_inverse()\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "cayley_table": {
                        "__doc__": "\n            Returns the \"multiplication\" table of this multiplicative group,\n            which is also known as the \"Cayley table\".\n\n            .. note:: The order of the elements in the row and column\n              headings is equal to the order given by the table's\n              :meth:`~sage.matrix.operation_table.OperationTable.column_keys`\n              method.  The association between the actual elements and the\n              names/symbols used in the table can also be retrieved as\n              a dictionary with the\n              :meth:`~sage.matrix.operation_table.OperationTable.translation`\n              method.\n\n            For groups, this routine should behave identically to the\n            :meth:`~sage.categories.magmas.Magmas.ParentMethods.multiplication_table`\n            method for magmas, which applies in greater generality.\n\n            INPUT:\n\n            - ``names`` - the type of names used, values are:\n\n              * ``'letters'`` - lowercase ASCII letters are used\n                for a base 26 representation of the elements'\n                positions in the list given by :meth:`list`,\n                padded to a common width with leading 'a's.\n              * ``'digits'`` - base 10 representation of the\n                elements' positions in the list given by\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`,\n                padded to a common width with leading zeros.\n              * ``'elements'`` - the string representations\n                of the elements themselves.\n              * a list - a list of strings, where the length\n                of the list equals the number of elements.\n\n            - ``elements`` - default = ``None``.  A list of\n              elements of the group, in forms that can be\n              coerced into the structure, eg. their string\n              representations. This may be used to impose an\n              alternate ordering on the elements, perhaps when\n              this is used in the context of a particular structure.\n              The default is to use whatever ordering is provided by the\n              the group, which is reported by the\n              :meth:`~sage.matrix.operation_table.OperationTable.column_keys`\n              method.  Or the ``elements`` can be a subset\n              which is closed under the operation. In particular,\n              this can be used when the base set is infinite.\n\n            OUTPUT:\n            An object representing the multiplication table.  This is\n            an :class:`~sage.matrix.operation_table.OperationTable` object\n            and even more documentation can be found there.\n\n\n            EXAMPLES:\n\n            Permutation groups, matrix groups and abelian groups\n            can all compute their multiplication tables.  ::\n\n                sage: G = DiCyclicGroup(3)\n                sage: T = G.cayley_table()\n                sage: T.column_keys()\n                ((), (1,3,2,4)(5,7), ..., (1,2)(3,4)(5,7,6))\n                sage: T\n                *  a b c d e f g h i j k l\n                 +------------------------\n                a| a b c d e f g h i j k l\n                b| b e f j i h d k a l c g\n                c| c g d e h b k l j f i a\n                d| d k e h l g i a f b j c\n                e| e i h l a k j c b g f d\n                f| f d j i k e c g l h a b\n                g| g h b f j l e i c a d k\n                h| h j l a c i f d g k b e\n                i| i a k g b c l f e d h j\n                j| j c i k g d a b h e l f\n                k| k l g b f a h j d c e i\n                l| l f a c d j b e k i g h\n\n            ::\n\n                sage: M=SL(2,2)\n                sage: M.cayley_table()\n                *  a b c d e f\n                 +------------\n                a| a b c d e f\n                b| b a d c f e\n                c| c f e b a d\n                d| d e f a b c\n                e| e d a f c b\n                f| f c b e d a\n                <BLANKLINE>\n\n            ::\n\n                sage: A=AbelianGroup([2,3])\n                sage: A.cayley_table()\n                *  a b c d e f\n                 +------------\n                a| a b c d e f\n                b| b c a e f d\n                c| c a b f d e\n                d| d e f a b c\n                e| e f d b c a\n                f| f d e c a b\n\n            Lowercase ASCII letters are the default symbols used\n            for the table, but you can also specify the use of\n            decimal digit strings, or provide your own strings\n            (in the proper order if they have meaning).\n            Also, if the elements themselves are not too complex,\n            you can choose to just use the string representations\n            of the elements themselves.  ::\n\n                sage: C=CyclicPermutationGroup(11)\n                sage: C.cayley_table(names='digits')\n                 *  00 01 02 03 04 05 06 07 08 09 10\n                  +---------------------------------\n                00| 00 01 02 03 04 05 06 07 08 09 10\n                01| 01 02 03 04 05 06 07 08 09 10 00\n                02| 02 03 04 05 06 07 08 09 10 00 01\n                03| 03 04 05 06 07 08 09 10 00 01 02\n                04| 04 05 06 07 08 09 10 00 01 02 03\n                05| 05 06 07 08 09 10 00 01 02 03 04\n                06| 06 07 08 09 10 00 01 02 03 04 05\n                07| 07 08 09 10 00 01 02 03 04 05 06\n                08| 08 09 10 00 01 02 03 04 05 06 07\n                09| 09 10 00 01 02 03 04 05 06 07 08\n                10| 10 00 01 02 03 04 05 06 07 08 09\n\n            ::\n\n                sage: G=QuaternionGroup()\n                sage: names=['1', 'I', 'J', '-1', '-K', 'K', '-I', '-J']\n                sage: G.cayley_table(names=names)\n                 *   1  I  J -1 -K  K -I -J\n                  +------------------------\n                 1|  1  I  J -1 -K  K -I -J\n                 I|  I -1  K -I  J -J  1 -K\n                 J|  J -K -1 -J -I  I  K  1\n                -1| -1 -I -J  1  K -K  I  J\n                -K| -K -J  I  K -1  1  J -I\n                 K|  K  J -I -K  1 -1 -J  I\n                -I| -I  1 -K  I -J  J -1  K\n                -J| -J  K  1  J  I -I -K -1\n\n            ::\n\n                sage: A=AbelianGroup([2,2])\n                sage: A.cayley_table(names='elements')\n                    *      1    f1    f0 f0*f1\n                     +------------------------\n                    1|     1    f1    f0 f0*f1\n                   f1|    f1     1 f0*f1    f0\n                   f0|    f0 f0*f1     1    f1\n                f0*f1| f0*f1    f0    f1     1\n\n            The :meth:`~sage.matrix.operation_table.OperationTable.change_names`\n            routine behaves similarly, but changes an existing table \"in-place.\"\n            ::\n\n                sage: G=AlternatingGroup(3)\n                sage: T=G.cayley_table()\n                sage: T.change_names('digits')\n                sage: T\n                *  0 1 2\n                 +------\n                0| 0 1 2\n                1| 1 2 0\n                2| 2 0 1\n\n            For an infinite group, you can still work with finite sets of\n            elements, provided the set is closed under multiplication.\n            Elements will be coerced into the group as part of setting\n            up the table.  ::\n\n                sage: G=SL(2,ZZ)\n                sage: G\n                Special Linear Group of degree 2 over Integer Ring\n                sage: identity = matrix(ZZ, [[1,0], [0,1]])\n                sage: G.cayley_table(elements=[identity, -identity])\n                *  a b\n                 +----\n                a| a b\n                b| b a\n\n            The\n            :class:`~sage.matrix.operation_table.OperationTable`\n            class provides even greater flexibility, including changing\n            the operation.  Here is one such example, illustrating the\n            computation of commutators.  ``commutator`` is defined as\n            a function of two variables, before being used to build\n            the table. From this, the commutator subgroup seems obvious,\n            and creating a Cayley table with just these three elements\n            confirms that they form a closed subset in the group.\n            ::\n\n                sage: from sage.matrix.operation_table import OperationTable\n                sage: G=DiCyclicGroup(3)\n                sage: commutator = lambda x, y: x*y*x^-1*y^-1\n                sage: T=OperationTable(G, commutator)\n                sage: T\n                .  a b c d e f g h i j k l\n                 +------------------------\n                a| a a a a a a a a a a a a\n                b| a a h d a d h h a h d d\n                c| a d a a a d d a d d d a\n                d| a h a a a h h a h h h a\n                e| a a a a a a a a a a a a\n                f| a h h d a a d h h d a d\n                g| a d h d a h a h d a h d\n                h| a d a a a d d a d d d a\n                i| a a h d a d h h a h d d\n                j| a d h d a h a h d a h d\n                k| a h h d a a d h h d a d\n                l| a h a a a h h a h h h a\n                sage: trans = T.translation()\n                sage: comm = [trans['a'], trans['d'],trans['h']]\n                sage: comm\n                [(), (5,7,6), (5,6,7)]\n                sage: P=G.cayley_table(elements=comm)\n                sage: P\n                *  a b c\n                 +------\n                a| a b c\n                b| b c a\n                c| c a b\n\n            TODO:\n\n            Arrange an ordering of elements into cosets of a normal\n            subgroup close to size `\\sqrt{n}`.  Then the quotient\n            group structure is often apparent in the table.  See\n            comments on :trac:`7555`.\n\n            AUTHOR:\n\n            - Rob Beezer (2010-03-15)\n\n            ",
                        "args": [
                            "self",
                            "names",
                            "elements"
                        ],
                        "argspec": [
                            [
                                "self",
                                "names",
                                "elements"
                            ],
                            null,
                            null,
                            [
                                "letters",
                                null
                            ]
                        ]
                    },
                    "conjugacy_class": {
                        "__doc__": "\n            Return the conjugacy class of the element ``g``.\n\n            This is a fall-back method for groups not defined over GAP.\n\n            EXAMPLES::\n\n                sage: A = AbelianGroup([2,2])\n                sage: c = A.conjugacy_class(A.an_element())\n                sage: type(c)\n                <class 'sage.groups.conjugacy_classes.ConjugacyClass_with_category'>\n            ",
                        "args": [
                            "self",
                            "g"
                        ],
                        "argspec": [
                            [
                                "self",
                                "g"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "group_generators": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method group_generators at 0x7faa353cfa28>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "list_of_self",
                        "gap_name": "GeneratorsOfGroup",
                        "mmt_name": null
                    },
                    "holomorph": {
                        "__doc__": "\n            The holomorph of a group\n\n            The holomorph of a group `G` is the semidirect product\n            `G \\rtimes_{id} Aut(G)`, where `id` is the identity function\n            on `Aut(G)`, the automorphism group of `G`.\n\n            See :wikipedia:`Holomorph (mathematics)`\n\n            EXAMPLES::\n\n                sage: G = Groups().example()\n                sage: G.holomorph()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: holomorph of General Linear Group of degree 4 over Rational Field not yet implemented\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "is_abelian": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method is_abelian at 0x7faa353cf938>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "sage",
                        "gap_name": "IsAbelian",
                        "mmt_name": null
                    },
                    "semidirect_product": {
                        "__doc__": "\n            The semi-direct product of two groups\n\n            EXAMPLES::\n\n                sage: G = Groups().example()\n                sage: G.semidirect_product(G,Morphism(G,G))\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: semidirect product of General Linear Group of degree 4 over Rational Field and General Linear Group of degree 4 over Rational Field not yet implemented\n            ",
                        "args": [
                            "self",
                            "N",
                            "mapping",
                            "check"
                        ],
                        "argspec": [
                            [
                                "self",
                                "N",
                                "mapping",
                                "check"
                            ],
                            null,
                            null,
                            [
                                true
                            ]
                        ]
                    }
                },
                "name": "sage.categories.groups.Groups.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets",
                "sage.categories.magmas.Magmas.Unital"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of (multiplicative) groups, i.e. monoids with\n    inverses.\n\n    EXAMPLES::\n\n        sage: Groups()\n        Category of groups\n        sage: Groups().super_categories()\n        [Category of monoids, Category of inverse unital magmas]\n\n    TESTS::\n\n        sage: TestSuite(Groups()).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.groups.Groups.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets": {
            "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
            "axioms": [
                "Infinite",
                "Enumerated"
            ],
            "element_class": {
                "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.enumerated_sets.EnumeratedSets",
                "sage.categories.sets_cat.Sets.Infinite"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.morphism_class"
            },
            "name": "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "_test_enumerated_set_iter_cardinality": {
                        "__doc__": "\n            Check that the methods :meth:`.cardinality` and\n            :meth:`.__iter__`. are consistent.\n\n            See also :class:`TestSuite`.\n\n            For infinite enumerated sets:\n\n               * :meth:`.cardinality` is supposed to return `infinity`\n\n               * :meth:`.list`` is supposed to raise a ``NotImplementedError``.\n\n            EXAMPLES::\n\n                sage: NN = InfiniteEnumeratedSets().example()\n                sage: NN._test_enumerated_set_iter_cardinality()\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    }
                },
                "name": "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.parent_class"
            },
            "structure": [
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.magmas.Magmas": {
            "__doc__": "\n    The category of (multiplicative) magmas.\n\n    A magma is a set with a binary operation `*`.\n\n    EXAMPLES::\n\n        sage: Magmas()\n        Category of magmas\n        sage: Magmas().super_categories()\n        [Category of sets]\n        sage: Magmas().all_super_categories()\n        [Category of magmas, Category of sets,\n         Category of sets with partial maps, Category of objects]\n\n    The following axioms are defined by this category::\n\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Unital()\n        Category of unital magmas\n        sage: Magmas().Commutative()\n        Category of commutative magmas\n        sage: Magmas().Unital().Inverse()\n        Category of inverse unital magmas\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Associative().Unital()\n        Category of monoids\n        sage: Magmas().Associative().Unital().Inverse()\n        Category of groups\n\n    TESTS::\n\n        sage: C = Magmas()\n        sage: TestSuite(C).run()\n    ",
            "axioms": [],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "_mul_": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method _mul_ at 0x7fab251e79b0>",
                        "args": [
                            "self",
                            "other"
                        ],
                        "argspec": [
                            [
                                "self",
                                "other"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "parent",
                        "gap_name": "\\*",
                        "mmt_name": "*"
                    },
                    "_mul_parent": {
                        "__doc__": "_mul_parent(self, other)\nFile: sage/categories/coercion_methods.pyx (starting at line 15)\n\n    Return the product of the two elements, calculated using\n    the ``product`` method of the parent.\n\n    This is inserted by :meth:`Magmas.ParentMethods.__init_extra__` as\n    default implementation of ``Magmas.ElementMethods._mul_`` if\n    ``product`` is implemented in the parent.\n\n    INPUT:\n\n    - ``other`` -- an element of the parent of ``self``\n\n    OUTPUT:\n\n    - an element of the parent of ``self``\n\n    EXAMPLES::\n\n        sage: S = Semigroups().example(\"free\")\n        sage: x = S('a'); y = S('b')\n        sage: x._mul_parent(y)\n        'ab'\n\n    .. SEEALSO::\n\n        - :meth:`Magmas.ElementMethods._mul_parent`\n        - :meth:`Magmas.ElementMethods.__init_extra__`\n        - :meth:`Magmas.ParentMethods.product`\n\n    This is :meth:`Magmas.ElementMethods._mul_parent`, implemented as\n    a Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x._mul_parent.im_func is Magmas.ElementMethods._mul_parent.im_func\n        True\n        sage: x._mul_parent.im_func is sage.categories.coercion_methods._mul_parent\n        True\n    ",
                        "args": [
                            "self",
                            "other"
                        ],
                        "argspec": [
                            [
                                "self",
                                "other"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "is_idempotent": {
                        "__doc__": "\n            Test whether ``self`` is idempotent.\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\"); S\n                An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n                sage: a = S('a')\n                sage: a^2\n                'aa'\n                sage: a.is_idempotent()\n                False\n\n            ::\n\n                sage: L = Semigroups().example(\"leftzero\"); L\n                An example of a semigroup: the left zero semigroup\n                sage: x = L('x')\n                sage: x^2\n                'x'\n                sage: x.is_idempotent()\n                True\n\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.magmas.Magmas.element_class"
            },
            "gap": "IsMagma",
            "implied": [
                "sage.categories.sets_cat.Sets"
            ],
            "mmt": "Magma",
            "morphism_class": {
                "__doc__": "\n    The category of (multiplicative) magmas.\n\n    A magma is a set with a binary operation `*`.\n\n    EXAMPLES::\n\n        sage: Magmas()\n        Category of magmas\n        sage: Magmas().super_categories()\n        [Category of sets]\n        sage: Magmas().all_super_categories()\n        [Category of magmas, Category of sets,\n         Category of sets with partial maps, Category of objects]\n\n    The following axioms are defined by this category::\n\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Unital()\n        Category of unital magmas\n        sage: Magmas().Commutative()\n        Category of commutative magmas\n        sage: Magmas().Unital().Inverse()\n        Category of inverse unital magmas\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Associative().Unital()\n        Category of monoids\n        sage: Magmas().Associative().Unital().Inverse()\n        Category of groups\n\n    TESTS::\n\n        sage: C = Magmas()\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.magmas.Magmas.morphism_class"
            },
            "name": "sage.categories.magmas.Magmas",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "__init_extra__": {
                        "__doc__": "\n                sage: S = Semigroups().example(\"free\")\n                sage: S('a') * S('b') # indirect doctest\n                'ab'\n                sage: S('a').__class__._mul_ == S('a').__class__._mul_parent\n                True\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "multiplication_table": {
                        "__doc__": "\n            Returns a table describing the multiplication operation.\n\n            .. note:: The order of the elements in the row and column\n              headings is equal to the order given by the table's\n              :meth:`~sage.matrix.operation_table.OperationTable.list`\n              method.  The association can also be retrieved with the\n              :meth:`~sage.matrix.operation_table.OperationTable.dict`\n              method.\n\n            INPUT:\n\n            - ``names`` - the type of names used\n\n              * ``'letters'`` - lowercase ASCII letters are used\n                for a base 26 representation of the elements'\n                positions in the list given by\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`,\n                padded to a common width with leading 'a's.\n              * ``'digits'`` - base 10 representation of the\n                elements' positions in the list given by\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`,\n                padded to a common width with leading zeros.\n              * ``'elements'`` - the string representations\n                of the elements themselves.\n              * a list - a list of strings, where the length\n                of the list equals the number of elements.\n            - ``elements`` - default = ``None``.  A list of\n              elements of the magma, in forms that can be\n              coerced into the structure, eg. their string\n              representations. This may be used to impose an\n              alternate ordering on the elements, perhaps when\n              this is used in the context of a particular structure.\n              The default is to use whatever ordering the ``S.list``\n              method returns. Or the ``elements`` can be a subset\n              which is closed under the operation. In particular,\n              this can be used when the base set is infinite.\n\n            OUTPUT:\n            The multiplication table as an object of the class\n            :class:`~sage.matrix.operation_table.OperationTable`\n            which defines several methods for manipulating and\n            displaying the table.  See the documentation there\n            for full details to supplement the documentation\n            here.\n\n            EXAMPLES:\n\n            The default is to represent elements as lowercase\n            ASCII letters.  ::\n\n                sage: G=CyclicPermutationGroup(5)\n                sage: G.multiplication_table()\n                *  a b c d e\n                 +----------\n                a| a b c d e\n                b| b c d e a\n                c| c d e a b\n                d| d e a b c\n                e| e a b c d\n\n            All that is required is that an algebraic structure\n            has a multiplication defined.  A\n            :class:`~sage.categories.examples.finite_semigroups.LeftRegularBand`\n            is an example of a finite semigroup.  The ``names`` argument allows\n            displaying the elements in different ways.  ::\n\n                sage: from sage.categories.examples.finite_semigroups import LeftRegularBand\n                sage: L=LeftRegularBand(('a','b'))\n                sage: T=L.multiplication_table(names='digits')\n                sage: T.column_keys()\n                ('a', 'b', 'ab', 'ba')\n                sage: T\n                *  0 1 2 3\n                 +--------\n                0| 0 2 2 2\n                1| 3 1 3 3\n                2| 2 2 2 2\n                3| 3 3 3 3\n\n            Specifying the elements in an alternative order can provide\n            more insight into how the operation behaves.  ::\n\n                sage: L=LeftRegularBand(('a','b','c'))\n                sage: elts = sorted(L.list())\n                sage: L.multiplication_table(elements=elts)\n                *  a b c d e f g h i j k l m n o\n                 +------------------------------\n                a| a b c d e b b c c c d d e e e\n                b| b b c c c b b c c c c c c c c\n                c| c c c c c c c c c c c c c c c\n                d| d e e d e e e e e e d d e e e\n                e| e e e e e e e e e e e e e e e\n                f| g g h h h f g h i j i j j i j\n                g| g g h h h g g h h h h h h h h\n                h| h h h h h h h h h h h h h h h\n                i| j j j j j i j j i j i j j i j\n                j| j j j j j j j j j j j j j j j\n                k| l m m l m n o o n o k l m n o\n                l| l m m l m m m m m m l l m m m\n                m| m m m m m m m m m m m m m m m\n                n| o o o o o n o o n o n o o n o\n                o| o o o o o o o o o o o o o o o\n\n            The ``elements`` argument can be used to provide\n            a subset of the elements of the structure.  The subset\n            must be closed under the operation.  Elements need only\n            be in a form that can be coerced into the set.  The\n            ``names`` argument can also be used to request that\n            the elements be represented with their usual string\n            representation.  ::\n\n                sage: L=LeftRegularBand(('a','b','c'))\n                sage: elts=['a', 'c', 'ac', 'ca']\n                sage: L.multiplication_table(names='elements', elements=elts)\n                   *   'a'  'c' 'ac' 'ca'\n                    +--------------------\n                 'a'|  'a' 'ac' 'ac' 'ac'\n                 'c'| 'ca'  'c' 'ca' 'ca'\n                'ac'| 'ac' 'ac' 'ac' 'ac'\n                'ca'| 'ca' 'ca' 'ca' 'ca'\n\n            The table returned can be manipulated in various ways.  See\n            the documentation for\n            :class:`~sage.matrix.operation_table.OperationTable` for more\n            comprehensive documentation. ::\n\n                sage: G=AlternatingGroup(3)\n                sage: T=G.multiplication_table()\n                sage: T.column_keys()\n                ((), (1,2,3), (1,3,2))\n                sage: sorted(T.translation().items())\n                [('a', ()), ('b', (1,2,3)), ('c', (1,3,2))]\n                sage: T.change_names(['x', 'y', 'z'])\n                sage: sorted(T.translation().items())\n                [('x', ()), ('y', (1,2,3)), ('z', (1,3,2))]\n                sage: T\n                *  x y z\n                 +------\n                x| x y z\n                y| y z x\n                z| z x y\n            ",
                        "args": [
                            "self",
                            "names",
                            "elements"
                        ],
                        "argspec": [
                            [
                                "self",
                                "names",
                                "elements"
                            ],
                            null,
                            null,
                            [
                                "letters",
                                null
                            ]
                        ]
                    },
                    "product": {
                        "__doc__": "\n            The binary multiplication of the magma.\n\n            INPUT:\n\n            - ``x``, ``y`` -- elements of this magma\n\n            OUTPUT:\n\n            - an element of the magma (the product of ``x`` and ``y``)\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\")\n                sage: x = S('a'); y = S('b')\n                sage: S.product(x, y)\n                'ab'\n\n            A parent in ``Magmas()`` must either implement\n            :meth:`.product` in the parent class or ``_mul_`` in the\n            element class. By default, the addition method on elements\n            ``x._mul_(y)`` calls ``S.product(x,y)``, and reciprocally.\n\n            As a bonus, ``S.product`` models the binary function from\n            ``S`` to ``S``::\n\n                sage: bin = S.product\n                sage: bin(x,y)\n                'ab'\n\n            Currently, ``S.product`` is just a bound method::\n\n                sage: bin\n                <bound method FreeSemigroup_with_category.product of An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')>\n\n            When Sage will support multivariate morphisms, it will be\n            possible, and in fact recommended, to enrich ``S.product``\n            with extra mathematical structure. This will typically be\n            implemented using lazy attributes.::\n\n                sage: bin                 # todo: not implemented\n                Generic binary morphism:\n                From: (S x S)\n                To:   S\n            ",
                        "args": [
                            "self",
                            "x",
                            "y"
                        ],
                        "argspec": [
                            [
                                "self",
                                "x",
                                "y"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "product_from_element_class_mul": {
                        "__doc__": "\n            The binary multiplication of the magma.\n\n            INPUT:\n\n            - ``x``, ``y`` -- elements of this magma\n\n            OUTPUT:\n\n            - an element of the magma (the product of ``x`` and ``y``)\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\")\n                sage: x = S('a'); y = S('b')\n                sage: S.product(x, y)\n                'ab'\n\n            A parent in ``Magmas()`` must either implement\n            :meth:`.product` in the parent class or ``_mul_`` in the\n            element class. By default, the addition method on elements\n            ``x._mul_(y)`` calls ``S.product(x,y)``, and reciprocally.\n\n            As a bonus, ``S.product`` models the binary function from\n            ``S`` to ``S``::\n\n                sage: bin = S.product\n                sage: bin(x,y)\n                'ab'\n\n            Currently, ``S.product`` is just a bound method::\n\n                sage: bin\n                <bound method FreeSemigroup_with_category.product of An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')>\n\n            When Sage will support multivariate morphisms, it will be\n            possible, and in fact recommended, to enrich ``S.product``\n            with extra mathematical structure. This will typically be\n            implemented using lazy attributes.::\n\n                sage: bin                 # todo: not implemented\n                Generic binary morphism:\n                From: (S x S)\n                To:   S\n            ",
                        "args": [
                            "self",
                            "x",
                            "y"
                        ],
                        "argspec": [
                            [
                                "self",
                                "x",
                                "y"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.magmas.Magmas.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "Associative": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Commutative": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Distributive": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "FinitelyGenerated": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "FinitelyGeneratedAsMagma": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "JTrivial": {
                        "__doc__": "\n            Return the full subcategory of the `J`-trivial objects of ``self``.\n\n            This axiom is in fact only meaningful for\n            :class:`semigroups <Semigroups>`. This stub definition is\n            here as a workaround for :trac:`20515`, in order to define\n            the `J`-trivial axiom as the intersection of the `L` and\n            `R`-trivial axioms.\n\n            .. SEEALSO:: :meth:`Semigroups.SubcategoryMethods.JTrivial`\n\n            TESTS::\n\n                sage: Magmas().JTrivial()\n                Category of j trivial magmas\n                sage: (Semigroups().RTrivial() & Semigroups().LTrivial()) is Semigroups().JTrivial()\n                True\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "Unital": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    }
                },
                "name": "sage.categories.magmas.Magmas.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.magmas.Magmas.Unital": {
            "__doc__": null,
            "axioms": [
                "Unital"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "__invert__": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method __invert__ at 0x7faa353c21b8>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "parent",
                        "gap_name": "Inverse",
                        "mmt_name": "inverse"
                    },
                    "_div_": {
                        "__doc__": "\n                Default implementation of division, multiplying (on the right) by the inverse.\n\n                INPUT:\n\n                - ``left``, ``right`` -- two elements of the same unital magma\n\n                .. SEEALSO:: :meth:`__div__`\n\n                EXAMPLES::\n\n                    sage: G = FreeGroup(2)\n                    sage: x0, x1 = G.group_generators()\n                    sage: c1 = cartesian_product([x0, x1])\n                    sage: c2 = cartesian_product([x1, x0])\n                    sage: c1._div_(c2)\n                    (x0*x1^-1, x1*x0^-1)\n\n                With this implementation, division will fail as soon\n                as ``right`` is not invertible, even if ``right``\n                actually divides ``left``::\n\n                    sage: x = cartesian_product([2, 1])\n                    sage: y = cartesian_product([1, 1])\n                    sage: x / y\n                    (2, 1)\n                    sage: x / x\n                    Traceback (most recent call last):\n                    ...\n                    TypeError: no conversion of this rational to integer\n\n                TESTS::\n\n                    sage: c1._div_.__module__\n                    'sage.categories.magmas'\n                ",
                        "args": [
                            "left",
                            "right"
                        ],
                        "argspec": [
                            [
                                "left",
                                "right"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.magmas.Magmas.Unital.element_class"
            },
            "gap": "IsMagmaWithOne",
            "implied": [
                "sage.categories.magmas.Magmas"
            ],
            "mmt": "NeutralElement",
            "morphism_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.magmas.Magmas.Unital.morphism_class"
            },
            "name": "sage.categories.magmas.Magmas.Unital",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "_test_one": {
                        "__doc__": "\n                Test that ``self.one()`` is an element of ``self`` and is\n                neutral for the operation ``*``.\n\n                INPUT:\n\n                - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n                EXAMPLES:\n\n                By default, this method tests only the elements returned by\n                ``self.some_elements()``::\n\n                    sage: S = Monoids().example()\n                    sage: S._test_one()\n\n                However, the elements tested can be customized with the\n                ``elements`` keyword argument::\n\n                    sage: S._test_one(elements = (S('a'), S('b')))\n\n                See the documentation for :class:`TestSuite` for more information.\n                ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "is_empty": {
                        "__doc__": "\n                Return whether ``self`` is empty.\n\n                Since this set is a unital magma it is not empty and this method\n                always return ``False``.\n\n                EXAMPLES::\n\n                    sage: S = SymmetricGroup(2)\n                    sage: S.is_empty()\n                    False\n\n                    sage: M = Monoids().example()\n                    sage: M.is_empty()\n                    False\n\n                TESTS::\n\n                    sage: S.is_empty.__module__\n                    'sage.categories.magmas'\n                    sage: M.is_empty.__module__\n                    'sage.categories.magmas'\n                ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "one": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method one at 0x7faa353c2140>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "self",
                        "gap_name": "One",
                        "mmt_name": "neutral"
                    }
                },
                "name": "sage.categories.magmas.Magmas.Unital.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.magmas.Magmas.Unital",
                "sage.categories.sets_cat.Sets",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
            ],
            "subcategory_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "Inverse": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    }
                },
                "name": "sage.categories.magmas.Magmas.Unital.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.magmas.Magmas.Unital.Inverse": {
            "__doc__": null,
            "axioms": [
                "Inverse",
                "Unital"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.magmas.Magmas.Unital.Inverse.element_class"
            },
            "gap": "IsMagmaWithInverses",
            "implied": [
                "sage.categories.magmas.Magmas.Unital"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.magmas.Magmas.Unital.Inverse.morphism_class"
            },
            "name": "sage.categories.magmas.Magmas.Unital.Inverse",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.magmas.Magmas.Unital.Inverse.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets",
                "sage.categories.magmas.Magmas.Unital"
            ],
            "subcategory_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.magmas.Magmas.Unital.Inverse.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.monoids.Monoids": {
            "__doc__": "\n    The category of (multiplicative) monoids.\n\n    A *monoid* is a unital :class:`semigroup <Semigroups>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative and admits a unit (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: Monoids()\n        Category of monoids\n        sage: Monoids().super_categories()\n        [Category of semigroups, Category of unital magmas]\n        sage: Monoids().all_super_categories()\n        [Category of monoids,\n         Category of semigroups,\n         Category of unital magmas, Category of magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: Monoids().axioms()\n        frozenset({'Associative', 'Unital'})\n        sage: Semigroups().Unital()\n        Category of monoids\n\n        sage: Monoids().example()\n        An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: C = Monoids()\n        sage: TestSuite(C).run()\n\n    ",
            "axioms": [
                "Associative",
                "Unital"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "_pow_naive": {
                        "__doc__": "\n            Return ``self`` to the `n^{th}` power (naive implementation).\n\n            INPUT:\n\n            - ``n`` -- a nonnegative integer\n\n            This naive implementation does not use binary\n            exponentiation; there are cases where this is actually\n            faster due to size explosion.\n\n            EXAMPLES::\n\n                sage: S = Monoids().example()\n                sage: x = S(\"aa\")\n                sage: [x._pow_naive(i) for i in range(6)]\n                ['', 'aa', 'aaaa', 'aaaaaa', 'aaaaaaaa', 'aaaaaaaaaa']\n            ",
                        "args": [
                            "self",
                            "n"
                        ],
                        "argspec": [
                            [
                                "self",
                                "n"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "is_one": {
                        "__doc__": "\n            Return whether ``self`` is the one of the monoid.\n\n            The default implementation is to compare with ``self.one()``.\n\n            TESTS::\n\n                sage: S = Monoids().example()\n                sage: S.one().is_one()\n                True\n                sage: S(\"aa\").is_one()\n                False\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "powers": {
                        "__doc__": "\n            Return the list `[x^0, x^1, \\ldots, x^{n-1}]`.\n\n            EXAMPLES::\n\n                sage: A = Matrix([[1, 1], [-1, 0]])\n                sage: A.powers(6)\n                [\n                [1 0]  [ 1  1]  [ 0  1]  [-1  0]  [-1 -1]  [ 0 -1]\n                [0 1], [-1  0], [-1 -1], [ 0 -1], [ 1  0], [ 1  1]\n                ]\n            ",
                        "args": [
                            "self",
                            "n"
                        ],
                        "argspec": [
                            [
                                "self",
                                "n"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.monoids.Monoids.element_class"
            },
            "gap": "IsMonoidAsSemigroup",
            "implied": [
                "sage.categories.semigroups.Semigroups",
                "sage.categories.magmas.Magmas.Unital"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category of (multiplicative) monoids.\n\n    A *monoid* is a unital :class:`semigroup <Semigroups>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative and admits a unit (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: Monoids()\n        Category of monoids\n        sage: Monoids().super_categories()\n        [Category of semigroups, Category of unital magmas]\n        sage: Monoids().all_super_categories()\n        [Category of monoids,\n         Category of semigroups,\n         Category of unital magmas, Category of magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: Monoids().axioms()\n        frozenset({'Associative', 'Unital'})\n        sage: Semigroups().Unital()\n        Category of monoids\n\n        sage: Monoids().example()\n        An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: C = Monoids()\n        sage: TestSuite(C).run()\n\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.monoids.Monoids.morphism_class"
            },
            "name": "sage.categories.monoids.Monoids",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "_test_prod": {
                        "__doc__": "\n            Run basic tests for the product method :meth:`prod` of ``self``.\n\n            See the documentation for :class:`TestSuite` for information on\n            further options.\n\n            INPUT:\n\n            - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n            EXAMPLES:\n\n            By default, this method tests only the elements returned by\n            ``self.some_elements()``::\n\n                sage: S = Monoids().example()\n                sage: S._test_prod()\n\n            However, the elements tested can be customized with the\n            ``elements`` keyword argument::\n\n                sage: S._test_prod(elements = (S('a'), S('b')))\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "monoid_generators": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method monoid_generators at 0x7faa353cf668>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "list_of_self",
                        "gap_name": "GeneratorsOfMonoid",
                        "mmt_name": null
                    },
                    "one_element": {
                        "__doc__": "\n            Backward compatibility alias for :meth:`one`.\n\n            TESTS::\n\n                sage: S = Monoids().example()\n                sage: S.one_element()\n                doctest:...: DeprecationWarning: .one_element() is deprecated. Please use .one() instead.\n                See http://trac.sagemath.org/17694 for details.\n                ''\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "submonoid": {
                        "__doc__": "\n            Return the multiplicative submonoid generated by ``generators``.\n\n            INPUT:\n\n            - ``generators`` -- a finite family of elements of\n              ``self``, or a list, iterable, ... that can be converted\n              into one (see :class:`Family`).\n\n            - ``category`` -- a category\n\n            This is a shorthand for\n            :meth:`Semigroups.ParentMethods.subsemigroup` that\n            specifies that this is a submonoid, and in particular that\n            the unit is ``self.one()``.\n\n            EXAMPLES::\n\n                sage: R = IntegerModRing(15)\n                sage: M = R.submonoid([R(3),R(5)]); M\n                A submonoid of (Ring of integers modulo 15) with 2 generators\n                sage: M.list()\n                [1, 3, 5, 9, 0, 10, 12, 6]\n\n            Not the presence of the unit, unlike in::\n\n                sage: S = R.subsemigroup([R(3),R(5)]); S\n                A subsemigroup of (Ring of integers modulo 15) with 2 generators\n                sage: S.list()\n                [3, 5, 9, 0, 10, 12, 6]\n\n            This method is really a shorthand for subsemigroup::\n\n                sage: M2 = R.subsemigroup([R(3),R(5)], one=R.one())\n                sage: M2 is M\n                True\n\n\n            ",
                        "args": [
                            "self",
                            "generators",
                            "category"
                        ],
                        "argspec": [
                            [
                                "self",
                                "generators",
                                "category"
                            ],
                            null,
                            null,
                            [
                                null
                            ]
                        ]
                    }
                },
                "name": "sage.categories.monoids.Monoids.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.magmas.Magmas.Unital",
                "sage.categories.sets_cat.Sets",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of (multiplicative) monoids.\n\n    A *monoid* is a unital :class:`semigroup <Semigroups>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative and admits a unit (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: Monoids()\n        Category of monoids\n        sage: Monoids().super_categories()\n        [Category of semigroups, Category of unital magmas]\n        sage: Monoids().all_super_categories()\n        [Category of monoids,\n         Category of semigroups,\n         Category of unital magmas, Category of magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: Monoids().axioms()\n        frozenset({'Associative', 'Unital'})\n        sage: Semigroups().Unital()\n        Category of monoids\n\n        sage: Monoids().example()\n        An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: C = Monoids()\n        sage: TestSuite(C).run()\n\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.monoids.Monoids.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.objects.Objects": {
            "__doc__": "\n    The category of all objects\n    the basic category\n\n    EXAMPLES::\n\n        sage: Objects()\n        Category of objects\n        sage: Objects().super_categories()\n        []\n\n    TESTS::\n\n        sage: TestSuite(Objects()).run()\n    ",
            "axioms": [],
            "element_class": {
                "__doc__": "\n    The category of all objects\n    the basic category\n\n    EXAMPLES::\n\n        sage: Objects()\n        Category of objects\n        sage: Objects().super_categories()\n        []\n\n    TESTS::\n\n        sage: TestSuite(Objects()).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.objects.Objects.element_class"
            },
            "gap": null,
            "implied": [],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category of all objects\n    the basic category\n\n    EXAMPLES::\n\n        sage: Objects()\n        Category of objects\n        sage: Objects().super_categories()\n        []\n\n    TESTS::\n\n        sage: TestSuite(Objects()).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.objects.Objects.morphism_class"
            },
            "name": "sage.categories.objects.Objects",
            "parent_class": {
                "__doc__": "\n        Methods for all category objects\n        ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.objects.Objects.parent_class"
            },
            "structure": [],
            "subcategory_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "Endsets": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "GAP": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Homsets": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "hom_category": {
                        "__doc__": "Deprecated: Use :meth:`Homsets` instead.\nSee :trac:`10668` for details.\n\n",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    }
                },
                "name": "sage.categories.objects.Objects.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.permutation_groups.PermutationGroups": {
            "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
            "axioms": [
                "Inverse",
                "Associative",
                "Unital"
            ],
            "element_class": {
                "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.permutation_groups.PermutationGroups.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.groups.Groups"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.permutation_groups.PermutationGroups.morphism_class"
            },
            "name": "sage.categories.permutation_groups.PermutationGroups",
            "parent_class": {
                "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.permutation_groups.PermutationGroups.parent_class"
            },
            "structure": [
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.magmas.Magmas",
                "sage.categories.magmas.Magmas.Unital",
                "sage.categories.sets_cat.Sets",
                "sage.categories.permutation_groups.PermutationGroups"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.permutation_groups.PermutationGroups.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.semigroups.Semigroups": {
            "__doc__": "\n    The category of (multiplicative) semigroups.\n\n    A *semigroup* is an associative :class:`magma <Magmas>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative (see :wikipedia:`Semigroup`).\n\n    The operation `*` is not required to have a neutral element. A\n    semigroup for which such an element exists is a :class:`monoid\n    <sage.categories.monoids.Monoids>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups(); C\n        Category of semigroups\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: C.all_super_categories()\n        [Category of semigroups, Category of magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n        sage: C.axioms()\n        frozenset({'Associative'})\n        sage: C.example()\n        An example of a semigroup: the left zero semigroup\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "axioms": [
                "Associative"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "__pow__": {
                        "__doc__": "\n            Return ``self`` to the `n^{th}` power.\n\n            INPUT:\n\n            - ``n`` -- a positive integer\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"leftzero\")\n                sage: x = S(\"x\")\n                sage: x^1, x^2, x^3, x^4, x^5\n                ('x', 'x', 'x', 'x', 'x')\n                sage: x^0\n                Traceback (most recent call last):\n                ...\n                AssertionError\n\n            TESTS::\n\n                sage: x._pow_(17)\n                'x'\n\n            ",
                        "args": [
                            "self",
                            "n"
                        ],
                        "argspec": [
                            [
                                "self",
                                "n"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_pow_": {
                        "__doc__": "\n            Return ``self`` to the `n^{th}` power.\n\n            INPUT:\n\n            - ``n`` -- a positive integer\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"leftzero\")\n                sage: x = S(\"x\")\n                sage: x^1, x^2, x^3, x^4, x^5\n                ('x', 'x', 'x', 'x', 'x')\n                sage: x^0\n                Traceback (most recent call last):\n                ...\n                AssertionError\n\n            TESTS::\n\n                sage: x._pow_(17)\n                'x'\n\n            ",
                        "args": [
                            "self",
                            "n"
                        ],
                        "argspec": [
                            [
                                "self",
                                "n"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.semigroups.Semigroups.element_class"
            },
            "gap": "IsAssociative",
            "implied": [
                "sage.categories.magmas.Magmas"
            ],
            "mmt": "Semigroup",
            "morphism_class": {
                "__doc__": "\n    The category of (multiplicative) semigroups.\n\n    A *semigroup* is an associative :class:`magma <Magmas>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative (see :wikipedia:`Semigroup`).\n\n    The operation `*` is not required to have a neutral element. A\n    semigroup for which such an element exists is a :class:`monoid\n    <sage.categories.monoids.Monoids>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups(); C\n        Category of semigroups\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: C.all_super_categories()\n        [Category of semigroups, Category of magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n        sage: C.axioms()\n        frozenset({'Associative'})\n        sage: C.example()\n        An example of a semigroup: the left zero semigroup\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.semigroups.Semigroups.morphism_class"
            },
            "name": "sage.categories.semigroups.Semigroups",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "__truediv__": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method __truediv__ at 0x7faa353c2d70>",
                        "args": [
                            "self",
                            "relations"
                        ],
                        "argspec": [
                            [
                                "self",
                                "relations"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": null,
                        "gap_name": "\\/",
                        "mmt_name": null
                    },
                    "_test_associativity": {
                        "__doc__": "\n            Test associativity for (not necessarily all) elements of this\n            semigroup.\n\n            INPUT:\n\n            - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n            EXAMPLES:\n\n            By default, this method tests only the elements returned by\n            ``self.some_elements()``::\n\n                sage: L = Semigroups().example(choice='leftzero')\n                sage: L._test_associativity()\n\n            However, the elements tested can be customized with the\n            ``elements`` keyword argument::\n\n                sage: L._test_associativity(elements = (L(1), L(2), L(3)))\n\n            See the documentation for :class:`TestSuite` for more information.\n\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "cayley_graph": {
                        "__doc__": "\n            Return the Cayley graph for this finite semigroup.\n\n            INPUT:\n\n            - ``side`` -- \"left\", \"right\", or \"twosided\":\n              the side on which the generators act (default:\"right\")\n            - ``simple`` -- boolean (default:False):\n              if True, returns a simple graph (no loops, no labels,\n              no multiple edges)\n            - ``generators`` -- a list, tuple, or family of elements\n              of ``self`` (default: ``self.semigroup_generators()``)\n            - ``connecting_set`` -- alias for ``generators``; deprecated\n            - ``elements`` -- a list (or iterable) of elements of ``self``\n\n            OUTPUT:\n\n            - :class:`DiGraph`\n\n            EXAMPLES:\n\n            We start with the (right) Cayley graphs of some classical groups::\n\n                sage: D4 = DihedralGroup(4); D4\n                Dihedral group of order 8 as a permutation group\n                sage: G = D4.cayley_graph()\n                sage: show(G, color_by_label=True, edge_labels=True)\n                sage: A5 = AlternatingGroup(5); A5\n                Alternating group of order 5!/2 as a permutation group\n                sage: G = A5.cayley_graph()\n                sage: G.show3d(color_by_label=True, edge_size=0.01, edge_size2=0.02, vertex_size=0.03)\n                sage: G.show3d(vertex_size=0.03, edge_size=0.01, edge_size2=0.02, vertex_colors={(1,1,1):G.vertices()}, bgcolor=(0,0,0), color_by_label=True, xres=700, yres=700, iterations=200) # long time (less than a minute)\n                sage: G.num_edges()\n                120\n\n                sage: w = WeylGroup(['A',3])\n                sage: d = w.cayley_graph(); d\n                Digraph on 24 vertices\n                sage: d.show3d(color_by_label=True, edge_size=0.01, vertex_size=0.03)\n\n            Alternative generators may be specified::\n\n                sage: G = A5.cayley_graph(generators=[A5.gens()[0]])\n                sage: G.num_edges()\n                60\n                sage: g=PermutationGroup([(i+1,j+1) for i in range(5) for j in range(5) if j!=i])\n                sage: g.cayley_graph(generators=[(1,2),(2,3)])\n                Digraph on 120 vertices\n\n            If ``elements`` is specified, then only the subgraph\n            induced and those elements is returned. Here we use it to\n            display the Cayley graph of the free monoid truncated on\n            the elements of length at most 3::\n\n                sage: M = Monoids().example(); M\n                An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n                sage: elements = [ M.prod(w) for w in sum((list(Words(M.semigroup_generators(),k)) for k in range(4)),[]) ]\n                sage: G = M.cayley_graph(elements = elements)\n                sage: G.num_verts(), G.num_edges()\n                (85, 84)\n                sage: G.show3d(color_by_label=True, edge_size=0.001, vertex_size=0.01)\n\n            We now illustrate the ``side`` and ``simple`` options on\n            a semigroup::\n\n                sage: S = FiniteSemigroups().example(alphabet=('a','b'))\n                sage: g = S.cayley_graph(simple=True)\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'ab', None), ('b', 'ba', None)]\n\n            ::\n\n                sage: g = S.cayley_graph(side=\"left\", simple=True)\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'ba', None), ('ab', 'ba', None), ('b', 'ab', None),\n                ('ba', 'ab', None)]\n\n            ::\n\n                sage: g = S.cayley_graph(side=\"twosided\", simple=True)\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'ab', None), ('a', 'ba', None), ('ab', 'ba', None),\n                ('b', 'ab', None), ('b', 'ba', None), ('ba', 'ab', None)]\n\n            ::\n\n                sage: g = S.cayley_graph(side=\"twosided\")\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'a', (0, 'left')), ('a', 'a', (0, 'right')), ('a', 'ab', (1, 'right')), ('a', 'ba', (1, 'left')), ('ab', 'ab', (0, 'left')), ('ab', 'ab', (0, 'right')), ('ab', 'ab', (1, 'right')), ('ab', 'ba', (1, 'left')), ('b', 'ab', (0, 'left')), ('b', 'b', (1, 'left')), ('b', 'b', (1, 'right')), ('b', 'ba', (0, 'right')), ('ba', 'ab', (0, 'left')), ('ba', 'ba', (0, 'right')), ('ba', 'ba', (1, 'left')), ('ba', 'ba', (1, 'right'))]\n\n            ::\n\n                sage: s1 = SymmetricGroup(1); s = s1.cayley_graph(); s.vertices()\n                [()]\n\n            TESTS::\n\n                sage: SymmetricGroup(2).cayley_graph(side=\"both\")\n                Traceback (most recent call last):\n                ...\n                ValueError: option 'side' must be 'left', 'right' or 'twosided'\n\n            .. TODO::\n\n                - Add more options for constructing subgraphs of the\n                  Cayley graph, handling the standard use cases when\n                  exploring large/infinite semigroups (a predicate,\n                  generators of an ideal, a maximal length in term of the\n                  generators)\n\n                - Specify good default layout/plot/latex options in the graph\n\n                - Generalize to combinatorial modules with module generators / operators\n\n            AUTHORS:\n\n            - Bobby Moretti (2007-08-10)\n            - Robert Miller (2008-05-01): editing\n            - Nicolas M. Thiery (2008-12): extension to semigroups,\n              ``side``, ``simple``, and ``elements`` options, ...\n            ",
                        "args": [
                            "self",
                            "side",
                            "simple",
                            "elements",
                            "generators",
                            "connecting_set"
                        ],
                        "argspec": [
                            [
                                "self",
                                "side",
                                "simple",
                                "elements",
                                "generators",
                                "connecting_set"
                            ],
                            null,
                            null,
                            [
                                "right",
                                false,
                                null,
                                null,
                                null
                            ]
                        ]
                    },
                    "is_d_trivial": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method is_d_trivial at 0x7faa353c2ed8>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": null,
                        "gap_name": "IsDTrivial",
                        "mmt_name": null
                    },
                    "is_l_trivial": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method is_l_trivial at 0x7faa353c2de8>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": null,
                        "gap_name": "IsLTrivial",
                        "mmt_name": null
                    },
                    "is_r_trivial": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method is_r_trivial at 0x7faa353c2e60>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": null,
                        "gap_name": "IsRTrivial",
                        "mmt_name": null
                    },
                    "magma_generators": {
                        "__doc__": "\n            An alias for :meth:`semigroup_generators`.\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\"); S\n                An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n                sage: S.magma_generators()\n                Family ('a', 'b', 'c', 'd')\n                sage: S.semigroup_generators()\n                Family ('a', 'b', 'c', 'd')\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "prod": {
                        "__doc__": "\n            Return the product of the list of elements ``args``\n            inside ``self``.\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\")\n                sage: S.prod([S('a'), S('b'), S('c')])\n                'abc'\n                sage: S.prod([])\n                Traceback (most recent call last):\n                ...\n                AssertionError: Cannot compute an empty product in a semigroup\n            ",
                        "args": [
                            "self",
                            "args"
                        ],
                        "argspec": [
                            [
                                "self",
                                "args"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "regular_representation": {
                        "__doc__": "\n            Return the regular representation of ``self`` over ``base_ring``.\n\n            - ``side`` -- (default: ``\"left\"``) whether this is the\n              ``\"left\"`` or ``\"right\"`` regular representation\n\n            EXAMPLES::\n\n                sage: G = groups.permutation.Dihedral(4)\n                sage: G.regular_representation()\n                Left Regular Representation of Dihedral group of order 8\n                 as a permutation group over Integer Ring\n            ",
                        "args": [
                            "self",
                            "base_ring",
                            "side"
                        ],
                        "argspec": [
                            [
                                "self",
                                "base_ring",
                                "side"
                            ],
                            null,
                            null,
                            [
                                null,
                                "left"
                            ]
                        ]
                    },
                    "semigroup_generators": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method semigroup_generators at 0x7faa353c2c80>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "list_of_self",
                        "gap_name": "GeneratorsOfSemigroup",
                        "mmt_name": null
                    },
                    "subsemigroup": {
                        "__doc__": "\n            Return the multiplicative subsemigroup generated by ``generators``.\n\n            INPUT:\n\n            - ``generators`` -- a finite family of elements of\n              ``self``, or a list, iterable, ... that can be converted\n              into one (see :class:`Family`).\n\n            - ``one`` -- a unit for the subsemigroup, or ``None``.\n\n            - ``category`` -- a category\n\n            This implementation lazily constructs all the elements of\n            the semigroup, and the right Cayley graph relations\n            between them, and uses the latter as an automaton.\n\n            See :class:`~sage.sets.monoids.AutomaticSemigroup` for details.\n\n            EXAMPLES::\n\n                sage: R = IntegerModRing(15)\n                sage: M = R.subsemigroup([R(3),R(5)]); M\n                A subsemigroup of (Ring of integers modulo 15) with 2 generators\n                sage: M.list()\n                [3, 5, 9, 0, 10, 12, 6]\n\n            By default, `M` is just in the category of subsemigroups::\n\n                sage: M in Semigroups().Subobjects()\n                True\n\n            In the following example, we specify that `M` is a\n            submonoid of the finite monoid `R` (it shares the same\n            unit), and a group by itself::\n\n                sage: M = R.subsemigroup([R(-1)],\n                ....:     category=Monoids().Finite().Subobjects() & Groups()); M\n                A submonoid of (Ring of integers modulo 15) with 1 generators\n                sage: M.list()\n                [1, 14]\n                sage: M.one()\n                1\n\n            In the following example `M` is a group; however its unit\n            does not coincide with that of `R`, so `M` is only a\n            subsemigroup, and we need to specify its unit explictly::\n\n                sage: M = R.subsemigroup([R(5)],\n                ....:     category=Semigroups().Finite().Subobjects() & Groups()); M\n                Traceback (most recent call last):\n                ...\n                ValueError: For a monoid which is just a subsemigroup, the unit should be specified\n\n                sage: M = R.subsemigroup([R(5)], one=R(10),\n                ....:     category=Semigroups().Finite().Subobjects() & Groups()); M\n                A subsemigroup of (Ring of integers modulo 15) with 1 generators\n                sage: M in Groups()\n                True\n                sage: M.list()\n                [10, 5]\n                sage: M.one()\n                10\n\n            TESTS::\n\n                sage: TestSuite(M).run()\n                Failure in _test_inverse:\n                Traceback (most recent call last):\n                ...\n                The following tests failed: _test_inverse\n\n            .. TODO::\n\n                - Fix the failure in TESTS by providing a default\n                  implementation of ``__invert__`` for finite groups\n                  (or even finite monoids).\n                - Provide a default implementation of ``one`` for a\n                  finite monoid, so that we would not need to specify\n                  it explicitly?\n            ",
                        "args": [
                            "self",
                            "generators",
                            "one",
                            "category"
                        ],
                        "argspec": [
                            [
                                "self",
                                "generators",
                                "one",
                                "category"
                            ],
                            null,
                            null,
                            [
                                null,
                                null
                            ]
                        ]
                    },
                    "trivial_representation": {
                        "__doc__": "\n            Return the trivial representation of ``self`` over ``base_ring``.\n\n            INPUT:\n\n            - ``base_ring`` -- (optional) the base ring; the default is `\\ZZ`\n            - ``side`` -- ignored\n\n            EXAMPLES::\n\n                sage: G = groups.permutation.Dihedral(4)\n                sage: G.trivial_representation()\n                Trivial representation of Dihedral group of order 8\n                 as a permutation group over Integer Ring\n            ",
                        "args": [
                            "self",
                            "base_ring",
                            "side"
                        ],
                        "argspec": [
                            [
                                "self",
                                "base_ring",
                                "side"
                            ],
                            null,
                            null,
                            [
                                null,
                                "twosided"
                            ]
                        ]
                    }
                },
                "name": "sage.categories.semigroups.Semigroups.parent_class"
            },
            "structure": [
                "sage.categories.magmas.Magmas",
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "Aperiodic": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "HTrivial": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "LTrivial": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "RTrivial": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    }
                },
                "name": "sage.categories.semigroups.Semigroups.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.sets_cat.Sets": {
            "__doc__": "\n    The category of sets.\n\n    The base category for collections of elements with = (equality).\n\n    This is also the category whose objects are all parents.\n\n    EXAMPLES::\n\n        sage: Sets()\n        Category of sets\n        sage: Sets().super_categories()\n        [Category of sets with partial maps]\n        sage: Sets().all_super_categories()\n        [Category of sets, Category of sets with partial maps, Category of objects]\n\n    Let us consider an example of set::\n\n        sage: P = Sets().example(\"inherits\")\n        sage: P\n        Set of prime numbers\n\n    See ``P??`` for the code.\n\n\n    P is in the category of sets::\n\n        sage: P.category()\n        Category of sets\n\n    and therefore gets its methods from the following classes::\n\n        sage: for cl in P.__class__.mro(): print(cl)\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits_with_category'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Abstract'>\n        <class 'sage.structure.unique_representation.UniqueRepresentation'>\n        <class 'sage.structure.unique_representation.CachedRepresentation'>\n        <type 'sage.misc.fast_methods.WithEqualityById'>\n        <type 'sage.structure.parent.Parent'>\n        <type 'sage.structure.category_object.CategoryObject'>\n        <type 'sage.structure.sage_object.SageObject'>\n        <class 'sage.categories.sets_cat.Sets.parent_class'>\n        <class 'sage.categories.sets_with_partial_maps.SetsWithPartialMaps.parent_class'>\n        <class 'sage.categories.objects.Objects.parent_class'>\n        <type 'object'>\n\n    We run some generic checks on P::\n\n        sage: TestSuite(P).run(verbose=True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_new() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_new() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n\n    Now, we manipulate some elements of P::\n\n        sage: P.an_element()\n        47\n        sage: x = P(3)\n        sage: x.parent()\n        Set of prime numbers\n        sage: x in P, 4 in P\n        (True, False)\n        sage: x.is_prime()\n        True\n\n    They get their methods from the following classes::\n\n        sage: for cl in x.__class__.mro(): print(cl)\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits_with_category.element_class'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits.Element'>\n        <type 'sage.rings.integer.IntegerWrapper'>\n        <type 'sage.rings.integer.Integer'>\n        <type 'sage.structure.element.EuclideanDomainElement'>\n        <type 'sage.structure.element.PrincipalIdealDomainElement'>\n        <type 'sage.structure.element.DedekindDomainElement'>\n        <type 'sage.structure.element.IntegralDomainElement'>\n        <type 'sage.structure.element.CommutativeRingElement'>\n        <type 'sage.structure.element.RingElement'>\n        <type 'sage.structure.element.ModuleElement'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Abstract.Element'>\n        <type 'sage.structure.element.Element'>\n        <type 'sage.structure.sage_object.SageObject'>\n        <class 'sage.categories.sets_cat.Sets.element_class'>\n        <class 'sage.categories.sets_with_partial_maps.SetsWithPartialMaps.element_class'>\n        <class 'sage.categories.objects.Objects.element_class'>\n        <type 'object'>\n\n    FIXME: Objects.element_class is not very meaningful ...\n\n\n    TESTS::\n\n          sage: TestSuite(Sets()).run()\n\n    ",
            "axioms": [],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "cartesian_product": {
                        "__doc__": "\n            Return the Cartesian product of its arguments, as an element of\n            the Cartesian product of the parents of those elements.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example()\n                sage: (a,b,c) = A.algebra_generators()\n                sage: a.cartesian_product(b, c)\n                B[(0, word: a)] + B[(1, word: b)] + B[(2, word: c)]\n\n            FIXME: is this a policy that we want to enforce on all parents?\n            ",
                        "args": [],
                        "argspec": [
                            [],
                            "elements",
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.sets_cat.Sets.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
            ],
            "mmt": "Set",
            "morphism_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "__invert__": {
                        "__doc__": "\n            Return the inverse morphism, or raise an error.\n\n            The error may either state that the morphism is not\n            invertible, or that Sage cannot invert it.\n\n            EXAMPLES::\n\n                sage: i = End(QQ).identity(); i\n                Identity endomorphism of Rational Field\n                sage: i.__invert__()\n                Identity endomorphism of Rational Field\n\n            This method is meant to be used with the Python inversion\n            operator `~`::\n\n                sage: ~i\n                Identity endomorphism of Rational Field\n\n            We now try to inverse a couple of morphisms defined by a matrix::\n\n                sage: H = End(QQ^2)\n                sage: phi = H(matrix([[1,1],[0,1]])); phi\n                Vector space morphism represented by the matrix:\n                [1 1]\n                [0 1]\n                Domain: Vector space of dimension 2 over Rational Field\n                Codomain: Vector space of dimension 2 over Rational Field\n                sage: ~phi\n                Vector space morphism represented by the matrix:\n                [ 1 -1]\n                [ 0  1]\n                Domain: Vector space of dimension 2 over Rational Field\n                Codomain: Vector space of dimension 2 over Rational Field\n\n                sage: phi = H(matrix([[1,1],[1,1]]))\n                sage: ~phi\n                Traceback (most recent call last):\n                ...\n                ZeroDivisionError: matrix morphism not invertible\n\n            .. NOTE::\n\n                This is an optional method. A default implementation\n                raising ``NotImplementedError`` could be provided instead.\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.sets_cat.Sets.morphism_class"
            },
            "name": "sage.categories.sets_cat.Sets",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "CartesianProduct": {
                        "__doc__": "LazyImport(module, name, as_name=None, namespace=None, at_startup=False, deprecation=None)\nFile: sage/misc/lazy_import.pyx (starting at line 135)\n\n    EXAMPLES::\n\n        sage: from sage.misc.lazy_import import LazyImport\n        sage: my_integer = LazyImport('sage.rings.all', 'Integer')\n        sage: my_integer(4)\n        4\n        sage: my_integer('101', base=2)\n        5\n        sage: my_integer(3/2)\n        Traceback (most recent call last):\n        ...\n        TypeError: no conversion of this rational to integer\n    ",
                        "args": [
                            "self",
                            "x"
                        ],
                        "argspec": [
                            [
                                "self",
                                "x"
                            ],
                            "args",
                            "kwds",
                            [
                                0
                            ]
                        ]
                    },
                    "__contains__": {
                        "__doc__": "\n            Test whether the set ``self`` contains the object ``x``.\n\n            All parents in the category ``Sets()`` should implement this method.\n\n            EXAMPLES::\n\n                sage: P = Sets().example(); P\n                Set of prime numbers (basic implementation)\n                sage: 12 in P\n                False\n                sage: P(5) in P\n                True\n            ",
                        "args": [
                            "self",
                            "x"
                        ],
                        "argspec": [
                            [
                                "self",
                                "x"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "_an_element_": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method _an_element_ at 0x7faa353be320>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "self",
                        "gap_name": "Representative",
                        "mmt_name": null
                    },
                    "_element_constructor_from_element_class": {
                        "__doc__": "\n            The default constructor for elements of this parent ``self``.\n\n            Among other things, it is called upon ``self(data)`` when\n            the coercion model did not find a way to coerce ``data`` into\n            this parent.\n\n            This default implementation for\n            :meth:`_element_constructor_` calls the constructor of the\n            element class, passing ``self`` as first argument.\n\n            EXAMPLES::\n\n                sage: S = Sets().example(\"inherits\")\n                sage: s = S._element_constructor_from_element_class(17); s\n                17\n                sage: type(s)\n                <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits_with_category.element_class'>\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            "args",
                            "keywords",
                            null
                        ]
                    },
                    "_test_an_element": {
                        "__doc__": "\n            Run generic tests on the method :meth:`.an_element`.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_an_element()\n\n            Let us now write a broken :meth:`.an_element` method::\n\n                sage: from sage.categories.examples.sets_cat import PrimeNumbers\n                sage: class CCls(PrimeNumbers):\n                ....:     def an_element(self):\n                ....:         return 18\n                sage: CC = CCls()\n                sage: CC._test_an_element()\n                Traceback (most recent call last):\n                ...\n                AssertionError: self.an_element() is not in self\n\n            TESTS::\n\n                sage: FiniteEnumeratedSet([])._test_an_element()\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "_test_cardinality": {
                        "__doc__": "\n            Run generic test on the method :meth:`.cardinality`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_cardinality()\n\n            Let us now write a broken :meth:`cardinality` method::\n\n                sage: from sage.categories.examples.sets_cat import *\n                sage: class CCls(PrimeNumbers):\n                ....:     def cardinality(self):\n                ....:         return int(5)\n                sage: CC = CCls()\n                sage: CC._test_cardinality()\n                Traceback (most recent call last):\n                ...\n                AssertionError: the output of the method cardinality must either\n                be a Sage integer or infinity. Not <... 'int'>.\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "_test_elements": {
                        "__doc__": "\n            Run generic tests on element(s) of ``self``.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements(verbose = True)\n                <BLANKLINE>\n                  Running the test suite of self.an_element()\n                  running ._test_category() . . . pass\n                  running ._test_eq() . . . pass\n                  running ._test_new() . . . pass\n                  running ._test_nonzero_equal() . . . pass\n                  running ._test_not_implemented_methods() . . . pass\n                  running ._test_pickling() . . . pass\n                <BLANKLINE>\n\n            Debugging tip: in case of failure of this test, run instead::\n\n                sage: TestSuite(C.an_element()).run()\n\n            Let us now implement a parent whose elements cannot be pickled::\n\n                sage: from sage.categories.examples.sets_cat import PrimeNumbers\n                sage: class Bla(SageObject): pass\n                sage: class CCls(PrimeNumbers):\n                ....:     def an_element(self):\n                ....:         return Bla()\n                sage: CC = CCls()\n                sage: CC._test_elements()\n                  Failure in _test_pickling:\n                  ...\n                  PicklingError: Can't pickle <class '__main__.Bla'>: attribute lookup __main__.Bla failed\n                  ...\n                  The following tests failed: _test_pickling\n            ",
                        "args": [
                            "self",
                            "tester"
                        ],
                        "argspec": [
                            [
                                "self",
                                "tester"
                            ],
                            null,
                            "options",
                            [
                                null
                            ]
                        ]
                    },
                    "_test_elements_eq_reflexive": {
                        "__doc__": "\n            Run generic tests on the equality of elements.\n\n            Test that ``==`` is reflexive.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_eq_reflexive()\n\n            We try a non-reflexive equality::\n\n                sage: P = Sets().example(\"wrapper\")\n                sage: P._test_elements_eq_reflexive()\n                sage: eq = P.element_class.__eq__\n\n                sage: P.element_class.__eq__ = (lambda x, y:\n                ....:      False if eq(x, P(47)) and eq(y, P(47)) else eq(x, y))\n                sage: P._test_elements_eq_reflexive()\n                Traceback (most recent call last):\n                ...\n                AssertionError: 47 != 47\n\n            We restore ``P.element_class`` in a proper state for further tests::\n\n                sage: P.element_class.__eq__ = eq\n\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "_test_elements_eq_symmetric": {
                        "__doc__": "\n            Run generic tests on the equality of elements.\n\n            This tests that ``==`` is symmetric.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_eq_symmetric()\n\n            We test a non symmetric equality::\n\n                sage: P = Sets().example(\"wrapper\")\n                sage: P._test_elements_eq_symmetric()\n                sage: eq = P.element_class.__eq__\n\n                sage: def non_sym_eq(x, y):\n                ....:    if not y in P:                      return False\n                ....:    elif eq(x, P(47)) and eq(y, P(53)): return True\n                ....:    else:                               return eq(x, y)\n                sage: P.element_class.__eq__ = non_sym_eq\n                sage: P._test_elements_eq_symmetric()\n                Traceback (most recent call last):\n                ...\n                AssertionError: non symmetric equality: 47 == 53 but 53 != 47\n\n            We restore ``P.element_class`` in a proper state for further tests::\n\n                sage: P.element_class.__eq__ = eq\n\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "_test_elements_eq_transitive": {
                        "__doc__": "\n            Run generic tests on the equality of elements.\n\n            Test that ``==`` is transitive.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_eq_transitive()\n\n            We test a non transitive equality::\n\n                sage: R = Zp(3)\n                sage: Sets().ParentMethods._test_elements_eq_transitive.__func__(R,elements=[R(3,2),R(3,1),R(0)])\n                Traceback (most recent call last):\n                ...\n                AssertionError: non transitive equality:\n                3 + O(3^2) == O(3) and O(3) == 0 but 3 + O(3^2) != 0\n\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "_test_elements_neq": {
                        "__doc__": "\n            Run generic tests on the equality of elements.\n\n            Test that ``==`` and ``!=`` are consistent.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_neq()\n\n            We try a broken inequality::\n\n                sage: P = Sets().example(\"wrapper\")\n                sage: P._test_elements_neq()\n                sage: ne = P.element_class.__ne__\n                sage: eq = P.element_class.__eq__\n\n                sage: P.element_class.__ne__ = lambda x, y: False\n                sage: P._test_elements_neq()\n                Traceback (most recent call last):\n                ...\n                AssertionError: __eq__ and __ne__ inconsistency:\n                  47 == 53 returns False  but  47 != 53 returns False\n\n                sage: P.element_class.__ne__ = lambda x, y: not(x == y)\n\n            We restore ``P.element_class`` in a proper state for further tests::\n\n                sage: P.element_class.__ne__ = ne\n                sage: P.element_class.__eq__ = eq\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "_test_some_elements": {
                        "__doc__": "\n            Run generic tests on the method :meth:`.some_elements`.\n\n            .. SEEALSO:: :class:`TestSuite`\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_some_elements()\n\n            Let us now write a broken :meth:`.some_elements` method::\n\n                sage: from sage.categories.examples.sets_cat import *\n                sage: class CCls(PrimeNumbers):\n                ....:     def some_elements(self):\n                ....:         return [self(17), 32]\n                sage: CC = CCls()\n                sage: CC._test_some_elements()\n                Traceback (most recent call last):\n                ...\n                AssertionError: the object 32 in self.some_elements() is not in self\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            "options",
                            null
                        ]
                    },
                    "algebra": {
                        "__doc__": "\n            Return the algebra of ``self`` over ``base_ring``.\n\n            INPUT:\n\n            - ``self`` -- a parent `S`\n            - ``base_ring`` -- a ring `K`\n            - ``category`` -- a super category of the category\n              of `S`, or ``None``\n\n            This returns the `K`-free module with basis indexed by\n            `S`, endowed with whatever structure can be induced from\n            that of `S`. Note that the ``category`` keyword needs to\n            be fed with the structure on `S` to be used, not the\n            structure that one wants to obtain on the result; see the\n            examples below.\n\n            EXAMPLES:\n\n            If `S` is a monoid, the result is the monoid algebra `KS`::\n\n                sage: S = Monoids().example(); S\n                An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n                sage: A = S.algebra(QQ); A\n                Free module generated by An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd') over Rational Field\n                sage: A.category()\n                Category of monoid algebras over Rational Field\n\n            If `S` is a group, the result is the group algebra `KS`::\n\n                sage: S = Groups().example(); S\n                General Linear Group of degree 4 over Rational Field\n                sage: A = S.algebra(QQ); A\n                Group algebra of General Linear Group of degree 4 over Rational Field over Rational Field\n                sage: A.category()\n                Category of group algebras over Rational Field\n\n            which is actually a Hopf algebra::\n\n                sage: A in HopfAlgebras(QQ)\n                True\n\n            By Maschke's theorem, for a finite group whose cardinality\n            does not divide the characteristic of the base field, the\n            algebra is semisimple::\n\n                sage: SymmetricGroup(5).algebra(QQ) in Algebras(QQ).Semisimple()\n                True\n                sage: CyclicPermutationGroup(10).algebra(FiniteField(5)) in Algebras.Semisimple\n                False\n                sage: CyclicPermutationGroup(10).algebra(FiniteField(7)) in Algebras.Semisimple\n                True\n\n\n            One may specify for which category one takes the algebra::\n\n                sage: A = S.algebra(QQ, category=Sets()); A\n                Free module generated by General Linear Group of degree 4 over Rational Field over Rational Field\n                sage: A.category()\n                Category of set algebras over Rational Field\n\n            One may construct as well algebras of additive magmas,\n            semigroups, monoids, or groups::\n\n                sage: S = CommutativeAdditiveMonoids().example(); S\n                An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd')\n                sage: U = S.algebra(QQ); U\n                Free module generated by An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd') over Rational Field\n\n            Despite saying \"free module\", this is really an algebra\n            and its elements can be multiplied::\n\n                sage: U in Algebras(QQ)\n                True\n                sage: (a,b,c,d) = S.additive_semigroup_generators()\n                sage: U(a) * U(b)\n                B[a + b]\n\n            Constructing the algebra of a set endowed with both an\n            additive and a multiplicative structure is ambiguous::\n\n                sage: Z3 = IntegerModRing(3)\n                sage: A = Z3.algebra(QQ)\n                Traceback (most recent call last):\n                ...\n                TypeError:  `S = Ring of integers modulo 3` is both an additive and a multiplicative semigroup.\n                Constructing its algebra is ambiguous.\n                Please use, e.g., S.algebra(QQ, category=Semigroups())\n\n            The ambiguity can be resolved using the ``category`` argument::\n\n                sage: A = Z3.algebra(QQ, category=Monoids()); A\n                Free module generated by Ring of integers modulo 3 over Rational Field\n                sage: A.category()\n                Category of finite dimensional monoid algebras over Rational Field\n\n                sage: A = Z3.algebra(QQ, category=CommutativeAdditiveGroups()); A\n                Free module generated by Ring of integers modulo 3 over Rational Field\n                sage: A.category()\n                Category of finite dimensional commutative additive group algebras over Rational Field\n\n            Similarly, on , we obtain for additive magmas, monoids, groups.\n\n\n            .. WARNING::\n\n                As we have seen, in most practical use cases, the\n                result is actually an algebra, hence the name of this\n                method. In the other cases this name is misleading::\n\n                    sage: A = Sets().example().algebra(QQ); A\n                    Free module generated by Set of prime numbers (basic implementation) over Rational Field\n                    sage: A.category()\n                    Category of set algebras over Rational Field\n                    sage: A in Algebras(QQ)\n                    False\n\n                Suggestions for a uniform, meaningful, and non\n                misleading name are welcome!\n            ",
                        "args": [
                            "self",
                            "base_ring",
                            "category"
                        ],
                        "argspec": [
                            [
                                "self",
                                "base_ring",
                                "category"
                            ],
                            null,
                            null,
                            [
                                null
                            ]
                        ]
                    },
                    "an_element": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "cardinality": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method cardinality at 0x7faa353be2a8>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "sage",
                        "gap_name": "Size",
                        "mmt_name": null
                    },
                    "cartesian_product": {
                        "__doc__": "\n            Return the Cartesian product of the parents.\n\n            INPUT:\n\n            - ``parents`` -- a list (or other iterable) of parents.\n\n            - ``category`` -- (default: ``None``) the category the\n              Cartesian product belongs to. If ``None`` is passed,\n              then\n              :meth:`~sage.categories.covariant_functorial_construction.CovariantFactorialConstruction.category_from_parents`\n              is used to determine the category.\n\n            - ``extra_category`` -- (default: ``None``) a category\n              that is added to the Cartesian product in addition\n              to the categories obtained from the parents.\n\n            - other keyword arguments will passed on to the class used\n              for this Cartesian product (see also\n              :class:`~sage.sets.cartesian_product.CartesianProduct`).\n\n            OUTPUT:\n\n            The Cartesian product.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example(); A.rename(\"A\")\n                sage: A.cartesian_product(A,A)\n                A (+) A (+) A\n                sage: ZZ.cartesian_product(GF(2), FiniteEnumeratedSet([1,2,3]))\n                The Cartesian product of (Integer Ring, Finite Field of size 2, {1, 2, 3})\n\n                sage: C = ZZ.cartesian_product(A); C\n                The Cartesian product of (Integer Ring, A)\n\n            TESTS::\n\n                sage: type(C)\n                <class 'sage.sets.cartesian_product.CartesianProduct_with_category'>\n                sage: C.category()\n                Join of Category of rings and ...\n                    and Category of Cartesian products of commutative additive groups\n\n            ::\n\n                sage: cartesian_product([ZZ, ZZ], category=Sets()).category()\n                Category of sets\n                sage: cartesian_product([ZZ, ZZ]).category()\n                Join of\n                Category of Cartesian products of commutative rings and\n                Category of Cartesian products of enumerated sets\n                sage: cartesian_product([ZZ, ZZ], extra_category=Posets()).category()\n                Join of\n                Category of Cartesian products of commutative rings and\n                Category of posets and\n                Category of Cartesian products of enumerated sets\n            ",
                        "args": [],
                        "argspec": [
                            [],
                            "parents",
                            "kwargs",
                            null
                        ]
                    },
                    "is_finite": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method is_finite at 0x7faa353be1b8>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "sage",
                        "gap_name": "IsFinite",
                        "mmt_name": null
                    },
                    "is_parent_of": {
                        "__doc__": "\n            Return whether ``self`` is the parent of ``element``.\n\n            INPUT:\n\n            - ``element`` -- any object\n\n            EXAMPLES::\n\n                sage: S = ZZ\n                sage: S.is_parent_of(1)\n                True\n                sage: S.is_parent_of(2/1)\n                False\n\n            This method differs from :meth:`__contains__` because it\n            does not attempt any coercion::\n\n                sage: 2/1 in S, S.is_parent_of(2/1)\n                (True, False)\n                sage: int(1) in S, S.is_parent_of(int(1))\n                (True, False)\n            ",
                        "args": [
                            "self",
                            "element"
                        ],
                        "argspec": [
                            [
                                "self",
                                "element"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "random_element": {
                        "__doc__": null,
                        "__imfunc__": "<abstract method random_element at 0x7faa353be398>",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ],
                        "codomain": "self",
                        "gap_name": "Random",
                        "mmt_name": null
                    },
                    "some_elements": {
                        "__doc__": "\n            Return a list (or iterable) of elements of ``self``.\n\n            This is typically used for running generic tests\n            (see :class:`TestSuite`).\n\n            This default implementation calls :meth:`.an_element`.\n\n            EXAMPLES::\n\n                sage: S = Sets().example(); S\n                Set of prime numbers (basic implementation)\n                sage: S.an_element()\n                47\n                sage: S.some_elements()\n                [47]\n                sage: S = Set([])\n                sage: S.some_elements()\n                []\n\n            This method should return an iterable, *not* an iterator.\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.sets_cat.Sets.parent_class"
            },
            "structure": [
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "Algebras": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "CartesianProducts": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Enumerated": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Facade": {
                        "__doc__": "\n            Return the full subcategory of the facade objects of ``self``.\n\n            .. _facade-sets:\n\n            .. RUBRIC:: What is a facade set?\n\n            Recall that, in Sage, :ref:`sets are modelled by *parents*\n            <category-primer-parents-elements-categories>`, and their\n            elements know which distinguished set they belong to. For\n            example, the ring of integers `\\ZZ` is modelled by the\n            parent :obj:`ZZ`, and integers know that they belong to\n            this set::\n\n                sage: ZZ\n                Integer Ring\n                sage: 42.parent()\n                Integer Ring\n\n            Sometimes, it is convenient to represent the elements of a\n            parent ``P`` by elements of some other parent. For\n            example, the elements of the set of prime numbers are\n            represented by plain integers::\n\n                sage: Primes()\n                Set of all prime numbers: 2, 3, 5, 7, ...\n                sage: p = Primes().an_element(); p\n                43\n                sage: p.parent()\n                Integer Ring\n\n            In this case, ``P`` is called a *facade set*.\n\n            This feature is advertised through the category of `P`::\n\n                sage: Primes().category()\n                Category of facade infinite enumerated sets\n                sage: Sets().Facade()\n                Category of facade sets\n\n            Typical use cases include modeling a subset of an existing\n            parent::\n\n                sage: Set([4,6,9])                    # random\n                {4, 6, 9}\n                sage: Sets().Facade().example()\n                An example of facade set: the monoid of positive integers\n\n            or the union of several parents::\n\n                sage: Sets().Facade().example(\"union\")\n                An example of a facade set: the integers completed by +-infinity\n\n            or endowing an existing parent with more (or less!)\n            structure::\n\n                sage: Posets().example(\"facade\")\n                An example of a facade poset: the positive integers ordered by divisibility\n\n            Let us investigate in detail a close variant of this last\n            example: let `P` be set of divisors of `12` partially\n            ordered by divisibility. There are two options for\n            representing its elements:\n\n            1. as plain integers::\n\n                sage: P = Poset((divisors(12), attrcall(\"divides\")), facade=True)\n\n            2. as integers, modified to be aware that their parent is `P`::\n\n                sage: Q = Poset((divisors(12), attrcall(\"divides\")), facade=False)\n\n            The advantage of option 1. is that one needs not do\n            conversions back and forth between `P` and `\\ZZ`. The\n            disadvantage is that this introduces an ambiguity when\n            writing `2 < 3`: does this compare `2` and `3` w.r.t. the\n            natural order on integers or w.r.t. divisibility?::\n\n                sage: 2 < 3\n                True\n\n            To raise this ambiguity, one needs to explicitly specify\n            the underlying poset as in `2 <_P 3`::\n\n                sage: P = Posets().example(\"facade\")\n                sage: P.lt(2,3)\n                False\n\n            On the other hand, with option 2. and once constructed,\n            the elements know unambiguously how to compare\n            themselves::\n\n                sage: Q(2) < Q(3)\n                False\n                sage: Q(2) < Q(6)\n                True\n\n            Beware that ``P(2)`` is still the integer `2`. Therefore\n            ``P(2) < P(3)`` still compares `2` and `3` as integers!::\n\n                sage: P(2) < P(3)\n                True\n\n            In short `P` being a facade parent is one of the programmatic\n            counterparts (with e.g. coercions) of the usual mathematical idiom:\n            \"for ease of notation, we identify an element of `P` with the\n            corresponding integer\". Too many identifications lead to\n            confusion; the lack thereof leads to heavy, if not obfuscated,\n            notations. Finding the right balance is an art, and even though\n            there are common guidelines, it is ultimately up to the writer to\n            choose which identifications to do. This is no different in code.\n\n            .. SEEALSO::\n\n               The following examples illustrate various ways to\n               implement subsets like the set of prime numbers; look\n               at their code for details::\n\n                   sage: Sets().example(\"facade\")\n                   Set of prime numbers (facade implementation)\n                   sage: Sets().example(\"inherits\")\n                   Set of prime numbers\n                   sage: Sets().example(\"wrapper\")\n                   Set of prime numbers (wrapper implementation)\n\n            .. RUBRIC:: Specifications\n\n            A parent which is a facade must either:\n\n            - call :meth:`Parent.__init__` using the ``facade`` parameter to\n              specify a parent, or tuple thereof.\n            - overload the method :meth:`~Sets.Facade.ParentMethods.facade_for`.\n\n            .. NOTE::\n\n                The concept of facade parents was originally introduced\n                in the computer algebra system MuPAD.\n\n            TESTS:\n\n            Check that multiple categories initialisation\n            works (:trac:`13801`)::\n\n                sage: class A(Parent):\n                ....:   def __init__(self):\n                ....:       Parent.__init__(self, category=(FiniteEnumeratedSets(),Monoids()), facade=True)\n                sage: a = A()\n\n                sage: Posets().Facade()\n                Category of facade posets\n                sage: Posets().Facade().Finite() is  Posets().Finite().Facade()\n                True\n            ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    },
                    "Facades": {
                        "__doc__": "Deprecated: Use :func:`Facade` instead.\nSee :trac:`17073` for details.\n\n",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Finite": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Infinite": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "IsomorphicObjects": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Metric": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Quotients": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Subobjects": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Subquotients": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    },
                    "Topological": {
                        "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                        "args": [
                            "self",
                            "inst"
                        ],
                        "argspec": [
                            [
                                "self",
                                "inst"
                            ],
                            "args",
                            "kwds",
                            null
                        ]
                    }
                },
                "name": "sage.categories.sets_cat.Sets.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.sets_cat.Sets.Infinite": {
            "__doc__": null,
            "axioms": [
                "Infinite"
            ],
            "element_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.sets_cat.Sets.Infinite.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.sets_cat.Sets"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.sets_cat.Sets.Infinite.morphism_class"
            },
            "name": "sage.categories.sets_cat.Sets.Infinite",
            "parent_class": {
                "__doc__": null,
                "implied": [],
                "methods": {
                    "is_empty": {
                        "__doc__": "\n                Return whether this set is empty.\n\n                Since this set is infinite this always returns ``False``.\n\n                EXAMPLES::\n\n                    sage: C = InfiniteEnumeratedSets().example()\n                    sage: C.is_empty()\n                    False\n                ",
                        "args": [
                            "self"
                        ],
                        "argspec": [
                            [
                                "self"
                            ],
                            null,
                            null,
                            null
                        ]
                    }
                },
                "name": "sage.categories.sets_cat.Sets.Infinite.parent_class"
            },
            "structure": [
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
                "sage.categories.sets_cat.Sets"
            ],
            "subcategory_class": {
                "__doc__": null,
                "implied": [],
                "methods": {},
                "name": "sage.categories.sets_cat.Sets.Infinite.subcategory_class"
            },
            "type": "Sage_Category"
        },
        "sage.categories.sets_with_partial_maps.SetsWithPartialMaps": {
            "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
            "axioms": [],
            "element_class": {
                "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.element_class"
            },
            "gap": null,
            "implied": [
                "sage.categories.objects.Objects"
            ],
            "mmt": null,
            "morphism_class": {
                "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.morphism_class"
            },
            "name": "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "parent_class": {
                "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.parent_class"
            },
            "structure": [
                "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
            ],
            "subcategory_class": {
                "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
                "implied": [],
                "methods": {},
                "name": "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.subcategory_class"
            },
            "type": "Sage_Category"
        }
    },
    "classes": {
        "sage.categories.enumerated_sets.EnumeratedSets.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "rank": {
                    "__doc__": "\n            Return the rank of ``self`` in its parent.\n\n            See also :meth:`EnumeratedSets.ElementMethods.rank`\n\n            EXAMPLES::\n\n                sage: F = FiniteSemigroups().example(('a','b','c'))\n                sage: L = list(F); L\n                ['a', 'b', 'c', 'ac', 'ab', 'ba', 'bc', 'cb', 'ca',\n                 'acb', 'abc', 'bca', 'cba', 'bac', 'cab']\n                sage: L[7].rank()\n                7\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.enumerated_sets.EnumeratedSets.element_class"
        },
        "sage.categories.enumerated_sets.EnumeratedSets.morphism_class": {
            "__doc__": "\n    The category of enumerated sets\n\n    An *enumerated set* is a *finite* or *countable* set or multiset `S`\n    together with a canonical enumeration of its elements;\n    conceptually, this is very similar to an immutable list. The main\n    difference lies in the names and the return type of the methods,\n    and of course the fact that the list of elements is not supposed to\n    be expanded in memory. Whenever possible one should use one of the\n    two sub-categories :class:`FiniteEnumeratedSets` or\n    :class:`InfiniteEnumeratedSets`.\n\n    The purpose of this category is threefold:\n\n     - to fix a common interface for all these sets;\n     - to provide a bunch of default implementations;\n     - to provide consistency tests.\n\n    The standard methods for an enumerated set ``S`` are:\n\n       - ``S.cardinality()``: the number of elements of the set. This\n         is the equivalent for ``len`` on a list except that the\n         return value is specified to be a Sage :class:`Integer` or\n         ``infinity``, instead of a Python ``int``.\n\n       - ``iter(S)``: an iterator for the elements of the set;\n\n       - ``S.list()``: the list of the elements of the set, when\n         possible; raises a NotImplementedError if the list is\n         predictably too large to be expanded in memory.\n\n       - ``S.unrank(n)``: the  ``n-th`` element of the set when ``n`` is a sage\n         ``Integer``. This is the equivalent for ``l[n]`` on a list.\n\n       - ``S.rank(e)``: the position of the element ``e`` in the set;\n         This is equivalent to ``l.index(e)`` for a list except that\n         the return value is specified to be a Sage :class:`Integer`,\n         instead of a Python ``int``.\n\n       - ``S.first()``: the first object of the set; it is equivalent to\n         ``S.unrank(0)``.\n\n       - ``S.next(e)``: the object of the set which follows ``e``; It is\n         equivalent to ``S.unrank(S.rank(e)+1)``.\n\n       - ``S.random_element()``: a random generator for an element of\n         the set. Unless otherwise stated, and for finite enumerated\n         sets, the probability is uniform.\n\n    For examples and tests see:\n\n       - ``FiniteEnumeratedSets().example()``\n       - ``InfiniteEnumeratedSets().example()``\n\n\n    EXAMPLES::\n\n        sage: EnumeratedSets()\n        Category of enumerated sets\n        sage: EnumeratedSets().super_categories()\n        [Category of sets]\n        sage: EnumeratedSets().all_super_categories()\n        [Category of enumerated sets, Category of sets, Category of sets with partial maps, Category of objects]\n\n    TESTS::\n\n        sage: C = EnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.enumerated_sets.EnumeratedSets.morphism_class"
        },
        "sage.categories.enumerated_sets.EnumeratedSets.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "__getitem__": {
                    "__doc__": "\n            Return the item indexed by ``i``.\n\n            .. WARNING::\n\n                This method is only meant as a convenience shorthand for\n                ``self.unrank(i)`` and\n                ``self.unrank_range(start, stop, step)`` respectively, for\n                casual use (e.g. in interactive sessions). Subclasses are\n                hereby explicitly permitted to overload ``__getitem__``\n                with a different semantic, typically for enumerated sets\n                that are naturally indexed by some `I` not of the\n                form `\\{0, 1, \\ldots\\}`. In particular, generic code\n                *should not* use this shorthand.\n\n            EXAMPLES::\n\n                sage: P = Partitions()\n                sage: P[:5]\n                [[], [1], [2], [1, 1], [3]]\n                sage: P[0:5]\n                [[], [1], [2], [1, 1], [3]]\n                sage: P[3:5]\n                [[1, 1], [3]]\n                sage: P[3:10]\n                [[1, 1], [3], [2, 1], [1, 1, 1], [4], [3, 1], [2, 2]]\n                sage: P[3:10:2]\n                [[1, 1], [2, 1], [4], [2, 2]]\n                sage: P[3:]\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n                sage: P[3]\n                [1, 1]\n                sage: P[-1]\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n\n            ::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.list()\n                [1, 2, 3]\n                sage: C[1]\n                2\n                sage: C[:]\n                [1, 2, 3]\n                sage: C[1:]\n                [2, 3]\n                sage: C[0:1:2]\n                [1]\n\n                sage: F = FiniteEnumeratedSet([1,2,3])\n                sage: F[1:]\n                [2, 3]\n                sage: F[:2]\n                [1, 2]\n                sage: F[:2:2]\n                [1]\n                sage: F[1::2]\n                [2]\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__iter__": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method __iter__ at 0x7faa353be9b0>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "iter_of_self",
                    "gap_name": "IsIterator",
                    "mmt_name": null
                },
                "__len__": {
                    "__doc__": "\n            Return the number of elements of ``self``.\n\n            EXAMPLES::\n\n                sage: len(GF(5))\n                5\n                sage: len(MatrixSpace(GF(2), 3, 3))\n                512\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_an_element_from_iterator": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "_first_from_iterator": {
                    "__doc__": "\n            The \"first\" element of ``self``.\n\n            ``self.first()`` returns the first element of the set\n            ``self``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__`` is\n            provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.first() # indirect doctest\n                1\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_iterator_from_list": {
                    "__doc__": "\n            An iterator for the elements of ``self``.\n\n            ``iter(self)`` returns an iterator for the elements\n            of ``self``. This is a generic implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``list`` is provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: it = C._iterator_from_list()\n                sage: [next(it), next(it), next(it)]\n                [1, 2, 3]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_iterator_from_next": {
                    "__doc__": "\n            An iterator for the elements of ``self``.\n\n            ``iter(self)`` returns an iterator for the element of\n            the set ``self``. This is a generic implementation from\n            the category ``EnumeratedSets()`` which can be used when\n            the methods ``first`` and ``next`` are provided.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: it = C._iterator_from_next()\n                sage: [next(it), next(it), next(it), next(it), next(it)]\n                [0, 1, 2, 3, 4]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_iterator_from_unrank": {
                    "__doc__": "\n            An iterator for the elements of ``self``.\n\n            ``iter(self)`` returns an iterator for the elements\n            of the set ``self``. This is a generic implementation from\n            the category ``EnumeratedSets()`` which can be used when\n            the method ``unrank`` is provided.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: it = C._iterator_from_unrank()\n                sage: [next(it), next(it), next(it), next(it), next(it)]\n                [0, 1, 2, 3, 4]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_list_default": {
                    "__doc__": "\n            Return a list of the elements of ``self``.\n\n            The elements of set ``x`` are created and cached on the fist call\n            of ``x.list()``. Then each call of ``x.list()`` returns a new list\n            from the cached result. Thus in looping, it may be better to do\n            ``for e in x:``, not ``for e in x.list():``.\n\n            If ``x`` is not known to be finite, then an exception is raised.\n\n            EXAMPLES::\n\n                sage: (GF(3)^2).list()\n                [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2)]\n                sage: R = Integers(11)\n                sage: R.list()\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: l = R.list(); l\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: l.remove(0); l\n                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: R.list()\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_list_from_iterator": {
                    "__doc__": "\n            Return a list of the elements of ``self`` after cached.\n\n            TESTS:\n\n            Trying to list an infinite vector space raises an error\n            instead of running forever (see :trac:`10470`)::\n\n                sage: (QQ^2).list()  # indirect test\n                Traceback (most recent call last):\n                ...\n                AttributeError: 'FreeModule_ambient_field_with_category' object has no attribute 'list'\n\n            Here we test that for an object that does not know whether it\n            is finite or not.  Calling ``x.list()`` simply tries to create\n            the list (but here it fails, since the object is not\n            iterable). This was fixed :trac:`11350` ::\n\n                sage: R.<t,p> = QQ[]\n                sage: Q = R.quotient(t^2-t+1)\n                sage: Q.is_finite()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError\n                sage: Q.list()   # indirect test\n                Traceback (most recent call last):\n                ...\n                AttributeError: 'QuotientRing_generic_with_category' object has no attribute 'list'\n\n            Here is another example. We artificially create a version of\n            the ring of integers that does not know whether it is finite\n            or not::\n\n                sage: from sage.rings.integer_ring import IntegerRing_class\n                sage: class MyIntegers_class(IntegerRing_class):\n                ....:      def is_finite(self):\n                ....:          raise NotImplementedError\n                sage: MyIntegers = MyIntegers_class()\n                sage: MyIntegers.is_finite()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError\n\n            Asking for ``list(MyIntegers)`` will also raise an exception::\n\n                sage: list(MyIntegers)  # indirect test\n                Traceback (most recent call last):\n                ...\n                NotImplementedError\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_next_from_iterator": {
                    "__doc__": "\n            The \"next\" element after ``obj`` in ``self``.\n\n            ``self.next(e)`` returns the element of the set ``self`` which\n            follows ``e``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__``\n            is provided.\n\n            Remark: this is the default (brute force) implementation\n            of the category ``EnumeratedSets()``. Its complexity is\n            `O(r)`, where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: C._next_from_iterator(10) # indirect doctest\n                11\n\n            TODO: specify the behavior when ``obj`` is not in ``self``.\n            ",
                    "args": [
                        "self",
                        "obj"
                    ],
                    "argspec": [
                        [
                            "self",
                            "obj"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_rank_from_iterator": {
                    "__doc__": "\n            The rank of an element of ``self``\n\n            ``self.rank(x)`` returns the rank of `x`, that is its\n            position in the enumeration of ``self``. This is an\n            integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``, or None if `x` is not in `self`.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``. For infinite enumerated\n            sets, this won't terminate when `x` is not in ``self``\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: list(C)\n                [1, 2, 3]\n                sage: C.rank(3) # indirect doctest\n                2\n                sage: C.rank(5) # indirect doctest\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_some_elements_from_iterator": {
                    "__doc__": "\n            Return some elements in ``self``.\n\n            See :class:`TestSuite` for a typical use case.\n\n            This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method\n            ``__iter__`` is provided. It returns an iterator for up to\n            the first 100 elements of ``self``\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: list(C.some_elements()) # indirect doctest\n                [1, 2, 3]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_test_enumerated_set_contains": {
                    "__doc__": "\n            Checks that the methods :meth:`.__contains__` and :meth:`.__iter__` are consistent.\n\n            See also :class:`TestSuite`.\n\n            TESTS::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._test_enumerated_set_contains()\n                sage: TestSuite(C).run()\n\n            Let us now break the class::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class CCls(Example):\n                ....:     def __contains__(self, obj):\n                ....:         if obj == 3:\n                ....:             return False\n                ....:         else:\n                ....:             return obj in C\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_contains()\n                Traceback (most recent call last):\n                ...\n                AssertionError: False is not true\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_enumerated_set_iter_list": {
                    "__doc__": "\n            Checks that the methods :meth:`.list` and :meth:`.__iter__` are consistent.\n\n            See also: :class:`TestSuite`.\n\n            .. NOTE::\n\n                This test does nothing if the cardinality of the set\n                is larger than the max_runs argument.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._test_enumerated_set_iter_list()\n                sage: TestSuite(C).run()\n\n            Let us now break the class::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class CCls(Example):\n                ....:     def list(self):\n                ....:         return [1,2,3,4]\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_iter_list()\n                Traceback (most recent call last):\n                ...\n                AssertionError: 3 != 4\n\n            For a large enumerated set this test does nothing:\n            increase tester._max_runs if you want to actually run the\n            test::\n\n                sage: class CCls(Example):\n                ....:     def list(self):\n                ....:         return [1,2,3]\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_iter_list(verbose=True,max_runs=2)\n                Enumerated set too big; skipping test; increase tester._max_runs\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_unrank_from_iterator": {
                    "__doc__": "\n            The ``r``-th element of ``self``\n\n            ``self.unrank(r)`` returns the ``r``-th element of ``self``, where\n            ``r`` is an integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.unrank(2) # indirect doctest\n                3\n                sage: C._unrank_from_iterator(5)\n                Traceback (most recent call last):\n                ...\n                ValueError: the value must be between 0 and 2 inclusive\n            ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "first": {
                    "__doc__": "\n            The \"first\" element of ``self``.\n\n            ``self.first()`` returns the first element of the set\n            ``self``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__`` is\n            provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.first() # indirect doctest\n                1\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_empty": {
                    "__doc__": "\n            Return whether this set is empty.\n\n            EXAMPLES::\n\n                sage: F = FiniteEnumeratedSet([1,2,3])\n                sage: F.is_empty()\n                False\n                sage: F = FiniteEnumeratedSet([])\n                sage: F.is_empty()\n                True\n\n            TESTS::\n\n                sage: F.is_empty.__module__\n                'sage.categories.enumerated_sets'\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "iterator_range": {
                    "__doc__": "\n            Iterate over the range of elements of ``self`` starting\n            at ``start``, ending at ``stop``, and stepping by ``step``.\n\n            .. SEEALSO::\n\n                ``unrank()``, ``unrank_range()``\n\n            EXAMPLES::\n\n                sage: P = Partitions()\n                sage: list(P.iterator_range(stop=5))\n                [[], [1], [2], [1, 1], [3]]\n                sage: list(P.iterator_range(0, 5))\n                [[], [1], [2], [1, 1], [3]]\n                sage: list(P.iterator_range(3, 5))\n                [[1, 1], [3]]\n                sage: list(P.iterator_range(3, 10))\n                [[1, 1], [3], [2, 1], [1, 1, 1], [4], [3, 1], [2, 2]]\n                sage: list(P.iterator_range(3, 10, 2))\n                [[1, 1], [2, 1], [4], [2, 2]]\n                sage: it = P.iterator_range(3)\n                sage: [next(it) for x in range(10)]\n                [[1, 1],\n                 [3], [2, 1], [1, 1, 1],\n                 [4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1],\n                 [5]]\n                sage: it = P.iterator_range(3, step=2)\n                sage: [next(it) for x in range(5)]\n                [[1, 1],\n                 [2, 1],\n                 [4], [2, 2], [1, 1, 1, 1]]\n                sage: next(P.iterator_range(stop=-3))\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n                sage: next(P.iterator_range(start=-3))\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n            ",
                    "args": [
                        "self",
                        "start",
                        "stop",
                        "step"
                    ],
                    "argspec": [
                        [
                            "self",
                            "start",
                            "stop",
                            "step"
                        ],
                        null,
                        null,
                        [
                            null,
                            null,
                            null
                        ]
                    ]
                },
                "list": {
                    "__doc__": "\n            Return a list of the elements of ``self``.\n\n            The elements of set ``x`` are created and cached on the fist call\n            of ``x.list()``. Then each call of ``x.list()`` returns a new list\n            from the cached result. Thus in looping, it may be better to do\n            ``for e in x:``, not ``for e in x.list():``.\n\n            If ``x`` is not known to be finite, then an exception is raised.\n\n            EXAMPLES::\n\n                sage: (GF(3)^2).list()\n                [(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2)]\n                sage: R = Integers(11)\n                sage: R.list()\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: l = R.list(); l\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: l.remove(0); l\n                [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n                sage: R.list()\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map": {
                    "__doc__": "\n            Return the image `\\{f(x) | x \\in \\text{self}\\}` of this\n            enumerated set by `f`, as an enumerated set.\n\n            `f` is supposed to be injective.\n\n            EXAMPLES::\n\n                sage: R = SymmetricGroup(3).map(attrcall('reduced_word')); R\n                Image of Symmetric group of order 3! as a permutation group by *.reduced_word()\n                sage: R.cardinality()\n                6\n                sage: R.list()\n                [[], [1], [2, 1], [1, 2], [2], [1, 2, 1]]\n                sage: [ r for r in R]\n                [[], [1], [2, 1], [1, 2], [2], [1, 2, 1]]\n\n            .. warning::\n\n                If the function is not injective, then there may be\n                repeated elements::\n\n                    sage: P = SymmetricGroup(3)\n                    sage: P.list()\n                    [(), (1,2), (1,2,3), (1,3,2), (2,3), (1,3)]\n                    sage: P.map(attrcall('length')).list()\n                    [0, 1, 2, 2, 1, 3]\n\n            .. warning::\n\n                :class:`MapCombinatorialClass` needs to be refactored to use categories::\n\n                    sage: R.category()             # todo: not implemented\n                    Category of enumerated sets\n                    sage: TestSuite(R).run(skip=['_test_an_element', '_test_category', '_test_some_elements'])\n            ",
                    "args": [
                        "self",
                        "f",
                        "name"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "name"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "next": {
                    "__doc__": "\n            The \"next\" element after ``obj`` in ``self``.\n\n            ``self.next(e)`` returns the element of the set ``self`` which\n            follows ``e``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__``\n            is provided.\n\n            Remark: this is the default (brute force) implementation\n            of the category ``EnumeratedSets()``. Its complexity is\n            `O(r)`, where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: C._next_from_iterator(10) # indirect doctest\n                11\n\n            TODO: specify the behavior when ``obj`` is not in ``self``.\n            ",
                    "args": [
                        "self",
                        "obj"
                    ],
                    "argspec": [
                        [
                            "self",
                            "obj"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "rank": {
                    "__doc__": "\n            The rank of an element of ``self``\n\n            ``self.rank(x)`` returns the rank of `x`, that is its\n            position in the enumeration of ``self``. This is an\n            integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``, or None if `x` is not in `self`.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``. For infinite enumerated\n            sets, this won't terminate when `x` is not in ``self``\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: list(C)\n                [1, 2, 3]\n                sage: C.rank(3) # indirect doctest\n                2\n                sage: C.rank(5) # indirect doctest\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "unrank": {
                    "__doc__": "\n            The ``r``-th element of ``self``\n\n            ``self.unrank(r)`` returns the ``r``-th element of ``self``, where\n            ``r`` is an integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.unrank(2) # indirect doctest\n                3\n                sage: C._unrank_from_iterator(5)\n                Traceback (most recent call last):\n                ...\n                ValueError: the value must be between 0 and 2 inclusive\n            ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "unrank_range": {
                    "__doc__": "\n            Return the range of elements of ``self`` starting at ``start``,\n            ending at ``stop``, and stepping by ``step``.\n\n            .. SEEALSO::\n\n                ``unrank()``, ``iterator_range()``\n\n            EXAMPLES::\n\n                sage: P = Partitions()\n                sage: P.unrank_range(stop=5)\n                [[], [1], [2], [1, 1], [3]]\n                sage: P.unrank_range(0, 5)\n                [[], [1], [2], [1, 1], [3]]\n                sage: P.unrank_range(3, 5)\n                [[1, 1], [3]]\n                sage: P.unrank_range(3, 10)\n                [[1, 1], [3], [2, 1], [1, 1, 1], [4], [3, 1], [2, 2]]\n                sage: P.unrank_range(3, 10, 2)\n                [[1, 1], [2, 1], [4], [2, 2]]\n                sage: P.unrank_range(3)\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n                sage: P.unrank_range(stop=-3)\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n                sage: P.unrank_range(start=-3)\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: cannot list an infinite set\n            ",
                    "args": [
                        "self",
                        "start",
                        "stop",
                        "step"
                    ],
                    "argspec": [
                        [
                            "self",
                            "start",
                            "stop",
                            "step"
                        ],
                        null,
                        null,
                        [
                            null,
                            null,
                            null
                        ]
                    ]
                }
            },
            "name": "sage.categories.enumerated_sets.EnumeratedSets.parent_class"
        },
        "sage.categories.enumerated_sets.EnumeratedSets.subcategory_class": {
            "__doc__": "\n    The category of enumerated sets\n\n    An *enumerated set* is a *finite* or *countable* set or multiset `S`\n    together with a canonical enumeration of its elements;\n    conceptually, this is very similar to an immutable list. The main\n    difference lies in the names and the return type of the methods,\n    and of course the fact that the list of elements is not supposed to\n    be expanded in memory. Whenever possible one should use one of the\n    two sub-categories :class:`FiniteEnumeratedSets` or\n    :class:`InfiniteEnumeratedSets`.\n\n    The purpose of this category is threefold:\n\n     - to fix a common interface for all these sets;\n     - to provide a bunch of default implementations;\n     - to provide consistency tests.\n\n    The standard methods for an enumerated set ``S`` are:\n\n       - ``S.cardinality()``: the number of elements of the set. This\n         is the equivalent for ``len`` on a list except that the\n         return value is specified to be a Sage :class:`Integer` or\n         ``infinity``, instead of a Python ``int``.\n\n       - ``iter(S)``: an iterator for the elements of the set;\n\n       - ``S.list()``: the list of the elements of the set, when\n         possible; raises a NotImplementedError if the list is\n         predictably too large to be expanded in memory.\n\n       - ``S.unrank(n)``: the  ``n-th`` element of the set when ``n`` is a sage\n         ``Integer``. This is the equivalent for ``l[n]`` on a list.\n\n       - ``S.rank(e)``: the position of the element ``e`` in the set;\n         This is equivalent to ``l.index(e)`` for a list except that\n         the return value is specified to be a Sage :class:`Integer`,\n         instead of a Python ``int``.\n\n       - ``S.first()``: the first object of the set; it is equivalent to\n         ``S.unrank(0)``.\n\n       - ``S.next(e)``: the object of the set which follows ``e``; It is\n         equivalent to ``S.unrank(S.rank(e)+1)``.\n\n       - ``S.random_element()``: a random generator for an element of\n         the set. Unless otherwise stated, and for finite enumerated\n         sets, the probability is uniform.\n\n    For examples and tests see:\n\n       - ``FiniteEnumeratedSets().example()``\n       - ``InfiniteEnumeratedSets().example()``\n\n\n    EXAMPLES::\n\n        sage: EnumeratedSets()\n        Category of enumerated sets\n        sage: EnumeratedSets().super_categories()\n        [Category of sets]\n        sage: EnumeratedSets().all_super_categories()\n        [Category of enumerated sets, Category of sets, Category of sets with partial maps, Category of objects]\n\n    TESTS::\n\n        sage: C = EnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.enumerated_sets.EnumeratedSets.subcategory_class"
        },
        "sage.categories.facade_sets.FacadeSets.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.facade_sets.FacadeSets.element_class"
        },
        "sage.categories.facade_sets.FacadeSets.morphism_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.facade_sets.FacadeSets.morphism_class"
        },
        "sage.categories.facade_sets.FacadeSets.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "facade_for": {
                    "__doc__": "\n            Returns the parents this set is a facade for\n\n            This default implementation assumes that ``self`` has\n            an attribute ``_facade_for``, typically initialized by\n            :meth:`Parent.__init__`. If the attribute is not present, the method\n            raises a NotImplementedError.\n\n            EXAMPLES::\n\n                sage: S = Sets().Facade().example(); S\n                An example of facade set: the monoid of positive integers\n                sage: S.facade_for()\n                (Integer Ring,)\n\n            Check that :trac:`13801` is corrected::\n\n                sage: class A(Parent):\n                ....:     def __init__(self):\n                ....:         Parent.__init__(self, category=Sets(), facade=True)\n                sage: a = A()\n                sage: a.facade_for()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: this parent did not specify which parents it is a facade for\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.facade_sets.FacadeSets.parent_class"
        },
        "sage.categories.facade_sets.FacadeSets.subcategory_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.facade_sets.FacadeSets.subcategory_class"
        },
        "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.element_class": {
            "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.element_class"
        },
        "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.morphism_class": {
            "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.morphism_class"
        },
        "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "_cardinality_from_iterator": {
                    "__doc__": "\n            Return the cardinality of ``self``.\n\n            This brute force implementation of :meth:`cardinality`\n            iterates through the elements of ``self`` to count them.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example(); C\n                An example of a finite enumerated set: {1,2,3}\n                sage: C._cardinality_from_iterator()\n                3\n\n            TESTS:\n\n            This is the default implementation of :meth:`cardinality`\n            from the category ``FiniteEnumeratedSet()``. To test this,\n            we need a fresh example::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class FreshExample(Example): pass\n                sage: C = FreshExample(); C.rename(\"FreshExample\")\n                sage: C.cardinality\n                <bound method FreshExample_with_category._cardinality_from_iterator of FreshExample>\n\n            This method shall return an ``Integer``; we test this\n            here, because :meth:`_test_enumerated_set_iter_cardinality`\n            does not do it for us::\n\n                sage: type(C._cardinality_from_iterator())\n                <type 'sage.rings.integer.Integer'>\n\n            We ignore additional inputs since during doctests classes which\n            override ``cardinality()`` call up to the category rather than\n            their own ``cardinality()`` method (see :trac:`13688`)::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._cardinality_from_iterator(algorithm='testing')\n                3\n\n            Here is a more complete example::\n\n                sage: class TestParent(Parent):\n                ....:   def __init__(self):\n                ....:       Parent.__init__(self, category=FiniteEnumeratedSets())\n                ....:   def __iter__(self):\n                ....:       yield 1\n                ....:       return\n                ....:   def cardinality(self, dummy_arg):\n                ....:       return 1 # we don't want to change the semantics of cardinality()\n                sage: P = TestParent()\n                sage: P.cardinality(-1)\n                1\n                sage: v = P.list(); v\n                [1]\n                sage: P.cardinality()\n                1\n                sage: P.cardinality('use alt algorithm') # Used to break here: see trac #13688\n                1\n                sage: P.cardinality(dummy_arg='use alg algorithm') # Used to break here: see trac #13688\n                1\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "ignored_args",
                        "ignored_kwds",
                        null
                    ]
                },
                "_cardinality_from_list": {
                    "__doc__": "\n            The cardinality of ``self``.\n\n            This implementation of :meth:`cardinality` computes the\n            cardinality from :meth:`list` (which is\n            cached). Reciprocally, calling ``self.list()`` makes this\n            method the default implementation of :meth:`cardinality`.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._cardinality_from_list()\n                3\n\n            We ignore additional inputs since during doctests classes which\n            override ``cardinality()`` call up to the category rather than\n            their own ``cardinality()`` method (see :trac:`13688`)::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._cardinality_from_list(algorithm='testing')\n                3\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "ignored_args",
                        "ignored_kwds",
                        null
                    ]
                },
                "_last_from_iterator": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "_last_from_unrank": {
                    "__doc__": "\n            The last element of ``self``.\n\n            ``self.last()`` returns the last element of ``self``\n\n            This is a generic implementation from the category\n            ``FiniteEnumeratedSet()`` which can be used when the\n            method ``unrank`` is provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._last_from_unrank()\n                3\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_random_element_from_unrank": {
                    "__doc__": "\n            A random element in ``self``.\n\n            ``self.random_element()`` returns a random element in\n            ``self`` with uniform probability.\n\n            This is the default implementation from the category\n            ``EnumeratedSet()`` which uses the method ``unrank``.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.random_element()\n                1\n                sage: C._random_element_from_unrank()\n                2\n\n            TODO: implement _test_random which checks uniformness\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_test_enumerated_set_iter_cardinality": {
                    "__doc__": "\n            Checks that the methods :meth:`.cardinality` and\n            :meth:`.__iter__` are consistent. Also checks that\n            :meth:`.cardinality` returns an ``Integer``.\n\n            For efficiency reasons, those tests are not run if\n            :meth:`.cardinality` is\n            :meth:`._cardinality_from_iterator`, or if ``self`` is too\n            big.\n\n            .. SEEALSO:: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._test_enumerated_set_iter_cardinality()\n\n            Let us now break the class::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class CCls(Example):\n                ....:     def cardinality(self):\n                ....:         return 4\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_iter_cardinality()\n                Traceback (most recent call last):\n                ...\n                AssertionError: 4 != 3\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_unrank_from_list": {
                    "__doc__": "\n            The ``r``-th element of ``self``\n\n            INPUT:\n\n              - ``r`` -- an integer between ``0`` and ``n-1``,\n                where ``n`` is the cardinality of ``self``.\n\n            OUTPUT: the ``r``-th element of ``self``\n\n            This implementation of :meth:`unrank` uses the method\n            :meth:`list` (which is cached). Reciprocally, calling\n            ``self.list()`` makes this method the default\n            implementation of :meth:`unrank`.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._unrank_from_list(1)\n                2\n            ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "last": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            },
            "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.parent_class"
        },
        "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.subcategory_class": {
            "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.subcategory_class"
        },
        "sage.categories.finite_groups.FiniteGroups.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_groups.FiniteGroups.element_class"
        },
        "sage.categories.finite_groups.FiniteGroups.morphism_class": {
            "__doc__": "\n    The category of finite (multiplicative) groups.\n\n    EXAMPLES::\n\n        sage: C = FiniteGroups(); C\n        Category of finite groups\n        sage: C.super_categories()\n        [Category of finite monoids, Category of groups]\n        sage: C.example()\n        General Linear Group of degree 2 over Finite Field of size 3\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_groups.FiniteGroups.morphism_class"
        },
        "sage.categories.finite_groups.FiniteGroups.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "cayley_graph_disabled": {
                    "__doc__": "\n\n            AUTHORS:\n\n            - Bobby Moretti (2007-08-10)\n\n            - Robert Miller (2008-05-01): editing\n            ",
                    "args": [
                        "self",
                        "connecting_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "connecting_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "conjugacy_classes": {
                    "__doc__": "\n            Return a list with all the conjugacy classes of the group.\n\n            This will eventually be a fall-back method for groups not defined\n            over GAP. Right now just raises a ``NotImplementedError``, until\n            we include a non-GAP way of listing the conjugacy classes\n            representatives.\n\n            EXAMPLES::\n\n                sage: from sage.groups.group import FiniteGroup\n                sage: G = FiniteGroup()\n                sage: G.conjugacy_classes()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: Listing the conjugacy classes for\n                group <type 'sage.groups.group.FiniteGroup'> is not implemented\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "conjugacy_classes_representatives": {
                    "__doc__": "\n            Return a list of the conjugacy classes representatives of the group.\n\n            EXAMPLES::\n\n                sage: G = SymmetricGroup(3)\n                sage: G.conjugacy_classes_representatives()\n                [(), (1,2), (1,2,3)]\n           ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.finite_groups.FiniteGroups.parent_class"
        },
        "sage.categories.finite_groups.FiniteGroups.subcategory_class": {
            "__doc__": "\n    The category of finite (multiplicative) groups.\n\n    EXAMPLES::\n\n        sage: C = FiniteGroups(); C\n        Category of finite groups\n        sage: C.super_categories()\n        [Category of finite monoids, Category of groups]\n        sage: C.example()\n        General Linear Group of degree 2 over Finite Field of size 3\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_groups.FiniteGroups.subcategory_class"
        },
        "sage.categories.finite_monoids.FiniteMonoids.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "pseudo_order": {
                    "__doc__": "\n            Returns the pair `[k, j]` with `k` minimal and `0\\leq j <k` such\n            that ``self^k == self^j``.\n\n            Note that `j` is uniquely determined.\n\n            EXAMPLES::\n\n                sage: M = FiniteMonoids().example(); M\n                An example of a finite multiplicative monoid: the integers modulo 12\n\n                sage: x = M(2)\n                sage: [ x^i for i in range(7) ]\n                [1, 2, 4, 8, 4, 8, 4]\n                sage: x.pseudo_order()\n                [4, 2]\n\n                sage: x = M(3)\n                sage: [ x^i for i in range(7) ]\n                [1, 3, 9, 3, 9, 3, 9]\n                sage: x.pseudo_order()\n                [3, 1]\n\n                sage: x = M(4)\n                sage: [ x^i for i in range(7) ]\n                [1, 4, 4, 4, 4, 4, 4]\n                sage: x.pseudo_order()\n                [2, 1]\n\n                sage: x = M(5)\n                sage: [ x^i for i in range(7) ]\n                [1, 5, 1, 5, 1, 5, 1]\n                sage: x.pseudo_order()\n                [2, 0]\n\n            TODO: more appropriate name? see, for example, Jean-Eric Pin's\n            lecture notes on semigroups.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.finite_monoids.FiniteMonoids.element_class"
        },
        "sage.categories.finite_monoids.FiniteMonoids.morphism_class": {
            "__doc__": "\n    The category of finite (multiplicative) :class:`monoids <Monoids>`.\n\n    A finite monoid is a :class:`finite sets <FiniteSets>` endowed\n    with an associative unital binary operation `*`.\n\n    EXAMPLES::\n\n        sage: FiniteMonoids()\n        Category of finite monoids\n        sage: FiniteMonoids().super_categories()\n        [Category of monoids, Category of finite semigroups]\n\n    TESTS::\n\n        sage: TestSuite(FiniteMonoids()).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_monoids.FiniteMonoids.morphism_class"
        },
        "sage.categories.finite_monoids.FiniteMonoids.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "nerve": {
                    "__doc__": "\n            The nerve (classifying space) of this monoid.\n\n            OUTPUT: the nerve $BG$ (if $G$ denotes this monoid), as a\n            simplicial set.  The $k$-dimensional simplices of this\n            object are indexed by products of $k$ elements in the\n            monoid:\n\n            .. MATH::\n\n                a_1 * a_2 * \\cdots * a_k\n\n            The 0th face of this is obtained by deleting $a_1$, and\n            the $k$-th face is obtained by deleting $a_k$. The other\n            faces are obtained by multiplying elements: the 1st face\n            is\n\n            .. MATH::\n\n               (a1 * a_2) * \\cdots * a_k\n\n            and so on. See :wikipedia:`Nerve_(category_theory)`, which\n            describes the construction of the nerve as a simplicial\n            set.\n\n            A simplex in this simplicial set will be degenerate if in\n            the corresponding product of $k$ elements, one of those\n            elements is the identity. So we only need to keep track of\n            the products of non-identity elements. Similarly, if a\n            product `a_{i-1} a_i` is the identity element, then the\n            corresponding face of the simplex will be a degenerate\n            simplex.\n\n            EXAMPLES:\n\n            The nerve (classifying space) of the cyclic group of order\n            2 is infinite-dimensional real projective space. ::\n\n                sage: Sigma2 = groups.permutation.Cyclic(2)\n                sage: BSigma2 = Sigma2.nerve()\n                sage: BSigma2.cohomology(4, base_ring=GF(2))\n                Vector space of dimension 1 over Finite Field of size 2\n\n            The `k`-simplices of the nerve are named after the chains\n            of `k` non-unit elements to be multiplied. The group\n            `\\Sigma_2` has two elements, writen ``()`` (the identity\n            element) and ``(1,2)`` in Sage. So the 1-cells and 2-cells\n            in `B\\Sigma_2` are::\n\n                sage: BSigma2.n_cells(1)\n                [(1,2)]\n                sage: BSigma2.n_cells(2)\n                [(1,2) * (1,2)]\n\n            Another construction of the group, with different names\n            for its elements::\n\n                sage: C2 = groups.misc.MultiplicativeAbelian([2])\n                sage: BC2 = C2.nerve()\n                sage: BC2.n_cells(0)\n                [1]\n                sage: BC2.n_cells(1)\n                [f]\n                sage: BC2.n_cells(2)\n                [f * f]\n\n            With mod `p` coefficients, `B \\Sigma_p` should have its\n            first nonvanishing homology group in dimension `p`::\n\n                sage: Sigma3 = groups.permutation.Symmetric(3)\n                sage: BSigma3 = Sigma3.nerve()\n                sage: BSigma3.homology(range(4), base_ring=GF(3))\n                {0: Vector space of dimension 0 over Finite Field of size 3,\n                1: Vector space of dimension 0 over Finite Field of size 3,\n                2: Vector space of dimension 0 over Finite Field of size 3,\n                3: Vector space of dimension 1 over Finite Field of size 3}\n\n            Note that we can construct the `n`-skeleton for\n            `B\\Sigma_2` for relatively large values of `n`, while for\n            `B\\Sigma_3`, the complexes get large pretty quickly::\n\n                sage: Sigma2.nerve().n_skeleton(14)\n                Simplicial set with 15 non-degenerate simplices\n\n                sage: BSigma3 = Sigma3.nerve()\n                sage: BSigma3.n_skeleton(3)\n                Simplicial set with 156 non-degenerate simplices\n                sage: BSigma3.n_skeleton(4)\n                Simplicial set with 781 non-degenerate simplices\n\n            Finally, note that the classifying space of the order `p`\n            cyclic group is smaller than that of the symmetric group\n            on `p` letters, and its first homology group appears\n            earlier::\n\n                sage: C3 = groups.misc.MultiplicativeAbelian([3])\n                sage: list(C3)\n                [1, f, f^2]\n                sage: BC3 = C3.nerve()\n                sage: BC3.n_cells(1)\n                [f, f^2]\n                sage: BC3.n_cells(2)\n                [f * f, f * f^2, f^2 * f, f^2 * f^2]\n                sage: len(BSigma3.n_cells(2))\n                25\n                sage: len(BC3.n_cells(3))\n                8\n                sage: len(BSigma3.n_cells(3))\n                125\n\n                sage: BC3.homology(range(5), base_ring=GF(3))\n                {0: Vector space of dimension 0 over Finite Field of size 3,\n                 1: Vector space of dimension 1 over Finite Field of size 3,\n                 2: Vector space of dimension 1 over Finite Field of size 3,\n                 3: Vector space of dimension 1 over Finite Field of size 3,\n                 4: Vector space of dimension 1 over Finite Field of size 3}\n\n                sage: BC5 = groups.permutation.Cyclic(5).nerve()\n                sage: BC5.homology(range(5), base_ring=GF(5))\n                {0: Vector space of dimension 0 over Finite Field of size 5,\n                1: Vector space of dimension 1 over Finite Field of size 5,\n                2: Vector space of dimension 1 over Finite Field of size 5,\n                3: Vector space of dimension 1 over Finite Field of size 5,\n                4: Vector space of dimension 1 over Finite Field of size 5}\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "rhodes_radical_congruence": {
                    "__doc__": "\n            Return the Rhodes radical congruence of the semigroup.\n\n            The Rhodes radical congruence is the congruence induced on S by the\n            map `S \\rightarrow kS \\rightarrow kS / rad kS` with k a field.\n\n            INPUT:\n\n            - ``base_ring`` (default: `\\QQ`) a field\n\n            OUTPUT:\n\n            - A list of couples (m, n) with `m \\neq n` in the lexicographic\n              order for the enumeration of the monoid ``self``.\n\n            EXAMPLES::\n\n                sage: M = Monoids().Finite().example()\n                sage: M.rhodes_radical_congruence()\n                [(0, 6), (2, 8), (4, 10)]\n                sage: from sage.monoids.hecke_monoid import HeckeMonoid\n                sage: H3 = HeckeMonoid(SymmetricGroup(3))\n                sage: H3.repr_element_method(style=\"reduced\")\n                sage: H3.rhodes_radical_congruence()\n                [([1, 2], [2, 1]), ([1, 2], [1, 2, 1]), ([2, 1], [1, 2, 1])]\n\n            By Maschke's theorem, every group algebra over `\\QQ`\n            is semisimple hence the Rhodes radical of a group must be trivial::\n\n                sage: SymmetricGroup(3).rhodes_radical_congruence()\n                []\n                sage: DihedralGroup(10).rhodes_radical_congruence()\n                []\n\n            REFERENCES:\n\n            - [Rho69]_\n            ",
                    "args": [
                        "self",
                        "base_ring"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            },
            "name": "sage.categories.finite_monoids.FiniteMonoids.parent_class"
        },
        "sage.categories.finite_monoids.FiniteMonoids.subcategory_class": {
            "__doc__": "\n    The category of finite (multiplicative) :class:`monoids <Monoids>`.\n\n    A finite monoid is a :class:`finite sets <FiniteSets>` endowed\n    with an associative unital binary operation `*`.\n\n    EXAMPLES::\n\n        sage: FiniteMonoids()\n        Category of finite monoids\n        sage: FiniteMonoids().super_categories()\n        [Category of monoids, Category of finite semigroups]\n\n    TESTS::\n\n        sage: TestSuite(FiniteMonoids()).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_monoids.FiniteMonoids.subcategory_class"
        },
        "sage.categories.finite_permutation_groups.FinitePermutationGroups.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_permutation_groups.FinitePermutationGroups.element_class"
        },
        "sage.categories.finite_permutation_groups.FinitePermutationGroups.morphism_class": {
            "__doc__": "\n    The category of finite permutation groups, i.e. groups concretely\n    represented as groups of permutations acting on a finite set.\n\n    It is currently assumed that any finite permutation group comes\n    endowed with a distinguished finite set of generators (method\n    ``group_generators``); this is the case for all the existing\n    implementations in Sage.\n\n    EXAMPLES::\n\n        sage: C = PermutationGroups().Finite(); C\n        Category of finite enumerated permutation groups\n        sage: C.super_categories()\n        [Category of permutation groups,\n         Category of finite groups,\n         Category of finite finitely generated semigroups]\n\n        sage: C.example()\n        Dihedral group of order 6 as a permutation group\n\n    TESTS::\n\n        sage: C is FinitePermutationGroups()\n        True\n        sage: TestSuite(C).run()\n\n        sage: G = FinitePermutationGroups().example()\n        sage: TestSuite(G).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_new() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_inverse() . . . pass\n        running ._test_new() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_permutation_groups.FinitePermutationGroups.morphism_class"
        },
        "sage.categories.finite_permutation_groups.FinitePermutationGroups.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "cycle_index": {
                    "__doc__": "\n            INPUT:\n\n             - ``self`` - a permutation group `G`\n             - ``parent`` -- a free module with basis indexed by partitions,\n               or behave as such, with a ``term`` and ``sum`` method\n               (default: the symmetric functions over the rational field in the p basis)\n\n            Returns the *cycle index* of `G`, which is a gadget counting\n            the elements of `G` by cycle type, averaged over the group:\n\n            .. MATH::\n\n                P = \\frac{1}{|G|} \\sum_{g\\in G} p_{ \\operatorname{cycle\\ type}(g) }\n\n            EXAMPLES:\n\n            Among the permutations of the symmetric group `S_4`, there is\n            the identity, 6 cycles of length 2, 3 products of two cycles\n            of length 2, 8 cycles of length 3, and 6 cycles of length 4::\n\n                sage: S4 = SymmetricGroup(4)\n                sage: P = S4.cycle_index()\n                sage: 24 * P\n                p[1, 1, 1, 1] + 6*p[2, 1, 1] + 3*p[2, 2] + 8*p[3, 1] + 6*p[4]\n\n            If `l = (l_1,\\dots,l_k)` is a partition, ``|G| P[l]`` is the number\n            of elements of `G` with cycles of length `(p_1,\\dots,p_k)`::\n\n                sage: 24 * P[ Partition([3,1]) ]\n                8\n\n            The cycle index plays an important role in the enumeration of\n            objects modulo the action of a group (Polya enumeration), via\n            the use of symmetric functions and plethysms. It is therefore\n            encoded as a symmetric function, expressed in the powersum\n            basis::\n\n                sage: P.parent()\n                Symmetric Functions over Rational Field in the powersum basis\n\n            This symmetric function can have some nice properties; for\n            example, for the symmetric group `S_n`, we get the complete\n            symmetric function `h_n`::\n\n                sage: S = SymmetricFunctions(QQ); h = S.h()\n                sage: h( P )\n                h[4]\n\n            TODO: add some simple examples of Polya enumeration, once it\n            will be easy to expand symmetric functions on any alphabet.\n\n            Here are the cycle indices of some permutation groups::\n\n                sage: 6 * CyclicPermutationGroup(6).cycle_index()\n                p[1, 1, 1, 1, 1, 1] + p[2, 2, 2] + 2*p[3, 3] + 2*p[6]\n\n                sage: 60 * AlternatingGroup(5).cycle_index()\n                p[1, 1, 1, 1, 1] + 15*p[2, 2, 1] + 20*p[3, 1, 1] + 24*p[5]\n\n                sage: for G in TransitiveGroups(5):               # optional - database_gap # long time\n                ....:     G.cardinality() * G.cycle_index()\n                p[1, 1, 1, 1, 1] + 4*p[5]\n                p[1, 1, 1, 1, 1] + 5*p[2, 2, 1] + 4*p[5]\n                p[1, 1, 1, 1, 1] + 5*p[2, 2, 1] + 10*p[4, 1] + 4*p[5]\n                p[1, 1, 1, 1, 1] + 15*p[2, 2, 1] + 20*p[3, 1, 1] + 24*p[5]\n                p[1, 1, 1, 1, 1] + 10*p[2, 1, 1, 1] + 15*p[2, 2, 1] + 20*p[3, 1, 1] + 20*p[3, 2] + 30*p[4, 1] + 24*p[5]\n\n            One may specify another parent for the result::\n\n                sage: F = CombinatorialFreeModule(QQ, Partitions())\n                sage: P = CyclicPermutationGroup(6).cycle_index(parent = F)\n                sage: 6 * P\n                B[[1, 1, 1, 1, 1, 1]] + B[[2, 2, 2]] + 2*B[[3, 3]] + 2*B[[6]]\n                sage: P.parent() is F\n                True\n\n            This parent should have a ``term`` and ``sum`` method::\n\n                sage: CyclicPermutationGroup(6).cycle_index(parent = QQ)\n                Traceback (most recent call last):\n                  ...\n                AssertionError: `parent` should be (or behave as) a free module with basis indexed by partitions\n\n            REFERENCES:\n\n            - [Ke1991]_\n\n            AUTHORS:\n\n             - Nicolas Borie and Nicolas M. Thiery\n\n            TESTS::\n\n                sage: P = PermutationGroup([]); P\n                Permutation Group with generators [()]\n                sage: P.cycle_index()\n                p[1]\n                sage: P = PermutationGroup([[(1)]]); P\n                Permutation Group with generators [()]\n                sage: P.cycle_index()\n                p[1]\n            ",
                    "args": [
                        "self",
                        "parent"
                    ],
                    "argspec": [
                        [
                            "self",
                            "parent"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            },
            "name": "sage.categories.finite_permutation_groups.FinitePermutationGroups.parent_class"
        },
        "sage.categories.finite_permutation_groups.FinitePermutationGroups.subcategory_class": {
            "__doc__": "\n    The category of finite permutation groups, i.e. groups concretely\n    represented as groups of permutations acting on a finite set.\n\n    It is currently assumed that any finite permutation group comes\n    endowed with a distinguished finite set of generators (method\n    ``group_generators``); this is the case for all the existing\n    implementations in Sage.\n\n    EXAMPLES::\n\n        sage: C = PermutationGroups().Finite(); C\n        Category of finite enumerated permutation groups\n        sage: C.super_categories()\n        [Category of permutation groups,\n         Category of finite groups,\n         Category of finite finitely generated semigroups]\n\n        sage: C.example()\n        Dihedral group of order 6 as a permutation group\n\n    TESTS::\n\n        sage: C is FinitePermutationGroups()\n        True\n        sage: TestSuite(C).run()\n\n        sage: G = FinitePermutationGroups().example()\n        sage: TestSuite(G).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_new() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_inverse() . . . pass\n        running ._test_new() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_permutation_groups.FinitePermutationGroups.subcategory_class"
        },
        "sage.categories.finite_semigroups.FiniteSemigroups.element_class": {
            "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_semigroups.FiniteSemigroups.element_class"
        },
        "sage.categories.finite_semigroups.FiniteSemigroups.morphism_class": {
            "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_semigroups.FiniteSemigroups.morphism_class"
        },
        "sage.categories.finite_semigroups.FiniteSemigroups.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "idempotents": {
                    "__doc__": "\n            Returns the idempotents of the semigroup\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example(alphabet=('x','y'))\n                sage: sorted(S.idempotents())\n                ['x', 'xy', 'y', 'yx']\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "isomorphism_transformation_monoid": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method isomorphism_transformation_monoid at 0x7faa353cf848>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": null,
                    "gap_name": "IsomorphismTransformationMonoid",
                    "mmt_name": null
                },
                "j_classes": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "j_classes_of_idempotents": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "j_transversal_of_idempotents": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            },
            "name": "sage.categories.finite_semigroups.FiniteSemigroups.parent_class"
        },
        "sage.categories.finite_semigroups.FiniteSemigroups.subcategory_class": {
            "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_semigroups.FiniteSemigroups.subcategory_class"
        },
        "sage.categories.finite_sets.FiniteSets.element_class": {
            "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_sets.FiniteSets.element_class"
        },
        "sage.categories.finite_sets.FiniteSets.morphism_class": {
            "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_sets.FiniteSets.morphism_class"
        },
        "sage.categories.finite_sets.FiniteSets.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "list": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method list at 0x7faa353be500>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "list_of_self",
                    "gap_name": "List",
                    "mmt_name": null
                }
            },
            "name": "sage.categories.finite_sets.FiniteSets.parent_class"
        },
        "sage.categories.finite_sets.FiniteSets.subcategory_class": {
            "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finite_sets.FiniteSets.subcategory_class"
        },
        "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.element_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.element_class"
        },
        "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.morphism_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.morphism_class"
        },
        "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "magma_generators": {
                    "__doc__": "\n            Return distinguished magma generators for ``self``.\n\n            OUTPUT: a finite family\n\n            This method should be implemented by all\n            :class:`finitely generated magmas <FinitelyGeneratedMagmas>`.\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example()\n                sage: S.magma_generators()\n                Family ('a', 'b', 'c', 'd')\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.parent_class"
        },
        "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.subcategory_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas.subcategory_class"
        },
        "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.element_class"
        },
        "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.morphism_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.morphism_class"
        },
        "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.parent_class"
        },
        "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.subcategory_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite.subcategory_class"
        },
        "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.element_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Enumerated', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.element_class"
        },
        "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.morphism_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Enumerated', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.morphism_class"
        },
        "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "ideal": {
                    "__doc__": "\n            Return the ``side``-sided ideal generated by ``gens``.\n\n            This brute force implementation recursively multiplies the\n            elements of ``gens`` by the distinguished generators of\n            this semigroup.\n\n            .. SEEALSO:: :meth:`semigroup_generators`\n\n            INPUT:\n\n            - ``gens`` -- a list (or iterable) of elements of ``self``\n            - ``side`` -- [default: \"twosided\"] \"left\", \"right\" or \"twosided\"\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example()\n                sage: list(S.ideal([S('cab')], side=\"left\"))\n                ['cab', 'acb', 'dcab', 'bca', 'abc', 'adcb', 'bdca',\n                 'cba', 'cdab', 'bac', 'dacb', 'dbca', 'adbc', 'bcda',\n                 'dbac', 'dabc', 'cbda', 'cdba', 'abdc', 'bdac', 'dcba',\n                 'cadb', 'badc', 'acdb', 'abcd', 'cbad', 'bacd', 'acbd',\n                 'bcad', 'cabd']\n                sage: list(S.ideal([S('cab')], side=\"right\"))\n                ['cab', 'cabd']\n                sage: list(S.ideal([S('cab')], side=\"twosided\"))\n                ['cab', 'acb', 'dcab', 'bca', 'cabd', 'abc', 'adcb',\n                 'acbd', 'bdca', 'bcad', 'cba', 'cdab', 'bac', 'dacb',\n                 'dbca', 'abcd', 'cbad', 'bacd', 'bcda', 'dbac', 'dabc',\n                 'cbda', 'cdba', 'abdc', 'adbc', 'bdac', 'dcba', 'cadb',\n                 'badc', 'acdb']\n                sage: list(S.ideal([S('cab')]))\n                ['cab', 'acb', 'dcab', 'bca', 'cabd', 'abc', 'adcb',\n                 'acbd', 'bdca', 'bcad', 'cba', 'cdab', 'bac', 'dacb',\n                 'dbca', 'abcd', 'cbad', 'bacd', 'bcda', 'dbac', 'dabc',\n                 'cbda', 'cdba', 'abdc', 'adbc', 'bdac', 'dcba', 'cadb',\n                 'badc', 'acdb']\n            ",
                    "args": [
                        "self",
                        "gens",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "gens",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "twosided"
                        ]
                    ]
                },
                "succ_generators": {
                    "__doc__": "\n            Return the successor function of the ``side``-sided Cayley\n            graph of ``self``.\n\n            This is a function that maps an element of ``self`` to all\n            the products of ``x`` by a generator of this semigroup,\n            where the product is taken on the left, right, or both\n            sides.\n\n            INPUT:\n\n            - ``side``: \"left\", \"right\", or \"twosided\"\n\n            .. TODO:: Design choice:\n\n               - find a better name for this method\n               - should we return a set? a family?\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example()\n                sage: S.succ_generators(\"left\" )(S('ca'))\n                ('ac', 'bca', 'ca', 'dca')\n                sage: S.succ_generators(\"right\")(S('ca'))\n                ('ca', 'cab', 'ca', 'cad')\n                sage: S.succ_generators(\"twosided\" )(S('ca'))\n                ('ac', 'bca', 'ca', 'dca', 'ca', 'cab', 'ca', 'cad')\n\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "twosided"
                        ]
                    ]
                }
            },
            "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.parent_class"
        },
        "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.subcategory_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Enumerated', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.subcategory_class"
        },
        "sage.categories.groups.Groups.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "conjugacy_class": {
                    "__doc__": "\n            Return the conjugacy class of ``self``.\n\n            EXAMPLES::\n\n                sage: D = DihedralGroup(5)\n                sage: g = D((1,3,5,2,4))\n                sage: g.conjugacy_class()\n                Conjugacy class of (1,3,5,2,4) in Dihedral group of order 10 as a permutation group\n\n                sage: H = MatrixGroup([matrix(GF(5),2,[1,2, -1, 1]), matrix(GF(5),2, [1,1, 0,1])])\n                sage: h = H(matrix(GF(5),2,[1,2, -1, 1]))\n                sage: h.conjugacy_class()\n                Conjugacy class of [1 2]\n                [4 1] in Matrix group over Finite Field of size 5 with 2 generators (\n                [1 2]  [1 1]\n                [4 1], [0 1]\n                )\n\n                sage: G = SL(2, GF(2))\n                sage: g = G.gens()[0]\n                sage: g.conjugacy_class()\n                Conjugacy class of [1 1]\n                [0 1] in Special Linear Group of degree 2 over Finite Field of size 2\n\n                sage: G = SL(2, QQ)\n                sage: g = G([[1,1],[0,1]])\n                sage: g.conjugacy_class()\n                Conjugacy class of [1 1]\n                [0 1] in Special Linear Group of degree 2 over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.groups.Groups.element_class"
        },
        "sage.categories.groups.Groups.morphism_class": {
            "__doc__": "\n    The category of (multiplicative) groups, i.e. monoids with\n    inverses.\n\n    EXAMPLES::\n\n        sage: Groups()\n        Category of groups\n        sage: Groups().super_categories()\n        [Category of monoids, Category of inverse unital magmas]\n\n    TESTS::\n\n        sage: TestSuite(Groups()).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.groups.Groups.morphism_class"
        },
        "sage.categories.groups.Groups.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "_test_inverse": {
                    "__doc__": "\n            Run generic tests on the method :meth:`.__invert__`.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: G = SymmetricGroup(3)\n                sage: G._test_inverse()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "cayley_table": {
                    "__doc__": "\n            Returns the \"multiplication\" table of this multiplicative group,\n            which is also known as the \"Cayley table\".\n\n            .. note:: The order of the elements in the row and column\n              headings is equal to the order given by the table's\n              :meth:`~sage.matrix.operation_table.OperationTable.column_keys`\n              method.  The association between the actual elements and the\n              names/symbols used in the table can also be retrieved as\n              a dictionary with the\n              :meth:`~sage.matrix.operation_table.OperationTable.translation`\n              method.\n\n            For groups, this routine should behave identically to the\n            :meth:`~sage.categories.magmas.Magmas.ParentMethods.multiplication_table`\n            method for magmas, which applies in greater generality.\n\n            INPUT:\n\n            - ``names`` - the type of names used, values are:\n\n              * ``'letters'`` - lowercase ASCII letters are used\n                for a base 26 representation of the elements'\n                positions in the list given by :meth:`list`,\n                padded to a common width with leading 'a's.\n              * ``'digits'`` - base 10 representation of the\n                elements' positions in the list given by\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`,\n                padded to a common width with leading zeros.\n              * ``'elements'`` - the string representations\n                of the elements themselves.\n              * a list - a list of strings, where the length\n                of the list equals the number of elements.\n\n            - ``elements`` - default = ``None``.  A list of\n              elements of the group, in forms that can be\n              coerced into the structure, eg. their string\n              representations. This may be used to impose an\n              alternate ordering on the elements, perhaps when\n              this is used in the context of a particular structure.\n              The default is to use whatever ordering is provided by the\n              the group, which is reported by the\n              :meth:`~sage.matrix.operation_table.OperationTable.column_keys`\n              method.  Or the ``elements`` can be a subset\n              which is closed under the operation. In particular,\n              this can be used when the base set is infinite.\n\n            OUTPUT:\n            An object representing the multiplication table.  This is\n            an :class:`~sage.matrix.operation_table.OperationTable` object\n            and even more documentation can be found there.\n\n\n            EXAMPLES:\n\n            Permutation groups, matrix groups and abelian groups\n            can all compute their multiplication tables.  ::\n\n                sage: G = DiCyclicGroup(3)\n                sage: T = G.cayley_table()\n                sage: T.column_keys()\n                ((), (1,3,2,4)(5,7), ..., (1,2)(3,4)(5,7,6))\n                sage: T\n                *  a b c d e f g h i j k l\n                 +------------------------\n                a| a b c d e f g h i j k l\n                b| b e f j i h d k a l c g\n                c| c g d e h b k l j f i a\n                d| d k e h l g i a f b j c\n                e| e i h l a k j c b g f d\n                f| f d j i k e c g l h a b\n                g| g h b f j l e i c a d k\n                h| h j l a c i f d g k b e\n                i| i a k g b c l f e d h j\n                j| j c i k g d a b h e l f\n                k| k l g b f a h j d c e i\n                l| l f a c d j b e k i g h\n\n            ::\n\n                sage: M=SL(2,2)\n                sage: M.cayley_table()\n                *  a b c d e f\n                 +------------\n                a| a b c d e f\n                b| b a d c f e\n                c| c f e b a d\n                d| d e f a b c\n                e| e d a f c b\n                f| f c b e d a\n                <BLANKLINE>\n\n            ::\n\n                sage: A=AbelianGroup([2,3])\n                sage: A.cayley_table()\n                *  a b c d e f\n                 +------------\n                a| a b c d e f\n                b| b c a e f d\n                c| c a b f d e\n                d| d e f a b c\n                e| e f d b c a\n                f| f d e c a b\n\n            Lowercase ASCII letters are the default symbols used\n            for the table, but you can also specify the use of\n            decimal digit strings, or provide your own strings\n            (in the proper order if they have meaning).\n            Also, if the elements themselves are not too complex,\n            you can choose to just use the string representations\n            of the elements themselves.  ::\n\n                sage: C=CyclicPermutationGroup(11)\n                sage: C.cayley_table(names='digits')\n                 *  00 01 02 03 04 05 06 07 08 09 10\n                  +---------------------------------\n                00| 00 01 02 03 04 05 06 07 08 09 10\n                01| 01 02 03 04 05 06 07 08 09 10 00\n                02| 02 03 04 05 06 07 08 09 10 00 01\n                03| 03 04 05 06 07 08 09 10 00 01 02\n                04| 04 05 06 07 08 09 10 00 01 02 03\n                05| 05 06 07 08 09 10 00 01 02 03 04\n                06| 06 07 08 09 10 00 01 02 03 04 05\n                07| 07 08 09 10 00 01 02 03 04 05 06\n                08| 08 09 10 00 01 02 03 04 05 06 07\n                09| 09 10 00 01 02 03 04 05 06 07 08\n                10| 10 00 01 02 03 04 05 06 07 08 09\n\n            ::\n\n                sage: G=QuaternionGroup()\n                sage: names=['1', 'I', 'J', '-1', '-K', 'K', '-I', '-J']\n                sage: G.cayley_table(names=names)\n                 *   1  I  J -1 -K  K -I -J\n                  +------------------------\n                 1|  1  I  J -1 -K  K -I -J\n                 I|  I -1  K -I  J -J  1 -K\n                 J|  J -K -1 -J -I  I  K  1\n                -1| -1 -I -J  1  K -K  I  J\n                -K| -K -J  I  K -1  1  J -I\n                 K|  K  J -I -K  1 -1 -J  I\n                -I| -I  1 -K  I -J  J -1  K\n                -J| -J  K  1  J  I -I -K -1\n\n            ::\n\n                sage: A=AbelianGroup([2,2])\n                sage: A.cayley_table(names='elements')\n                    *      1    f1    f0 f0*f1\n                     +------------------------\n                    1|     1    f1    f0 f0*f1\n                   f1|    f1     1 f0*f1    f0\n                   f0|    f0 f0*f1     1    f1\n                f0*f1| f0*f1    f0    f1     1\n\n            The :meth:`~sage.matrix.operation_table.OperationTable.change_names`\n            routine behaves similarly, but changes an existing table \"in-place.\"\n            ::\n\n                sage: G=AlternatingGroup(3)\n                sage: T=G.cayley_table()\n                sage: T.change_names('digits')\n                sage: T\n                *  0 1 2\n                 +------\n                0| 0 1 2\n                1| 1 2 0\n                2| 2 0 1\n\n            For an infinite group, you can still work with finite sets of\n            elements, provided the set is closed under multiplication.\n            Elements will be coerced into the group as part of setting\n            up the table.  ::\n\n                sage: G=SL(2,ZZ)\n                sage: G\n                Special Linear Group of degree 2 over Integer Ring\n                sage: identity = matrix(ZZ, [[1,0], [0,1]])\n                sage: G.cayley_table(elements=[identity, -identity])\n                *  a b\n                 +----\n                a| a b\n                b| b a\n\n            The\n            :class:`~sage.matrix.operation_table.OperationTable`\n            class provides even greater flexibility, including changing\n            the operation.  Here is one such example, illustrating the\n            computation of commutators.  ``commutator`` is defined as\n            a function of two variables, before being used to build\n            the table. From this, the commutator subgroup seems obvious,\n            and creating a Cayley table with just these three elements\n            confirms that they form a closed subset in the group.\n            ::\n\n                sage: from sage.matrix.operation_table import OperationTable\n                sage: G=DiCyclicGroup(3)\n                sage: commutator = lambda x, y: x*y*x^-1*y^-1\n                sage: T=OperationTable(G, commutator)\n                sage: T\n                .  a b c d e f g h i j k l\n                 +------------------------\n                a| a a a a a a a a a a a a\n                b| a a h d a d h h a h d d\n                c| a d a a a d d a d d d a\n                d| a h a a a h h a h h h a\n                e| a a a a a a a a a a a a\n                f| a h h d a a d h h d a d\n                g| a d h d a h a h d a h d\n                h| a d a a a d d a d d d a\n                i| a a h d a d h h a h d d\n                j| a d h d a h a h d a h d\n                k| a h h d a a d h h d a d\n                l| a h a a a h h a h h h a\n                sage: trans = T.translation()\n                sage: comm = [trans['a'], trans['d'],trans['h']]\n                sage: comm\n                [(), (5,7,6), (5,6,7)]\n                sage: P=G.cayley_table(elements=comm)\n                sage: P\n                *  a b c\n                 +------\n                a| a b c\n                b| b c a\n                c| c a b\n\n            TODO:\n\n            Arrange an ordering of elements into cosets of a normal\n            subgroup close to size `\\sqrt{n}`.  Then the quotient\n            group structure is often apparent in the table.  See\n            comments on :trac:`7555`.\n\n            AUTHOR:\n\n            - Rob Beezer (2010-03-15)\n\n            ",
                    "args": [
                        "self",
                        "names",
                        "elements"
                    ],
                    "argspec": [
                        [
                            "self",
                            "names",
                            "elements"
                        ],
                        null,
                        null,
                        [
                            "letters",
                            null
                        ]
                    ]
                },
                "conjugacy_class": {
                    "__doc__": "\n            Return the conjugacy class of the element ``g``.\n\n            This is a fall-back method for groups not defined over GAP.\n\n            EXAMPLES::\n\n                sage: A = AbelianGroup([2,2])\n                sage: c = A.conjugacy_class(A.an_element())\n                sage: type(c)\n                <class 'sage.groups.conjugacy_classes.ConjugacyClass_with_category'>\n            ",
                    "args": [
                        "self",
                        "g"
                    ],
                    "argspec": [
                        [
                            "self",
                            "g"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "group_generators": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method group_generators at 0x7faa353cfa28>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "list_of_self",
                    "gap_name": "GeneratorsOfGroup",
                    "mmt_name": null
                },
                "holomorph": {
                    "__doc__": "\n            The holomorph of a group\n\n            The holomorph of a group `G` is the semidirect product\n            `G \\rtimes_{id} Aut(G)`, where `id` is the identity function\n            on `Aut(G)`, the automorphism group of `G`.\n\n            See :wikipedia:`Holomorph (mathematics)`\n\n            EXAMPLES::\n\n                sage: G = Groups().example()\n                sage: G.holomorph()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: holomorph of General Linear Group of degree 4 over Rational Field not yet implemented\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_abelian": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method is_abelian at 0x7faa353cf938>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "sage",
                    "gap_name": "IsAbelian",
                    "mmt_name": null
                },
                "semidirect_product": {
                    "__doc__": "\n            The semi-direct product of two groups\n\n            EXAMPLES::\n\n                sage: G = Groups().example()\n                sage: G.semidirect_product(G,Morphism(G,G))\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: semidirect product of General Linear Group of degree 4 over Rational Field and General Linear Group of degree 4 over Rational Field not yet implemented\n            ",
                    "args": [
                        "self",
                        "N",
                        "mapping",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "N",
                            "mapping",
                            "check"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                }
            },
            "name": "sage.categories.groups.Groups.parent_class"
        },
        "sage.categories.groups.Groups.subcategory_class": {
            "__doc__": "\n    The category of (multiplicative) groups, i.e. monoids with\n    inverses.\n\n    EXAMPLES::\n\n        sage: Groups()\n        Category of groups\n        sage: Groups().super_categories()\n        [Category of monoids, Category of inverse unital magmas]\n\n    TESTS::\n\n        sage: TestSuite(Groups()).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.groups.Groups.subcategory_class"
        },
        "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.element_class": {
            "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.element_class"
        },
        "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.morphism_class": {
            "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.morphism_class"
        },
        "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "_test_enumerated_set_iter_cardinality": {
                    "__doc__": "\n            Check that the methods :meth:`.cardinality` and\n            :meth:`.__iter__`. are consistent.\n\n            See also :class:`TestSuite`.\n\n            For infinite enumerated sets:\n\n               * :meth:`.cardinality` is supposed to return `infinity`\n\n               * :meth:`.list`` is supposed to raise a ``NotImplementedError``.\n\n            EXAMPLES::\n\n                sage: NN = InfiniteEnumeratedSets().example()\n                sage: NN._test_enumerated_set_iter_cardinality()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                }
            },
            "name": "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.parent_class"
        },
        "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.subcategory_class": {
            "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets.subcategory_class"
        },
        "sage.categories.magmas.Magmas.Unital.Inverse.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.magmas.Magmas.Unital.Inverse.element_class"
        },
        "sage.categories.magmas.Magmas.Unital.Inverse.morphism_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.magmas.Magmas.Unital.Inverse.morphism_class"
        },
        "sage.categories.magmas.Magmas.Unital.Inverse.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.magmas.Magmas.Unital.Inverse.parent_class"
        },
        "sage.categories.magmas.Magmas.Unital.Inverse.subcategory_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.magmas.Magmas.Unital.Inverse.subcategory_class"
        },
        "sage.categories.magmas.Magmas.Unital.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "__invert__": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method __invert__ at 0x7faa353c21b8>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "Inverse",
                    "mmt_name": "inverse"
                },
                "_div_": {
                    "__doc__": "\n                Default implementation of division, multiplying (on the right) by the inverse.\n\n                INPUT:\n\n                - ``left``, ``right`` -- two elements of the same unital magma\n\n                .. SEEALSO:: :meth:`__div__`\n\n                EXAMPLES::\n\n                    sage: G = FreeGroup(2)\n                    sage: x0, x1 = G.group_generators()\n                    sage: c1 = cartesian_product([x0, x1])\n                    sage: c2 = cartesian_product([x1, x0])\n                    sage: c1._div_(c2)\n                    (x0*x1^-1, x1*x0^-1)\n\n                With this implementation, division will fail as soon\n                as ``right`` is not invertible, even if ``right``\n                actually divides ``left``::\n\n                    sage: x = cartesian_product([2, 1])\n                    sage: y = cartesian_product([1, 1])\n                    sage: x / y\n                    (2, 1)\n                    sage: x / x\n                    Traceback (most recent call last):\n                    ...\n                    TypeError: no conversion of this rational to integer\n\n                TESTS::\n\n                    sage: c1._div_.__module__\n                    'sage.categories.magmas'\n                ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.magmas.Magmas.Unital.element_class"
        },
        "sage.categories.magmas.Magmas.Unital.morphism_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.magmas.Magmas.Unital.morphism_class"
        },
        "sage.categories.magmas.Magmas.Unital.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "_test_one": {
                    "__doc__": "\n                Test that ``self.one()`` is an element of ``self`` and is\n                neutral for the operation ``*``.\n\n                INPUT:\n\n                - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n                EXAMPLES:\n\n                By default, this method tests only the elements returned by\n                ``self.some_elements()``::\n\n                    sage: S = Monoids().example()\n                    sage: S._test_one()\n\n                However, the elements tested can be customized with the\n                ``elements`` keyword argument::\n\n                    sage: S._test_one(elements = (S('a'), S('b')))\n\n                See the documentation for :class:`TestSuite` for more information.\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "is_empty": {
                    "__doc__": "\n                Return whether ``self`` is empty.\n\n                Since this set is a unital magma it is not empty and this method\n                always return ``False``.\n\n                EXAMPLES::\n\n                    sage: S = SymmetricGroup(2)\n                    sage: S.is_empty()\n                    False\n\n                    sage: M = Monoids().example()\n                    sage: M.is_empty()\n                    False\n\n                TESTS::\n\n                    sage: S.is_empty.__module__\n                    'sage.categories.magmas'\n                    sage: M.is_empty.__module__\n                    'sage.categories.magmas'\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "one": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method one at 0x7faa353c2140>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "self",
                    "gap_name": "One",
                    "mmt_name": "neutral"
                }
            },
            "name": "sage.categories.magmas.Magmas.Unital.parent_class"
        },
        "sage.categories.magmas.Magmas.Unital.subcategory_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "Inverse": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            },
            "name": "sage.categories.magmas.Magmas.Unital.subcategory_class"
        },
        "sage.categories.magmas.Magmas.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "_mul_": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method _mul_ at 0x7fab251e79b0>",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "\\*",
                    "mmt_name": "*"
                },
                "_mul_parent": {
                    "__doc__": "_mul_parent(self, other)\nFile: sage/categories/coercion_methods.pyx (starting at line 15)\n\n    Return the product of the two elements, calculated using\n    the ``product`` method of the parent.\n\n    This is inserted by :meth:`Magmas.ParentMethods.__init_extra__` as\n    default implementation of ``Magmas.ElementMethods._mul_`` if\n    ``product`` is implemented in the parent.\n\n    INPUT:\n\n    - ``other`` -- an element of the parent of ``self``\n\n    OUTPUT:\n\n    - an element of the parent of ``self``\n\n    EXAMPLES::\n\n        sage: S = Semigroups().example(\"free\")\n        sage: x = S('a'); y = S('b')\n        sage: x._mul_parent(y)\n        'ab'\n\n    .. SEEALSO::\n\n        - :meth:`Magmas.ElementMethods._mul_parent`\n        - :meth:`Magmas.ElementMethods.__init_extra__`\n        - :meth:`Magmas.ParentMethods.product`\n\n    This is :meth:`Magmas.ElementMethods._mul_parent`, implemented as\n    a Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x._mul_parent.im_func is Magmas.ElementMethods._mul_parent.im_func\n        True\n        sage: x._mul_parent.im_func is sage.categories.coercion_methods._mul_parent\n        True\n    ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_idempotent": {
                    "__doc__": "\n            Test whether ``self`` is idempotent.\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\"); S\n                An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n                sage: a = S('a')\n                sage: a^2\n                'aa'\n                sage: a.is_idempotent()\n                False\n\n            ::\n\n                sage: L = Semigroups().example(\"leftzero\"); L\n                An example of a semigroup: the left zero semigroup\n                sage: x = L('x')\n                sage: x^2\n                'x'\n                sage: x.is_idempotent()\n                True\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.magmas.Magmas.element_class"
        },
        "sage.categories.magmas.Magmas.morphism_class": {
            "__doc__": "\n    The category of (multiplicative) magmas.\n\n    A magma is a set with a binary operation `*`.\n\n    EXAMPLES::\n\n        sage: Magmas()\n        Category of magmas\n        sage: Magmas().super_categories()\n        [Category of sets]\n        sage: Magmas().all_super_categories()\n        [Category of magmas, Category of sets,\n         Category of sets with partial maps, Category of objects]\n\n    The following axioms are defined by this category::\n\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Unital()\n        Category of unital magmas\n        sage: Magmas().Commutative()\n        Category of commutative magmas\n        sage: Magmas().Unital().Inverse()\n        Category of inverse unital magmas\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Associative().Unital()\n        Category of monoids\n        sage: Magmas().Associative().Unital().Inverse()\n        Category of groups\n\n    TESTS::\n\n        sage: C = Magmas()\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.magmas.Magmas.morphism_class"
        },
        "sage.categories.magmas.Magmas.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "__init_extra__": {
                    "__doc__": "\n                sage: S = Semigroups().example(\"free\")\n                sage: S('a') * S('b') # indirect doctest\n                'ab'\n                sage: S('a').__class__._mul_ == S('a').__class__._mul_parent\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "multiplication_table": {
                    "__doc__": "\n            Returns a table describing the multiplication operation.\n\n            .. note:: The order of the elements in the row and column\n              headings is equal to the order given by the table's\n              :meth:`~sage.matrix.operation_table.OperationTable.list`\n              method.  The association can also be retrieved with the\n              :meth:`~sage.matrix.operation_table.OperationTable.dict`\n              method.\n\n            INPUT:\n\n            - ``names`` - the type of names used\n\n              * ``'letters'`` - lowercase ASCII letters are used\n                for a base 26 representation of the elements'\n                positions in the list given by\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`,\n                padded to a common width with leading 'a's.\n              * ``'digits'`` - base 10 representation of the\n                elements' positions in the list given by\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`,\n                padded to a common width with leading zeros.\n              * ``'elements'`` - the string representations\n                of the elements themselves.\n              * a list - a list of strings, where the length\n                of the list equals the number of elements.\n            - ``elements`` - default = ``None``.  A list of\n              elements of the magma, in forms that can be\n              coerced into the structure, eg. their string\n              representations. This may be used to impose an\n              alternate ordering on the elements, perhaps when\n              this is used in the context of a particular structure.\n              The default is to use whatever ordering the ``S.list``\n              method returns. Or the ``elements`` can be a subset\n              which is closed under the operation. In particular,\n              this can be used when the base set is infinite.\n\n            OUTPUT:\n            The multiplication table as an object of the class\n            :class:`~sage.matrix.operation_table.OperationTable`\n            which defines several methods for manipulating and\n            displaying the table.  See the documentation there\n            for full details to supplement the documentation\n            here.\n\n            EXAMPLES:\n\n            The default is to represent elements as lowercase\n            ASCII letters.  ::\n\n                sage: G=CyclicPermutationGroup(5)\n                sage: G.multiplication_table()\n                *  a b c d e\n                 +----------\n                a| a b c d e\n                b| b c d e a\n                c| c d e a b\n                d| d e a b c\n                e| e a b c d\n\n            All that is required is that an algebraic structure\n            has a multiplication defined.  A\n            :class:`~sage.categories.examples.finite_semigroups.LeftRegularBand`\n            is an example of a finite semigroup.  The ``names`` argument allows\n            displaying the elements in different ways.  ::\n\n                sage: from sage.categories.examples.finite_semigroups import LeftRegularBand\n                sage: L=LeftRegularBand(('a','b'))\n                sage: T=L.multiplication_table(names='digits')\n                sage: T.column_keys()\n                ('a', 'b', 'ab', 'ba')\n                sage: T\n                *  0 1 2 3\n                 +--------\n                0| 0 2 2 2\n                1| 3 1 3 3\n                2| 2 2 2 2\n                3| 3 3 3 3\n\n            Specifying the elements in an alternative order can provide\n            more insight into how the operation behaves.  ::\n\n                sage: L=LeftRegularBand(('a','b','c'))\n                sage: elts = sorted(L.list())\n                sage: L.multiplication_table(elements=elts)\n                *  a b c d e f g h i j k l m n o\n                 +------------------------------\n                a| a b c d e b b c c c d d e e e\n                b| b b c c c b b c c c c c c c c\n                c| c c c c c c c c c c c c c c c\n                d| d e e d e e e e e e d d e e e\n                e| e e e e e e e e e e e e e e e\n                f| g g h h h f g h i j i j j i j\n                g| g g h h h g g h h h h h h h h\n                h| h h h h h h h h h h h h h h h\n                i| j j j j j i j j i j i j j i j\n                j| j j j j j j j j j j j j j j j\n                k| l m m l m n o o n o k l m n o\n                l| l m m l m m m m m m l l m m m\n                m| m m m m m m m m m m m m m m m\n                n| o o o o o n o o n o n o o n o\n                o| o o o o o o o o o o o o o o o\n\n            The ``elements`` argument can be used to provide\n            a subset of the elements of the structure.  The subset\n            must be closed under the operation.  Elements need only\n            be in a form that can be coerced into the set.  The\n            ``names`` argument can also be used to request that\n            the elements be represented with their usual string\n            representation.  ::\n\n                sage: L=LeftRegularBand(('a','b','c'))\n                sage: elts=['a', 'c', 'ac', 'ca']\n                sage: L.multiplication_table(names='elements', elements=elts)\n                   *   'a'  'c' 'ac' 'ca'\n                    +--------------------\n                 'a'|  'a' 'ac' 'ac' 'ac'\n                 'c'| 'ca'  'c' 'ca' 'ca'\n                'ac'| 'ac' 'ac' 'ac' 'ac'\n                'ca'| 'ca' 'ca' 'ca' 'ca'\n\n            The table returned can be manipulated in various ways.  See\n            the documentation for\n            :class:`~sage.matrix.operation_table.OperationTable` for more\n            comprehensive documentation. ::\n\n                sage: G=AlternatingGroup(3)\n                sage: T=G.multiplication_table()\n                sage: T.column_keys()\n                ((), (1,2,3), (1,3,2))\n                sage: sorted(T.translation().items())\n                [('a', ()), ('b', (1,2,3)), ('c', (1,3,2))]\n                sage: T.change_names(['x', 'y', 'z'])\n                sage: sorted(T.translation().items())\n                [('x', ()), ('y', (1,2,3)), ('z', (1,3,2))]\n                sage: T\n                *  x y z\n                 +------\n                x| x y z\n                y| y z x\n                z| z x y\n            ",
                    "args": [
                        "self",
                        "names",
                        "elements"
                    ],
                    "argspec": [
                        [
                            "self",
                            "names",
                            "elements"
                        ],
                        null,
                        null,
                        [
                            "letters",
                            null
                        ]
                    ]
                },
                "product": {
                    "__doc__": "\n            The binary multiplication of the magma.\n\n            INPUT:\n\n            - ``x``, ``y`` -- elements of this magma\n\n            OUTPUT:\n\n            - an element of the magma (the product of ``x`` and ``y``)\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\")\n                sage: x = S('a'); y = S('b')\n                sage: S.product(x, y)\n                'ab'\n\n            A parent in ``Magmas()`` must either implement\n            :meth:`.product` in the parent class or ``_mul_`` in the\n            element class. By default, the addition method on elements\n            ``x._mul_(y)`` calls ``S.product(x,y)``, and reciprocally.\n\n            As a bonus, ``S.product`` models the binary function from\n            ``S`` to ``S``::\n\n                sage: bin = S.product\n                sage: bin(x,y)\n                'ab'\n\n            Currently, ``S.product`` is just a bound method::\n\n                sage: bin\n                <bound method FreeSemigroup_with_category.product of An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')>\n\n            When Sage will support multivariate morphisms, it will be\n            possible, and in fact recommended, to enrich ``S.product``\n            with extra mathematical structure. This will typically be\n            implemented using lazy attributes.::\n\n                sage: bin                 # todo: not implemented\n                Generic binary morphism:\n                From: (S x S)\n                To:   S\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "product_from_element_class_mul": {
                    "__doc__": "\n            The binary multiplication of the magma.\n\n            INPUT:\n\n            - ``x``, ``y`` -- elements of this magma\n\n            OUTPUT:\n\n            - an element of the magma (the product of ``x`` and ``y``)\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\")\n                sage: x = S('a'); y = S('b')\n                sage: S.product(x, y)\n                'ab'\n\n            A parent in ``Magmas()`` must either implement\n            :meth:`.product` in the parent class or ``_mul_`` in the\n            element class. By default, the addition method on elements\n            ``x._mul_(y)`` calls ``S.product(x,y)``, and reciprocally.\n\n            As a bonus, ``S.product`` models the binary function from\n            ``S`` to ``S``::\n\n                sage: bin = S.product\n                sage: bin(x,y)\n                'ab'\n\n            Currently, ``S.product`` is just a bound method::\n\n                sage: bin\n                <bound method FreeSemigroup_with_category.product of An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')>\n\n            When Sage will support multivariate morphisms, it will be\n            possible, and in fact recommended, to enrich ``S.product``\n            with extra mathematical structure. This will typically be\n            implemented using lazy attributes.::\n\n                sage: bin                 # todo: not implemented\n                Generic binary morphism:\n                From: (S x S)\n                To:   S\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.magmas.Magmas.parent_class"
        },
        "sage.categories.magmas.Magmas.subcategory_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "Associative": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Commutative": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Distributive": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "FinitelyGenerated": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "FinitelyGeneratedAsMagma": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "JTrivial": {
                    "__doc__": "\n            Return the full subcategory of the `J`-trivial objects of ``self``.\n\n            This axiom is in fact only meaningful for\n            :class:`semigroups <Semigroups>`. This stub definition is\n            here as a workaround for :trac:`20515`, in order to define\n            the `J`-trivial axiom as the intersection of the `L` and\n            `R`-trivial axioms.\n\n            .. SEEALSO:: :meth:`Semigroups.SubcategoryMethods.JTrivial`\n\n            TESTS::\n\n                sage: Magmas().JTrivial()\n                Category of j trivial magmas\n                sage: (Semigroups().RTrivial() & Semigroups().LTrivial()) is Semigroups().JTrivial()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "Unital": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            },
            "name": "sage.categories.magmas.Magmas.subcategory_class"
        },
        "sage.categories.monoids.Monoids.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "_pow_naive": {
                    "__doc__": "\n            Return ``self`` to the `n^{th}` power (naive implementation).\n\n            INPUT:\n\n            - ``n`` -- a nonnegative integer\n\n            This naive implementation does not use binary\n            exponentiation; there are cases where this is actually\n            faster due to size explosion.\n\n            EXAMPLES::\n\n                sage: S = Monoids().example()\n                sage: x = S(\"aa\")\n                sage: [x._pow_naive(i) for i in range(6)]\n                ['', 'aa', 'aaaa', 'aaaaaa', 'aaaaaaaa', 'aaaaaaaaaa']\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_one": {
                    "__doc__": "\n            Return whether ``self`` is the one of the monoid.\n\n            The default implementation is to compare with ``self.one()``.\n\n            TESTS::\n\n                sage: S = Monoids().example()\n                sage: S.one().is_one()\n                True\n                sage: S(\"aa\").is_one()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "powers": {
                    "__doc__": "\n            Return the list `[x^0, x^1, \\ldots, x^{n-1}]`.\n\n            EXAMPLES::\n\n                sage: A = Matrix([[1, 1], [-1, 0]])\n                sage: A.powers(6)\n                [\n                [1 0]  [ 1  1]  [ 0  1]  [-1  0]  [-1 -1]  [ 0 -1]\n                [0 1], [-1  0], [-1 -1], [ 0 -1], [ 1  0], [ 1  1]\n                ]\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.monoids.Monoids.element_class"
        },
        "sage.categories.monoids.Monoids.morphism_class": {
            "__doc__": "\n    The category of (multiplicative) monoids.\n\n    A *monoid* is a unital :class:`semigroup <Semigroups>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative and admits a unit (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: Monoids()\n        Category of monoids\n        sage: Monoids().super_categories()\n        [Category of semigroups, Category of unital magmas]\n        sage: Monoids().all_super_categories()\n        [Category of monoids,\n         Category of semigroups,\n         Category of unital magmas, Category of magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: Monoids().axioms()\n        frozenset({'Associative', 'Unital'})\n        sage: Semigroups().Unital()\n        Category of monoids\n\n        sage: Monoids().example()\n        An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: C = Monoids()\n        sage: TestSuite(C).run()\n\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.monoids.Monoids.morphism_class"
        },
        "sage.categories.monoids.Monoids.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "_test_prod": {
                    "__doc__": "\n            Run basic tests for the product method :meth:`prod` of ``self``.\n\n            See the documentation for :class:`TestSuite` for information on\n            further options.\n\n            INPUT:\n\n            - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n            EXAMPLES:\n\n            By default, this method tests only the elements returned by\n            ``self.some_elements()``::\n\n                sage: S = Monoids().example()\n                sage: S._test_prod()\n\n            However, the elements tested can be customized with the\n            ``elements`` keyword argument::\n\n                sage: S._test_prod(elements = (S('a'), S('b')))\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "monoid_generators": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method monoid_generators at 0x7faa353cf668>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "list_of_self",
                    "gap_name": "GeneratorsOfMonoid",
                    "mmt_name": null
                },
                "one_element": {
                    "__doc__": "\n            Backward compatibility alias for :meth:`one`.\n\n            TESTS::\n\n                sage: S = Monoids().example()\n                sage: S.one_element()\n                doctest:...: DeprecationWarning: .one_element() is deprecated. Please use .one() instead.\n                See http://trac.sagemath.org/17694 for details.\n                ''\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "submonoid": {
                    "__doc__": "\n            Return the multiplicative submonoid generated by ``generators``.\n\n            INPUT:\n\n            - ``generators`` -- a finite family of elements of\n              ``self``, or a list, iterable, ... that can be converted\n              into one (see :class:`Family`).\n\n            - ``category`` -- a category\n\n            This is a shorthand for\n            :meth:`Semigroups.ParentMethods.subsemigroup` that\n            specifies that this is a submonoid, and in particular that\n            the unit is ``self.one()``.\n\n            EXAMPLES::\n\n                sage: R = IntegerModRing(15)\n                sage: M = R.submonoid([R(3),R(5)]); M\n                A submonoid of (Ring of integers modulo 15) with 2 generators\n                sage: M.list()\n                [1, 3, 5, 9, 0, 10, 12, 6]\n\n            Not the presence of the unit, unlike in::\n\n                sage: S = R.subsemigroup([R(3),R(5)]); S\n                A subsemigroup of (Ring of integers modulo 15) with 2 generators\n                sage: S.list()\n                [3, 5, 9, 0, 10, 12, 6]\n\n            This method is really a shorthand for subsemigroup::\n\n                sage: M2 = R.subsemigroup([R(3),R(5)], one=R.one())\n                sage: M2 is M\n                True\n\n\n            ",
                    "args": [
                        "self",
                        "generators",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "generators",
                            "category"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            },
            "name": "sage.categories.monoids.Monoids.parent_class"
        },
        "sage.categories.monoids.Monoids.subcategory_class": {
            "__doc__": "\n    The category of (multiplicative) monoids.\n\n    A *monoid* is a unital :class:`semigroup <Semigroups>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative and admits a unit (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: Monoids()\n        Category of monoids\n        sage: Monoids().super_categories()\n        [Category of semigroups, Category of unital magmas]\n        sage: Monoids().all_super_categories()\n        [Category of monoids,\n         Category of semigroups,\n         Category of unital magmas, Category of magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: Monoids().axioms()\n        frozenset({'Associative', 'Unital'})\n        sage: Semigroups().Unital()\n        Category of monoids\n\n        sage: Monoids().example()\n        An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: C = Monoids()\n        sage: TestSuite(C).run()\n\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.monoids.Monoids.subcategory_class"
        },
        "sage.categories.objects.Objects.element_class": {
            "__doc__": "\n    The category of all objects\n    the basic category\n\n    EXAMPLES::\n\n        sage: Objects()\n        Category of objects\n        sage: Objects().super_categories()\n        []\n\n    TESTS::\n\n        sage: TestSuite(Objects()).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.objects.Objects.element_class"
        },
        "sage.categories.objects.Objects.morphism_class": {
            "__doc__": "\n    The category of all objects\n    the basic category\n\n    EXAMPLES::\n\n        sage: Objects()\n        Category of objects\n        sage: Objects().super_categories()\n        []\n\n    TESTS::\n\n        sage: TestSuite(Objects()).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.objects.Objects.morphism_class"
        },
        "sage.categories.objects.Objects.parent_class": {
            "__doc__": "\n        Methods for all category objects\n        ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.objects.Objects.parent_class"
        },
        "sage.categories.objects.Objects.subcategory_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "Endsets": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "GAP": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Homsets": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "hom_category": {
                    "__doc__": "Deprecated: Use :meth:`Homsets` instead.\nSee :trac:`10668` for details.\n\n",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            },
            "name": "sage.categories.objects.Objects.subcategory_class"
        },
        "sage.categories.permutation_groups.PermutationGroups.element_class": {
            "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.permutation_groups.PermutationGroups.element_class"
        },
        "sage.categories.permutation_groups.PermutationGroups.morphism_class": {
            "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.permutation_groups.PermutationGroups.morphism_class"
        },
        "sage.categories.permutation_groups.PermutationGroups.parent_class": {
            "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.permutation_groups.PermutationGroups.parent_class"
        },
        "sage.categories.permutation_groups.PermutationGroups.subcategory_class": {
            "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.permutation_groups.PermutationGroups.subcategory_class"
        },
        "sage.categories.semigroups.Semigroups.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "__pow__": {
                    "__doc__": "\n            Return ``self`` to the `n^{th}` power.\n\n            INPUT:\n\n            - ``n`` -- a positive integer\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"leftzero\")\n                sage: x = S(\"x\")\n                sage: x^1, x^2, x^3, x^4, x^5\n                ('x', 'x', 'x', 'x', 'x')\n                sage: x^0\n                Traceback (most recent call last):\n                ...\n                AssertionError\n\n            TESTS::\n\n                sage: x._pow_(17)\n                'x'\n\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_pow_": {
                    "__doc__": "\n            Return ``self`` to the `n^{th}` power.\n\n            INPUT:\n\n            - ``n`` -- a positive integer\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"leftzero\")\n                sage: x = S(\"x\")\n                sage: x^1, x^2, x^3, x^4, x^5\n                ('x', 'x', 'x', 'x', 'x')\n                sage: x^0\n                Traceback (most recent call last):\n                ...\n                AssertionError\n\n            TESTS::\n\n                sage: x._pow_(17)\n                'x'\n\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.semigroups.Semigroups.element_class"
        },
        "sage.categories.semigroups.Semigroups.morphism_class": {
            "__doc__": "\n    The category of (multiplicative) semigroups.\n\n    A *semigroup* is an associative :class:`magma <Magmas>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative (see :wikipedia:`Semigroup`).\n\n    The operation `*` is not required to have a neutral element. A\n    semigroup for which such an element exists is a :class:`monoid\n    <sage.categories.monoids.Monoids>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups(); C\n        Category of semigroups\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: C.all_super_categories()\n        [Category of semigroups, Category of magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n        sage: C.axioms()\n        frozenset({'Associative'})\n        sage: C.example()\n        An example of a semigroup: the left zero semigroup\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.semigroups.Semigroups.morphism_class"
        },
        "sage.categories.semigroups.Semigroups.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "__truediv__": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method __truediv__ at 0x7faa353c2d70>",
                    "args": [
                        "self",
                        "relations"
                    ],
                    "argspec": [
                        [
                            "self",
                            "relations"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": null,
                    "gap_name": "\\/",
                    "mmt_name": null
                },
                "_test_associativity": {
                    "__doc__": "\n            Test associativity for (not necessarily all) elements of this\n            semigroup.\n\n            INPUT:\n\n            - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n            EXAMPLES:\n\n            By default, this method tests only the elements returned by\n            ``self.some_elements()``::\n\n                sage: L = Semigroups().example(choice='leftzero')\n                sage: L._test_associativity()\n\n            However, the elements tested can be customized with the\n            ``elements`` keyword argument::\n\n                sage: L._test_associativity(elements = (L(1), L(2), L(3)))\n\n            See the documentation for :class:`TestSuite` for more information.\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "cayley_graph": {
                    "__doc__": "\n            Return the Cayley graph for this finite semigroup.\n\n            INPUT:\n\n            - ``side`` -- \"left\", \"right\", or \"twosided\":\n              the side on which the generators act (default:\"right\")\n            - ``simple`` -- boolean (default:False):\n              if True, returns a simple graph (no loops, no labels,\n              no multiple edges)\n            - ``generators`` -- a list, tuple, or family of elements\n              of ``self`` (default: ``self.semigroup_generators()``)\n            - ``connecting_set`` -- alias for ``generators``; deprecated\n            - ``elements`` -- a list (or iterable) of elements of ``self``\n\n            OUTPUT:\n\n            - :class:`DiGraph`\n\n            EXAMPLES:\n\n            We start with the (right) Cayley graphs of some classical groups::\n\n                sage: D4 = DihedralGroup(4); D4\n                Dihedral group of order 8 as a permutation group\n                sage: G = D4.cayley_graph()\n                sage: show(G, color_by_label=True, edge_labels=True)\n                sage: A5 = AlternatingGroup(5); A5\n                Alternating group of order 5!/2 as a permutation group\n                sage: G = A5.cayley_graph()\n                sage: G.show3d(color_by_label=True, edge_size=0.01, edge_size2=0.02, vertex_size=0.03)\n                sage: G.show3d(vertex_size=0.03, edge_size=0.01, edge_size2=0.02, vertex_colors={(1,1,1):G.vertices()}, bgcolor=(0,0,0), color_by_label=True, xres=700, yres=700, iterations=200) # long time (less than a minute)\n                sage: G.num_edges()\n                120\n\n                sage: w = WeylGroup(['A',3])\n                sage: d = w.cayley_graph(); d\n                Digraph on 24 vertices\n                sage: d.show3d(color_by_label=True, edge_size=0.01, vertex_size=0.03)\n\n            Alternative generators may be specified::\n\n                sage: G = A5.cayley_graph(generators=[A5.gens()[0]])\n                sage: G.num_edges()\n                60\n                sage: g=PermutationGroup([(i+1,j+1) for i in range(5) for j in range(5) if j!=i])\n                sage: g.cayley_graph(generators=[(1,2),(2,3)])\n                Digraph on 120 vertices\n\n            If ``elements`` is specified, then only the subgraph\n            induced and those elements is returned. Here we use it to\n            display the Cayley graph of the free monoid truncated on\n            the elements of length at most 3::\n\n                sage: M = Monoids().example(); M\n                An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n                sage: elements = [ M.prod(w) for w in sum((list(Words(M.semigroup_generators(),k)) for k in range(4)),[]) ]\n                sage: G = M.cayley_graph(elements = elements)\n                sage: G.num_verts(), G.num_edges()\n                (85, 84)\n                sage: G.show3d(color_by_label=True, edge_size=0.001, vertex_size=0.01)\n\n            We now illustrate the ``side`` and ``simple`` options on\n            a semigroup::\n\n                sage: S = FiniteSemigroups().example(alphabet=('a','b'))\n                sage: g = S.cayley_graph(simple=True)\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'ab', None), ('b', 'ba', None)]\n\n            ::\n\n                sage: g = S.cayley_graph(side=\"left\", simple=True)\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'ba', None), ('ab', 'ba', None), ('b', 'ab', None),\n                ('ba', 'ab', None)]\n\n            ::\n\n                sage: g = S.cayley_graph(side=\"twosided\", simple=True)\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'ab', None), ('a', 'ba', None), ('ab', 'ba', None),\n                ('b', 'ab', None), ('b', 'ba', None), ('ba', 'ab', None)]\n\n            ::\n\n                sage: g = S.cayley_graph(side=\"twosided\")\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'a', (0, 'left')), ('a', 'a', (0, 'right')), ('a', 'ab', (1, 'right')), ('a', 'ba', (1, 'left')), ('ab', 'ab', (0, 'left')), ('ab', 'ab', (0, 'right')), ('ab', 'ab', (1, 'right')), ('ab', 'ba', (1, 'left')), ('b', 'ab', (0, 'left')), ('b', 'b', (1, 'left')), ('b', 'b', (1, 'right')), ('b', 'ba', (0, 'right')), ('ba', 'ab', (0, 'left')), ('ba', 'ba', (0, 'right')), ('ba', 'ba', (1, 'left')), ('ba', 'ba', (1, 'right'))]\n\n            ::\n\n                sage: s1 = SymmetricGroup(1); s = s1.cayley_graph(); s.vertices()\n                [()]\n\n            TESTS::\n\n                sage: SymmetricGroup(2).cayley_graph(side=\"both\")\n                Traceback (most recent call last):\n                ...\n                ValueError: option 'side' must be 'left', 'right' or 'twosided'\n\n            .. TODO::\n\n                - Add more options for constructing subgraphs of the\n                  Cayley graph, handling the standard use cases when\n                  exploring large/infinite semigroups (a predicate,\n                  generators of an ideal, a maximal length in term of the\n                  generators)\n\n                - Specify good default layout/plot/latex options in the graph\n\n                - Generalize to combinatorial modules with module generators / operators\n\n            AUTHORS:\n\n            - Bobby Moretti (2007-08-10)\n            - Robert Miller (2008-05-01): editing\n            - Nicolas M. Thiery (2008-12): extension to semigroups,\n              ``side``, ``simple``, and ``elements`` options, ...\n            ",
                    "args": [
                        "self",
                        "side",
                        "simple",
                        "elements",
                        "generators",
                        "connecting_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "simple",
                            "elements",
                            "generators",
                            "connecting_set"
                        ],
                        null,
                        null,
                        [
                            "right",
                            false,
                            null,
                            null,
                            null
                        ]
                    ]
                },
                "is_d_trivial": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method is_d_trivial at 0x7faa353c2ed8>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": null,
                    "gap_name": "IsDTrivial",
                    "mmt_name": null
                },
                "is_l_trivial": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method is_l_trivial at 0x7faa353c2de8>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": null,
                    "gap_name": "IsLTrivial",
                    "mmt_name": null
                },
                "is_r_trivial": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method is_r_trivial at 0x7faa353c2e60>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": null,
                    "gap_name": "IsRTrivial",
                    "mmt_name": null
                },
                "magma_generators": {
                    "__doc__": "\n            An alias for :meth:`semigroup_generators`.\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\"); S\n                An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n                sage: S.magma_generators()\n                Family ('a', 'b', 'c', 'd')\n                sage: S.semigroup_generators()\n                Family ('a', 'b', 'c', 'd')\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "prod": {
                    "__doc__": "\n            Return the product of the list of elements ``args``\n            inside ``self``.\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\")\n                sage: S.prod([S('a'), S('b'), S('c')])\n                'abc'\n                sage: S.prod([])\n                Traceback (most recent call last):\n                ...\n                AssertionError: Cannot compute an empty product in a semigroup\n            ",
                    "args": [
                        "self",
                        "args"
                    ],
                    "argspec": [
                        [
                            "self",
                            "args"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "regular_representation": {
                    "__doc__": "\n            Return the regular representation of ``self`` over ``base_ring``.\n\n            - ``side`` -- (default: ``\"left\"``) whether this is the\n              ``\"left\"`` or ``\"right\"`` regular representation\n\n            EXAMPLES::\n\n                sage: G = groups.permutation.Dihedral(4)\n                sage: G.regular_representation()\n                Left Regular Representation of Dihedral group of order 8\n                 as a permutation group over Integer Ring\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "left"
                        ]
                    ]
                },
                "semigroup_generators": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method semigroup_generators at 0x7faa353c2c80>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "list_of_self",
                    "gap_name": "GeneratorsOfSemigroup",
                    "mmt_name": null
                },
                "subsemigroup": {
                    "__doc__": "\n            Return the multiplicative subsemigroup generated by ``generators``.\n\n            INPUT:\n\n            - ``generators`` -- a finite family of elements of\n              ``self``, or a list, iterable, ... that can be converted\n              into one (see :class:`Family`).\n\n            - ``one`` -- a unit for the subsemigroup, or ``None``.\n\n            - ``category`` -- a category\n\n            This implementation lazily constructs all the elements of\n            the semigroup, and the right Cayley graph relations\n            between them, and uses the latter as an automaton.\n\n            See :class:`~sage.sets.monoids.AutomaticSemigroup` for details.\n\n            EXAMPLES::\n\n                sage: R = IntegerModRing(15)\n                sage: M = R.subsemigroup([R(3),R(5)]); M\n                A subsemigroup of (Ring of integers modulo 15) with 2 generators\n                sage: M.list()\n                [3, 5, 9, 0, 10, 12, 6]\n\n            By default, `M` is just in the category of subsemigroups::\n\n                sage: M in Semigroups().Subobjects()\n                True\n\n            In the following example, we specify that `M` is a\n            submonoid of the finite monoid `R` (it shares the same\n            unit), and a group by itself::\n\n                sage: M = R.subsemigroup([R(-1)],\n                ....:     category=Monoids().Finite().Subobjects() & Groups()); M\n                A submonoid of (Ring of integers modulo 15) with 1 generators\n                sage: M.list()\n                [1, 14]\n                sage: M.one()\n                1\n\n            In the following example `M` is a group; however its unit\n            does not coincide with that of `R`, so `M` is only a\n            subsemigroup, and we need to specify its unit explictly::\n\n                sage: M = R.subsemigroup([R(5)],\n                ....:     category=Semigroups().Finite().Subobjects() & Groups()); M\n                Traceback (most recent call last):\n                ...\n                ValueError: For a monoid which is just a subsemigroup, the unit should be specified\n\n                sage: M = R.subsemigroup([R(5)], one=R(10),\n                ....:     category=Semigroups().Finite().Subobjects() & Groups()); M\n                A subsemigroup of (Ring of integers modulo 15) with 1 generators\n                sage: M in Groups()\n                True\n                sage: M.list()\n                [10, 5]\n                sage: M.one()\n                10\n\n            TESTS::\n\n                sage: TestSuite(M).run()\n                Failure in _test_inverse:\n                Traceback (most recent call last):\n                ...\n                The following tests failed: _test_inverse\n\n            .. TODO::\n\n                - Fix the failure in TESTS by providing a default\n                  implementation of ``__invert__`` for finite groups\n                  (or even finite monoids).\n                - Provide a default implementation of ``one`` for a\n                  finite monoid, so that we would not need to specify\n                  it explicitly?\n            ",
                    "args": [
                        "self",
                        "generators",
                        "one",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "generators",
                            "one",
                            "category"
                        ],
                        null,
                        null,
                        [
                            null,
                            null
                        ]
                    ]
                },
                "trivial_representation": {
                    "__doc__": "\n            Return the trivial representation of ``self`` over ``base_ring``.\n\n            INPUT:\n\n            - ``base_ring`` -- (optional) the base ring; the default is `\\ZZ`\n            - ``side`` -- ignored\n\n            EXAMPLES::\n\n                sage: G = groups.permutation.Dihedral(4)\n                sage: G.trivial_representation()\n                Trivial representation of Dihedral group of order 8\n                 as a permutation group over Integer Ring\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "twosided"
                        ]
                    ]
                }
            },
            "name": "sage.categories.semigroups.Semigroups.parent_class"
        },
        "sage.categories.semigroups.Semigroups.subcategory_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "Aperiodic": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "HTrivial": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "LTrivial": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "RTrivial": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            },
            "name": "sage.categories.semigroups.Semigroups.subcategory_class"
        },
        "sage.categories.sets_cat.Sets.Infinite.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.sets_cat.Sets.Infinite.element_class"
        },
        "sage.categories.sets_cat.Sets.Infinite.morphism_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.sets_cat.Sets.Infinite.morphism_class"
        },
        "sage.categories.sets_cat.Sets.Infinite.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "is_empty": {
                    "__doc__": "\n                Return whether this set is empty.\n\n                Since this set is infinite this always returns ``False``.\n\n                EXAMPLES::\n\n                    sage: C = InfiniteEnumeratedSets().example()\n                    sage: C.is_empty()\n                    False\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.sets_cat.Sets.Infinite.parent_class"
        },
        "sage.categories.sets_cat.Sets.Infinite.subcategory_class": {
            "__doc__": null,
            "implied": [],
            "methods": {},
            "name": "sage.categories.sets_cat.Sets.Infinite.subcategory_class"
        },
        "sage.categories.sets_cat.Sets.element_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "cartesian_product": {
                    "__doc__": "\n            Return the Cartesian product of its arguments, as an element of\n            the Cartesian product of the parents of those elements.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example()\n                sage: (a,b,c) = A.algebra_generators()\n                sage: a.cartesian_product(b, c)\n                B[(0, word: a)] + B[(1, word: b)] + B[(2, word: c)]\n\n            FIXME: is this a policy that we want to enforce on all parents?\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "elements",
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.sets_cat.Sets.element_class"
        },
        "sage.categories.sets_cat.Sets.morphism_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "__invert__": {
                    "__doc__": "\n            Return the inverse morphism, or raise an error.\n\n            The error may either state that the morphism is not\n            invertible, or that Sage cannot invert it.\n\n            EXAMPLES::\n\n                sage: i = End(QQ).identity(); i\n                Identity endomorphism of Rational Field\n                sage: i.__invert__()\n                Identity endomorphism of Rational Field\n\n            This method is meant to be used with the Python inversion\n            operator `~`::\n\n                sage: ~i\n                Identity endomorphism of Rational Field\n\n            We now try to inverse a couple of morphisms defined by a matrix::\n\n                sage: H = End(QQ^2)\n                sage: phi = H(matrix([[1,1],[0,1]])); phi\n                Vector space morphism represented by the matrix:\n                [1 1]\n                [0 1]\n                Domain: Vector space of dimension 2 over Rational Field\n                Codomain: Vector space of dimension 2 over Rational Field\n                sage: ~phi\n                Vector space morphism represented by the matrix:\n                [ 1 -1]\n                [ 0  1]\n                Domain: Vector space of dimension 2 over Rational Field\n                Codomain: Vector space of dimension 2 over Rational Field\n\n                sage: phi = H(matrix([[1,1],[1,1]]))\n                sage: ~phi\n                Traceback (most recent call last):\n                ...\n                ZeroDivisionError: matrix morphism not invertible\n\n            .. NOTE::\n\n                This is an optional method. A default implementation\n                raising ``NotImplementedError`` could be provided instead.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.sets_cat.Sets.morphism_class"
        },
        "sage.categories.sets_cat.Sets.parent_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "CartesianProduct": {
                    "__doc__": "LazyImport(module, name, as_name=None, namespace=None, at_startup=False, deprecation=None)\nFile: sage/misc/lazy_import.pyx (starting at line 135)\n\n    EXAMPLES::\n\n        sage: from sage.misc.lazy_import import LazyImport\n        sage: my_integer = LazyImport('sage.rings.all', 'Integer')\n        sage: my_integer(4)\n        4\n        sage: my_integer('101', base=2)\n        5\n        sage: my_integer(3/2)\n        Traceback (most recent call last):\n        ...\n        TypeError: no conversion of this rational to integer\n    ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        "args",
                        "kwds",
                        [
                            0
                        ]
                    ]
                },
                "__contains__": {
                    "__doc__": "\n            Test whether the set ``self`` contains the object ``x``.\n\n            All parents in the category ``Sets()`` should implement this method.\n\n            EXAMPLES::\n\n                sage: P = Sets().example(); P\n                Set of prime numbers (basic implementation)\n                sage: 12 in P\n                False\n                sage: P(5) in P\n                True\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_an_element_": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method _an_element_ at 0x7faa353be320>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "self",
                    "gap_name": "Representative",
                    "mmt_name": null
                },
                "_element_constructor_from_element_class": {
                    "__doc__": "\n            The default constructor for elements of this parent ``self``.\n\n            Among other things, it is called upon ``self(data)`` when\n            the coercion model did not find a way to coerce ``data`` into\n            this parent.\n\n            This default implementation for\n            :meth:`_element_constructor_` calls the constructor of the\n            element class, passing ``self`` as first argument.\n\n            EXAMPLES::\n\n                sage: S = Sets().example(\"inherits\")\n                sage: s = S._element_constructor_from_element_class(17); s\n                17\n                sage: type(s)\n                <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits_with_category.element_class'>\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "keywords",
                        null
                    ]
                },
                "_test_an_element": {
                    "__doc__": "\n            Run generic tests on the method :meth:`.an_element`.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_an_element()\n\n            Let us now write a broken :meth:`.an_element` method::\n\n                sage: from sage.categories.examples.sets_cat import PrimeNumbers\n                sage: class CCls(PrimeNumbers):\n                ....:     def an_element(self):\n                ....:         return 18\n                sage: CC = CCls()\n                sage: CC._test_an_element()\n                Traceback (most recent call last):\n                ...\n                AssertionError: self.an_element() is not in self\n\n            TESTS::\n\n                sage: FiniteEnumeratedSet([])._test_an_element()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_cardinality": {
                    "__doc__": "\n            Run generic test on the method :meth:`.cardinality`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_cardinality()\n\n            Let us now write a broken :meth:`cardinality` method::\n\n                sage: from sage.categories.examples.sets_cat import *\n                sage: class CCls(PrimeNumbers):\n                ....:     def cardinality(self):\n                ....:         return int(5)\n                sage: CC = CCls()\n                sage: CC._test_cardinality()\n                Traceback (most recent call last):\n                ...\n                AssertionError: the output of the method cardinality must either\n                be a Sage integer or infinity. Not <... 'int'>.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_elements": {
                    "__doc__": "\n            Run generic tests on element(s) of ``self``.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements(verbose = True)\n                <BLANKLINE>\n                  Running the test suite of self.an_element()\n                  running ._test_category() . . . pass\n                  running ._test_eq() . . . pass\n                  running ._test_new() . . . pass\n                  running ._test_nonzero_equal() . . . pass\n                  running ._test_not_implemented_methods() . . . pass\n                  running ._test_pickling() . . . pass\n                <BLANKLINE>\n\n            Debugging tip: in case of failure of this test, run instead::\n\n                sage: TestSuite(C.an_element()).run()\n\n            Let us now implement a parent whose elements cannot be pickled::\n\n                sage: from sage.categories.examples.sets_cat import PrimeNumbers\n                sage: class Bla(SageObject): pass\n                sage: class CCls(PrimeNumbers):\n                ....:     def an_element(self):\n                ....:         return Bla()\n                sage: CC = CCls()\n                sage: CC._test_elements()\n                  Failure in _test_pickling:\n                  ...\n                  PicklingError: Can't pickle <class '__main__.Bla'>: attribute lookup __main__.Bla failed\n                  ...\n                  The following tests failed: _test_pickling\n            ",
                    "args": [
                        "self",
                        "tester"
                    ],
                    "argspec": [
                        [
                            "self",
                            "tester"
                        ],
                        null,
                        "options",
                        [
                            null
                        ]
                    ]
                },
                "_test_elements_eq_reflexive": {
                    "__doc__": "\n            Run generic tests on the equality of elements.\n\n            Test that ``==`` is reflexive.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_eq_reflexive()\n\n            We try a non-reflexive equality::\n\n                sage: P = Sets().example(\"wrapper\")\n                sage: P._test_elements_eq_reflexive()\n                sage: eq = P.element_class.__eq__\n\n                sage: P.element_class.__eq__ = (lambda x, y:\n                ....:      False if eq(x, P(47)) and eq(y, P(47)) else eq(x, y))\n                sage: P._test_elements_eq_reflexive()\n                Traceback (most recent call last):\n                ...\n                AssertionError: 47 != 47\n\n            We restore ``P.element_class`` in a proper state for further tests::\n\n                sage: P.element_class.__eq__ = eq\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_elements_eq_symmetric": {
                    "__doc__": "\n            Run generic tests on the equality of elements.\n\n            This tests that ``==`` is symmetric.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_eq_symmetric()\n\n            We test a non symmetric equality::\n\n                sage: P = Sets().example(\"wrapper\")\n                sage: P._test_elements_eq_symmetric()\n                sage: eq = P.element_class.__eq__\n\n                sage: def non_sym_eq(x, y):\n                ....:    if not y in P:                      return False\n                ....:    elif eq(x, P(47)) and eq(y, P(53)): return True\n                ....:    else:                               return eq(x, y)\n                sage: P.element_class.__eq__ = non_sym_eq\n                sage: P._test_elements_eq_symmetric()\n                Traceback (most recent call last):\n                ...\n                AssertionError: non symmetric equality: 47 == 53 but 53 != 47\n\n            We restore ``P.element_class`` in a proper state for further tests::\n\n                sage: P.element_class.__eq__ = eq\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_elements_eq_transitive": {
                    "__doc__": "\n            Run generic tests on the equality of elements.\n\n            Test that ``==`` is transitive.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_eq_transitive()\n\n            We test a non transitive equality::\n\n                sage: R = Zp(3)\n                sage: Sets().ParentMethods._test_elements_eq_transitive.__func__(R,elements=[R(3,2),R(3,1),R(0)])\n                Traceback (most recent call last):\n                ...\n                AssertionError: non transitive equality:\n                3 + O(3^2) == O(3) and O(3) == 0 but 3 + O(3^2) != 0\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_elements_neq": {
                    "__doc__": "\n            Run generic tests on the equality of elements.\n\n            Test that ``==`` and ``!=`` are consistent.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_neq()\n\n            We try a broken inequality::\n\n                sage: P = Sets().example(\"wrapper\")\n                sage: P._test_elements_neq()\n                sage: ne = P.element_class.__ne__\n                sage: eq = P.element_class.__eq__\n\n                sage: P.element_class.__ne__ = lambda x, y: False\n                sage: P._test_elements_neq()\n                Traceback (most recent call last):\n                ...\n                AssertionError: __eq__ and __ne__ inconsistency:\n                  47 == 53 returns False  but  47 != 53 returns False\n\n                sage: P.element_class.__ne__ = lambda x, y: not(x == y)\n\n            We restore ``P.element_class`` in a proper state for further tests::\n\n                sage: P.element_class.__ne__ = ne\n                sage: P.element_class.__eq__ = eq\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_some_elements": {
                    "__doc__": "\n            Run generic tests on the method :meth:`.some_elements`.\n\n            .. SEEALSO:: :class:`TestSuite`\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_some_elements()\n\n            Let us now write a broken :meth:`.some_elements` method::\n\n                sage: from sage.categories.examples.sets_cat import *\n                sage: class CCls(PrimeNumbers):\n                ....:     def some_elements(self):\n                ....:         return [self(17), 32]\n                sage: CC = CCls()\n                sage: CC._test_some_elements()\n                Traceback (most recent call last):\n                ...\n                AssertionError: the object 32 in self.some_elements() is not in self\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "algebra": {
                    "__doc__": "\n            Return the algebra of ``self`` over ``base_ring``.\n\n            INPUT:\n\n            - ``self`` -- a parent `S`\n            - ``base_ring`` -- a ring `K`\n            - ``category`` -- a super category of the category\n              of `S`, or ``None``\n\n            This returns the `K`-free module with basis indexed by\n            `S`, endowed with whatever structure can be induced from\n            that of `S`. Note that the ``category`` keyword needs to\n            be fed with the structure on `S` to be used, not the\n            structure that one wants to obtain on the result; see the\n            examples below.\n\n            EXAMPLES:\n\n            If `S` is a monoid, the result is the monoid algebra `KS`::\n\n                sage: S = Monoids().example(); S\n                An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n                sage: A = S.algebra(QQ); A\n                Free module generated by An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd') over Rational Field\n                sage: A.category()\n                Category of monoid algebras over Rational Field\n\n            If `S` is a group, the result is the group algebra `KS`::\n\n                sage: S = Groups().example(); S\n                General Linear Group of degree 4 over Rational Field\n                sage: A = S.algebra(QQ); A\n                Group algebra of General Linear Group of degree 4 over Rational Field over Rational Field\n                sage: A.category()\n                Category of group algebras over Rational Field\n\n            which is actually a Hopf algebra::\n\n                sage: A in HopfAlgebras(QQ)\n                True\n\n            By Maschke's theorem, for a finite group whose cardinality\n            does not divide the characteristic of the base field, the\n            algebra is semisimple::\n\n                sage: SymmetricGroup(5).algebra(QQ) in Algebras(QQ).Semisimple()\n                True\n                sage: CyclicPermutationGroup(10).algebra(FiniteField(5)) in Algebras.Semisimple\n                False\n                sage: CyclicPermutationGroup(10).algebra(FiniteField(7)) in Algebras.Semisimple\n                True\n\n\n            One may specify for which category one takes the algebra::\n\n                sage: A = S.algebra(QQ, category=Sets()); A\n                Free module generated by General Linear Group of degree 4 over Rational Field over Rational Field\n                sage: A.category()\n                Category of set algebras over Rational Field\n\n            One may construct as well algebras of additive magmas,\n            semigroups, monoids, or groups::\n\n                sage: S = CommutativeAdditiveMonoids().example(); S\n                An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd')\n                sage: U = S.algebra(QQ); U\n                Free module generated by An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd') over Rational Field\n\n            Despite saying \"free module\", this is really an algebra\n            and its elements can be multiplied::\n\n                sage: U in Algebras(QQ)\n                True\n                sage: (a,b,c,d) = S.additive_semigroup_generators()\n                sage: U(a) * U(b)\n                B[a + b]\n\n            Constructing the algebra of a set endowed with both an\n            additive and a multiplicative structure is ambiguous::\n\n                sage: Z3 = IntegerModRing(3)\n                sage: A = Z3.algebra(QQ)\n                Traceback (most recent call last):\n                ...\n                TypeError:  `S = Ring of integers modulo 3` is both an additive and a multiplicative semigroup.\n                Constructing its algebra is ambiguous.\n                Please use, e.g., S.algebra(QQ, category=Semigroups())\n\n            The ambiguity can be resolved using the ``category`` argument::\n\n                sage: A = Z3.algebra(QQ, category=Monoids()); A\n                Free module generated by Ring of integers modulo 3 over Rational Field\n                sage: A.category()\n                Category of finite dimensional monoid algebras over Rational Field\n\n                sage: A = Z3.algebra(QQ, category=CommutativeAdditiveGroups()); A\n                Free module generated by Ring of integers modulo 3 over Rational Field\n                sage: A.category()\n                Category of finite dimensional commutative additive group algebras over Rational Field\n\n            Similarly, on , we obtain for additive magmas, monoids, groups.\n\n\n            .. WARNING::\n\n                As we have seen, in most practical use cases, the\n                result is actually an algebra, hence the name of this\n                method. In the other cases this name is misleading::\n\n                    sage: A = Sets().example().algebra(QQ); A\n                    Free module generated by Set of prime numbers (basic implementation) over Rational Field\n                    sage: A.category()\n                    Category of set algebras over Rational Field\n                    sage: A in Algebras(QQ)\n                    False\n\n                Suggestions for a uniform, meaningful, and non\n                misleading name are welcome!\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "category"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "an_element": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "cardinality": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method cardinality at 0x7faa353be2a8>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "sage",
                    "gap_name": "Size",
                    "mmt_name": null
                },
                "cartesian_product": {
                    "__doc__": "\n            Return the Cartesian product of the parents.\n\n            INPUT:\n\n            - ``parents`` -- a list (or other iterable) of parents.\n\n            - ``category`` -- (default: ``None``) the category the\n              Cartesian product belongs to. If ``None`` is passed,\n              then\n              :meth:`~sage.categories.covariant_functorial_construction.CovariantFactorialConstruction.category_from_parents`\n              is used to determine the category.\n\n            - ``extra_category`` -- (default: ``None``) a category\n              that is added to the Cartesian product in addition\n              to the categories obtained from the parents.\n\n            - other keyword arguments will passed on to the class used\n              for this Cartesian product (see also\n              :class:`~sage.sets.cartesian_product.CartesianProduct`).\n\n            OUTPUT:\n\n            The Cartesian product.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example(); A.rename(\"A\")\n                sage: A.cartesian_product(A,A)\n                A (+) A (+) A\n                sage: ZZ.cartesian_product(GF(2), FiniteEnumeratedSet([1,2,3]))\n                The Cartesian product of (Integer Ring, Finite Field of size 2, {1, 2, 3})\n\n                sage: C = ZZ.cartesian_product(A); C\n                The Cartesian product of (Integer Ring, A)\n\n            TESTS::\n\n                sage: type(C)\n                <class 'sage.sets.cartesian_product.CartesianProduct_with_category'>\n                sage: C.category()\n                Join of Category of rings and ...\n                    and Category of Cartesian products of commutative additive groups\n\n            ::\n\n                sage: cartesian_product([ZZ, ZZ], category=Sets()).category()\n                Category of sets\n                sage: cartesian_product([ZZ, ZZ]).category()\n                Join of\n                Category of Cartesian products of commutative rings and\n                Category of Cartesian products of enumerated sets\n                sage: cartesian_product([ZZ, ZZ], extra_category=Posets()).category()\n                Join of\n                Category of Cartesian products of commutative rings and\n                Category of posets and\n                Category of Cartesian products of enumerated sets\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "parents",
                        "kwargs",
                        null
                    ]
                },
                "is_finite": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method is_finite at 0x7faa353be1b8>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "sage",
                    "gap_name": "IsFinite",
                    "mmt_name": null
                },
                "is_parent_of": {
                    "__doc__": "\n            Return whether ``self`` is the parent of ``element``.\n\n            INPUT:\n\n            - ``element`` -- any object\n\n            EXAMPLES::\n\n                sage: S = ZZ\n                sage: S.is_parent_of(1)\n                True\n                sage: S.is_parent_of(2/1)\n                False\n\n            This method differs from :meth:`__contains__` because it\n            does not attempt any coercion::\n\n                sage: 2/1 in S, S.is_parent_of(2/1)\n                (True, False)\n                sage: int(1) in S, S.is_parent_of(int(1))\n                (True, False)\n            ",
                    "args": [
                        "self",
                        "element"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "random_element": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method random_element at 0x7faa353be398>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "self",
                    "gap_name": "Random",
                    "mmt_name": null
                },
                "some_elements": {
                    "__doc__": "\n            Return a list (or iterable) of elements of ``self``.\n\n            This is typically used for running generic tests\n            (see :class:`TestSuite`).\n\n            This default implementation calls :meth:`.an_element`.\n\n            EXAMPLES::\n\n                sage: S = Sets().example(); S\n                Set of prime numbers (basic implementation)\n                sage: S.an_element()\n                47\n                sage: S.some_elements()\n                [47]\n                sage: S = Set([])\n                sage: S.some_elements()\n                []\n\n            This method should return an iterable, *not* an iterator.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.categories.sets_cat.Sets.parent_class"
        },
        "sage.categories.sets_cat.Sets.subcategory_class": {
            "__doc__": null,
            "implied": [],
            "methods": {
                "Algebras": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "CartesianProducts": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Enumerated": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Facade": {
                    "__doc__": "\n            Return the full subcategory of the facade objects of ``self``.\n\n            .. _facade-sets:\n\n            .. RUBRIC:: What is a facade set?\n\n            Recall that, in Sage, :ref:`sets are modelled by *parents*\n            <category-primer-parents-elements-categories>`, and their\n            elements know which distinguished set they belong to. For\n            example, the ring of integers `\\ZZ` is modelled by the\n            parent :obj:`ZZ`, and integers know that they belong to\n            this set::\n\n                sage: ZZ\n                Integer Ring\n                sage: 42.parent()\n                Integer Ring\n\n            Sometimes, it is convenient to represent the elements of a\n            parent ``P`` by elements of some other parent. For\n            example, the elements of the set of prime numbers are\n            represented by plain integers::\n\n                sage: Primes()\n                Set of all prime numbers: 2, 3, 5, 7, ...\n                sage: p = Primes().an_element(); p\n                43\n                sage: p.parent()\n                Integer Ring\n\n            In this case, ``P`` is called a *facade set*.\n\n            This feature is advertised through the category of `P`::\n\n                sage: Primes().category()\n                Category of facade infinite enumerated sets\n                sage: Sets().Facade()\n                Category of facade sets\n\n            Typical use cases include modeling a subset of an existing\n            parent::\n\n                sage: Set([4,6,9])                    # random\n                {4, 6, 9}\n                sage: Sets().Facade().example()\n                An example of facade set: the monoid of positive integers\n\n            or the union of several parents::\n\n                sage: Sets().Facade().example(\"union\")\n                An example of a facade set: the integers completed by +-infinity\n\n            or endowing an existing parent with more (or less!)\n            structure::\n\n                sage: Posets().example(\"facade\")\n                An example of a facade poset: the positive integers ordered by divisibility\n\n            Let us investigate in detail a close variant of this last\n            example: let `P` be set of divisors of `12` partially\n            ordered by divisibility. There are two options for\n            representing its elements:\n\n            1. as plain integers::\n\n                sage: P = Poset((divisors(12), attrcall(\"divides\")), facade=True)\n\n            2. as integers, modified to be aware that their parent is `P`::\n\n                sage: Q = Poset((divisors(12), attrcall(\"divides\")), facade=False)\n\n            The advantage of option 1. is that one needs not do\n            conversions back and forth between `P` and `\\ZZ`. The\n            disadvantage is that this introduces an ambiguity when\n            writing `2 < 3`: does this compare `2` and `3` w.r.t. the\n            natural order on integers or w.r.t. divisibility?::\n\n                sage: 2 < 3\n                True\n\n            To raise this ambiguity, one needs to explicitly specify\n            the underlying poset as in `2 <_P 3`::\n\n                sage: P = Posets().example(\"facade\")\n                sage: P.lt(2,3)\n                False\n\n            On the other hand, with option 2. and once constructed,\n            the elements know unambiguously how to compare\n            themselves::\n\n                sage: Q(2) < Q(3)\n                False\n                sage: Q(2) < Q(6)\n                True\n\n            Beware that ``P(2)`` is still the integer `2`. Therefore\n            ``P(2) < P(3)`` still compares `2` and `3` as integers!::\n\n                sage: P(2) < P(3)\n                True\n\n            In short `P` being a facade parent is one of the programmatic\n            counterparts (with e.g. coercions) of the usual mathematical idiom:\n            \"for ease of notation, we identify an element of `P` with the\n            corresponding integer\". Too many identifications lead to\n            confusion; the lack thereof leads to heavy, if not obfuscated,\n            notations. Finding the right balance is an art, and even though\n            there are common guidelines, it is ultimately up to the writer to\n            choose which identifications to do. This is no different in code.\n\n            .. SEEALSO::\n\n               The following examples illustrate various ways to\n               implement subsets like the set of prime numbers; look\n               at their code for details::\n\n                   sage: Sets().example(\"facade\")\n                   Set of prime numbers (facade implementation)\n                   sage: Sets().example(\"inherits\")\n                   Set of prime numbers\n                   sage: Sets().example(\"wrapper\")\n                   Set of prime numbers (wrapper implementation)\n\n            .. RUBRIC:: Specifications\n\n            A parent which is a facade must either:\n\n            - call :meth:`Parent.__init__` using the ``facade`` parameter to\n              specify a parent, or tuple thereof.\n            - overload the method :meth:`~Sets.Facade.ParentMethods.facade_for`.\n\n            .. NOTE::\n\n                The concept of facade parents was originally introduced\n                in the computer algebra system MuPAD.\n\n            TESTS:\n\n            Check that multiple categories initialisation\n            works (:trac:`13801`)::\n\n                sage: class A(Parent):\n                ....:   def __init__(self):\n                ....:       Parent.__init__(self, category=(FiniteEnumeratedSets(),Monoids()), facade=True)\n                sage: a = A()\n\n                sage: Posets().Facade()\n                Category of facade posets\n                sage: Posets().Facade().Finite() is  Posets().Finite().Facade()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "Facades": {
                    "__doc__": "Deprecated: Use :func:`Facade` instead.\nSee :trac:`17073` for details.\n\n",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Finite": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Infinite": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "IsomorphicObjects": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Metric": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Quotients": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Subobjects": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Subquotients": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "Topological": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            },
            "name": "sage.categories.sets_cat.Sets.subcategory_class"
        },
        "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.element_class": {
            "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.element_class"
        },
        "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.morphism_class": {
            "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.morphism_class"
        },
        "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.parent_class": {
            "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.parent_class"
        },
        "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.subcategory_class": {
            "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
            "implied": [],
            "methods": {},
            "name": "sage.categories.sets_with_partial_maps.SetsWithPartialMaps.subcategory_class"
        },
        "sage.groups.old.FiniteGroup": {
            "__doc__": "File: sage/groups/old.pyx (starting at line 225)\n\n    Generic finite group.\n    ",
            "implied": [
                "sage.groups.old.Group"
            ],
            "methods": {},
            "name": "sage.groups.old.FiniteGroup"
        },
        "sage.groups.old.Group": {
            "__doc__": "Group(category=None)\nFile: sage/groups/old.pyx (starting at line 29)\n\n    Generic group class\n    ",
            "implied": [
                "sage.structure.parent_gens.ParentWithGens"
            ],
            "methods": {
                "is_abelian": {
                    "__doc__": "Group.is_abelian(self)\nFile: sage/groups/old.pyx (starting at line 99)\n\n        Return True if this group is abelian.\n\n        EXAMPLES::\n\n            sage: from sage.groups.old import Group\n            sage: G = Group()\n            sage: G.is_abelian()\n            Traceback (most recent call last):\n            ...\n            NotImplementedError\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_commutative": {
                    "__doc__": "Group.is_commutative(self)\nFile: sage/groups/old.pyx (starting at line 114)\n\n        Return True if this group is commutative. This is an alias for\n        is_abelian, largely to make groups work well with the Factorization\n        class.\n\n        (Note for developers: Derived classes should override is_abelian, not\n        is_commutative.)\n\n        EXAMPLES::\n\n            sage: SL(2, 7).is_commutative()\n            False\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_finite": {
                    "__doc__": "Group.is_finite(self)\nFile: sage/groups/old.pyx (starting at line 146)\n\n        Returns True if this group is finite.\n\n        EXAMPLES::\n\n            sage: from sage.groups.old import Group\n            sage: G = Group()\n            sage: G.is_finite()\n            Traceback (most recent call last):\n            ...\n            NotImplementedError\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_multiplicative": {
                    "__doc__": "Group.is_multiplicative(self)\nFile: sage/groups/old.pyx (starting at line 161)\n\n        Returns True if the group operation is given by \\* (rather than\n        +).\n\n        Override for additive groups.\n\n        EXAMPLES::\n\n            sage: from sage.groups.old import Group\n            sage: G = Group()\n            sage: G.is_multiplicative()\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "order": {
                    "__doc__": "Group.order(self)\nFile: sage/groups/old.pyx (starting at line 130)\n\n        Returns the number of elements of this group, which is either a\n        positive integer or infinity.\n\n        EXAMPLES::\n\n            sage: from sage.groups.old import Group\n            sage: G = Group()\n            sage: G.order()\n            Traceback (most recent call last):\n            ...\n            NotImplementedError\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "quotient": {
                    "__doc__": "Group.quotient(self, H)\nFile: sage/groups/old.pyx (starting at line 192)\n\n        Return the quotient of this group by the normal subgroup\n        `H`.\n\n        EXAMPLES::\n\n            sage: from sage.groups.old import Group\n            sage: G = Group()\n            sage: G.quotient(G)\n            Traceback (most recent call last):\n            ...\n            NotImplementedError\n        ",
                    "args": [
                        "self",
                        "H"
                    ],
                    "argspec": [
                        [
                            "self",
                            "H"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "random_element": {
                    "__doc__": "Group.random_element(self, bound=None)\nFile: sage/groups/old.pyx (starting at line 177)\n\n        Return a random element of this group.\n\n        EXAMPLES::\n\n            sage: from sage.groups.old import Group\n            sage: G = Group()\n            sage: G.random_element()\n            Traceback (most recent call last):\n            ...\n            NotImplementedError\n        ",
                    "args": [
                        "self",
                        "bound"
                    ],
                    "argspec": [
                        [
                            "self",
                            "bound"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            },
            "name": "sage.groups.old.Group"
        },
        "sage.groups.perm_gps.permgroup.PermutationGroup_generic": {
            "__doc__": "\n    EXAMPLES::\n\n        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])\n        sage: G\n        Permutation Group with generators [(3,4), (1,2,3)(4,5)]\n        sage: G.center()\n        Subgroup of (Permutation Group with generators [(3,4), (1,2,3)(4,5)]) generated by [()]\n        sage: G.group_id()          # optional - database_gap\n        [120, 34]\n        sage: n = G.order(); n\n        120\n        sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])\n        sage: TestSuite(G).run()\n    ",
            "implied": [
                "sage.groups.old.FiniteGroup"
            ],
            "methods": {
                "__cmp__": {
                    "__doc__": "\n        Compare ``self`` and ``right``.\n\n        The comparison extends the subgroup relation. Hence, it is first checked\n        whether one of the groups is subgroup of the other. If this is not the\n        case then the ordering is whatever it is in Gap.\n\n        .. NOTE::\n\n            The comparison does not provide a total ordering, as can be seen\n            in the examples below.\n\n        EXAMPLES::\n\n            sage: G1 = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])\n            sage: G2 = PermutationGroup([[(1,2,3),(4,5)]])\n            sage: G1 > G2 # since G2 is a subgroup of G1\n            True\n            sage: G1 < G2\n            False\n\n        The following example shows that the comparison does not yield a total\n        ordering::\n\n            sage: H1 = PermutationGroup([[(1,2)],[(5,6)]])\n            sage: H2 = PermutationGroup([[(3,4)]])\n            sage: H3 = PermutationGroup([[(1,2)]])\n            sage: H1 < H2 # according to Gap's ordering\n            True\n            sage: H2 < H3 # according to Gap's ordering\n            True\n            sage: H3 < H1 # since H3 is a subgroup of H1\n            True\n        ",
                    "args": [
                        "self",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__iter__": {
                    "__doc__": "\n        Return an iterator over the elements of this group.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3)], [(1,2)]])\n            sage: [a for a in G]\n            [(), (1,2), (1,2,3), (2,3), (1,3,2), (1,3)]\n\n        Test that it is possible to iterate through moderately large groups\n        (:trac:`18239`)::\n\n            sage: p = [(i,i+1) for i in range(1,601,2)]\n            sage: q = [tuple(range(1+i,601,3)) for i in range(3)]\n            sage: A = PermutationGroup([p,q])\n            sage: A.cardinality()\n            60000\n            sage: for x in A:    # long time - 2 secs\n            ....:     pass       # long time\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_domain_gap": {
                    "__doc__": "\n        Returns a GAP string representation of the underlying set\n        that this group acts on.  See also :meth:`domain`.\n\n        EXAMPLES::\n\n            sage: P = PermutationGroup([(1,2),(3,5)])\n            sage: P._domain_gap()\n            '[1, 2, 3, 4, 5]'\n        ",
                    "args": [
                        "self",
                        "domain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "domain"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_element_class": {
                    "__doc__": "\n        Return the class to be used for creating elements of this group. By\n        default this is\n        ``sage.groups.perm_gps.permgroup_element.PermutationGroupElement``, but\n        it may be overridden in derived subclasses (most importantly\n        ``sage.rings.number_field.galois_group.GaloisGroup_v2``).\n\n        EXAMPLES::\n\n            sage: AlternatingGroup(17)._element_class()\n            <type 'sage.groups.perm_gps.permgroup_element.PermutationGroupElement'>\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_has_natural_domain": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "_latex_": {
                    "__doc__": "\n        Method for describing ``self`` in LaTeX. Encapsulates\n        ``self.gens()`` in angle brackets to denote that ``self``\n        is generated by these elements. Called by the\n        ``latex()`` function.\n\n        EXAMPLES:\n\n        We explicitly construct the alternating group on four\n        elements::\n\n            sage: A4 = PermutationGroup([[(1,2,3)],[(2,3,4)]]); A4\n            Permutation Group with generators [(2,3,4), (1,2,3)]\n            sage: latex(A4)\n            \\langle (2,3,4), (1,2,3) \\rangle\n            sage: A4._latex_()\n            '\\\\langle (2,3,4), (1,2,3) \\\\rangle'\n\n            sage: S = SymmetricGroup(['a','b','c'])\n            sage: latex(S)\n            \\langle (\\text{\\texttt{a}},\\text{\\texttt{b}},\\text{\\texttt{c}}), (\\text{\\texttt{a}},\\text{\\texttt{b}}) \\rangle\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_order": {
                    "__doc__": "\n        This handles a few special cases of computing the subgroup order much\n        faster than GAP.\n\n        This currently operates very quickly for stabilizer subgroups of\n        permutation groups, for one.\n\n        Will return None if the we could not easily compute it.\n\n        Author: Christopher Swenson\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(10).subgroup([(i, 10) for i in range(1, 10) if i != 4])\n            sage: G._order()\n            362880\n\n        TESTS::\n\n            sage: [SymmetricGroup(n).stabilizer(1)._gap_().Size() for n in [4..10]]\n            [6, 24, 120, 720, 5040, 40320, 362880]\n            sage: special_gens = [\n            ....:     [(3,4), (2,4)],\n            ....:     [(4,5), (3,5), (2,5)],\n            ....:     [(5,6), (4,6), (3,6), (2,6)],\n            ....:     [(6,7), (5,7), (4,7), (3,7), (2,7)],\n            ....:     [(7,8), (6,8), (5,8), (4,8), (3,8), (2,8)],\n            ....:     [(8,9), (7,9), (6,9), (5,9), (4,9), (3,9), (2,9)],\n            ....:     [(9,10), (8,10), (7,10), (6,10), (5,10), (4,10), (3,10), (2,10)]]\n            sage: [SymmetricGroup(n).subgroup(gen)._order() for gen in special_gens]\n            [6, 24, 120, 720, 5040, 40320, 362880]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_regular_subgroup_gap": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "_repr_": {
                    "__doc__": "\n        Returns a string describing ``self``.\n\n        EXAMPLES:\n\n        We explicitly construct the alternating group on four\n        elements. Note that the ``AlternatingGroup`` class has\n        its own representation string::\n\n            sage: A4 = PermutationGroup([[(1,2,3)],[(2,3,4)]]); A4\n            Permutation Group with generators [(2,3,4), (1,2,3)]\n            sage: A4._repr_()\n            'Permutation Group with generators [(2,3,4), (1,2,3)]'\n            sage: AlternatingGroup(4)._repr_()\n            'Alternating group of order 4!/2 as a permutation group'\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "as_finitely_presented_group": {
                    "__doc__": "\n        Return a finitely presented group isomorphic to ``self``.\n\n        This method acts as wrapper for the GAP function ``IsomorphismFpGroupByGenerators``,\n        which yields an isomorphism from a given group to a finitely presented group.\n\n        INPUT:\n\n        - ``reduced`` -- Default ``False``, if ``True`` :meth:`FinitelyPresentedGroup.simplified\n          <sage.groups.finitely_presented.FinitelyPresentedGroup.simplified>`\n          is called, attempting to simplify the presentation of the finitely presented group\n          to be returned.\n\n        OUTPUT:\n\n        Finite presentation of self, obtained by taking the image\n        of the isomorphism returned by the GAP function, ``IsomorphismFpGroupByGenerators``.\n\n        ALGORITHM:\n\n        Uses GAP.\n\n        EXAMPLES::\n\n            sage: CyclicPermutationGroup(50).as_finitely_presented_group()\n            Finitely presented group < a | a^50 >\n            sage: DihedralGroup(4).as_finitely_presented_group()\n            Finitely presented group < a, b | b^2, a^4, (b*a)^2 >\n            sage: GeneralDihedralGroup([2,2]).as_finitely_presented_group()\n            Finitely presented group < a, b, c | a^2, b^2, c^2, (c*b)^2, (c*a)^2, (b*a)^2 >\n\n        GAP algorithm is not guaranteed to produce minimal or canonical presentation::\n\n            sage: G = PermutationGroup(['(1,2,3,4,5)', '(1,5)(2,4)'])\n            sage: G.is_isomorphic(DihedralGroup(5))\n            True\n            sage: K = G.as_finitely_presented_group(); K\n            Finitely presented group < a, b | b^2, (b*a)^2, b*a^-3*b*a^2 >\n            sage: K.as_permutation_group().is_isomorphic(DihedralGroup(5))\n            True\n\n        We can attempt to reduce the output presentation::\n\n            sage: PermutationGroup(['(1,2,3,4,5)','(1,3,5,2,4)']).as_finitely_presented_group()\n            Finitely presented group < a, b | b^-2*a^-1, b*a^-2 >\n            sage: PermutationGroup(['(1,2,3,4,5)','(1,3,5,2,4)']).as_finitely_presented_group(reduced=True)\n            Finitely presented group < a | a^5 >\n\n        TESTS::\n\n            sage: PermutationGroup([]).as_finitely_presented_group()\n            Finitely presented group < a | a >\n            sage: S = SymmetricGroup(6)\n            sage: perm_ls = [S.random_element() for i in range(3)]\n            sage: G = PermutationGroup(perm_ls)\n            sage: G.as_finitely_presented_group().as_permutation_group().is_isomorphic(G)\n            True\n\n        `D_9` is the only non-Abelian group of order 18\n        with an automorphism group of order 54 [TW1980]_::\n\n            sage: D = DihedralGroup(9).as_finitely_presented_group().gap()\n            sage: D.Order(), D.IsAbelian(), D.AutomorphismGroup().Order()\n            (18, false, 54)\n\n        `S_3` is the only non-Abelian group of order 6 [TW1980]_::\n\n            sage: S = SymmetricGroup(3).as_finitely_presented_group().gap()\n            sage: S.Order(), S.IsAbelian()\n            (6, false)\n\n        We can manually construct a permutation representation using GAP\n        coset enumeration methods::\n\n            sage: D = GeneralDihedralGroup([3,3,4]).as_finitely_presented_group().gap()\n            sage: ctab = D.CosetTable(D.Subgroup([]))\n            sage: gen_ls = gap.List(ctab, gap.PermList)\n            sage: PermutationGroup(gen_ls).is_isomorphic(GeneralDihedralGroup([3,3,4]))\n            True\n            sage: A = AlternatingGroup(5).as_finitely_presented_group().gap()\n            sage: ctab = A.CosetTable(A.Subgroup([]))\n            sage: gen_ls = gap.List(ctab, gap.PermList)\n            sage: PermutationGroup(gen_ls).is_isomorphic(AlternatingGroup(5))\n            True\n\n        AUTHORS:\n\n        - Davis Shurbert (2013-06-21): initial version\n        ",
                    "args": [
                        "self",
                        "reduced"
                    ],
                    "argspec": [
                        [
                            "self",
                            "reduced"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "blocks_all": {
                    "__doc__": "\n        Returns the list of block systems of imprimitivity.\n\n        For more information on primitivity, see the :wikipedia:`Wikipedia\n        article on primitive group actions <Primitive_permutation_group>`.\n\n        INPUT:\n\n        - ``representative`` (boolean) -- whether to return all possible block\n          systems of imprimitivity or only one of their representatives (the\n          block can be obtained from its representative set `S` by computing the\n          orbit of `S` under ``self``).\n\n          This parameter is set to ``True`` by default (as it is GAP's default\n          behaviour).\n\n        OUTPUT:\n\n        This method returns a description of *all* block systems. Hence, the\n        output is a \"list of lists of lists\" or a \"list of lists\" depending on\n        the value of ``representatives``. A bit more clearly, output is :\n\n        * A list of length (#number of different block systems) of\n\n           * block systems, each of them being defined as\n\n               * If ``representatives = True`` : a list of representatives of\n                 each set of the block system\n\n               * If ``representatives = False`` : a partition of the elements\n                 defining an imprimitivity block.\n\n        .. SEEALSO::\n\n            - :meth:`~PermutationGroup_generic.is_primitive`\n\n        EXAMPLES:\n\n        Picking an interesting group::\n\n            sage: g = graphs.DodecahedralGraph()\n            sage: g.is_vertex_transitive()\n            True\n            sage: ag = g.automorphism_group()\n            sage: ag.is_primitive()\n            False\n\n        Computing its blocks representatives::\n\n            sage: ag.blocks_all()\n            [[0, 15]]\n\n        Now the full block::\n\n            sage: sorted(ag.blocks_all(representatives = False)[0])\n            [[0, 15], [1, 16], [2, 12], [3, 13], [4, 9], [5, 10], [6, 11], [7, 18], [8, 17], [14, 19]]\n\n        TESTS::\n\n            sage: g = PermutationGroup([(\"a\",\"b\",\"c\",\"d\")])\n            sage: g.blocks_all()\n            [['a', 'c']]\n            sage: g.blocks_all(False)\n            [[['a', 'c'], ['b', 'd']]]\n        ",
                    "args": [
                        "self",
                        "representatives"
                    ],
                    "argspec": [
                        [
                            "self",
                            "representatives"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "cardinality": {
                    "__doc__": "\n        Return the number of elements of this group.\n        See also: G.degree()\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])\n            sage: G.order()\n            12\n            sage: G = PermutationGroup([()])\n            sage: G.order()\n            1\n            sage: G = PermutationGroup([])\n            sage: G.order()\n            1\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "center": {
                    "__doc__": "\n        Return the subgroup of elements that commute with every element\n        of this group.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3,4)]])\n            sage: G.center()\n            Subgroup of (Permutation Group with generators [(1,2,3,4)]) generated by [(1,2,3,4)]\n            sage: G = PermutationGroup([[(1,2,3,4)], [(1,2)]])\n            sage: G.center()\n            Subgroup of (Permutation Group with generators [(1,2), (1,2,3,4)]) generated by [()]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "centralizer": {
                    "__doc__": "\n        Returns the centralizer of ``g`` in ``self``.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])\n            sage: g = G([(1,3)])\n            sage: G.centralizer(g)\n            Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(2,4), (1,3)]\n            sage: g = G([(1,2,3,4)])\n            sage: G.centralizer(g)\n            Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(1,2,3,4)]\n            sage: H = G.subgroup([G([(1,2,3,4)])])\n            sage: G.centralizer(H)\n            Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(1,2,3,4)]\n        ",
                    "args": [
                        "self",
                        "g"
                    ],
                    "argspec": [
                        [
                            "self",
                            "g"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "character": {
                    "__doc__": "\n        Returns a group character from ``values``, where ``values`` is\n        a list of the values of the character evaluated on the conjugacy\n        classes.\n\n        EXAMPLES::\n\n            sage: G = AlternatingGroup(4)\n            sage: n = len(G.conjugacy_classes_representatives())\n            sage: G.character([1]*n)\n            Character of Alternating group of order 4!/2 as a permutation group\n        ",
                    "args": [
                        "self",
                        "values"
                    ],
                    "argspec": [
                        [
                            "self",
                            "values"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "character_table": {
                    "__doc__": "\n        Returns the matrix of values of the irreducible characters of a\n        permutation group `G` at the conjugacy classes of\n        `G`.\n\n        The columns represent the conjugacy classes of\n        `G` and the rows represent the different irreducible\n        characters in the ordering given by GAP.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3)]])\n            sage: G.order()\n            12\n            sage: G.character_table()\n            [         1          1          1          1]\n            [         1 -zeta3 - 1      zeta3          1]\n            [         1      zeta3 -zeta3 - 1          1]\n            [         3          0          0         -1]\n            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3)]])\n            sage: CT = gap(G).CharacterTable()\n\n        Type ``print(gap.eval(\"Display(%s)\"%CT.name()))`` to display this\n        nicely.\n\n        ::\n\n            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])\n            sage: G.order()\n            8\n            sage: G.character_table()\n            [ 1  1  1  1  1]\n            [ 1 -1 -1  1  1]\n            [ 1 -1  1 -1  1]\n            [ 1  1 -1 -1  1]\n            [ 2  0  0  0 -2]\n            sage: CT = gap(G).CharacterTable()\n\n        Again, type ``print(gap.eval(\"Display(%s)\"%CT.name()))`` to display this\n        nicely.\n\n        ::\n\n            sage: SymmetricGroup(2).character_table()\n            [ 1 -1]\n            [ 1  1]\n            sage: SymmetricGroup(3).character_table()\n            [ 1 -1  1]\n            [ 2  0 -1]\n            [ 1  1  1]\n            sage: SymmetricGroup(5).character_table()\n            [ 1 -1  1  1 -1 -1  1]\n            [ 4 -2  0  1  1  0 -1]\n            [ 5 -1  1 -1 -1  1  0]\n            [ 6  0 -2  0  0  0  1]\n            [ 5  1  1 -1  1 -1  0]\n            [ 4  2  0  1 -1  0 -1]\n            [ 1  1  1  1  1  1  1]\n            sage: list(AlternatingGroup(6).character_table())\n            [(1, 1, 1, 1, 1, 1, 1), (5, 1, 2, -1, -1, 0, 0), (5, 1, -1, 2, -1, 0, 0), (8, 0, -1, -1, 0, zeta5^3 + zeta5^2 + 1, -zeta5^3 - zeta5^2), (8, 0, -1, -1, 0, -zeta5^3 - zeta5^2, zeta5^3 + zeta5^2 + 1), (9, 1, 0, 0, 1, -1, -1), (10, -2, 1, 1, 0, 0, 0)]\n\n        Suppose that you have a class function `f(g)` on\n        `G` and you know the values `v_1, \\ldots, v_n` on\n        the conjugacy class elements in\n        ``conjugacy_classes_representatives(G)`` =\n        `[g_1, \\ldots, g_n]`. Since the irreducible characters\n        `\\rho_1, \\ldots, \\rho_n` of `G` form an\n        `E`-basis of the space of all class functions (`E`\n        a \"sufficiently large\" cyclotomic field), such a class function is\n        a linear combination of these basis elements,\n        `f = c_1 \\rho_1 + \\cdots + c_n \\rho_n`. To find\n        the coefficients `c_i`, you simply solve the linear system\n        ``character_table_values(G)`` `[v_1, ..., v_n] = [c_1, ..., c_n]`,\n        where `[v_1, \\ldots, v_n]` = ``character_table_values(G)`` `^{(-1)}[c_1, ..., c_n]`.\n\n        AUTHORS:\n\n        - David Joyner and William Stein (2006-01-04)\n\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "cohomology": {
                    "__doc__": "\n        Computes the group cohomology `H^n(G, F)`, where `F = \\ZZ`\n        if `p=0` and `F = \\ZZ / p \\ZZ` if `p > 0` is a prime.\n\n        Wraps HAP's ``GroupHomology`` function, written by Graham Ellis.\n\n        REQUIRES: GAP package HAP (in gap_packages-\\*.spkg).\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(4)\n            sage: G.cohomology(1,2)                            # optional - gap_packages\n            Multiplicative Abelian group isomorphic to C2\n            sage: G = SymmetricGroup(3)\n            sage: G.cohomology(5)                              # optional - gap_packages\n            Trivial Abelian group\n            sage: G.cohomology(5,2)                            # optional - gap_packages\n            Multiplicative Abelian group isomorphic to C2\n            sage: G.homology(5,3)                              # optional - gap_packages\n            Trivial Abelian group\n            sage: G.homology(5,4)                              # optional - gap_packages\n            Traceback (most recent call last):\n            ...\n            ValueError: p must be 0 or prime\n\n        This computes `H^4(S_3, \\ZZ)` and\n        `H^4(S_3, \\ZZ / 2 \\ZZ)`, respectively.\n\n        AUTHORS:\n\n        - David Joyner and Graham Ellis\n\n        REFERENCES:\n\n        - G. Ellis, 'Computing group resolutions', J. Symbolic\n          Computation. Vol.38, (2004)1077-1118 (Available at\n          http://hamilton.nuigalway.ie/).\n\n        - D. Joyner, 'A primer on computational group homology and\n          cohomology', http://front.math.ucdavis.edu/0706.0549.\n        ",
                    "args": [
                        "self",
                        "n",
                        "p"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n",
                            "p"
                        ],
                        null,
                        null,
                        [
                            0
                        ]
                    ]
                },
                "cohomology_part": {
                    "__doc__": "\n        Computes the p-part of the group cohomology `H^n(G, F)`,\n        where `F = \\ZZ` if `p=0` and `F = \\ZZ / p \\ZZ` if\n        `p > 0` is a prime.\n\n        Wraps HAP's Homology function, written\n        by Graham Ellis, applied to the `p`-Sylow subgroup of\n        `G`.\n\n        REQUIRES: GAP package HAP (in gap_packages-\\*.spkg).\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(5)\n            sage: G.cohomology_part(7,2)                   # optional - gap_packages\n            Multiplicative Abelian group isomorphic to C2 x C2 x C2\n            sage: G = SymmetricGroup(3)\n            sage: G.cohomology_part(2,3)                   # optional - gap_packages\n            Multiplicative Abelian group isomorphic to C3\n\n        AUTHORS:\n\n        - David Joyner and Graham Ellis\n        ",
                    "args": [
                        "self",
                        "n",
                        "p"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n",
                            "p"
                        ],
                        null,
                        null,
                        [
                            0
                        ]
                    ]
                },
                "commutator": {
                    "__doc__": "\n        Returns the commutator subgroup of a group, or of a pair of groups.\n\n        INPUT:\n\n        - ``other`` - default: ``None`` - a permutation group.\n\n        OUTPUT:\n\n        Let $G$ denote ``self``.  If ``other`` is ``None`` then this method\n        returns the subgroup of $G$ generated by the set of commutators,\n\n        .. MATH::\n\n            \\{[g_1,g_2]\\vert g_1, g_2\\in G\\} = \\{g_1^{-1}g_2^{-1}g_1g_2\\vert g_1, g_2\\in G\\}\n\n        Let $H$ denote ``other``, in the case that it is not ``None``.  Then\n        this method returns the group generated by the set of commutators,\n\n        .. MATH::\n\n            \\{[g,h]\\vert g\\in G\\, h\\in H\\} = \\{g^{-1}h^{-1}gh\\vert  g\\in G\\, h\\in H\\}\n\n        The two groups need only be permutation groups, there is no notion\n        of requiring them to explicitly be subgroups of some other group.\n\n        .. note::\n\n            For the identical statement, the generators of the returned\n            group can vary from one execution to the next.\n\n        EXAMPLES::\n\n            sage: G = DiCyclicGroup(4)\n            sage: G.commutator()\n            Permutation Group with generators [(1,3,5,7)(2,4,6,8)(9,11,13,15)(10,12,14,16)]\n\n            sage: G = SymmetricGroup(5)\n            sage: H = CyclicPermutationGroup(5)\n            sage: C = G.commutator(H)\n            sage: C.is_isomorphic(AlternatingGroup(5))\n            True\n\n        An abelian group will have a trivial commutator.  ::\n\n            sage: G = CyclicPermutationGroup(10)\n            sage: G.commutator()\n            Permutation Group with generators [()]\n\n        The quotient of a group by its commutator is always abelian.  ::\n\n            sage: G = DihedralGroup(20)\n            sage: C = G.commutator()\n            sage: Q = G.quotient(C)\n            sage: Q.is_abelian()\n            True\n\n        When forming commutators from two groups, the order of the\n        groups does not matter.  ::\n\n            sage: D = DihedralGroup(3)\n            sage: S = SymmetricGroup(2)\n            sage: C1 = D.commutator(S); C1\n            Permutation Group with generators [(1,2,3)]\n            sage: C2 = S.commutator(D); C2\n            Permutation Group with generators [(1,3,2)]\n            sage: C1 == C2\n            True\n\n        This method calls two different functions in GAP, so\n        this tests that their results are consistent.  The\n        commutator groups may have different generators, but the\n        groups are equal. ::\n\n            sage: G = DiCyclicGroup(3)\n            sage: C = G.commutator(); C\n            Permutation Group with generators [(5,7,6)]\n            sage: CC = G.commutator(G); CC\n            Permutation Group with generators [(5,6,7)]\n            sage: C == CC\n            True\n\n        The second group is checked.  ::\n\n            sage: G = SymmetricGroup(2)\n            sage: G.commutator('junk')\n            Traceback (most recent call last):\n            ...\n            TypeError: junk is not a permutation group\n        ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "composition_series": {
                    "__doc__": "\n        Return the composition series of this group as a list of\n        permutation groups.\n\n        EXAMPLES:\n\n        These computations use pseudo-random numbers, so we set\n        the seed for reproducible testing.\n\n        ::\n\n            sage: set_random_seed(0)\n            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])\n            sage: G.composition_series()  # random output\n            [Permutation Group with generators [(1,2,3)(4,5), (3,4)], Permutation Group with generators [(1,5)(3,4), (1,5)(2,3), (1,5,4)], Permutation Group with generators [()]]\n            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])\n            sage: CS = G.composition_series()\n            sage: CS[3]\n            Subgroup of (Permutation Group with generators [(1,2), (1,2,3)(4,5)]) generated by [()]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "conjugacy_class": {
                    "__doc__": "\n        Return the conjugacy class of ``g`` inside the group ``self``.\n\n        INPUT:\n\n        - ``g`` -- an element of the permutation group ``self``\n\n        OUTPUT:\n\n        The conjugacy class of ``g`` in the group ``self``. If ``self`` is\n        the group denoted by `G`, this method computes the set\n        `\\{x^{-1}gx\\ \\vert\\ x \\in G \\}`\n\n        EXAMPLES::\n\n            sage: G = DihedralGroup(3)\n            sage: g = G.gen(0)\n            sage: G.conjugacy_class(g)\n            Conjugacy class of (1,2,3) in Dihedral group of order 6 as a permutation group\n        ",
                    "args": [
                        "self",
                        "g"
                    ],
                    "argspec": [
                        [
                            "self",
                            "g"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "conjugacy_classes": {
                    "__doc__": "\n        Return a list with all the conjugacy classes of ``self``.\n\n        EXAMPLES::\n\n            sage: G = DihedralGroup(3)\n            sage: G.conjugacy_classes()\n            [Conjugacy class of () in Dihedral group of order 6 as a permutation group,\n             Conjugacy class of (2,3) in Dihedral group of order 6 as a permutation group,\n             Conjugacy class of (1,2,3) in Dihedral group of order 6 as a permutation group]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "conjugacy_classes_representatives": {
                    "__doc__": "\n        Returns a complete list of representatives of conjugacy classes in\n        a permutation group `G`.\n\n        The ordering is that given by GAP.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])\n            sage: cl = G.conjugacy_classes_representatives(); cl\n            [(), (2,4), (1,2)(3,4), (1,2,3,4), (1,3)(2,4)]\n            sage: cl[3] in G\n            True\n\n        ::\n\n            sage: G = SymmetricGroup(5)\n            sage: G.conjugacy_classes_representatives()\n            [(), (1,2), (1,2)(3,4), (1,2,3), (1,2,3)(4,5), (1,2,3,4), (1,2,3,4,5)]\n\n        ::\n\n            sage: S = SymmetricGroup(['a','b','c'])\n            sage: S.conjugacy_classes_representatives()\n            [(), ('a','b'), ('a','b','c')]\n\n        AUTHORS:\n\n        - David Joyner and William Stein (2006-01-04)\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "conjugacy_classes_subgroups": {
                    "__doc__": "\n        Returns a complete list of representatives of conjugacy classes of\n        subgroups in a permutation group `G`.\n\n        The ordering is that given by GAP.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])\n            sage: cl = G.conjugacy_classes_subgroups()\n            sage: cl\n            [Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [()], Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(1,2)(3,4)], Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(1,3)(2,4)], Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(2,4)], Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(1,2)(3,4), (1,4)(2,3)], Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(2,4), (1,3)(2,4)], Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(1,2,3,4), (1,3)(2,4)], Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(2,4), (1,2)(3,4), (1,4)(2,3)]]\n\n        ::\n\n            sage: G = SymmetricGroup(3)\n            sage: G.conjugacy_classes_subgroups()\n            [Subgroup of (Symmetric group of order 3! as a permutation group) generated by [()], Subgroup of (Symmetric group of order 3! as a permutation group) generated by [(2,3)], Subgroup of (Symmetric group of order 3! as a permutation group) generated by [(1,2,3)], Subgroup of (Symmetric group of order 3! as a permutation group) generated by [(2,3), (1,2,3)]]\n\n        AUTHORS:\n\n        - David Joyner (2006-10)\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "conjugate": {
                    "__doc__": "\n        Returns the group formed by conjugating ``self`` with ``g``.\n\n        INPUT:\n\n        - ``g`` - a permutation group element, or an object that converts\n          to a permutation group element, such as a list of integers or\n          a string of cycles.\n\n        OUTPUT:\n\n        If ``self`` is the group denoted by `H`, then this method computes\n        the group\n\n        .. MATH::\n\n            g^{-1}Hg = \\{g^{-1}hg\\vert h\\in H\\}\n\n        which is the group `H` conjugated by `g`.\n\n        There are no restrictions on ``self`` and ``g`` belonging to\n        a common permutation group, and correspondingly, there is no\n        relationship (such as a common parent) between ``self`` and the\n        output group.\n\n        EXAMPLES::\n\n            sage: G = DihedralGroup(6)\n            sage: a = PermutationGroupElement(\"(1,2,3,4)\")\n            sage: G.conjugate(a)\n            Permutation Group with generators [(1,4)(2,6)(3,5), (1,5,6,2,3,4)]\n\n        The element performing the conjugation can be specified in\n        several ways.  ::\n\n            sage: G = DihedralGroup(6)\n            sage: strng = \"(1,2,3,4)\"\n            sage: G.conjugate(strng)\n            Permutation Group with generators [(1,4)(2,6)(3,5), (1,5,6,2,3,4)]\n            sage: G = DihedralGroup(6)\n            sage: lst = [2,3,4,1]\n            sage: G.conjugate(lst)\n            Permutation Group with generators [(1,4)(2,6)(3,5), (1,5,6,2,3,4)]\n            sage: G = DihedralGroup(6)\n            sage: cycles = [(1,2,3,4)]\n            sage: G.conjugate(cycles)\n            Permutation Group with generators [(1,4)(2,6)(3,5), (1,5,6,2,3,4)]\n\n        Conjugation is a group automorphism, so conjugate groups\n        will be isomorphic. ::\n\n            sage: G = DiCyclicGroup(6)\n            sage: G.degree()\n            11\n            sage: cycle = [i+1 for i in range(1,11)] + [1]\n            sage: C = G.conjugate(cycle)\n            sage: G.is_isomorphic(C)\n            True\n\n        The conjugating element may be from a symmetric group with\n        larger degree than the group being conjugated.  ::\n\n            sage: G = AlternatingGroup(5)\n            sage: G.degree()\n            5\n            sage: g = \"(1,3)(5,6,7)\"\n            sage: H = G.conjugate(g); H\n            Permutation Group with generators [(1,4,6,3,2), (1,4,6)]\n            sage: H.degree()\n            6\n\n        The conjugating element is checked. ::\n\n            sage: G = SymmetricGroup(3)\n            sage: G.conjugate(\"junk\")\n            Traceback (most recent call last):\n            ...\n            TypeError: junk does not convert to a permutation group element\n        ",
                    "args": [
                        "self",
                        "g"
                    ],
                    "argspec": [
                        [
                            "self",
                            "g"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "cosets": {
                    "__doc__": "\n        Returns a list of the cosets of ``S`` in ``self``.\n\n        INPUT:\n\n        - ``S`` - a subgroup of ``self``.  An error is raised\n          if ``S`` is not a subgroup.\n\n        - ``side`` - default: 'right' - determines if right cosets or\n          left cosets are returned.  ``side`` refers to where the\n          representative is placed in the products forming the cosets\n          and thus allowable values are only 'right' and 'left'.\n\n        OUTPUT:\n\n        A list of lists.  Each inner list is a coset of the subgroup\n        in the group.  The first element of each coset is the smallest\n        element (based on the ordering of the elements of ``self``)\n        of all the group elements that have not yet appeared in a\n        previous coset. The elements of each coset are in the same\n        order as the subgroup elements used to build the coset's\n        elements.\n\n        As a consequence, the subgroup itself is the first coset,\n        and its first element is the identity element.  For each coset,\n        the first element listed is the element used as a representative\n        to build the coset.  These representatives form an increasing\n        sequence across the list of cosets, and within a coset the\n        representative is the smallest element of its coset (both\n        orderings are based on of the ordering of elements of ``self``).\n\n        In the case of a normal subgroup, left and right cosets should\n        appear in the same order as part of the outer list.  However,\n        the list of the elements of a particular coset may be in a\n        different order for the right coset versus the order in the\n        left coset. So, if you check to see if a subgroup is normal,\n        it is necessary to sort each individual coset first (but not\n        the list of cosets, due to the ordering of the representatives).\n        See below for examples of this.\n\n        .. note::\n\n            This is a naive implementation intended for instructional\n            purposes, and hence is slow for larger groups.  Sage and GAP\n            provide more sophisticated functions for working quickly with\n            cosets of larger groups.\n\n        EXAMPLES:\n\n        The default is to build right cosets. This example works with\n        the symmetry group of an 8-gon and a normal subgroup.\n        Notice that a straight check on the equality of the output\n        is not sufficient to check normality, while sorting the\n        individual cosets is sufficient to then simply test equality of\n        the list of lists.  Study the second coset in each list to understand the\n        need for sorting the elements of the cosets.  ::\n\n            sage: G = DihedralGroup(8)\n            sage: quarter_turn = G('(1,3,5,7)(2,4,6,8)'); quarter_turn\n            (1,3,5,7)(2,4,6,8)\n            sage: S = G.subgroup([quarter_turn])\n            sage: rc = G.cosets(S); rc\n            [[(), (1,3,5,7)(2,4,6,8), (1,5)(2,6)(3,7)(4,8), (1,7,5,3)(2,8,6,4)],\n             [(2,8)(3,7)(4,6), (1,7)(2,6)(3,5), (1,5)(2,4)(6,8), (1,3)(4,8)(5,7)],\n             [(1,2)(3,8)(4,7)(5,6), (1,8)(2,7)(3,6)(4,5), (1,6)(2,5)(3,4)(7,8), (1,4)(2,3)(5,8)(6,7)],\n             [(1,2,3,4,5,6,7,8), (1,4,7,2,5,8,3,6), (1,6,3,8,5,2,7,4), (1,8,7,6,5,4,3,2)]]\n            sage: lc = G.cosets(S, side='left'); lc\n            [[(), (1,3,5,7)(2,4,6,8), (1,5)(2,6)(3,7)(4,8), (1,7,5,3)(2,8,6,4)],\n             [(2,8)(3,7)(4,6), (1,3)(4,8)(5,7), (1,5)(2,4)(6,8), (1,7)(2,6)(3,5)],\n             [(1,2)(3,8)(4,7)(5,6), (1,4)(2,3)(5,8)(6,7), (1,6)(2,5)(3,4)(7,8), (1,8)(2,7)(3,6)(4,5)],\n             [(1,2,3,4,5,6,7,8), (1,4,7,2,5,8,3,6), (1,6,3,8,5,2,7,4), (1,8,7,6,5,4,3,2)]]\n\n            sage: S.is_normal(G)\n            True\n            sage: rc == lc\n            False\n            sage: rc_sorted = [sorted(c) for c in rc]\n            sage: lc_sorted = [sorted(c) for c in lc]\n            sage: rc_sorted == lc_sorted\n            True\n\n        An example with the symmetry group of a regular\n        tetrahedron and a subgroup that is not normal.\n        Thus, the right and left cosets are different\n        (and so are the representatives). With each\n        individual coset sorted, a naive test of normality\n        is possible.  ::\n\n            sage: A = AlternatingGroup(4)\n            sage: face_turn = A('(1,2,3)'); face_turn\n            (1,2,3)\n            sage: stabilizer = A.subgroup([face_turn])\n            sage: rc = A.cosets(stabilizer, side='right'); rc\n            [[(), (1,2,3), (1,3,2)],\n             [(2,3,4), (1,3)(2,4), (1,4,2)],\n             [(2,4,3), (1,4,3), (1,2)(3,4)],\n             [(1,2,4), (1,4)(2,3), (1,3,4)]]\n            sage: lc = A.cosets(stabilizer, side='left'); lc\n            [[(), (1,2,3), (1,3,2)],\n             [(2,3,4), (1,2)(3,4), (1,3,4)],\n             [(2,4,3), (1,2,4), (1,3)(2,4)],\n             [(1,4,2), (1,4,3), (1,4)(2,3)]]\n\n            sage: stabilizer.is_normal(A)\n            False\n            sage: rc_sorted = [sorted(c) for c in rc]\n            sage: lc_sorted = [sorted(c) for c in lc]\n            sage: rc_sorted == lc_sorted\n            False\n\n        TESTS:\n\n        The keyword ``side`` is checked for the two possible values. ::\n\n            sage: G = SymmetricGroup(3)\n            sage: S = G.subgroup([G(\"(1,2)\")])\n            sage: G.cosets(S, side='junk')\n            Traceback (most recent call last):\n            ...\n            ValueError: side should be 'right' or 'left', not junk\n\n        The subgroup argument is checked to see if it is a permutation group.\n        Even a legitimate GAP object can be rejected. ::\n\n            sage: G=SymmetricGroup(3)\n            sage: G.cosets(gap(3))\n            Traceback (most recent call last):\n            ...\n            TypeError: 3 is not a permutation group\n\n        The subgroup is verified as a subgroup of ``self``. ::\n\n            sage: A = AlternatingGroup(3)\n            sage: G = SymmetricGroup(3)\n            sage: S = G.subgroup([G(\"(1,2)\")])\n            sage: A.cosets(S)\n            Traceback (most recent call last):\n            ...\n            ValueError: Subgroup of (Symmetric group of order 3! as a permutation group) generated by [(1,2)] is not a subgroup of Alternating group of order 3!/2 as a permutation group\n\n        AUTHOR:\n\n        - Rob Beezer (2011-01-31)\n        ",
                    "args": [
                        "self",
                        "S",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "degree": {
                    "__doc__": "\n        Returns the degree of this permutation group.\n\n        EXAMPLES::\n\n            sage: S = SymmetricGroup(['a','b','c'])\n            sage: S.degree()\n            3\n            sage: G = PermutationGroup([(1,3),(4,5)])\n            sage: G.degree()\n            5\n\n        Note that you can explicitly specify the domain to get a\n        permutation group of smaller degree::\n\n            sage: G = PermutationGroup([(1,3),(4,5)], domain=[1,3,4,5])\n            sage: G.degree()\n            4\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "derived_series": {
                    "__doc__": "\n        Return the derived series of this group as a list of permutation\n        groups.\n\n        EXAMPLES:\n\n        These computations use pseudo-random numbers, so we set\n        the seed for reproducible testing.\n\n        ::\n\n            sage: set_random_seed(0)\n            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])\n            sage: G.derived_series()  # random output\n            [Permutation Group with generators [(1,2,3)(4,5), (3,4)], Permutation Group with generators [(1,5)(3,4), (1,5)(2,4), (2,4)(3,5)]]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "direct_product": {
                    "__doc__": "\n        Wraps GAP's ``DirectProduct``, ``Embedding``, and ``Projection``.\n\n        Sage calls GAP's ``DirectProduct``, which chooses an efficient\n        representation for the direct product. The direct product of\n        permutation groups will be a permutation group again. For a direct\n        product ``D``, the GAP operation ``Embedding(D,i)`` returns the\n        homomorphism embedding the i-th factor into ``D``. The GAP operation\n        ``Projection(D,i)`` gives the projection of ``D`` onto the i-th factor.\n        This method returns a 5-tuple: a permutation group and 4 morphisms.\n\n        INPUT:\n\n        -  ``self, other`` - permutation groups\n\n        OUTPUT:\n\n        -  ``D`` - a direct product of the inputs, returned as\n           a permutation group as well\n\n        -  ``iota1`` - an embedding of ``self`` into ``D``\n\n        -  ``iota2`` - an embedding of ``other`` into ``D``\n\n        -  ``pr1`` - the projection of ``D`` onto ``self`` (giving a\n           splitting 1 - other - D - self - 1)\n\n        -  ``pr2`` - the projection of ``D`` onto ``other`` (giving a\n           splitting 1 - self - D - other - 1)\n\n        EXAMPLES::\n\n            sage: G = CyclicPermutationGroup(4)\n            sage: D = G.direct_product(G,False)\n            sage: D\n            Permutation Group with generators [(5,6,7,8), (1,2,3,4)]\n            sage: D,iota1,iota2,pr1,pr2 = G.direct_product(G)\n            sage: D; iota1; iota2; pr1; pr2\n            Permutation Group with generators [(5,6,7,8), (1,2,3,4)]\n            Permutation group morphism:\n              From: Cyclic group of order 4 as a permutation group\n              To:   Permutation Group with generators [(5,6,7,8), (1,2,3,4)]\n              Defn: Embedding( Group( [ (1,2,3,4), (5,6,7,8) ] ), 1 )\n            Permutation group morphism:\n              From: Cyclic group of order 4 as a permutation group\n              To:   Permutation Group with generators [(5,6,7,8), (1,2,3,4)]\n              Defn: Embedding( Group( [ (1,2,3,4), (5,6,7,8) ] ), 2 )\n            Permutation group morphism:\n              From: Permutation Group with generators [(5,6,7,8), (1,2,3,4)]\n              To:   Cyclic group of order 4 as a permutation group\n              Defn: Projection( Group( [ (1,2,3,4), (5,6,7,8) ] ), 1 )\n            Permutation group morphism:\n              From: Permutation Group with generators [(5,6,7,8), (1,2,3,4)]\n              To:   Cyclic group of order 4 as a permutation group\n              Defn: Projection( Group( [ (1,2,3,4), (5,6,7,8) ] ), 2 )\n            sage: g=D([(1,3),(2,4)]); g\n            (1,3)(2,4)\n            sage: d=D([(1,4,3,2),(5,7),(6,8)]); d\n            (1,4,3,2)(5,7)(6,8)\n            sage: iota1(g); iota2(g); pr1(d); pr2(d)\n            (1,3)(2,4)\n            (5,7)(6,8)\n            (1,4,3,2)\n            (1,3)(2,4)\n        ",
                    "args": [
                        "self",
                        "other",
                        "maps"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other",
                            "maps"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "domain": {
                    "__doc__": "\n        Returns the underlying set that this permutation group acts\n        on.\n\n        EXAMPLES::\n\n            sage: P = PermutationGroup([(1,2),(3,5)])\n            sage: P.domain()\n            {1, 2, 3, 4, 5}\n            sage: S = SymmetricGroup(['a', 'b', 'c'])\n            sage: S.domain()\n            {'a', 'b', 'c'}\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "exponent": {
                    "__doc__": "\n        Computes the exponent of the group.\n\n        The exponent `e` of a group `G` is the LCM of the orders of its\n        elements, that is, `e` is the smallest integer such that `g^e=1` for all\n        `g \\in G`.\n\n        EXAMPLES::\n\n            sage: G = AlternatingGroup(4)\n            sage: G.exponent()\n            6\n\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "fitting_subgroup": {
                    "__doc__": "\n        Returns the Fitting subgroup of ``self``.\n\n        The Fitting subgroup of a group $G$ is the largest nilpotent normal\n        subgroup of `G`.\n\n        EXAMPLES::\n\n            sage: G=PermutationGroup([[(1,2,3,4)],[(2,4)]])\n            sage: G.fitting_subgroup()\n            Subgroup of (Permutation Group with generators [(2,4), (1,2,3,4)]) generated by [(2,4), (1,2,3,4), (1,3)]\n            sage: G=PermutationGroup([[(1,2,3,4)],[(1,2)]])\n            sage: G.fitting_subgroup()\n            Subgroup of (Permutation Group with generators [(1,2), (1,2,3,4)]) generated by [(1,2)(3,4), (1,3)(2,4)]\n\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "fixed_points": {
                    "__doc__": "\n        Return the list of points fixed by ``self``, i.e., the subset\n        of ``.domain()`` not moved by any element of ``self``.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([(1,2,3)])\n            sage: G.fixed_points()\n            []\n            sage: G = PermutationGroup([(1,2,3),(5,6)])\n            sage: G.fixed_points()\n            [4]\n            sage: G = PermutationGroup([[(1,4,7)],[(4,3),(6,7)]])\n            sage: G.fixed_points()\n            [2, 5]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "frattini_subgroup": {
                    "__doc__": "\n        Returns the Frattini subgroup of ``self``.\n\n        The Frattini subgroup of a group $G$ is the intersection of all maximal\n        subgroups of `G`.\n\n        EXAMPLES::\n\n            sage: G=PermutationGroup([[(1,2,3,4)],[(2,4)]])\n            sage: G.frattini_subgroup()\n            Subgroup of (Permutation Group with generators [(2,4), (1,2,3,4)]) generated by [(1,3)(2,4)]\n            sage: G=SymmetricGroup(4)\n            sage: G.frattini_subgroup()\n            Subgroup of (Symmetric group of order 4! as a permutation group) generated by [()]\n\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "gens_small": {
                    "__doc__": "\n        For this group, returns a generating set which has few elements.\n        As neither irredundancy nor minimal length is proven, it is fast.\n\n        EXAMPLES::\n\n            sage: R = \"(25,27,32,30)(26,29,31,28)( 3,38,43,19)( 5,36,45,21)( 8,33,48,24)\" ## R = right\n            sage: U = \"( 1, 3, 8, 6)( 2, 5, 7, 4)( 9,33,25,17)(10,34,26,18)(11,35,27,19)\" ## U = top\n            sage: L = \"( 9,11,16,14)(10,13,15,12)( 1,17,41,40)( 4,20,44,37)( 6,22,46,35)\" ## L = left\n            sage: F = \"(17,19,24,22)(18,21,23,20)( 6,25,43,16)( 7,28,42,13)( 8,30,41,11)\" ## F = front\n            sage: B = \"(33,35,40,38)(34,37,39,36)( 3, 9,46,32)( 2,12,47,29)( 1,14,48,27)\" ## B = back or rear\n            sage: D = \"(41,43,48,46)(42,45,47,44)(14,22,30,38)(15,23,31,39)(16,24,32,40)\" ## D = down or bottom\n            sage: G = PermutationGroup([R,L,U,F,B,D])\n            sage: len(G.gens_small())\n            2\n\n        The output may be unpredictable, due to the use of randomized\n        algorithms in GAP. Note that both the following answers are equally valid.\n\n        ::\n\n            sage: G = PermutationGroup([[('a','b')], [('b', 'c')], [('a', 'c')]])\n            sage: G.gens_small() # random\n            [('b','c'), ('a','c','b')] ## (on 64-bit Linux)\n            [('a','b'), ('a','c','b')] ## (on Solaris)\n            sage: len(G.gens_small()) == 2\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "group_id": {
                    "__doc__": "\n        Return the ID code of this group, which is a list of two integers.\n        Requires \"optional\" database_gap-4.4.x package.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])\n            sage: G.group_id()    # optional - database_gap\n            [12, 4]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "group_primitive_id": {
                    "__doc__": "\n        Return the index of this group in the GAP database of primitive groups.\n\n        Requires \"optional\" database_gap-4.4.x package.\n\n        OUTPUT:\n\n        A positive integer, following GAP's conventions. A\n        ``ValueError`` is raised if the group is not primitive.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3,4,5)], [(1,5),(2,4)]])\n            sage: G.group_primitive_id()    # optional - database_gap\n            2\n            sage: G.degree()\n            5\n\n        From the information of the degree and the identification number,\n        you can recover the isomorphism class of your group in the GAP\n        database::\n\n            sage: H = PrimitiveGroup(5,2)  # optional - database_gap\n            sage: G == H                     # optional - database_gap\n            False\n            sage: G.is_isomorphic(H)         # optional - database_gap\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "has_element": {
                    "__doc__": "\n        Returns boolean value of ``item in self`` - however *ignores*\n        parentage.\n\n        EXAMPLES::\n\n            sage: G = CyclicPermutationGroup(4)\n            sage: gens = G.gens()\n            sage: H = DihedralGroup(4)\n            sage: g = G([(1,2,3,4)]); g\n            (1,2,3,4)\n            sage: G.has_element(g)\n            True\n            sage: h = H([(1,2),(3,4)]); h\n            (1,2)(3,4)\n            sage: G.has_element(h)\n            False\n        ",
                    "args": [
                        "self",
                        "item"
                    ],
                    "argspec": [
                        [
                            "self",
                            "item"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "has_regular_subgroup": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "holomorph": {
                    "__doc__": "\n        The holomorph of a group as a permutation group.\n\n        The holomorph of a group `G` is the semidirect product\n        `G \\rtimes_{id} Aut(G)`, where `id` is the identity function\n        on `Aut(G)`, the automorphism group of `G`.\n\n        See :wikipedia:`Holomorph (mathematics)`\n\n        OUTPUT:\n\n        Returns the holomorph of a given group as permutation group\n        via a wrapping of GAP's semidirect product function.\n\n        EXAMPLES:\n\n        Thomas and Wood's 'Group Tables' (Shiva Publishing, 1980) tells\n        us that the holomorph of `C_5` is the unique group of order 20\n        with a trivial center. ::\n\n            sage: C5 = CyclicPermutationGroup(5)\n            sage: A = C5.holomorph()\n            sage: A.order()\n            20\n            sage: A.is_abelian()\n            False\n            sage: A.center()\n            Subgroup of (Permutation Group with generators\n            [(5,6,7,8,9), (1,2,4,3)(6,7,9,8)]) generated by [()]\n            sage: A\n            Permutation Group with generators [(5,6,7,8,9), (1,2,4,3)(6,7,9,8)]\n\n        Noting that the automorphism group of `D_4` is itself `D_4`, it\n        can easily be shown that the holomorph is indeed an internal\n        semidirect product of these two groups. ::\n\n            sage: D4 = DihedralGroup(4)\n            sage: H = D4.holomorph()\n            sage: H.gens()\n            [(3,8)(4,7), (2,3,5,8), (2,5)(3,8), (1,4,6,7)(2,3,5,8), (1,8)(2,7)(3,6)(4,5)]\n            sage: G = H.subgroup([H.gens()[0],H.gens()[1],H.gens()[2]])\n            sage: N = H.subgroup([H.gens()[3],H.gens()[4]])\n            sage: N.is_normal(H)\n            True\n            sage: G.is_isomorphic(D4)\n            True\n            sage: N.is_isomorphic(D4)\n            True\n            sage: G.intersection(N)\n            Permutation Group with generators [()]\n            sage: L = [H(x)*H(y) for x in G for y in N]; L.sort()\n            sage: L1 = H.list(); L1.sort()\n            sage: L == L1\n            True\n\n        Author:\n\n        - Kevin Halasz (2012-08-14)\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homology": {
                    "__doc__": "\n        Computes the group homology `H_n(G, F)`, where\n        `F = \\ZZ` if `p=0` and `F = \\ZZ / p \\ZZ` if\n        `p > 0` is a prime. Wraps HAP's ``GroupHomology`` function,\n        written by Graham Ellis.\n\n        REQUIRES: GAP package HAP (in gap_packages-\\*.spkg).\n\n        AUTHORS:\n\n        - David Joyner and Graham Ellis\n\n        The example below computes `H_7(S_5, \\ZZ)`,\n        `H_7(S_5, \\ZZ / 2 \\ZZ)`,\n        `H_7(S_5, \\ZZ / 3 \\ZZ)`, and\n        `H_7(S_5, \\ZZ / 5 \\ZZ)`, respectively. To compute the\n        `2`-part of `H_7(S_5, \\ZZ)`, use the ``homology_part``\n        function.\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(5)\n            sage: G.homology(7)                              # optional - gap_packages\n            Multiplicative Abelian group isomorphic to C2 x C2 x C4 x C3 x C5\n            sage: G.homology(7,2)                              # optional - gap_packages\n            Multiplicative Abelian group isomorphic to C2 x C2 x C2 x C2 x C2\n            sage: G.homology(7,3)                              # optional - gap_packages\n            Multiplicative Abelian group isomorphic to C3\n            sage: G.homology(7,5)                              # optional - gap_packages\n            Multiplicative Abelian group isomorphic to C5\n\n        REFERENCES:\n\n        - G. Ellis, \"Computing group resolutions\", J. Symbolic\n          Computation. Vol.38, (2004)1077-1118 (Available at\n          http://hamilton.nuigalway.ie/.\n\n        - D. Joyner, \"A primer on computational group homology and cohomology\",\n          http://front.math.ucdavis.edu/0706.0549\n        ",
                    "args": [
                        "self",
                        "n",
                        "p"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n",
                            "p"
                        ],
                        null,
                        null,
                        [
                            0
                        ]
                    ]
                },
                "homology_part": {
                    "__doc__": "\n        Computes the `p`-part of the group homology\n        `H_n(G, F)`, where `F = \\ZZ` if `p=0` and\n        `F = \\ZZ / p \\ZZ` if `p > 0` is a prime. Wraps HAP's\n        ``Homology`` function, written by Graham Ellis, applied to the\n        `p`-Sylow subgroup of `G`.\n\n        REQUIRES: GAP package HAP (in gap_packages-\\*.spkg).\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(5)\n            sage: G.homology_part(7,2)                              # optional - gap_packages\n            Multiplicative Abelian group isomorphic to C2 x C2 x C2 x C2 x C4\n\n        AUTHORS:\n\n        - David Joyner and Graham Ellis\n        ",
                    "args": [
                        "self",
                        "n",
                        "p"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n",
                            "p"
                        ],
                        null,
                        null,
                        [
                            0
                        ]
                    ]
                },
                "id": {
                    "__doc__": "\n        (Same as ``self.group_id()``.) Return the ID code of this group, which\n        is a list of two integers. Requires \"optional\" database_gap-4.4.x\n        package.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3),(4,5)], [(1,2)]])\n            sage: G.group_id()    # optional - database_gap\n            [12, 4]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "identity": {
                    "__doc__": "\n        Return the identity element of this group.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3),(4,5)]])\n            sage: e = G.identity()\n            sage: e\n            ()\n            sage: g = G.gen(0)\n            sage: g*e\n            (1,2,3)(4,5)\n            sage: e*g\n            (1,2,3)(4,5)\n\n            sage: S = SymmetricGroup(['a','b','c'])\n            sage: S.identity()\n            ()\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "intersection": {
                    "__doc__": "\n        Returns the permutation group that is the intersection of\n        ``self`` and ``other``.\n\n        INPUT:\n\n        - ``other`` - a permutation group.\n\n        OUTPUT:\n\n        A permutation group that is the set-theoretic intersection of ``self``\n        with ``other``.  The groups are viewed as subgroups of a symmetric\n        group big enough to contain both group's symbol sets.  So there is\n        no strict notion of the two groups being subgroups of a common parent.\n\n        EXAMPLES::\n\n            sage: H = DihedralGroup(4)\n\n            sage: K = CyclicPermutationGroup(4)\n            sage: H.intersection(K)\n            Permutation Group with generators [(1,2,3,4)]\n\n            sage: L = DihedralGroup(5)\n            sage: H.intersection(L)\n            Permutation Group with generators [(1,4)(2,3)]\n\n            sage: M = PermutationGroup([\"()\"])\n            sage: H.intersection(M)\n            Permutation Group with generators [()]\n\n        Some basic properties. ::\n\n            sage: H = DihedralGroup(4)\n            sage: L = DihedralGroup(5)\n            sage: H.intersection(L) == L.intersection(H)\n            True\n            sage: H.intersection(H) == H\n            True\n\n        The group ``other`` is verified as such.  ::\n\n            sage: H = DihedralGroup(4)\n            sage: H.intersection('junk')\n            Traceback (most recent call last):\n            ...\n            TypeError: junk is not a permutation group\n        ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "irreducible_characters": {
                    "__doc__": "\n        Returns a list of the irreducible characters of ``self``.\n\n        EXAMPLES::\n\n            sage: irr = SymmetricGroup(3).irreducible_characters()\n            sage: [x.values() for x in irr]\n            [[1, -1, 1], [2, 0, -1], [1, 1, 1]]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_cyclic": {
                    "__doc__": "\n        Return ``True`` if this group is cyclic.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])\n            sage: G.is_cyclic()\n            False\n            sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: G.is_cyclic()\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_elementary_abelian": {
                    "__doc__": "\n        Return ``True`` if this group is elementary abelian. An elementary\n        abelian group is a finite abelian group, where every nontrivial\n        element has order `p`, where `p` is a prime.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])\n            sage: G.is_elementary_abelian()\n            False\n            sage: G = PermutationGroup(['(1,2,3)','(4,5,6)'])\n            sage: G.is_elementary_abelian()\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_isomorphic": {
                    "__doc__": "\n        Return ``True`` if the groups are isomorphic.\n\n        INPUT:\n\n\n        -  ``self`` - this group\n\n        -  ``right`` - a permutation group\n\n\n        OUTPUT:\n\n        - boolean; ``True`` if ``self`` and ``right`` are isomorphic groups;\n          ``False`` otherwise.\n\n        EXAMPLES::\n\n            sage: v = ['(1,2,3)(4,5)', '(1,2,3,4,5)']\n            sage: G = PermutationGroup(v)\n            sage: H = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: G.is_isomorphic(H)\n            False\n            sage: G.is_isomorphic(G)\n            True\n            sage: G.is_isomorphic(PermutationGroup(list(reversed(v))))\n            True\n        ",
                    "args": [
                        "self",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_monomial": {
                    "__doc__": "\n        Returns ``True`` if the group is monomial. A finite group is monomial\n        if every irreducible complex character is induced from a linear\n        character of a subgroup.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: G.is_monomial()\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_nilpotent": {
                    "__doc__": "\n        Return ``True`` if this group is nilpotent.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])\n            sage: G.is_nilpotent()\n            False\n            sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: G.is_nilpotent()\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_normal": {
                    "__doc__": "\n        Return ``True`` if this group is a normal subgroup of ``other``.\n\n        EXAMPLES::\n\n            sage: AlternatingGroup(4).is_normal(SymmetricGroup(4))\n            True\n            sage: H = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])\n            sage: H.is_normal(G)\n            False\n        ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_perfect": {
                    "__doc__": "\n        Return ``True`` if this group is perfect. A group is perfect if it\n        equals its derived subgroup.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])\n            sage: G.is_perfect()\n            False\n            sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: G.is_perfect()\n            False\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_pgroup": {
                    "__doc__": "\n        Returns ``True`` if this group is a `p`-group. A finite group is\n        a `p`-group if its order is of the form `p^n` for a prime integer\n        `p` and a nonnegative integer `n`.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3,4,5)'])\n            sage: G.is_pgroup()\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_polycyclic": {
                    "__doc__": "\n        Return ``True`` if this group is polycyclic. A group is polycyclic if\n        it has a subnormal series with cyclic factors. (For finite groups,\n        this is the same as if the group is solvable - see\n        ``is_solvable``.)\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])\n            sage: G.is_polycyclic()\n            False\n            sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: G.is_polycyclic()\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_primitive": {
                    "__doc__": "\n        Returns ``True`` if ``self`` acts primitively on ``domain``.\n        A group $G$ acts primitively on a set $S$ if\n\n        1. $G$ acts transitively on $S$ and\n\n        2. the action induces no non-trivial block system on $S$.\n\n        INPUT:\n\n        - ``domain`` (optional)\n\n        .. SEEALSO::\n\n            - :meth:`~PermutationGroup_generic.blocks_all`\n\n        EXAMPLES:\n\n        By default, test for primitivity of ``self`` on its domain::\n\n            sage: G = PermutationGroup([[(1,2,3,4)],[(1,2)]])\n            sage: G.is_primitive()\n            True\n            sage: G = PermutationGroup([[(1,2,3,4)],[(2,4)]])\n            sage: G.is_primitive()\n            False\n\n        You can specify a domain on which to test primitivity::\n\n            sage: G = PermutationGroup([[(1,2,3,4)],[(2,4)]])\n            sage: G.is_primitive([1..4])\n            False\n            sage: G.is_primitive([1,2,3])\n            True\n            sage: G = PermutationGroup([[(3,4,5,6)],[(3,4)]]) #S_4 on [3..6]\n            sage: G.is_primitive(G.non_fixed_points())\n            True\n\n        ",
                    "args": [
                        "self",
                        "domain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "domain"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "is_regular": {
                    "__doc__": "\n        Returns ``True`` if ``self`` acts regularly on ``domain``.\n        A group $G$ acts regularly on a set $S$ if\n\n        1. $G$ acts transitively on $S$ and\n        2. $G$ acts semi-regularly on $S$.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3,4)]])\n            sage: G.is_regular()\n            True\n            sage: G = PermutationGroup([[(1,2,3,4)],[(5,6)]])\n            sage: G.is_regular()\n            False\n\n        You can pass in a domain on which to test regularity::\n\n            sage: G = PermutationGroup([[(1,2,3,4)],[(5,6)]])\n            sage: G.is_regular([1..4])\n            True\n            sage: G.is_regular(G.non_fixed_points())\n            False\n\n        ",
                    "args": [
                        "self",
                        "domain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "domain"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "is_semi_regular": {
                    "__doc__": "\n        Returns ``True`` if ``self`` acts semi-regularly on ``domain``.\n        A group $G$ acts semi-regularly on a set $S$ if the point\n        stabilizers of $S$ in $G$ are trivial.\n\n        ``domain`` is optional and may take several forms. See examples.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3,4)]])\n            sage: G.is_semi_regular()\n            True\n            sage: G = PermutationGroup([[(1,2,3,4)],[(5,6)]])\n            sage: G.is_semi_regular()\n            False\n\n        You can pass in a domain to test semi-regularity::\n\n            sage: G = PermutationGroup([[(1,2,3,4)],[(5,6)]])\n            sage: G.is_semi_regular([1..4])\n            True\n            sage: G.is_semi_regular(G.non_fixed_points())\n            False\n\n        ",
                    "args": [
                        "self",
                        "domain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "domain"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "is_simple": {
                    "__doc__": "\n        Returns ``True`` if the group is simple. A group is simple if it has no\n        proper normal subgroups.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: G.is_simple()\n            False\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_solvable": {
                    "__doc__": "\n        Returns ``True`` if the group is solvable.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: G.is_solvable()\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_subgroup": {
                    "__doc__": "\n        Returns ``True`` if ``self`` is a subgroup of ``other``.\n\n        EXAMPLES::\n\n            sage: G = AlternatingGroup(5)\n            sage: H = SymmetricGroup(5)\n            sage: G.is_subgroup(H)\n            True\n        ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_supersolvable": {
                    "__doc__": "\n        Returns ``True`` if the group is supersolvable. A finite group is\n        supersolvable if it has a normal series with cyclic factors.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: G.is_supersolvable()\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_transitive": {
                    "__doc__": "\n        Returns ``True`` if ``self`` acts transitively on ``domain``.\n        A group $G$ acts transitively on set $S$ if for all `x,y\\in S`\n        there is some `g\\in G` such that `x^g=y`.\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(5)\n            sage: G.is_transitive()\n            True\n            sage: G = PermutationGroup(['(1,2)(3,4)(5,6)'])\n            sage: G.is_transitive()\n            False\n\n        ::\n\n            sage: G = PermutationGroup([[(1,2,3,4,5)],[(1,2)]]) #S_5 on [1..5]\n            sage: G.is_transitive([1,4,5])\n            True\n            sage: G.is_transitive([2..6])\n            False\n            sage: G.is_transitive(G.non_fixed_points())\n            True\n            sage: H = PermutationGroup([[(1,2,3)],[(4,5,6)]])\n            sage: H.is_transitive(H.non_fixed_points())\n            False\n\n        Note that this differs from the definition in GAP, where\n        ``IsTransitive`` returns whether the group is transitive on the\n        set of points moved by the group.\n\n        ::\n\n            sage: G = PermutationGroup([(2,3)])\n            sage: G.is_transitive()\n            False\n            sage: gap(G).IsTransitive()\n            true\n        ",
                    "args": [
                        "self",
                        "domain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "domain"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "isomorphism_to": {
                    "__doc__": "\n        Return an isomorphism from ``self`` to ``right`` if the groups\n        are isomorphic, otherwise ``None``.\n\n        INPUT:\n\n\n        -  ``self`` - this group\n\n        -  ``right`` - a permutation group\n\n\n        OUTPUT:\n\n        - ``None`` or a morphism of permutation groups.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])\n            sage: H = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: G.isomorphism_to(H) is None\n            True\n            sage: G = PermutationGroup([(1,2,3), (2,3)])\n            sage: H = PermutationGroup([(1,2,4), (1,4)])\n            sage: G.isomorphism_to(H)  # not tested, see below\n            Permutation group morphism:\n              From: Permutation Group with generators [(2,3), (1,2,3)]\n              To:   Permutation Group with generators [(1,2,4), (1,4)]\n              Defn: [(2,3), (1,2,3)] -> [(2,4), (1,2,4)]\n\n        TESTS:\n\n        Partial check that the output makes some sense::\n\n            sage: G.isomorphism_to(H)\n            Permutation group morphism:\n              From: Permutation Group with generators [(2,3), (1,2,3)]\n              To:   Permutation Group with generators [(1,2,4), (1,4)]\n              Defn: [(2,3), (1,2,3)] -> [...]\n        ",
                    "args": [
                        "self",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "isomorphism_type_info_simple_group": {
                    "__doc__": "\n        If the group is simple, then this returns the name of the group.\n\n        EXAMPLES::\n\n            sage: G = CyclicPermutationGroup(5)\n            sage: G.isomorphism_type_info_simple_group()\n            rec(\n              name := \"Z(5)\",\n              parameter := 5,\n              series := \"Z\" )\n\n        TESTS:\n\n        This shows that the issue at :trac:`7360` is fixed::\n\n            sage: G = KleinFourGroup()\n            sage: G.is_simple()\n            False\n            sage: G.isomorphism_type_info_simple_group()\n            Traceback (most recent call last):\n            ...\n            TypeError: Group must be simple.\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "largest_moved_point": {
                    "__doc__": "\n        Return the largest point moved by a permutation in this group.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])\n            sage: G.largest_moved_point()\n            4\n            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])\n            sage: G.largest_moved_point()\n            10\n\n        ::\n\n            sage: G = PermutationGroup([[('a','b','c'),('d','e')]])\n            sage: G.largest_moved_point()\n            'e'\n\n        .. warning::\n\n           The name of this function is not good; this function\n           should be deprecated in term of degree::\n\n                sage: P = PermutationGroup([[1,2,3,4]])\n                sage: P.largest_moved_point()\n                4\n                sage: P.cardinality()\n                1\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "list": {
                    "__doc__": "\n        Return list of all elements of this group.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3,4)], [(1,2)]])\n            sage: G.list()\n            [(), (1,2), (1,2,3,4), (1,3)(2,4), (1,3,4), (2,3,4), (1,4,3,2),\n             (1,3,2,4), (1,3,4,2), (1,2,4,3), (1,4,2,3), (2,4,3), (1,4,3),\n             (1,4)(2,3), (1,4,2), (1,3,2), (1,3), (3,4), (2,4), (1,4), (2,3),\n             (1,2)(3,4), (1,2,3), (1,2,4)]\n\n            sage: G = PermutationGroup([[('a','b')]], domain=('a', 'b')); G\n            Permutation Group with generators [('a','b')]\n            sage: G.list()\n            [(), ('a','b')]\n\n        TESTS:\n\n        Test :trac:`9155`::\n\n            sage: G = SymmetricGroup(2)\n            sage: elements = G.list()\n            sage: elements.remove(G(\"()\"))\n            sage: elements\n            [(1,2)]\n            sage: G.list()\n            [(), (1,2)]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "lower_central_series": {
                    "__doc__": "\n        Return the lower central series of this group as a list of\n        permutation groups.\n\n        EXAMPLES:\n\n        These computations use pseudo-random numbers, so we set\n        the seed for reproducible testing.\n\n        ::\n\n            sage: set_random_seed(0)\n            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])\n            sage: G.lower_central_series()  # random output\n            [Permutation Group with generators [(1,2,3)(4,5), (3,4)], Permutation Group with generators [(1,5)(3,4), (1,5)(2,3), (1,3)(2,4)]]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "minimal_generating_set": {
                    "__doc__": "\n        Return a minimal generating set\n\n        EXAMPLES::\n\n            sage: g = graphs.CompleteGraph(4)\n            sage: g.relabel(['a','b','c','d'])\n            sage: mgs = g.automorphism_group().minimal_generating_set(); len(mgs)\n            2\n            sage: mgs # random\n            [('b','d','c'), ('a','c','b','d')]\n\n\n        TESTS::\n\n            sage: PermutationGroup([\"(1,2,3)(4,5,6)\",\"(1,2,3,4,5,6)\"]).minimal_generating_set()\n            [(2,5)(3,6), (1,5,3,4,2,6)]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "molien_series": {
                    "__doc__": "\n        Return the Molien series of a permutation group. The\n        function\n\n        .. MATH::\n\n                     M(x) = (1/|G|)\\sum_{g\\in G} \\det(1-x*g)^{-1}\n\n        is sometimes called the \"Molien series\" of `G`. GAP's\n        ``MolienSeries`` is associated to a character of a\n        group `G`. How are these related? A group `G`, given as a permutation\n        group on `n` points, has a \"natural\" representation of dimension `n`,\n        given by permutation matrices. The Molien series of `G` is the one\n        associated to that permutation representation of `G` using the above\n        formula. Character values then count fixed points of the\n        corresponding permutations.\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(5)\n            sage: G.molien_series()\n            1/(-x^15 + x^14 + x^13 - x^10 - x^9 - x^8 + x^7 + x^6 + x^5 - x^2 - x + 1)\n            sage: G = SymmetricGroup(3)\n            sage: G.molien_series()\n            1/(-x^6 + x^5 + x^4 - x^2 - x + 1)\n\n        Some further tests (after :trac:`15817`)::\n\n            sage: G = PermutationGroup([[(1,2,3,4)]])\n            sage: S4ms = SymmetricGroup(4).molien_series()\n            sage: G.molien_series() / S4ms\n            x^5 + 2*x^4 + x^3 + x^2 + 1\n\n        This works for not-transitive groups::\n\n            sage: G = PermutationGroup([[(1,2)],[(3,4)]])\n            sage: G.molien_series() / S4ms\n            x^4 + x^3 + 2*x^2 + x + 1\n\n        This works for groups with fixed points::\n\n            sage: G = PermutationGroup([[(2,)]])\n            sage: G.molien_series()\n            1/(x^2 - 2*x + 1)\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "non_fixed_points": {
                    "__doc__": "\n        Return the list of points not fixed by ``self``, i.e., the subset\n        of ``self.domain()`` moved by some element of ``self``.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(3,4,5)],[(7,10)]])\n            sage: G.non_fixed_points()\n            [3, 4, 5, 7, 10]\n            sage: G = PermutationGroup([[(2,3,6)],[(9,)]]) # note: 9 is fixed\n            sage: G.non_fixed_points()\n            [2, 3, 6]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "normal_subgroups": {
                    "__doc__": "\n        Return the normal subgroups of this group as a (sorted in\n        increasing order) list of permutation groups.\n\n        The normal subgroups of `H = PSL(2,7) \\times PSL(2,7)` are\n        `1`, two copies of `PSL(2,7)` and `H`\n        itself, as the following example shows.\n\n        EXAMPLES::\n\n            sage: G = PSL(2,7)\n            sage: D = G.direct_product(G)\n            sage: H = D[0]\n            sage: NH = H.normal_subgroups()\n            sage: len(NH)\n            4\n            sage: NH[1].is_isomorphic(G)\n            True\n            sage: NH[2].is_isomorphic(G)\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "normalizer": {
                    "__doc__": "\n        Returns the normalizer of ``g`` in ``self``.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4)]])\n            sage: g = G([(1,3)])\n            sage: G.normalizer(g)\n            Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(2,4), (1,3)]\n            sage: g = G([(1,2,3,4)])\n            sage: G.normalizer(g)\n            Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(2,4), (1,2,3,4), (1,3)(2,4)]\n            sage: H = G.subgroup([G([(1,2,3,4)])])\n            sage: G.normalizer(H)\n            Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4)]) generated by [(2,4), (1,2,3,4), (1,3)(2,4)]\n        ",
                    "args": [
                        "self",
                        "g"
                    ],
                    "argspec": [
                        [
                            "self",
                            "g"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "normalizes": {
                    "__doc__": "\n        Returns ``True`` if the group ``other`` is normalized by ``self``.\n        Wraps GAP's ``IsNormal`` function.\n\n        A group `G` normalizes a group `U` if and only if for every\n        `g \\in G` and `u \\in U` the element `u^g`\n        is a member of `U`. Note that `U` need not be a subgroup of `G`.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: H = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])\n            sage: H.normalizes(G)\n            False\n            sage: G = SymmetricGroup(3)\n            sage: H = PermutationGroup( [ (4,5,6) ] )\n            sage: G.normalizes(H)\n            True\n            sage: H.normalizes(G)\n            True\n\n        In the last example, `G` and `H` are disjoint, so each normalizes the\n        other.\n        ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "orbit": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "orbits": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "poincare_series": {
                    "__doc__": "\n        Returns the Poincare series of `G \\mod p` (`p \\geq 2` must be a prime),\n        for `n` large.\n\n        In other words, if you input a finite group `G`, a prime `p`, and a\n        positive integer `n`, it returns a quotient of polynomials `f(x) = P(x)\n        / Q(x)` whose coefficient of `x^k` equals the rank of the vector space\n        `H_k(G, \\ZZ / p \\ZZ)`, for all `k` in the range `1 \\leq k \\leq n`.\n\n        REQUIRES: GAP package HAP (in gap_packages-\\*.spkg).\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(5)\n            sage: G.poincare_series(2,10)                              # optional - gap_packages\n            (x^2 + 1)/(x^4 - x^3 - x + 1)\n            sage: G = SymmetricGroup(3)\n            sage: G.poincare_series(2,10)                              # optional - gap_packages\n            1/(-x + 1)\n\n        AUTHORS:\n\n        - David Joyner and Graham Ellis\n\n        ",
                    "args": [
                        "self",
                        "p",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "p",
                            "n"
                        ],
                        null,
                        null,
                        [
                            2,
                            10
                        ]
                    ]
                },
                "representative_action": {
                    "__doc__": "\n        Return an element of self that maps `x` to `y` if it exists.\n\n        This method wraps the gap function ``RepresentativeAction``, which can\n        also return elements that map a given set of points on another set of\n        points.\n\n        INPUT:\n\n        - ``x,y`` -- two elements of the domain.\n\n        EXAMPLES::\n\n            sage: G = groups.permutation.Cyclic(14)\n            sage: g = G.representative_action(1,10)\n            sage: all(g(x) == 1+((x+9-1)%14) for x in G.domain())\n            True\n\n        TESTS::\n\n            sage: g = graphs.PetersenGraph()\n            sage: g.relabel(list(\"abcdefghik\"))\n            sage: g.vertices()\n            ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k']\n            sage: ag = g.automorphism_group()\n            sage: a = ag.representative_action('a','b')\n            sage: g == g.relabel(a,inplace=False)\n            True\n            sage: a('a') == 'b'\n            True\n        ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "semidirect_product": {
                    "__doc__": "\n        The semidirect product of ``self`` with ``N``.\n\n        INPUT:\n\n        - ``N`` - A group which is acted on by ``self`` and\n          naturally embeds as a normal subgroup of the returned semidirect\n          product.\n\n        - ``mapping`` - A pair of lists that together define a\n          homomorphism, `\\phi :` self `\\rightarrow` Aut(N), by giving,\n          in the second list, the images of the generators of ``self``\n          in the order given in the first list.\n\n        - ``check`` - A boolean that, if set to False, will skip the\n          initial tests which are made on ``mapping``. This may be beneficial\n          for large ``N``, since in such cases the injectivity test can be\n          expensive. Set to True by default.\n\n        OUTPUT:\n\n        The semidirect product of ``self`` and ``N`` defined by the\n        action of ``self`` on ``N`` given in ``mapping`` (note that a\n        homomorphism from A to the automorphism group of B is\n        equivalent to an action of A on the B's underlying set). The\n        semidirect product of two groups, `H` and `N`, is a construct\n        similar to the direct product in so far as the elements are\n        the Cartesian product of the elements of `H` and the elements\n        of `N`. The operation, however, is built upon an action of `H`\n        on `N`, and is defined as such:\n\n        .. MATH::\n\n                (h_1,n_1)(h_2,n_2) = (h_{1}h_{2}, n_{1}^{h_2}n_2)\n\n        This function is a wrapper for GAP's ``SemidirectProduct``\n        command. The permutation group returned is built upon a\n        permutation representation of the semidirect product of ``self``\n        and ``N`` on a set of size `\\mid N \\mid`. The generators of\n        ``N`` are given as their right regular representations, while the\n        generators of ``self`` are defined by the underlying action of\n        ``self`` on ``N``. It should be noted that the defining action is\n        not always faithful, and in this case the inputted representations\n        of the generators of ``self`` are placed on additional letters\n        and adjoined to the output's generators of ``self``.\n\n\n        EXAMPLES:\n\n        Perhaps the most common example of a semidirect product comes\n        from the family of dihedral groups. Each dihedral group is the\n        semidirect product of $C_2$ with $C_n$, where, by convention,\n        $3 \\leq n$. In this case, the nontrivial element of $C_2$ acts\n        on $C_n$ so as to send each element to its inverse. ::\n\n            sage: C2 = CyclicPermutationGroup(2)\n            sage: C8 = CyclicPermutationGroup(8)\n            sage: alpha = PermutationGroupMorphism_im_gens(C8,C8,[(1,8,7,6,5,4,3,2)])\n            sage: S = C2.semidirect_product(C8,[[(1,2)],[alpha]])\n            sage: S == DihedralGroup(8)\n            False\n            sage: S.is_isomorphic(DihedralGroup(8))\n            True\n            sage: S.gens()\n            [(3,4,5,6,7,8,9,10), (1,2)(4,10)(5,9)(6,8)]\n\n        A more complicated example can be drawn from [TW1980]_.\n        It is there given that a semidirect product of $D_4$ and $C_3$\n        is isomorphic to one of $C_2$ and the dicyclic group of order\n        12. This nonabelian group of order 24 has very similar\n        structure to the dicyclic and dihedral groups of order 24, the\n        three being the only groups of order 24 with a two-element\n        center and 9 conjugacy classes. ::\n\n            sage: D4 = DihedralGroup(4)\n            sage: C3 = CyclicPermutationGroup(3)\n            sage: alpha1 = PermutationGroupMorphism_im_gens(C3,C3,[(1,3,2)])\n            sage: alpha2 = PermutationGroupMorphism_im_gens(C3,C3,[(1,2,3)])\n            sage: S1 = D4.semidirect_product(C3,[[(1,2,3,4),(1,3)],[alpha1,alpha2]])\n            sage: C2 = CyclicPermutationGroup(2)\n            sage: Q = DiCyclicGroup(3)\n            sage: a = Q.gens()[0]; b=Q.gens()[1].inverse()\n            sage: alpha = PermutationGroupMorphism_im_gens(Q,Q,[a,b])\n            sage: S2 = C2.semidirect_product(Q,[[(1,2)],[alpha]])\n            sage: S1.is_isomorphic(S2)\n            True\n            sage: S1.is_isomorphic(DihedralGroup(12))\n            False\n            sage: S1.is_isomorphic(DiCyclicGroup(6))\n            False\n            sage: S1.center()\n            Subgroup of (Permutation Group with generators\n            [(5,6,7), (1,2,3,4)(6,7), (1,3)]) generated by [(1,3)(2,4)]\n            sage: len(S1.conjugacy_classes_representatives())\n            9\n\n        If your normal subgroup is large, and you are confident that\n        your inputs will successfully create a semidirect product, then\n        it is beneficial, for the sake of time efficiency, to set the\n        ``check`` parameter to ``False``.  ::\n\n            sage: C2 = CyclicPermutationGroup(2)\n            sage: C2000 = CyclicPermutationGroup(500)\n            sage: alpha = PermutationGroupMorphism(C2000,C2000,[C2000.gen().inverse()])\n            sage: S = C2.semidirect_product(C2000,[[(1,2)],[alpha]],check=False)\n\n        TESTS::\n\n            sage: C3 = CyclicPermutationGroup(3)\n            sage: D4 = DihedralGroup(4)\n            sage: alpha = PermutationGroupMorphism(C3,C3,[C3(\"(1,3,2)\")])\n            sage: alpha1 = PermutationGroupMorphism(C3,C3,[C3(\"(1,2,3)\")])\n\n            sage: s = D4.semidirect_product('junk', [[(1,2,3,4),(1,2)], [alpha, alpha1]])\n            Traceback (most recent call last):\n            ...\n            TypeError: junk is not a permutation group\n\n            sage: s = D4.semidirect_product(C3, [[(1,2,3,4),(1,2)], [alpha, alpha1]])\n            Traceback (most recent call last):\n            ...\n            ValueError: the generator list must generate the calling group, [(1, 2, 3, 4), (1, 2)]\n            does not generate Dihedral group of order 8 as a permutation group\n\n            sage: s = D4.semidirect_product(C3, [[(1,2,3,4),(1,3)], [alpha]])\n            Traceback (most recent call last):\n            ...\n            ValueError: the list of generators and the list of morphisms must be of equal length\n\n            sage: alpha2 = PermutationGroupMorphism(C3, D4, [D4(\"()\")])\n            sage: s = D4.semidirect_product(C3, [[(1,2,3,4),(1,3)], [alpha, alpha2]])\n            Traceback (most recent call last):\n            ...\n            ValueError: an element of the automorphism list is not an endomorphism (and is therefore not an automorphism)\n\n            sage: alpha3 = PermutationGroupMorphism(C3,C3,[C3(\"()\")])\n            sage: s = D4.semidirect_product(C3, [[(1,2,3,4),(1,3)], [alpha, alpha3]])\n            Traceback (most recent call last):\n            ...\n            ValueError: an element of the automorphism list is not an injection (and is therefore not an automorphism)\n\n        AUTHOR:\n\n        - Kevin Halasz (2012-8-12)\n\n        ",
                    "args": [
                        "self",
                        "N",
                        "mapping",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "N",
                            "mapping",
                            "check"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "smallest_moved_point": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "socle": {
                    "__doc__": "\n        Returns the socle of ``self``. The socle of a group $G$ is\n        the subgroup generated by all minimal normal subgroups.\n\n        EXAMPLES::\n\n            sage: G=SymmetricGroup(4)\n            sage: G.socle()\n            Subgroup of (Symmetric group of order 4! as a permutation group) generated by [(1,2)(3,4), (1,4)(2,3)]\n            sage: G.socle().socle()\n            Subgroup of (Subgroup of (Symmetric group of order 4! as a permutation group) generated by [(1,2)(3,4), (1,4)(2,3)]) generated by [(1,2)(3,4), (1,4)(2,3)]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "solvable_radical": {
                    "__doc__": "\n        Returns the solvable radical of ``self``. The solvable\n        radical (or just radical) of a group $G$ is the largest\n        solvable normal subgroup of $G$.\n\n        EXAMPLES::\n\n            sage: G=SymmetricGroup(4)\n            sage: G.solvable_radical()\n            Subgroup of (Symmetric group of order 4! as a permutation group) generated by [(1,2), (1,2,3,4)]\n            sage: G=SymmetricGroup(5)\n            sage: G.solvable_radical()\n            Subgroup of (Symmetric group of order 5! as a permutation group) generated by [()]\n\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "stabilizer": {
                    "__doc__": "\n        Return the subgroup of ``self`` which stabilize the given position.\n        ``self`` and its stabilizers must have same degree.\n\n        INPUT:\n\n        - ``point`` -- a point of the :meth:`domain`, or a set of points\n          depending on the value of ``action``.\n\n        - ``action`` (string; default ``\"OnPoints\"``) -- should the group be\n          considered to act on points (``action=\"OnPoints\"``) or on sets of\n          points (``action=\"OnSets\"``) ? In the latter case, the first argument\n          must be a subset of :meth:`domain`.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([ [(3,4)], [(1,3)] ])\n            sage: G.stabilizer(1)\n            Subgroup of (Permutation Group with generators [(3,4), (1,3)]) generated by [(3,4)]\n            sage: G.stabilizer(3)\n            Subgroup of (Permutation Group with generators [(3,4), (1,3)]) generated by [(1,4)]\n\n        The stabilizer of a set of points::\n\n            sage: s10 = groups.permutation.Symmetric(10)\n            sage: s10.stabilizer([1..3],\"OnSets\").cardinality()\n            30240\n            sage: factorial(3)*factorial(7)\n            30240\n\n        ::\n\n            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])\n            sage: G.stabilizer(10)\n            Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4,10)]) generated by [(2,3,4), (1,2)(3,4)]\n            sage: G.stabilizer(1)\n            Subgroup of (Permutation Group with generators [(1,2)(3,4), (1,2,3,4,10)]) generated by [(2,3)(4,10), (2,10,4)]\n            sage: G = PermutationGroup([[(2,3,4)],[(6,7)]])\n            sage: G.stabilizer(1)\n            Subgroup of (Permutation Group with generators [(6,7), (2,3,4)]) generated by [(6,7), (2,3,4)]\n            sage: G.stabilizer(2)\n            Subgroup of (Permutation Group with generators [(6,7), (2,3,4)]) generated by [(6,7)]\n            sage: G.stabilizer(3)\n            Subgroup of (Permutation Group with generators [(6,7), (2,3,4)]) generated by [(6,7)]\n            sage: G.stabilizer(4)\n            Subgroup of (Permutation Group with generators [(6,7), (2,3,4)]) generated by [(6,7)]\n            sage: G.stabilizer(5)\n            Subgroup of (Permutation Group with generators [(6,7), (2,3,4)]) generated by [(6,7), (2,3,4)]\n            sage: G.stabilizer(6)\n            Subgroup of (Permutation Group with generators [(6,7), (2,3,4)]) generated by [(2,3,4)]\n            sage: G.stabilizer(7)\n            Subgroup of (Permutation Group with generators [(6,7), (2,3,4)]) generated by [(2,3,4)]\n            sage: G.stabilizer(8)\n            Traceback (most recent call last):\n            ...\n            ValueError: 8 does not belong to the domain\n\n        ::\n\n            sage: G = PermutationGroup([ [('c','d')], [('a','c')] ], domain='abcd')\n            sage: G.stabilizer('a')\n            Subgroup of (Permutation Group with generators [('c','d'), ('a','c')]) generated by [('c','d')]\n            sage: G.stabilizer('b')\n            Subgroup of (Permutation Group with generators [('c','d'), ('a','c')]) generated by [('c','d'), ('a','c')]\n            sage: G.stabilizer('c')\n            Subgroup of (Permutation Group with generators [('c','d'), ('a','c')]) generated by [('a','d')]\n            sage: G.stabilizer('d')\n            Subgroup of (Permutation Group with generators [('c','d'), ('a','c')]) generated by [('a','c')]\n\n        TESTS::\n\n            sage: G.stabilizer(['a'],\"OnMonkeys\")\n            Traceback (most recent call last):\n            ...\n            ValueError: 'action' must be equal to 'OnPoints' or to 'OnSets'.\n        ",
                    "args": [
                        "self",
                        "point",
                        "action"
                    ],
                    "argspec": [
                        [
                            "self",
                            "point",
                            "action"
                        ],
                        null,
                        null,
                        [
                            "OnPoints"
                        ]
                    ]
                },
                "strong_generating_system": {
                    "__doc__": "\n        Return a Strong Generating System of ``self`` according the given\n        base for the right action of ``self`` on itself.\n\n        ``base_of_group`` is a list of the  positions on which ``self`` acts,\n        in any order. The algorithm returns a list of transversals and each\n        transversal is a list of permutations. By default, ``base_of_group``\n        is ``[1, 2, 3, ..., d]`` where `d` is the degree of the group.\n\n        For ``base_of_group`` =\n        `[ \\mathrm{pos}_1, \\mathrm{pos}_2, \\dots , \\mathrm{pos}_d]`\n        let `G_i` be the subgroup of `G` = ``self`` which stabilizes\n        `\\mathrm{pos}_1, \\mathrm{pos}_2, \\dots , \\mathrm{pos}_i`, so\n\n        .. MATH::\n\n           G = G_0 \\supset G_1 \\supset G_2 \\supset \\dots \\supset G_n = \\{e\\}\n\n        Then the algorithm returns `[ G_i.\\mathrm{transversals}(\\mathrm{pos}_{i+1})]_{1 \\leq i \\leq n}`\n\n        INPUT:\n\n        - ``base_of_group`` (optional) -- default: ``[1, 2, 3, ..., d]``\n          -- a list containing the integers\n          `1, 2, \\dots , d` in any order (`d` is the degree of ``self``)\n\n        OUTPUT:\n\n        - A list of lists of permutations from the group, which form a strong\n          generating system.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(7,8)],[(3,4)],[(4,5)]])\n            sage: G.strong_generating_system()\n            [[()], [()], [(), (3,4,5), (3,5)], [(), (4,5)], [()], [()], [(), (7,8)], [()]]\n            sage: G = PermutationGroup([[(1,2,3,4)],[(1,2)]])\n            sage: G.strong_generating_system()\n            [[(), (1,2)(3,4), (1,3)(2,4), (1,4)(2,3)], [(), (2,3,4), (2,4,3)], [(), (3,4)], [()]]\n            sage: G = PermutationGroup([[(1,2,3)],[(4,5,7)],[(1,4,6)]])\n            sage: G.strong_generating_system()\n            [[(), (1,2,3), (1,4,6), (1,3,2), (1,5,7,4,6), (1,6,4), (1,7,5,4,6)], [(), (2,6,3), (2,5,7,6,3), (2,3,6), (2,7,5,6,3), (2,4,7,6,3)], [(), (3,6,7), (3,5,6), (3,7,6), (3,4,7,5,6)], [(), (4,5)(6,7), (4,7)(5,6), (4,6)(5,7)], [(), (5,7,6), (5,6,7)], [()], [()]]\n            sage: G = PermutationGroup([[(1,2,3)],[(2,3,4)],[(3,4,5)]])\n            sage: G.strong_generating_system([5,4,3,2,1])\n            [[(), (1,5,3,4,2), (1,5,4,3,2), (1,5)(2,3), (1,5,2)], [(), (1,3)(2,4), (1,2)(3,4), (1,4)(2,3)], [(), (1,3,2), (1,2,3)], [()], [()]]\n            sage: G = PermutationGroup([[(3,4)]])\n            sage: G.strong_generating_system()\n            [[()], [()], [(), (3,4)], [()]]\n            sage: G.strong_generating_system(base_of_group=[3,1,2,4])\n            [[(), (3,4)], [()], [()], [()]]\n            sage: G = TransitiveGroup(12,17)                # optional - database_gap\n            sage: G.strong_generating_system()              # optional - database_gap\n            [[(), (1,4,11,2)(3,6,5,8)(7,10,9,12), (1,8,3,2)(4,11,10,9)(5,12,7,6), (1,7)(2,8)(3,9)(4,10)(5,11)(6,12), (1,12,7,2)(3,10,9,8)(4,11,6,5), (1,11)(2,8)(3,5)(4,10)(6,12)(7,9), (1,10,11,8)(2,3,12,5)(4,9,6,7), (1,3)(2,8)(4,10)(5,7)(6,12)(9,11), (1,2,3,8)(4,9,10,11)(5,6,7,12), (1,6,7,8)(2,3,4,9)(5,10,11,12), (1,5,9)(3,11,7), (1,9,5)(3,7,11)], [(), (2,6,10)(4,12,8), (2,10,6)(4,8,12)], [()], [()], [()], [()], [()], [()], [()], [()], [()], [()]]\n\n        TESTS::\n\n            sage: G = SymmetricGroup(10)\n            sage: H = PermutationGroup([G.random_element() for i in range(randrange(1,3,1))])\n            sage: prod(len(x) for x in H.strong_generating_system()) == H.cardinality()\n            True\n        ",
                    "args": [
                        "self",
                        "base_of_group"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_of_group"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "structure_description": {
                    "__doc__": "\n    Return a string that tries to describe the structure of ``G``.\n\n    This methods wraps GAP's ``StructureDescription`` method.\n\n    Requires the *optional* ``database_gap`` package.\n\n    For full details, including the form of the returned string and the\n    algorithm to build it, see `GAP's documentation\n    <http://www.gap-system.org/Manuals/doc/ref/chap39.html>`_.\n\n    INPUT:\n\n    - ``latex`` -- a boolean (default: ``False``). If ``True`` return a\n      LaTeX formatted string.\n\n    OUTPUT:\n\n    - string\n\n    .. WARNING::\n\n        From GAP's documentation: The string returned by\n        ``StructureDescription`` is **not** an isomorphism invariant:\n        non-isomorphic groups can have the same string value, and two\n        isomorphic groups in different representations can produce different\n        strings.\n\n    EXAMPLES::\n\n        sage: G = CyclicPermutationGroup(6)\n        sage: G.structure_description()             # optional - database_gap\n        'C6'\n        sage: G.structure_description(latex=True)   # optional - database_gap\n        'C_{6}'\n        sage: G2 = G.direct_product(G, maps=False)\n        sage: LatexExpr(G2.structure_description(latex=True))   # optional - database_gap\n        C_{6} \\times C_{6}\n\n    This method is mainly intended for small groups or groups with few\n    normal subgroups. Even then there are some surprises::\n\n        sage: D3 = DihedralGroup(3)\n        sage: D3.structure_description()    # optional - database_gap\n        'S3'\n\n    We use the Sage notation for the degree of dihedral groups::\n\n        sage: D4 = DihedralGroup(4)\n        sage: D4.structure_description()    # optional - database_gap\n        'D4'\n\n    Works for finitely presented groups (:trac:`17573`)::\n\n        sage: F.<x, y> = FreeGroup()\n        sage: G=F / [x^2*y^-1, x^3*y^2, x*y*x^-1*y^-1]\n        sage: G.structure_description()     # optional - database_gap\n        'C7'\n\n    And matrix groups (:trac:`17573`)::\n\n        sage: groups.matrix.GL(4,2).structure_description() # optional - database_gap\n        'A8'\n    ",
                    "args": [
                        "G",
                        "latex"
                    ],
                    "argspec": [
                        [
                            "G",
                            "latex"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "subgroup": {
                    "__doc__": "\n        Wraps the ``PermutationGroup_subgroup`` constructor. The argument\n        ``gens`` is a list of elements of ``self``.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([(1,2,3),(3,4,5)])\n            sage: g = G((1,2,3))\n            sage: G.subgroup([g])\n            Subgroup of (Permutation Group with generators [(3,4,5), (1,2,3)]) generated by [(1,2,3)]\n        ",
                    "args": [
                        "self",
                        "gens",
                        "gap_group",
                        "domain",
                        "category",
                        "canonicalize",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "gens",
                            "gap_group",
                            "domain",
                            "category",
                            "canonicalize",
                            "check"
                        ],
                        null,
                        null,
                        [
                            null,
                            null,
                            null,
                            null,
                            true,
                            true
                        ]
                    ]
                },
                "subgroups": {
                    "__doc__": "\n        Returns a list of all the subgroups of ``self``.\n\n        OUTPUT:\n\n        Each possible subgroup of ``self`` is contained once\n        in the returned list.  The list is in order, according\n        to the size of the subgroups, from the trivial subgroup\n        with one element on through up to the whole group.\n        Conjugacy classes of subgroups are contiguous in the list.\n\n        .. warning::\n\n            For even relatively small groups this method can\n            take a very long time to execute, or create vast\n            amounts of output.  Likely both.  Its purpose is\n            instructional, as it can be useful for studying\n            small groups.  The 156 subgroups of the full\n            symmetric group on 5 symbols of order 120, `S_5`,\n            can be computed in about a minute on commodity hardware\n            in 2011. The 64 subgroups of the cyclic group of order\n            `30030 = 2\\cdot 3\\cdot 5\\cdot 7\\cdot 11\\cdot 13` takes\n            about twice as long.\n\n            For faster results, which still exhibit the structure of\n            the possible subgroups, use\n            :meth:`conjugacy_classes_subgroups`.\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(3)\n            sage: G.subgroups()\n            [Subgroup of (Symmetric group of order 3! as a permutation group) generated by [()],\n             Subgroup of (Symmetric group of order 3! as a permutation group) generated by [(2,3)],\n             Subgroup of (Symmetric group of order 3! as a permutation group) generated by [(1,2)],\n             Subgroup of (Symmetric group of order 3! as a permutation group) generated by [(1,3)],\n             Subgroup of (Symmetric group of order 3! as a permutation group) generated by [(1,2,3)],\n             Subgroup of (Symmetric group of order 3! as a permutation group) generated by [(2,3), (1,2,3)]]\n\n            sage: G = CyclicPermutationGroup(14)\n            sage: G.subgroups()\n            [Subgroup of (Cyclic group of order 14 as a permutation group) generated by [()],\n             Subgroup of (Cyclic group of order 14 as a permutation group) generated by [(1,8)(2,9)(3,10)(4,11)(5,12)(6,13)(7,14)],\n             Subgroup of (Cyclic group of order 14 as a permutation group) generated by [(1,3,5,7,9,11,13)(2,4,6,8,10,12,14)],\n             Subgroup of (Cyclic group of order 14 as a permutation group) generated by [(1,2,3,4,5,6,7,8,9,10,11,12,13,14), (1,3,5,7,9,11,13)(2,4,6,8,10,12,14)]]\n\n             Subgroup of (Cyclic group of order 14 as a permutation group) generated by [(1,2,3,4,5,6,7,8,9,10,11,12,13,14)]]\n\n        AUTHOR:\n\n        - Rob Beezer (2011-01-24)\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "sylow_subgroup": {
                    "__doc__": "\n        Returns a Sylow `p`-subgroup of the finite group `G`, where `p` is a\n        prime. This is a `p`-subgroup of `G` whose index in `G` is coprime to\n        `p`.\n\n        Wraps the GAP function ``SylowSubgroup``.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)', '(2,3)'])\n            sage: G.sylow_subgroup(2)\n            Subgroup of (Permutation Group with generators [(2,3), (1,2,3)]) generated by [(2,3)]\n            sage: G.sylow_subgroup(5)\n            Subgroup of (Permutation Group with generators [(2,3), (1,2,3)]) generated by [()]\n\n        TESTS:\n\n        Implementation details should not prevent us from computing\n        large subgroups (:trac:`5491`)::\n\n            sage: PSL(10,2).sylow_subgroup(7)\n            Subgroup of...\n\n        ",
                    "args": [
                        "self",
                        "p"
                    ],
                    "argspec": [
                        [
                            "self",
                            "p"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "transversals": {
                    "__doc__": "\n        If G is a permutation group acting on the set `X = \\{1, 2, ...., n\\}`\n        and H is the stabilizer subgroup of <integer>, a right\n        (respectively left) transversal is a set containing exactly\n        one element from each right (respectively left) coset of H. This\n        method returns a right transversal of ``self`` by the stabilizer\n        of ``self`` on <integer> position.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([ [(3,4)], [(1,3)] ])\n            sage: G.transversals(1)\n            [(), (1,3,4), (1,4,3)]\n            sage: G = PermutationGroup([[(1,2),(3,4)], [(1,2,3,4,10)]])\n            sage: G.transversals(1)\n            [(), (1,2)(3,4), (1,3,2,10,4), (1,4,2,10,3), (1,10,4,3,2)]\n\n            sage: G = PermutationGroup([ [('c','d')], [('a','c')] ])\n            sage: G.transversals('a')\n            [(), ('a','c','d'), ('a','d','c')]\n        ",
                    "args": [
                        "self",
                        "point"
                    ],
                    "argspec": [
                        [
                            "self",
                            "point"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "trivial_character": {
                    "__doc__": "\n        Returns the trivial character of ``self``.\n\n        EXAMPLES::\n\n            sage: SymmetricGroup(3).trivial_character()\n            Character of Symmetric group of order 3! as a permutation group\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "upper_central_series": {
                    "__doc__": "\n        Return the upper central series of this group as a list of\n        permutation groups.\n\n        EXAMPLES:\n\n        These computations use pseudo-random numbers, so we set\n        the seed for reproducible testing::\n\n            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]])\n            sage: G.upper_central_series()\n            [Subgroup of (Permutation Group with generators [(3,4), (1,2,3)(4,5)]) generated by [()]]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.groups.perm_gps.permgroup.PermutationGroup_generic"
        },
        "sage.groups.perm_gps.permgroup_element.PermutationGroupElement": {
            "__doc__": "PermutationGroupElement(g, parent=None, check=True)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 258)\n\n    An element of a permutation group.\n\n    EXAMPLES::\n\n        sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n        sage: G\n        Permutation Group with generators [(1,2,3)(4,5)]\n        sage: g = G.random_element()\n        sage: g in G\n        True\n        sage: g = G.gen(0); g\n        (1,2,3)(4,5)\n        sage: print(g)\n        (1,2,3)(4,5)\n        sage: g*g\n        (1,3,2)\n        sage: g**(-1)\n        (1,3,2)(4,5)\n        sage: g**2\n        (1,3,2)\n        sage: G = PermutationGroup([(1,2,3)])\n        sage: g = G.gen(0); g\n        (1,2,3)\n        sage: g.order()\n        3\n\n    This example illustrates how permutations act on multivariate\n    polynomials.\n\n    ::\n\n        sage: R = PolynomialRing(RationalField(), 5, [\"x\",\"y\",\"z\",\"u\",\"v\"])\n        sage: x, y, z, u, v = R.gens()\n        sage: f = x**2 - y**2 + 3*z**2\n        sage: G = PermutationGroup(['(1,2,3)(4,5)', '(1,2,3,4,5)'])\n        sage: sigma = G.gen(0)\n        sage: f * sigma\n        3*x^2 + y^2 - z^2\n    ",
            "implied": [
                "sage.structure.element.MultiplicativeGroupElement"
            ],
            "methods": {
                "__getitem__": {
                    "__doc__": "File: sage/groups/perm_gps/permgroup_element.pyx (starting at line 601)\n\n        Return the ith permutation cycle in the disjoint cycle\n        representation of self.\n\n        INPUT:\n\n\n        -  ``i`` - integer\n\n\n        OUTPUT: a permutation group element\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3),(4,5)]],5)\n            sage: g = G.gen(0)\n            sage: g[0]\n            (1,2,3)\n            sage: g[1]\n            (4,5)\n        ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_act_on_array_on_position": {
                    "__doc__": "PermutationGroupElement._act_on_array_on_position(self, ClonableIntArray x) -> ClonableIntArray\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 763)\n\n        Returns the right action of ``self`` on the ClonableIntArray\n        ``x``. This is the action on positions.\n\n        EXAMPLES::\n\n            sage: from sage.structure.list_clone_demo import IncreasingIntArrays\n            sage: v = IncreasingIntArrays()([1,2,3,4])\n            sage: G = PermutationGroup([[(1,2,3,4)]])\n            sage: id = G.identity()\n            sage: id._act_on_array_on_position(v)\n            [1, 2, 3, 4]\n        ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_act_on_list_on_position": {
                    "__doc__": "PermutationGroupElement._act_on_list_on_position(self, list x) -> list\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 735)\n\n        Returns the right action of ``self`` on the list ``x``. This is the\n        action on positions.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3,4,5,6)]])\n            sage: p = G.gen()^2; p\n            (1,3,5)(2,4,6)\n            sage: p._act_on_list_on_position([1,2,3,4,5,6])\n            [3, 4, 5, 6, 1, 2]\n            sage: p._act_on_list_on_position(['a','b','c','d','e','f'])\n            ['c', 'd', 'e', 'f', 'a', 'b']\n            sage: p._act_on_list_on_position(['c','d','e','f','a','b'])\n            ['e', 'f', 'a', 'b', 'c', 'd']\n            sage: p._act_on_list_on_position([])\n            Traceback (most recent call last):\n            ...\n            AssertionError: (1,3,5)(2,4,6) and [] should have the same length\n            sage: p._act_on_list_on_position([1,2,3,4,5,6,7])\n            Traceback (most recent call last):\n            ...\n            AssertionError: (1,3,5)(2,4,6) and [1, 2, 3, 4, 5, 6, 7] should have the same length\n        ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_gap_cycle_string": {
                    "__doc__": "PermutationGroupElement._gap_cycle_string(self)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 908)\n\n        Returns a cycle string for this permutation compatible with\n        the GAP numbering.\n\n        EXAMPLES::\n\n            sage: S = SymmetricGroup(3)\n            sage: s = S.gen(0); s\n            (1,2,3)\n            sage: s._gap_cycle_string()\n            '(1,2,3)'\n\n        ::\n\n            sage: S = SymmetricGroup(['a', 'b', 'c'])\n            sage: s = S.gen(0); s\n            ('a','b','c')\n            sage: s._gap_cycle_string()\n            '(1,2,3)'\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_gap_list": {
                    "__doc__": "PermutationGroupElement._gap_list(self)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 884)\n\n        Returns this permutation in list notation compatible with the\n        GAP numbering.\n\n        EXAMPLES::\n\n            sage: S = SymmetricGroup(3)\n            sage: s = S.gen(0); s\n            (1,2,3)\n            sage: s._gap_list()\n            [2, 3, 1]\n\n        ::\n\n            sage: S = SymmetricGroup(['a', 'b', 'c'])\n            sage: s = S.gen(0); s\n            ('a','b','c')\n            sage: s._gap_list()\n            [2, 3, 1]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_latex_": {
                    "__doc__": "PermutationGroupElement._latex_(self)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 584)\n\n        Returns a latex representation of this permutation.\n\n        EXAMPLES::\n\n            sage: g = PermutationGroupElement([(1,2,3),(4,5)])\n            sage: latex(g)\n            (1,2,3)(4,5)\n\n            sage: S = SymmetricGroup(['a', 'b'])\n            sage: latex(S.gens())\n            \\left[(\\text{\\texttt{a}},\\text{\\texttt{b}})\\right]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_mul_": {
                    "__doc__": "PermutationGroupElement._mul_(left, _right)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 849)\n\n        EXAMPLES::\n\n            sage: S = SymmetricGroup(['a', 'b'])\n            sage: s = S([('a', 'b')]); s\n            ('a','b')\n            sage: s*s\n            ()\n        ",
                    "args": [
                        "left",
                        "_right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "_right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "cycle_string": {
                    "__doc__": "PermutationGroupElement.cycle_string(self, singletons=False)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1291)\n\n        Return string representation of this permutation.\n\n       EXAMPLES::\n\n            sage: g = PermutationGroupElement([(1,2,3),(4,5)])\n            sage: g.cycle_string()\n            '(1,2,3)(4,5)'\n\n            sage: g = PermutationGroupElement([3,2,1])\n            sage: g.cycle_string(singletons=True)\n            '(1,3)(2)'\n        ",
                    "args": [
                        "self",
                        "singletons"
                    ],
                    "argspec": [
                        [
                            "self",
                            "singletons"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "cycle_tuples": {
                    "__doc__": "PermutationGroupElement.cycle_tuples(self, singletons=False)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1233)\n\n        Return self as a list of disjoint cycles, represented as tuples\n        rather than permutation group elements.\n\n        INPUT:\n\n        - ``singletons`` - boolean (default: False) whether or not consider the\n          cycle that correspond to fixed point\n\n        EXAMPLES::\n\n            sage: p = PermutationGroupElement('(2,6)(4,5,1)')\n            sage: p.cycle_tuples()\n            [(1, 4, 5), (2, 6)]\n            sage: p.cycle_tuples(singletons=True)\n            [(1, 4, 5), (2, 6), (3,)]\n\n        EXAMPLES::\n\n            sage: S = SymmetricGroup(4)\n            sage: S.gen(0).cycle_tuples()\n            [(1, 2, 3, 4)]\n\n        ::\n\n            sage: S = SymmetricGroup(['a','b','c','d'])\n            sage: S.gen(0).cycle_tuples()\n            [('a', 'b', 'c', 'd')]\n            sage: S([('a', 'b'), ('c', 'd')]).cycle_tuples()\n            [('a', 'b'), ('c', 'd')]\n        ",
                    "args": [
                        "self",
                        "singletons"
                    ],
                    "argspec": [
                        [
                            "self",
                            "singletons"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "cycle_type": {
                    "__doc__": "PermutationGroupElement.cycle_type(self, singletons=True, as_list=False)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1310)\n\n        Return the partition that gives the cycle type of ``g`` as an element of\n        ``self``.\n\n        INPUT:\n\n        - ``g`` -- an element of the permutation group ``self.parent()``\n        \n        - ``singletons`` -- ``True`` or ``False`` depending on whether on or not\n          trivial cycles should be counted (default: ``True``)\n\n        - ``as_list`` -- ``True`` or ``False`` depending on whether the cycle\n          type should be returned as a ``list`` or as a class:`Partition` \n          (default: ``False``)\n\n        OUTPUT:\n\n        A class:`Partition`, or `list` if ``is_list`` is ``True``, giving the cycle type of ``g`` \n\n        If speed is a concern then ``as_list=True`` should be used.\n\n        EXAMPLES::\n\n            sage: G = DihedralGroup(3)\n            sage: [g.cycle_type() for g in G]\n            [[1, 1, 1], [2, 1], [3], [2, 1], [3], [2, 1]]\n            sage: PermutationGroupElement('(1,2,3)(4,5)(6,7,8)').cycle_type()\n            [3, 3, 2]\n            sage: G = SymmetricGroup(3); G('(1,2)').cycle_type()\n            [2, 1]\n            sage: G = SymmetricGroup(4); G('(1,2)').cycle_type()\n            [2, 1, 1]\n            sage: G = SymmetricGroup(4); G('(1,2)').cycle_type(singletons=False)\n            [2]\n            sage: G = SymmetricGroup(4); G('(1,2)').cycle_type(as_list=False)\n            [2, 1, 1]\n        ",
                    "args": [
                        "self",
                        "singletons",
                        "as_list"
                    ],
                    "argspec": [
                        [
                            "self",
                            "singletons",
                            "as_list"
                        ],
                        null,
                        null,
                        [
                            true,
                            false
                        ]
                    ]
                },
                "cycles": {
                    "__doc__": "PermutationGroupElement.cycles(self)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1200)\n\n        Return self as a list of disjoint cycles.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5,6,7)'])\n            sage: g = G.0\n            sage: g.cycles()\n            [(1,2,3), (4,5,6,7)]\n            sage: a, b = g.cycles()\n            sage: a(1), b(1)\n            (2, 1)\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "dict": {
                    "__doc__": "PermutationGroupElement.dict(self)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1019)\n\n        Returns a dictionary associating each element of the domain with its\n        image.\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(4)\n            sage: g = G((1,2,3,4)); g\n            (1,2,3,4)\n            sage: v = g.dict(); v\n            {1: 2, 2: 3, 3: 4, 4: 1}\n            sage: type(v[1])\n            <... 'int'>\n            sage: x = G([2,1]); x\n            (1,2)\n            sage: x.dict()\n            {1: 2, 2: 1, 3: 3, 4: 4}\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "domain": {
                    "__doc__": "PermutationGroupElement.domain(self)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 932)\n\n        Returns the domain of self.\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(4)\n            sage: x = G([2,1,4,3]); x\n            (1,2)(3,4)\n            sage: v = x.domain(); v\n            [2, 1, 4, 3]\n            sage: type(v[0])\n            <... 'int'>\n            sage: x = G([2,1]); x\n            (1,2)\n            sage: x.domain()\n            [2, 1, 3, 4]\n\n        TESTS::\n\n            sage: S = SymmetricGroup(0)\n            sage: x = S.one(); x\n            ()\n            sage: x.domain()\n            []\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "has_descent": {
                    "__doc__": "PermutationGroupElement.has_descent(self, i, side='right', positive=False)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1356)\n\n        INPUT:\n\n         - ``i``: an element of the index set\n         - ``side``: \"left\" or \"right\" (default: \"right\")\n         - ``positive``: a boolean (default: False)\n\n        Returns whether ``self`` has a left (resp. right) descent at\n        position ``i``. If ``positive`` is True, then test for a non\n        descent instead.\n\n        Beware that, since permutations are acting on the right, the\n        meaning of descents is the reverse of the usual\n        convention. Hence, ``self`` has a left descent at position\n        ``i`` if ``self(i) > self(i+1)``.\n\n        EXAMPLES::\n\n            sage: S = SymmetricGroup([1,2,3])\n            sage: S.one().has_descent(1)\n            False\n            sage: S.one().has_descent(2)\n            False\n            sage: s = S.simple_reflections()\n            sage: x = s[1]*s[2]\n            sage: x.has_descent(1, side = \"right\")\n            False\n            sage: x.has_descent(2, side = \"right\")\n            True\n            sage: x.has_descent(1, side = \"left\")\n            True\n            sage: x.has_descent(2, side = \"left\")\n            False\n            sage: S._test_has_descent()\n\n        The symmetric group acting on a set not of the form\n        `(1,\\dots,n)` is also supported::\n\n            sage: S = SymmetricGroup([2,4,1])\n            sage: s = S.simple_reflections()\n            sage: x = s[2]*s[4]\n            sage: x.has_descent(4)\n            True\n            sage: S._test_has_descent()\n        ",
                    "args": [
                        "self",
                        "i",
                        "side",
                        "positive"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "side",
                            "positive"
                        ],
                        null,
                        null,
                        [
                            "right",
                            false
                        ]
                    ]
                },
                "inverse": {
                    "__doc__": "PermutationGroupElement.inverse(self)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1088)\n\n        Returns the inverse permutation.\n\n        OUTPUT:\n\n        For an element of a permutation group, this method returns the inverse\n        element, which is both the inverse function and the inverse as an\n        element of a group.\n\n        EXAMPLES::\n\n            sage: s = PermutationGroupElement(\"(1,2,3)(4,5)\")\n            sage: s.inverse()\n            (1,3,2)(4,5)\n\n            sage: A = AlternatingGroup(4)\n            sage: t = A(\"(1,2,3)\")\n            sage: t.inverse()\n            (1,3,2)\n\n        There are several ways (syntactically) to get an inverse\n        of a permutation group element.  ::\n\n            sage: s = PermutationGroupElement(\"(1,2,3,4)(6,7,8)\")\n            sage: s.inverse() == s^-1\n            True\n            sage: s.inverse() == ~s\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "matrix": {
                    "__doc__": "PermutationGroupElement.matrix(self)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1414)\n\n        Returns deg x deg permutation matrix associated to the permutation\n        self\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: g = G.gen(0)\n            sage: g.matrix()\n            [0 1 0 0 0]\n            [0 0 1 0 0]\n            [1 0 0 0 0]\n            [0 0 0 0 1]\n            [0 0 0 1 0]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "orbit": {
                    "__doc__": "PermutationGroupElement.orbit(self, n, bool sorted=True)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1156)\n\n        Returns the orbit of the integer `n` under this group\n        element, as a sorted list.\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup(['(1,2,3)(4,5)'])\n            sage: g = G.gen(0)\n            sage: g.orbit(4)\n            [4, 5]\n            sage: g.orbit(3)\n            [1, 2, 3]\n            sage: g.orbit(10)\n            [10]\n\n        ::\n\n            sage: s = SymmetricGroup(['a', 'b']).gen(0); s\n            ('a','b')\n            sage: s.orbit('a')\n            ['a', 'b']\n        ",
                    "args": [
                        "self",
                        "n",
                        "sorted"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n",
                            "sorted"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "sign": {
                    "__doc__": "PermutationGroupElement.sign(self)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1120)\n\n        Returns the sign of self, which is `(-1)^{s}`, where\n        `s` is the number of swaps.\n\n        EXAMPLES::\n\n            sage: s = PermutationGroupElement('(1,2)(3,5,6)')\n            sage: s.sign()\n            -1\n\n        ALGORITHM: Only even cycles contribute to the sign, thus\n\n        .. MATH::\n\n            sign(sigma) = (-1)^{\\sum_c len(c)-1}\n\n\n        where the sum is over cycles in self.\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "tuple": {
                    "__doc__": "PermutationGroupElement.tuple(self)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1000)\n\n        Return tuple of images of the domain under self.\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(5)\n            sage: s = G([2,1,5,3,4])\n            sage: s.tuple()\n            (2, 1, 5, 3, 4)\n\n            sage: S = SymmetricGroup(['a', 'b'])\n            sage: S.gen().tuple()\n            ('b', 'a')\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "word_problem": {
                    "__doc__": "PermutationGroupElement.word_problem(self, words, display=True)\nFile: sage/groups/perm_gps/permgroup_element.pyx (starting at line 1437)\n\n        G and H are permutation groups, g in G, H is a subgroup of G\n        generated by a list (words) of elements of G. If g is in H, return\n        the expression for g as a word in the elements of (words).\n\n        This function does not solve the word problem in Sage. Rather it\n        pushes it over to GAP, which has optimized algorithms for the word\n        problem. Essentially, this function is a wrapper for the GAP\n        functions \"EpimorphismFromFreeGroup\" and\n        \"PreImagesRepresentative\".\n\n        EXAMPLES::\n\n            sage: G = PermutationGroup([[(1,2,3),(4,5)],[(3,4)]], canonicalize=False)\n            sage: g1, g2 = G.gens()\n            sage: h = g1^2*g2*g1\n            sage: h.word_problem([g1,g2], False)\n            ('x1^2*x2^-1*x1', '(1,2,3)(4,5)^2*(3,4)^-1*(1,2,3)(4,5)')\n            sage: h.word_problem([g1,g2])\n               x1^2*x2^-1*x1\n               [['(1,2,3)(4,5)', 2], ['(3,4)', -1], ['(1,2,3)(4,5)', 1]]\n            ('x1^2*x2^-1*x1', '(1,2,3)(4,5)^2*(3,4)^-1*(1,2,3)(4,5)')\n        ",
                    "args": [
                        "self",
                        "words",
                        "display"
                    ],
                    "argspec": [
                        [
                            "self",
                            "words",
                            "display"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                }
            },
            "name": "sage.groups.perm_gps.permgroup_element.PermutationGroupElement"
        },
        "sage.groups.perm_gps.permgroup_named.PermutationGroup_unique": {
            "__doc__": "\n    .. TODO::\n\n        Fix the broken hash. ::\n\n            sage: G = SymmetricGroup(6)\n            sage: G3 = G.subgroup([G((1,2,3,4,5,6)),G((1,2))])\n            sage: hash(G) == hash(G3)  # todo: Should be True!\n            False\n    ",
            "implied": [
                "sage.groups.perm_gps.permgroup.PermutationGroup_generic"
            ],
            "methods": {},
            "name": "sage.groups.perm_gps.permgroup_named.PermutationGroup_unique"
        },
        "sage.groups.perm_gps.permgroup_named.TransitiveGroup": {
            "__doc__": null,
            "implied": [
                "sage.groups.perm_gps.permgroup_named.PermutationGroup_unique"
            ],
            "methods": {},
            "name": "sage.groups.perm_gps.permgroup_named.TransitiveGroup"
        },
        "sage.groups.perm_gps.permgroup_named.TransitiveGroup_with_category": {
            "__doc__": null,
            "categories": [
                "sage.categories.finite_permutation_groups.FinitePermutationGroups"
            ],
            "implied": [
                "sage.groups.perm_gps.permgroup_named.TransitiveGroup"
            ],
            "methods": {},
            "name": "sage.groups.perm_gps.permgroup_named.TransitiveGroup_with_category"
        },
        "sage.groups.perm_gps.permgroup_named.TransitiveGroupsAll": {
            "__doc__": "\n    The infinite set of all transitive groups up to isomorphisms.\n\n    EXAMPLES::\n\n        sage: L = TransitiveGroups(); L\n        Transitive Groups\n        sage: L.category()\n        Category of facade infinite enumerated sets\n        sage: L.cardinality()\n        +Infinity\n\n        sage: p = L.__iter__()            # optional - database_gap\n        sage: (next(p), next(p), next(p), next(p), next(p), next(p), next(p), next(p)) # optional - database_gap\n        (Transitive group number 1 of degree 0, Transitive group number 1 of degree 1, Transitive group number 1 of degree 2, Transitive group number 1 of degree 3, Transitive group number 2 of degree 3, Transitive group number 1 of degree 4, Transitive group number 2 of degree 4, Transitive group number 3 of degree 4)\n\n    TESTS:\n\n    The following test is broken, see :trac:`22576`::\n\n        sage: TestSuite(TransitiveGroups()).run() # known bug # optional - database_gap # long time\n    ",
            "implied": [
                "sage.sets.disjoint_union_enumerated_sets.DisjointUnionEnumeratedSets"
            ],
            "methods": {},
            "name": "sage.groups.perm_gps.permgroup_named.TransitiveGroupsAll"
        },
        "sage.groups.perm_gps.permgroup_named.TransitiveGroupsAll_with_category": {
            "__doc__": "\n    The infinite set of all transitive groups up to isomorphisms.\n\n    EXAMPLES::\n\n        sage: L = TransitiveGroups(); L\n        Transitive Groups\n        sage: L.category()\n        Category of facade infinite enumerated sets\n        sage: L.cardinality()\n        +Infinity\n\n        sage: p = L.__iter__()            # optional - database_gap\n        sage: (next(p), next(p), next(p), next(p), next(p), next(p), next(p), next(p)) # optional - database_gap\n        (Transitive group number 1 of degree 0, Transitive group number 1 of degree 1, Transitive group number 1 of degree 2, Transitive group number 1 of degree 3, Transitive group number 2 of degree 3, Transitive group number 1 of degree 4, Transitive group number 2 of degree 4, Transitive group number 3 of degree 4)\n\n    TESTS:\n\n    The following test is broken, see :trac:`22576`::\n\n        sage: TestSuite(TransitiveGroups()).run() # known bug # optional - database_gap # long time\n    ",
            "categories": [
                "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets",
                "sage.categories.facade_sets.FacadeSets"
            ],
            "implied": [
                "sage.groups.perm_gps.permgroup_named.TransitiveGroupsAll"
            ],
            "methods": {},
            "name": "sage.groups.perm_gps.permgroup_named.TransitiveGroupsAll_with_category"
        },
        "sage.sets.disjoint_union_enumerated_sets.DisjointUnionEnumeratedSets": {
            "__doc__": "\n    A class for disjoint unions of enumerated sets.\n\n    INPUT:\n\n     - ``family``  -- a list (or iterable or family) of enumerated sets\n     - ``keepkey`` -- a boolean\n     - ``facade``  -- a boolean\n\n    This models the enumerated set obtained by concatenating together\n    the specified ordered sets. The later are supposed to be pairwise\n    disjoint; otherwise, a multiset is created.\n\n    The argument ``family`` can be a list, a tuple, a dictionary, or a\n    family. If it is not a family it is first converted into a family\n    (see :func:`sage.sets.family.Family`).\n\n    Experimental options:\n\n    By default, there is no way to tell from which set of the union an\n    element is generated. The option ``keepkey=True`` keeps track of\n    those by returning pairs ``(key, el)`` where ``key`` is the index\n    of the set to which ``el`` belongs. When this option is specified,\n    the enumerated sets need not be disjoint anymore.\n\n    With the option ``facade=False`` the elements are wrapped in an\n    object whose parent is the disjoint union itself. The wrapped\n    object can then be recovered using the ``value`` attribute.\n\n    The two options can be combined.\n\n    The names of those options is imperfect, and subject to change in\n    future versions. Feedback welcome.\n\n    EXAMPLES:\n\n    The input can be a list or a tuple of FiniteEnumeratedSets::\n\n        sage: U1 = DisjointUnionEnumeratedSets((\n        ....:       FiniteEnumeratedSet([1,2,3]),\n        ....:       FiniteEnumeratedSet([4,5,6])))\n        sage: U1\n        Disjoint union of Family ({1, 2, 3}, {4, 5, 6})\n        sage: U1.list()\n        [1, 2, 3, 4, 5, 6]\n        sage: U1.cardinality()\n        6\n\n    The input can also be a dictionary::\n\n        sage: U2 = DisjointUnionEnumeratedSets({1: FiniteEnumeratedSet([1,2,3]),\n        ....:                                   2: FiniteEnumeratedSet([4,5,6])})\n        sage: U2\n        Disjoint union of Finite family {1: {1, 2, 3}, 2: {4, 5, 6}}\n        sage: U2.list()\n        [1, 2, 3, 4, 5, 6]\n        sage: U2.cardinality()\n        6\n\n    However in that case the enumeration order is not specified.\n\n    In general the input can be any family::\n\n        sage: U3 = DisjointUnionEnumeratedSets(\n        ....:     Family([2,3,4], Permutations, lazy=True))\n        sage: U3\n        Disjoint union of Lazy family (<class 'sage.combinat.permutation.Permutations'>(i))_{i in [2, 3, 4]}\n        sage: U3.cardinality()\n        32\n        sage: it = iter(U3)\n        sage: [next(it), next(it), next(it), next(it), next(it), next(it)]\n        [[1, 2], [2, 1], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]]\n        sage: U3.unrank(18)\n        [2, 4, 1, 3]\n\n    This allows for infinite unions::\n\n        sage: U4 = DisjointUnionEnumeratedSets(\n        ....:     Family(NonNegativeIntegers(), Permutations))\n        sage: U4\n        Disjoint union of Lazy family (<class 'sage.combinat.permutation.Permutations'>(i))_{i in Non negative integers}\n        sage: U4.cardinality()\n        +Infinity\n        sage: it = iter(U4)\n        sage: [next(it), next(it), next(it), next(it), next(it), next(it)]\n        [[], [1], [1, 2], [2, 1], [1, 2, 3], [1, 3, 2]]\n        sage: U4.unrank(18)\n        [2, 3, 1, 4]\n\n    .. WARNING::\n\n        Beware that some of the operations assume in that case that infinitely\n        many of the enumerated sets are non empty.\n\n\n    .. RUBRIC:: Experimental options\n\n    We demonstrate the ``keepkey`` option::\n\n        sage: Ukeep = DisjointUnionEnumeratedSets(\n        ....:            Family(list(range(4)), Permutations), keepkey=True)\n        sage: it = iter(Ukeep)\n        sage: [next(it) for i in range(6)]\n        [(0, []), (1, [1]), (2, [1, 2]), (2, [2, 1]), (3, [1, 2, 3]), (3, [1, 3, 2])]\n        sage: type(next(it)[1])\n        <class 'sage.combinat.permutation.StandardPermutations_n_with_category.element_class'>\n\n    We now demonstrate the ``facade`` option::\n\n        sage: UNoFacade = DisjointUnionEnumeratedSets(\n        ....:                Family(list(range(4)), Permutations), facade=False)\n        sage: it = iter(UNoFacade)\n        sage: [next(it) for i in range(6)]\n        [[], [1], [1, 2], [2, 1], [1, 2, 3], [1, 3, 2]]\n        sage: el = next(it); el\n        [2, 1, 3]\n        sage: type(el)\n        <type 'sage.structure.element_wrapper.ElementWrapper'>\n        sage: el.parent() == UNoFacade\n        True\n        sage: elv = el.value; elv\n        [2, 1, 3]\n        sage: type(elv)\n        <class 'sage.combinat.permutation.StandardPermutations_n_with_category.element_class'>\n\n    The elements ``el`` of the disjoint union are simple wrapped elements.\n    So to access the methods, you need to do ``el.value``::\n\n        sage: el[0]\n        Traceback (most recent call last):\n        ...\n        TypeError: 'sage.structure.element_wrapper.ElementWrapper' object\n         has no attribute '__getitem__'\n        sage: el.value[0]\n        2\n\n    Possible extensions: the current enumeration order is not suitable\n    for unions of infinite enumerated sets (except possibly for the\n    last one). One could add options to specify alternative enumeration\n    orders (anti-diagonal, round robin, ...) to handle this case.\n\n\n    .. RUBRIC:: Inheriting from ``DisjointUnionEnumeratedSets``\n\n    There are two different use cases for inheriting from\n    :class:`DisjointUnionEnumeratedSets`: writing a parent which\n    happens to be a disjoint union of some known parents, or writing\n    generic disjoint unions for some particular classes of\n    :class:`sage.categories.enumerated_sets.EnumeratedSets`.\n\n    - In the first use case, the input of the ``__init__`` method is\n      most likely different from that of\n      :class:`DisjointUnionEnumeratedSets`. Then, one simply\n      writes the ``__init__`` method as usual::\n\n          sage: class MyUnion(DisjointUnionEnumeratedSets):\n          ....:   def __init__(self):\n          ....:       DisjointUnionEnumeratedSets.__init__(self,\n          ....:            Family([1,2], Permutations))\n          sage: pp = MyUnion()\n          sage: pp.list()\n          [[1], [1, 2], [2, 1]]\n\n      In case the :meth:`__init__` method takes optional arguments,\n      or does some normalization on them, a specific method\n      ``__classcall_private__`` is required (see the\n      documentation of :class:`UniqueRepresentation`).\n\n    - In the second use case, the input of the ``__init__`` method\n      is the same as that of :class:`DisjointUnionEnumeratedSets`;\n      one therefore wants to inherit the :meth:`__classcall_private__`\n      method as well, which can be achieved as follows::\n\n          sage: class UnionOfSpecialSets(DisjointUnionEnumeratedSets):\n          ....:     __classcall_private__ = staticmethod(DisjointUnionEnumeratedSets.__classcall_private__)\n          sage: psp = UnionOfSpecialSets(Family([1,2], Permutations))\n          sage: psp.list()\n          [[1], [1, 2], [2, 1]]\n\n    TESTS::\n\n        sage: TestSuite(U1).run()\n        sage: TestSuite(U2).run()\n        sage: TestSuite(U3).run()\n        sage: TestSuite(U4).run()\n        doctest:...: UserWarning: Disjoint union of Lazy family (<class 'sage.combinat.permutation.Permutations'>(i))_{i in Non negative integers} is an infinite union\n        The default implementation of __contains__ can loop forever. Please overload it.\n        sage: TestSuite(UNoFacade).run()\n\n    We skip ``_test_an_element`` because the coercion framework does not\n    currently allow a tuple to be returned for facade parents::\n\n        sage: TestSuite(Ukeep).run(skip=\"_test_an_element\")\n\n    The following three lines are required for the pickling tests,\n    because the classes ``MyUnion`` and ``UnionOfSpecialSets`` have\n    been defined interactively::\n\n        sage: import __main__\n        sage: __main__.MyUnion = MyUnion\n        sage: __main__.UnionOfSpecialSets = UnionOfSpecialSets\n\n        sage: TestSuite(pp).run()\n        sage: TestSuite(psp).run()\n\n    ",
            "implied": [
                "sage.structure.parent.Parent"
            ],
            "methods": {
                "__iter__": {
                    "__doc__": "\n        TESTS::\n\n            sage: U4 = DisjointUnionEnumeratedSets(\n            ....:          Family(NonNegativeIntegers(), Permutations))\n            sage: it = iter(U4)\n            sage: [next(it), next(it), next(it), next(it), next(it), next(it)]\n            [[], [1], [1, 2], [2, 1], [1, 2, 3], [1, 3, 2]]\n\n            sage: U4 = DisjointUnionEnumeratedSets(\n            ....:          Family(NonNegativeIntegers(), Permutations),\n            ....:          keepkey=True, facade=False)\n            sage: it = iter(U4)\n            sage: [next(it), next(it), next(it), next(it), next(it), next(it)]\n            [(0, []), (1, [1]), (2, [1, 2]), (2, [2, 1]), (3, [1, 2, 3]), (3, [1, 3, 2])]\n            sage: el = next(it); el.parent() == U4\n            True\n            sage: el.value == (3, Permutation([2,1,3]))\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_element_constructor_default": {
                    "__doc__": "\n        TESTS::\n\n            sage: U = DisjointUnionEnumeratedSets(\n            ....:         Family([1,2,3], Partitions), facade=False)\n            sage: U([1])       # indirect doctest\n            [1]\n            sage: U([2,1])     # indirect doctest\n            [2, 1]\n            sage: U([1,3,2])   # indirect doctest\n            Traceback (most recent call last):\n            ...\n            ValueError: value [1, 3, 2] does not belong to Disjoint union of\n             Finite family {1: Partitions of the integer 1,\n                 2: Partitions of the integer 2,\n                 3: Partitions of the integer 3}\n\n            sage: U = DisjointUnionEnumeratedSets(\n            ....:          Family([1,2,3], Partitions), keepkey=True, facade=False)\n            sage: U((1, [1]))    # indirect doctest\n            (1, [1])\n            sage: U((3,[2,1]))   # indirect doctest\n            (3, [2, 1])\n            sage: U((4,[2,1]))   # indirect doctest\n            Traceback (most recent call last):\n            ...\n            ValueError: value (4, [2, 1]) does not belong to Disjoint union of\n             Finite family {1: Partitions of the integer 1,\n                 2: Partitions of the integer 2,\n                 3: Partitions of the integer 3}\n        ",
                    "args": [
                        "self",
                        "el"
                    ],
                    "argspec": [
                        [
                            "self",
                            "el"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_element_constructor_facade": {
                    "__doc__": "\n        TESTS::\n\n            sage: X = DisjointUnionEnumeratedSets({i: Partitions(i) for i in range(5)})\n            sage: X([1]).parent()\n            Partitions of the integer 1\n            sage: X([2,1,1]).parent()  # indirect doctest\n            Partitions of the integer 4\n            sage: X([6])\n            Traceback (most recent call last):\n            ...\n            ValueError: cannot coerce `[6]` in any parent in `Finite family {...}`\n\n        We need to call the element constructor directly when ``keepkey=True``\n        because this returns a `tuple`, where the coercion framework requires\n        an :class:`Element` be returned.\n\n            sage: X = DisjointUnionEnumeratedSets({i: Partitions(i) for i in range(5)},\n            ....:                                 keepkey=True)\n            sage: p = X._element_constructor_((0, []))  # indirect doctest\n            sage: p[1].parent()\n            Partitions of the integer 0\n \n        Test that facade parents can create and properly access elements\n        that are tuples (fixed by :trac:`22382`)::\n\n            sage: f = lambda mu: cartesian_product([mu.standard_tableaux(), \n            ....:                                   mu.standard_tableaux()])\n            sage: tabs = DisjointUnionEnumeratedSets(Family(Partitions(4), f))\n            sage: s = StandardTableau([[1,3],[2,4]])\n            sage: (s,s) in tabs\n            True\n            sage: ss = tabs( (s,s) )\n            sage: ss[0]\n            [[1, 3], [2, 4]]\n\n        We do not coerce when one of the elements is already in the set::\n\n            sage: X = DisjointUnionEnumeratedSets([QQ, ZZ])\n            sage: x = X(2)\n            sage: x.parent() is ZZ\n            True\n        ",
                    "args": [
                        "self",
                        "el"
                    ],
                    "argspec": [
                        [
                            "self",
                            "el"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_is_a": {
                    "__doc__": "\n        Check if a Sage object ``x`` belongs to ``self``.\n\n        This methods is a helper for :meth:`__contains__` and the\n        constructor :meth:`_element_constructor_`.\n\n        EXAMPLES::\n\n            sage: U4 = DisjointUnionEnumeratedSets(\n            ....:          Family(NonNegativeIntegers(), Compositions))\n            sage: U4._is_a(Composition([3,2,1,1]))\n            doctest:...: UserWarning: Disjoint union of Lazy family (<class 'sage.combinat.composition.Compositions'>(i))_{i in Non negative integers} is an infinite union\n            The default implementation of __contains__ can loop forever. Please overload it.\n            True\n        ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_repr_": {
                    "__doc__": "\n        TESTS::\n\n            sage: U = DisjointUnionEnumeratedSets({1: FiniteEnumeratedSet([1,2,3]),\n            ....:                                  2: FiniteEnumeratedSet([4,5,6])})\n            sage: U\n            Disjoint union of Finite family {1: {1, 2, 3}, 2: {4, 5, 6}}\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "cardinality": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            },
            "name": "sage.sets.disjoint_union_enumerated_sets.DisjointUnionEnumeratedSets"
        },
        "sage.structure.category_object.CategoryObject": {
            "__doc__": "CategoryObject(category=None, base=None)\nFile: sage/structure/category_object.pyx (starting at line 105)\n\n    An object in some category.\n    ",
            "implied": [
                "sage.structure.sage_object.SageObject"
            ],
            "methods": {
                "Hom": {
                    "__doc__": "CategoryObject.Hom(self, codomain, cat=None)\nFile: sage/structure/category_object.pyx (starting at line 626)\n\n        Return the homspace ``Hom(self, codomain, cat)`` of all\n        homomorphisms from self to codomain in the category cat.  The\n        default category is determined by ``self.category()`` and\n        ``codomain.category()``.\n\n        EXAMPLES::\n\n            sage: R.<x,y> = PolynomialRing(QQ, 2)\n            sage: R.Hom(QQ)\n            Set of Homomorphisms from Multivariate Polynomial Ring in x, y over Rational Field to Rational Field\n\n        Homspaces are defined for very general Sage objects, even elements of familiar rings.\n\n        ::\n\n            sage: n = 5; Hom(n,7)\n            Set of Morphisms from 5 to 7 in Category of elements of Integer Ring\n            sage: z=(2/3); Hom(z,8/1)\n            Set of Morphisms from 2/3 to 8 in Category of elements of Rational Field\n\n        This example illustrates the optional third argument::\n\n            sage: QQ.Hom(ZZ, Sets())\n            Set of Morphisms from Rational Field to Integer Ring in Category of sets\n        ",
                    "args": [
                        "self",
                        "codomain",
                        "cat"
                    ],
                    "argspec": [
                        [
                            "self",
                            "codomain",
                            "cat"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "__dir__": {
                    "__doc__": "CategoryObject.__dir__(self)\nFile: sage/structure/category_object.pyx (starting at line 855)\n\n        Let cat be the category of ``self``. This method emulates\n        ``self`` being an instance of both ``CategoryObject`` and\n        ``cat.parent_class``, in that order, for attribute directory.\n\n        EXAMPLES::\n\n            sage: for s in dir(ZZ):\n            ....:     if s[:6] == \"_test_\": print(s)\n            _test_additive_associativity\n            _test_an_element\n            _test_associativity\n            _test_cardinality\n            _test_category\n            _test_characteristic\n            _test_distributivity\n            _test_elements\n            _test_elements_eq_reflexive\n            _test_elements_eq_symmetric\n            _test_elements_eq_transitive\n            _test_elements_neq\n            _test_enumerated_set_contains\n            _test_enumerated_set_iter_cardinality\n            _test_enumerated_set_iter_list\n            _test_eq\n            _test_euclidean_degree\n            _test_gcd_vs_xgcd\n            _test_metric\n            _test_new\n            _test_not_implemented_methods\n            _test_one\n            _test_pickling\n            _test_prod\n            _test_quo_rem\n            _test_some_elements\n            _test_zero\n            _test_zero_divisors\n            sage: F = GF(9,'a')\n            sage: dir(F)\n            [..., '__class__', ..., '_test_pickling', ..., 'extension', ...]\n\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__div__": {
                    "__doc__": "File: sage/structure/category_object.pyx (starting at line 903)\n\n        Implement Python 2 division as true division.\n\n        EXAMPLES::\n\n            sage: V = QQ^2\n            sage: V.__div__(V.span([(1,3)]))\n            Vector space quotient V/W of dimension 1 over Rational Field where\n            V: Vector space of dimension 2 over Rational Field\n            W: Vector space of degree 2 and dimension 1 over Rational Field\n            Basis matrix:\n            [1 3]\n            sage: V.__truediv__(V.span([(1,3)]))\n            Vector space quotient V/W of dimension 1 over Rational Field where\n            V: Vector space of dimension 2 over Rational Field\n            W: Vector space of degree 2 and dimension 1 over Rational Field\n            Basis matrix:\n            [1 3]\n        ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__getstate__": {
                    "__doc__": "CategoryObject.__getstate__(self)\nFile: sage/structure/category_object.pyx (starting at line 697)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__rdiv__": {
                    "__doc__": "x.__rdiv__(y) <==> y/x",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__setstate__": {
                    "__doc__": "CategoryObject.__setstate__(self, d)\nFile: sage/structure/category_object.pyx (starting at line 716)",
                    "args": [
                        "self",
                        "d"
                    ],
                    "argspec": [
                        [
                            "self",
                            "d"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__temporarily_change_names": {
                    "__doc__": "CategoryObject.__temporarily_change_names(self, names, latex_names)\nFile: sage/structure/category_object.pyx (starting at line 495)\n\n        This is used by the variable names context manager.\n\n        TEST:\n\n        In an old version, it was impossible to temporarily change\n        the names if no names were previously assigned. But if one\n        wants to print elements of the quotient of such an \"unnamed\"\n        ring, an error resulted. That was fixed in :trac:`11068`::\n\n            sage: MS = MatrixSpace(GF(5),2,2)\n            sage: I = MS*[MS.0*MS.1,MS.2+MS.3]*MS\n            sage: Q.<a,b,c,d> = MS.quo(I)\n            sage: a     #indirect doctest\n            [1 0]\n            [0 0]\n\n        ",
                    "args": [
                        "self",
                        "names",
                        "latex_names"
                    ],
                    "argspec": [
                        [
                            "self",
                            "names",
                            "latex_names"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_assign_names": {
                    "__doc__": "CategoryObject._assign_names(self, names=None, normalize=True, ngens=None)\nFile: sage/structure/category_object.pyx (starting at line 401)\n\n        Set the names of the generator of this object.\n\n        This can only be done once because objects with generators\n        are immutable, and is typically done during creation of the object.\n\n\n        EXAMPLES:\n        When we create this polynomial ring, self._assign_names is called by the constructor::\n\n            sage: R = QQ['x,y,abc']; R\n            Multivariate Polynomial Ring in x, y, abc over Rational Field\n            sage: R.2\n            abc\n\n        We can't rename the variables::\n\n            sage: R._assign_names(['a','b','c'])\n            Traceback (most recent call last):\n            ...\n            ValueError: variable names cannot be changed after object creation.\n        ",
                    "args": [
                        "self",
                        "names",
                        "normalize",
                        "ngens"
                    ],
                    "argspec": [
                        [
                            "self",
                            "names",
                            "normalize",
                            "ngens"
                        ],
                        null,
                        null,
                        [
                            null,
                            true,
                            null
                        ]
                    ]
                },
                "_defining_names": {
                    "__doc__": "CachedMethod(f, name=None, key=None, do_pickle=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2607)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    The parameter ``do_pickle`` can be used to enable pickling of the cache.\n    Usually the cache is not stored when pickling::\n\n        sage: class A(object):\n        ....:     @cached_method\n        ....:     def f(self, x): return None\n        sage: import __main__\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        0\n\n    When ``do_pickle`` is set, the pickle contains the contents of the cache::\n\n        sage: class A(object):\n        ....:     @cached_method(do_pickle=True)\n        ....:     def f(self, x): return None\n        sage: __main__.A = A\n        sage: a = A()\n        sage: a.f(1)\n        sage: len(a.f.cache)\n        1\n        sage: b = loads(dumps(a))\n        sage: len(b.f.cache)\n        1\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "_first_ngens": {
                    "__doc__": "CategoryObject._first_ngens(self, n)\nFile: sage/structure/category_object.pyx (starting at line 329)\n\n        Used by the preparser for ``R.<x> = ...``.\n\n        EXAMPLES::\n\n            sage: R.<x> = PolynomialRing(QQ)\n            sage: x\n            x\n            sage: parent(x)\n            Univariate Polynomial Ring in x over Rational Field\n\n        For orders, we correctly use the ring generator, see\n        :trac:`15348`::\n\n            sage: A.<i> = ZZ.extension(x^2 + 1)\n            sage: i\n            i\n            sage: parent(i)\n            Order in Number Field in i with defining polynomial x^2 + 1\n\n        ::\n\n            sage: B.<z> = EquationOrder(x^2 + 3)\n            sage: z.minpoly()\n            x^2 + 3\n        ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_init_category_": {
                    "__doc__": "CategoryObject._init_category_(self, category)\nFile: sage/structure/category_object.pyx (starting at line 150)\n\n        Sets the category or categories of this object.\n\n        INPUT:\n\n        - ``category`` -- a category, or list or tuple thereof, or ``None``\n\n        EXAMPLES::\n\n            sage: A = sage.structure.category_object.CategoryObject()\n            sage: A._init_category_(Rings())\n            sage: A.category()\n            Category of rings\n            sage: A._init_category_((Semigroups(), CommutativeAdditiveSemigroups()))\n            sage: A.category()\n            Join of Category of semigroups and Category of commutative additive semigroups\n            sage: A._init_category_(None)\n            sage: A.category()\n            Category of objects\n\n            sage: P = Parent(category = None)\n            sage: P.category()\n            Category of sets\n        ",
                    "args": [
                        "self",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "category"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_is_category_initialized": {
                    "__doc__": "CategoryObject._is_category_initialized(self)\nFile: sage/structure/category_object.pyx (starting at line 224)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_refine_category_": {
                    "__doc__": "CategoryObject._refine_category_(self, category)\nFile: sage/structure/category_object.pyx (starting at line 183)\n\n        Changes the category of ``self`` into a subcategory.\n\n        INPUT:\n\n        - ``category`` -- a category or list or tuple thereof\n\n        The new category is obtained by adjoining ``category`` to the\n        current one.\n\n        .. SEEALSO:: :function:`Category.join`\n\n        EXAMPLES::\n\n            sage: P = Parent()\n            sage: P.category()\n            Category of sets\n            sage: P._refine_category_(Magmas())\n            sage: P.category()\n            Category of magmas\n            sage: P._refine_category_(Magmas())\n            sage: P.category()\n            Category of magmas\n            sage: P._refine_category_(EnumeratedSets())\n            sage: P.category()\n            Category of enumerated magmas\n            sage: P._refine_category_([Semigroups(), CommutativeAdditiveSemigroups()])\n            sage: P.category()\n            Join of Category of semigroups and Category of commutative additive semigroups and Category of enumerated sets\n            sage: P._refine_category_((CommutativeAdditiveMonoids(), Monoids()))\n            sage: P.category()\n            Join of Category of monoids and Category of commutative additive monoids and Category of enumerated sets\n        ",
                    "args": [
                        "self",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "category"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "base": {
                    "__doc__": "CategoryObject.base(self)\nFile: sage/structure/category_object.pyx (starting at line 620)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "base_ring": {
                    "__doc__": "CategoryObject.base_ring(self)\nFile: sage/structure/category_object.pyx (starting at line 564)\n\n        Return the base ring of ``self``.\n\n        INPUT:\n\n        - ``self`` -- an object over a base ring; typically a module\n\n        EXAMPLES::\n\n            sage: from sage.modules.module import Module\n            sage: Module(ZZ).base_ring()\n            Integer Ring\n\n            sage: F = FreeModule(ZZ,3)\n            sage: F.base_ring()\n            Integer Ring\n            sage: F.__class__.base_ring\n            <method 'base_ring' of 'sage.structure.category_object.CategoryObject' objects>\n\n        Note that the coordinates of the elements of a module can lie\n        in a bigger ring, the ``coordinate_ring``::\n\n            sage: M = (ZZ^2) * (1/2)\n            sage: v = M([1/2, 0])\n            sage: v.base_ring()\n            Integer Ring\n            sage: parent(v[0])\n            Rational Field\n            sage: v.coordinate_ring()\n            Rational Field\n\n        More examples::\n\n            sage: F = FreeAlgebra(QQ, 'x')\n            sage: F.base_ring()\n            Rational Field\n            sage: F.__class__.base_ring\n            <method 'base_ring' of 'sage.structure.category_object.CategoryObject' objects>\n\n            sage: E = CombinatorialFreeModule(ZZ, [1,2,3])\n            sage: F = CombinatorialFreeModule(ZZ, [2,3,4])\n            sage: H = Hom(E, F)\n            sage: H.base_ring()\n            Integer Ring\n            sage: H.__class__.base_ring\n            <method 'base_ring' of 'sage.structure.category_object.CategoryObject' objects>\n\n        .. TODO::\n\n            Move this method elsewhere (typically in the Modules\n            category) so as not to pollute the namespace of all\n            category objects.\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "categories": {
                    "__doc__": "CategoryObject.categories(self)\nFile: sage/structure/category_object.pyx (starting at line 234)\n\n        Return the categories of ``self``.\n\n        EXAMPLES::\n\n            sage: ZZ.categories()\n            [Join of Category of euclidean domains\n                 and Category of infinite enumerated sets\n                 and Category of metric spaces,\n             Category of euclidean domains,\n             Category of principal ideal domains,\n             Category of unique factorization domains,\n             Category of gcd domains,\n             Category of integral domains,\n             Category of domains,\n             Category of commutative rings, ...\n             Category of monoids, ...,\n             Category of commutative additive groups, ...,\n             Category of sets, ...,\n             Category of objects]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "gens_dict": {
                    "__doc__": "CategoryObject.gens_dict(self)\nFile: sage/structure/category_object.pyx (starting at line 262)\n\n        Return a dictionary whose entries are ``{name:variable,...}``,\n        where ``name`` stands for the variable names of this\n        object (as strings) and ``variable`` stands for the\n        corresponding defining generators (as elements of this object).\n\n        EXAMPLES::\n\n            sage: B.<a,b,c,d> = BooleanPolynomialRing()\n            sage: B.gens_dict()\n            {'a': a, 'b': b, 'c': c, 'd': d}\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "gens_dict_recursive": {
                    "__doc__": "CategoryObject.gens_dict_recursive(self)\nFile: sage/structure/category_object.pyx (starting at line 280)\n\n        Return the dictionary of generators of ``self`` and its base rings.\n\n        OUTPUT:\n\n        - a dictionary with string names of generators as keys and\n          generators of ``self`` and its base rings as values.\n\n        EXAMPLES::\n\n            sage: R = QQ['x,y']['z,w']\n            sage: sorted(R.gens_dict_recursive().items())\n            [('w', w), ('x', x), ('y', y), ('z', z)]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "has_base": {
                    "__doc__": "CategoryObject.has_base(self, category=None)\nFile: sage/structure/category_object.pyx (starting at line 556)",
                    "args": [
                        "self",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "category"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "inject_variables": {
                    "__doc__": "CategoryObject.inject_variables(self, scope=None, verbose=True)\nFile: sage/structure/category_object.pyx (starting at line 528)\n\n        Inject the generators of self with their names into the\n        namespace of the Python code from which this function is\n        called.  Thus, e.g., if the generators of self are labeled\n        'a', 'b', and 'c', then after calling this method the\n        variables a, b, and c in the current scope will be set\n        equal to the generators of self.\n\n        NOTE: If Foo is a constructor for a Sage object with generators, and\n        Foo is defined in Cython, then it would typically call\n        ``inject_variables()`` on the object it creates.  E.g.,\n        ``PolynomialRing(QQ, 'y')`` does this so that the variable y is the\n        generator of the polynomial ring.\n        ",
                    "args": [
                        "self",
                        "scope",
                        "verbose"
                    ],
                    "argspec": [
                        [
                            "self",
                            "scope",
                            "verbose"
                        ],
                        null,
                        null,
                        [
                            null,
                            true
                        ]
                    ]
                },
                "latex_name": {
                    "__doc__": "CategoryObject.latex_name(self)\nFile: sage/structure/category_object.pyx (starting at line 689)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "latex_variable_names": {
                    "__doc__": "CategoryObject.latex_variable_names(self)\nFile: sage/structure/category_object.pyx (starting at line 660)\n\n        Returns the list of variable names suitable for latex output.\n\n        All ``_SOMETHING`` substrings are replaced by ``_{SOMETHING}``\n        recursively so that subscripts of subscripts work.\n\n        EXAMPLES::\n\n            sage: R, x = PolynomialRing(QQ, 'x', 12).objgens()\n            sage: x\n            (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11)\n            sage: R.latex_variable_names ()\n            ['x_{0}', 'x_{1}', 'x_{2}', 'x_{3}', 'x_{4}', 'x_{5}', 'x_{6}', 'x_{7}', 'x_{8}', 'x_{9}', 'x_{10}', 'x_{11}']\n            sage: f = x[0]^3 + 15/3 * x[1]^10\n            sage: print(latex(f))\n            5 x_{1}^{10} + x_{0}^{3}\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "normalize_names": {
                    "__doc__": "CategoryObject.normalize_names(self, ngens, names)\nFile: sage/structure/category_object.pyx (starting at line 440)\n\n        TESTS::\n\n            sage: ZZ.normalize_names(1, \"x\")\n            doctest:...: DeprecationWarning: The method normalize_names() has been changed to a function\n            See http://trac.sagemath.org/19675 for details.\n            ('x',)\n        ",
                    "args": [
                        "self",
                        "ngens",
                        "names"
                    ],
                    "argspec": [
                        [
                            "self",
                            "ngens",
                            "names"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "objgen": {
                    "__doc__": "CategoryObject.objgen(self)\nFile: sage/structure/category_object.pyx (starting at line 315)\n\n        Return the tuple ``(self, self.gen())``.\n\n        EXAMPLES::\n\n            sage: R, x = PolynomialRing(QQ,'x').objgen()\n            sage: R\n            Univariate Polynomial Ring in x over Rational Field\n            sage: x\n            x\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "objgens": {
                    "__doc__": "CategoryObject.objgens(self)\nFile: sage/structure/category_object.pyx (starting at line 302)\n\n        Return the tuple ``(self, self.gens())``.\n\n        EXAMPLES::\n\n            sage: R = PolynomialRing(QQ, 3, 'x'); R\n            Multivariate Polynomial Ring in x0, x1, x2 over Rational Field\n            sage: R.objgens()\n            (Multivariate Polynomial Ring in x0, x1, x2 over Rational Field, (x0, x1, x2))\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "variable_name": {
                    "__doc__": "CategoryObject.variable_name(self)\nFile: sage/structure/category_object.pyx (starting at line 478)\n\n        Return the first variable name.\n\n        OUTPUT: a string\n\n        EXAMPLES::\n\n            sage: R.<z,y,a42> = ZZ[]\n            sage: R.variable_name()\n            'z'\n            sage: R.<x> = InfinitePolynomialRing(ZZ)\n            sage: R.variable_name()\n            'x'\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "variable_names": {
                    "__doc__": "CategoryObject.variable_names(self)\nFile: sage/structure/category_object.pyx (starting at line 453)\n\n        Return the list of variable names corresponding to the generators.\n\n        OUTPUT: a tuple of strings\n\n        EXAMPLES::\n\n            sage: R.<z,y,a42> = QQ[]\n            sage: R.variable_names()\n            ('z', 'y', 'a42')\n            sage: S = R.quotient_ring(z+y)\n            sage: S.variable_names()\n            ('zbar', 'ybar', 'a42bar')\n\n        ::\n\n            sage: T.<x> = InfinitePolynomialRing(ZZ)\n            sage: T.variable_names()\n            ('x',)\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.structure.category_object.CategoryObject"
        },
        "sage.structure.element.Element": {
            "__doc__": "Element(parent)\nFile: sage/structure/element.pyx (starting at line 356)\n\n    Generic element of a structure. All other types of elements\n    (:class:`RingElement`, :class:`ModuleElement`, etc)\n    derive from this type.\n\n    Subtypes must either call ``__init__()`` to set ``_parent``, or may\n    set ``_parent`` themselves if that would be more efficient.\n\n    .. automethod:: _cmp_\n    .. automethod:: _richcmp_\n    .. automethod:: __add__\n    .. automethod:: __sub__\n    .. automethod:: __neg__\n    .. automethod:: __mul__\n    .. automethod:: __div__\n    .. automethod:: __truediv__\n    .. automethod:: __floordiv__\n    .. automethod:: __mod__\n    ",
            "implied": [
                "sage.structure.sage_object.SageObject"
            ],
            "methods": {
                "N": {
                    "__doc__": "Deprecated: Use :meth:`n` instead.\nSee :trac:`13055` for details.\n\n",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__add__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 1182)\n\n        Top-level addition operator for :class:`Element` invoking\n        the coercion model.\n\n        See :ref:`element_arithmetic`.\n\n        EXAMPLES::\n\n            sage: from sage.structure.element import Element\n            sage: class MyElement(Element):\n            ....:     def _add_(self, other):\n            ....:         return 42\n            sage: e = MyElement(Parent())\n            sage: e + e\n            42\n\n        TESTS::\n\n            sage: e = Element(Parent())\n            sage: e + e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for +: '<type 'sage.structure.parent.Parent'>' and '<type 'sage.structure.parent.Parent'>'\n            sage: 1 + e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for +: 'Integer Ring' and '<type 'sage.structure.parent.Parent'>'\n            sage: e + 1\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for +: '<type 'sage.structure.parent.Parent'>' and 'Integer Ring'\n            sage: int(1) + e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for +: 'int' and 'sage.structure.element.Element'\n            sage: e + int(1)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for +: 'sage.structure.element.Element' and 'int'\n            sage: None + e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for +: 'NoneType' and 'sage.structure.element.Element'\n            sage: e + None\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for +: 'sage.structure.element.Element' and 'NoneType'\n        ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__cmp__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 1000)\n\n        Compare ``left`` and ``right`` using the coercion framework.\n\n        ``self`` and ``other`` are coerced to a common parent and then\n        ``_cmp_`` and ``_richcmp_`` are tried.\n\n        EXAMPLES:\n\n        We create an ``Element`` class where we define ``_richcmp_``\n        and check that comparison works::\n\n            sage: cython('''\n            ....: from sage.structure.sage_object cimport rich_to_bool\n            ....: from sage.structure.element cimport Element\n            ....: cdef class FloatCmp(Element):\n            ....:     cdef float x\n            ....:     def __init__(self, float v):\n            ....:         self.x = v\n            ....:     cpdef _richcmp_(self, other, int op):\n            ....:         cdef float x1 = (<FloatCmp>self).x\n            ....:         cdef float x2 = (<FloatCmp>other).x\n            ....:         return rich_to_bool(op, (x1 > x2) - (x1 < x2) )\n            ....: ''')\n            sage: a = FloatCmp(1)\n            sage: b = FloatCmp(2)\n            sage: cmp(a, b)\n            -1\n            sage: b.__cmp__(a)\n            1\n            sage: a <= b, b <= a\n            (True, False)\n\n        This works despite ``_cmp_`` not being implemented::\n\n            sage: a._cmp_(b)\n            Traceback (most recent call last):\n            ...\n            NotImplementedError: comparison not implemented for <type '...FloatCmp'>\n        ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__copy__": {
                    "__doc__": "Element.__copy__(self)\nFile: sage/structure/element.pyx (starting at line 538)\n\n        Return a copy of ``self``.\n\n        OUTPUT:\n\n          - a new object which is a copy of ``self``.\n\n        This implementation ensures that ``self.__dict__`` is properly copied\n        when it exists (typically for instances of classes deriving from\n        :class:`Element`).\n\n        TESTS::\n\n            sage: from sage.structure.element import Element\n            sage: el = Element(parent = ZZ)\n            sage: el1 = copy(el)\n            sage: el1 is el\n            False\n\n            sage: class Demo(Element): pass\n            sage: el = Demo(parent = ZZ)\n            sage: el.x = [1,2,3]\n            sage: el1 = copy(el)\n            sage: el1 is el\n            False\n            sage: el1.__dict__ is el.__dict__\n            False\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__dir__": {
                    "__doc__": "Element.__dir__(self)\nFile: sage/structure/element.pyx (starting at line 474)\n\n        Let cat be the category of the parent of ``self``. This method\n        emulates ``self`` being an instance of both ``Element`` and\n        ``cat.element_class``, in that order, for attribute directory.\n\n        EXAMPLES::\n\n            sage: dir(1/2)\n            ['N', ..., 'is_idempotent', 'is_integer', 'is_integral', ...]\n\n        Caveat: dir on Integer's and some other extension types seem to ignore __dir__::\n\n            sage: 1.__dir__()\n            ['N', ..., 'is_idempotent', 'is_integer', 'is_integral', ...]\n            sage: dir(1)         # todo: not implemented\n            ['N', ..., 'is_idempotent', 'is_integer', 'is_integral', ...]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__div__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 1576)\n\n        Top-level division operator for :class:`Element` invoking\n        the coercion model.\n\n        See :ref:`element_arithmetic`.\n\n        EXAMPLES::\n\n            sage: 2 / 3\n            2/3\n            sage: pi / 3\n            1/3*pi\n            sage: K.<i> = NumberField(x^2+1)\n            sage: 2 / K.ideal(i+1)\n            Fractional ideal (-i + 1)\n\n        ::\n\n            sage: from sage.structure.element import Element\n            sage: class MyElement(Element):\n            ....:     def _div_(self, other):\n            ....:         return 42\n            sage: e = MyElement(Parent())\n            sage: e / e\n            42\n\n        TESTS::\n\n            sage: e = Element(Parent())\n            sage: e / e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for /: '<type 'sage.structure.parent.Parent'>' and '<type 'sage.structure.parent.Parent'>'\n            sage: 1 / e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for /: 'Integer Ring' and '<type 'sage.structure.parent.Parent'>'\n            sage: e / 1\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for /: '<type 'sage.structure.parent.Parent'>' and 'Integer Ring'\n            sage: int(1) / e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for /: 'int' and 'sage.structure.element.Element'\n            sage: e / int(1)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for /: 'sage.structure.element.Element' and 'int'\n            sage: None / e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for /: 'NoneType' and 'sage.structure.element.Element'\n            sage: e / None\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for /: 'sage.structure.element.Element' and 'NoneType'\n        ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__floordiv__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 1749)\n\n        Top-level floor division operator for :class:`Element` invoking\n        the coercion model.\n\n        See :ref:`element_arithmetic`.\n\n        EXAMPLES::\n\n            sage: 7 // 3\n            2\n            sage: 7 // int(3)\n            2\n            sage: int(7) // 3\n            2\n\n        ::\n\n            sage: from sage.structure.element import Element\n            sage: class MyElement(Element):\n            ....:     def _floordiv_(self, other):\n            ....:         return 42\n            sage: e = MyElement(Parent())\n            sage: e // e\n            42\n\n        TESTS::\n\n            sage: e = Element(Parent())\n            sage: e // e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for //: '<type 'sage.structure.parent.Parent'>' and '<type 'sage.structure.parent.Parent'>'\n            sage: 1 // e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for //: 'Integer Ring' and '<type 'sage.structure.parent.Parent'>'\n            sage: e // 1\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for //: '<type 'sage.structure.parent.Parent'>' and 'Integer Ring'\n            sage: int(1) // e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for //: 'int' and 'sage.structure.element.Element'\n            sage: e // int(1)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for //: 'sage.structure.element.Element' and 'int'\n            sage: None // e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for //: 'NoneType' and 'sage.structure.element.Element'\n            sage: e // None\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for //: 'sage.structure.element.Element' and 'NoneType'\n        ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__getmetaclass__": {
                    "__doc__": "Element.__getmetaclass__(_)\nFile: sage/structure/element.pyx (starting at line 376)",
                    "args": [
                        "_"
                    ],
                    "argspec": [
                        [
                            "_"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__getstate__": {
                    "__doc__": "Element.__getstate__(self)\nFile: sage/structure/element.pyx (starting at line 498)\n\n        Return a tuple describing the state of your object.\n\n        This should return all information that will be required to unpickle\n        the object. The functionality for unpickling is implemented in\n        __setstate__().\n\n        TESTS::\n\n            sage: R.<x,y> = QQ[]\n            sage: i = ideal(x^2 - y^2 + 1)\n            sage: i.__getstate__()\n            (Monoid of ideals of Multivariate Polynomial Ring in x, y over Rational Field,\n             {'_Ideal_generic__gens': (x^2 - y^2 + 1,),\n              '_Ideal_generic__ring': Multivariate Polynomial Ring in x, y over Rational Field,\n              '_gb_by_ordering': {}})\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__mod__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 1849)\n\n        Top-level modulo operator for :class:`Element` invoking\n        the coercion model.\n\n        See :ref:`element_arithmetic`.\n\n        EXAMPLES::\n\n            sage: 7 % 3\n            1\n            sage: 7 % int(3)\n            1\n            sage: int(7) % 3\n            1\n\n        ::\n\n            sage: from sage.structure.element import Element\n            sage: class MyElement(Element):\n            ....:     def _mod_(self, other):\n            ....:         return 42\n            sage: e = MyElement(Parent())\n            sage: e % e\n            42\n\n        TESTS::\n\n            sage: e = Element(Parent())\n            sage: e % e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for %: '<type 'sage.structure.parent.Parent'>' and '<type 'sage.structure.parent.Parent'>'\n            sage: 1 % e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for %: 'Integer Ring' and '<type 'sage.structure.parent.Parent'>'\n            sage: e % 1\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for %: '<type 'sage.structure.parent.Parent'>' and 'Integer Ring'\n            sage: int(1) % e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for %: 'int' and 'sage.structure.element.Element'\n            sage: e % int(1)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for %: 'sage.structure.element.Element' and 'int'\n            sage: None % e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for %: 'NoneType' and 'sage.structure.element.Element'\n            sage: e % None\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for %: 'sage.structure.element.Element' and 'NoneType'\n        ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__mul__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 1448)\n\n        Top-level multiplication operator for :class:`Element` invoking\n        the coercion model.\n\n        See :ref:`element_arithmetic`.\n\n        EXAMPLES::\n\n            sage: from sage.structure.element import Element\n            sage: class MyElement(Element):\n            ....:     def _mul_(self, other):\n            ....:         return 42\n            sage: e = MyElement(Parent())\n            sage: e * e\n            42\n\n        TESTS::\n\n            sage: e = Element(Parent())\n            sage: e * e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for *: '<type 'sage.structure.parent.Parent'>' and '<type 'sage.structure.parent.Parent'>'\n            sage: 1 * e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for *: 'Integer Ring' and '<type 'sage.structure.parent.Parent'>'\n            sage: e * 1\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for *: '<type 'sage.structure.parent.Parent'>' and 'Integer Ring'\n            sage: int(1) * e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for *: 'int' and 'sage.structure.element.Element'\n            sage: e * int(1)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for *: 'sage.structure.element.Element' and 'int'\n            sage: None * e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for *: 'NoneType' and 'sage.structure.element.Element'\n            sage: e * None\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for *: 'sage.structure.element.Element' and 'NoneType'\n\n        ::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__neg__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 1394)\n\n        Top-level negation operator for :class:`Element`.\n\n        EXAMPLES::\n\n            sage: from sage.structure.element import Element\n            sage: class MyElement(Element):\n            ....:     def _neg_(self):\n            ....:         return 42\n            sage: e = MyElement(Parent())\n            sage: -e\n            42\n\n        TESTS::\n\n            sage: e = Element(Parent())\n            sage: -e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent for unary -: '<type 'sage.structure.parent.Parent'>'\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__nonzero__": {
                    "__doc__": "x.__nonzero__() <==> x != 0",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__pos__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 922)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__radd__": {
                    "__doc__": "x.__radd__(y) <==> y+x",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__rdiv__": {
                    "__doc__": "x.__rdiv__(y) <==> y/x",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__rfloordiv__": {
                    "__doc__": "x.__rfloordiv__(y) <==> y//x",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__rmod__": {
                    "__doc__": "x.__rmod__(y) <==> y%x",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__rmul__": {
                    "__doc__": "x.__rmul__(y) <==> y*x",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__rsub__": {
                    "__doc__": "x.__rsub__(y) <==> y-x",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__rtruediv__": {
                    "__doc__": "x.__rtruediv__(y) <==> y/x",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__rxor__": {
                    "__doc__": "x.__rxor__(y) <==> y^x",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__setstate__": {
                    "__doc__": "Element.__setstate__(self, state)\nFile: sage/structure/element.pyx (starting at line 518)\n\n        Initializes the state of the object from data saved in a pickle.\n\n        During unpickling __init__ methods of classes are not called, the saved\n        data is passed to the class via this function instead.\n\n        TESTS::\n\n            sage: R.<x,y> = QQ[]\n            sage: i = ideal(x); i\n            Ideal (x) of Multivariate Polynomial Ring in x, y over Rational Field\n            sage: S.<x,y,z> = ZZ[]\n            sage: i.__setstate__((R,{'_Ideal_generic__ring':S,'_Ideal_generic__gens': (S(x^2 - y^2 + 1),)}))\n            sage: i\n            Ideal (x^2 - y^2 + 1) of Multivariate Polynomial Ring in x, y, z over Integer Ring\n        ",
                    "args": [
                        "self",
                        "state"
                    ],
                    "argspec": [
                        [
                            "self",
                            "state"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__sub__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 1303)\n\n        Top-level subtraction operator for :class:`Element` invoking\n        the coercion model.\n\n        See :ref:`element_arithmetic`.\n\n        EXAMPLES::\n\n            sage: from sage.structure.element import Element\n            sage: class MyElement(Element):\n            ....:     def _sub_(self, other):\n            ....:         return 42\n            sage: e = MyElement(Parent())\n            sage: e - e\n            42\n\n        TESTS::\n\n            sage: e = Element(Parent())\n            sage: e - e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for -: '<type 'sage.structure.parent.Parent'>' and '<type 'sage.structure.parent.Parent'>'\n            sage: 1 - e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for -: 'Integer Ring' and '<type 'sage.structure.parent.Parent'>'\n            sage: e - 1\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for -: '<type 'sage.structure.parent.Parent'>' and 'Integer Ring'\n            sage: int(1) - e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for -: 'int' and 'sage.structure.element.Element'\n            sage: e - int(1)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for -: 'sage.structure.element.Element' and 'int'\n            sage: None - e\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for -: 'NoneType' and 'sage.structure.element.Element'\n            sage: e - None\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for -: 'sage.structure.element.Element' and 'NoneType'\n        ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__truediv__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 1647)\n\n        Top-level true division operator for :class:`Element` invoking\n        the coercion model.\n\n        See :ref:`element_arithmetic`.\n\n        EXAMPLES::\n\n            sage: operator.truediv(2, 3)\n            2/3\n            sage: operator.truediv(pi, 3)\n            1/3*pi\n            sage: K.<i> = NumberField(x^2+1)\n            sage: operator.truediv(2, K.ideal(i+1))\n            Fractional ideal (-i + 1)\n\n        ::\n\n            sage: from sage.structure.element import Element\n            sage: class MyElement(Element):\n            ....:     def _div_(self, other):\n            ....:         return 42\n            sage: e = MyElement(Parent())\n            sage: operator.truediv(e, e)\n            42\n\n        TESTS::\n\n            sage: e = Element(Parent())\n            sage: operator.truediv(e, e)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for /: '<type 'sage.structure.parent.Parent'>' and '<type 'sage.structure.parent.Parent'>'\n            sage: operator.truediv(1, e)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for /: 'Integer Ring' and '<type 'sage.structure.parent.Parent'>'\n            sage: operator.truediv(e, 1)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for /: '<type 'sage.structure.parent.Parent'>' and 'Integer Ring'\n            sage: operator.truediv(int(1), e)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for /: 'int' and 'sage.structure.element.Element'\n            sage: operator.truediv(e, int(1))\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for /: 'sage.structure.element.Element' and 'int'\n            sage: operator.truediv(None, e)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for /: 'NoneType' and 'sage.structure.element.Element'\n            sage: operator.truediv(e, None)\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand type(s) for /: 'sage.structure.element.Element' and 'NoneType'\n        ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__xor__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 918)",
                    "args": [
                        "self",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_act_on_": {
                    "__doc__": "Element._act_on_(self, x, bool self_on_left)\nFile: sage/structure/element.pyx (starting at line 899)\n\n        Use this method to implement ``self`` acting on ``x``.\n\n        Return None or raise a CoercionException if no\n        such action is defined here.\n        ",
                    "args": [
                        "self",
                        "x",
                        "self_on_left"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "self_on_left"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_acted_upon_": {
                    "__doc__": "Element._acted_upon_(self, x, bool self_on_left)\nFile: sage/structure/element.pyx (starting at line 908)\n\n        Use this method to implement ``self`` acted on by x.\n\n        Return None or raise a CoercionException if no\n        such action is defined here.\n        ",
                    "args": [
                        "self",
                        "x",
                        "self_on_left"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "self_on_left"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_cmp_": {
                    "__doc__": "Element._cmp_(left, right) -> int\nFile: sage/structure/element.pyx (starting at line 1167)\n\n        Default three-way comparison method which only checks for a\n        Python class defining ``__cmp__``.\n        ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_coeff_repr": {
                    "__doc__": "Element._coeff_repr(self, no_space=True)\nFile: sage/structure/element.pyx (starting at line 925)",
                    "args": [
                        "self",
                        "no_space"
                    ],
                    "argspec": [
                        [
                            "self",
                            "no_space"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "_im_gens_": {
                    "__doc__": "Element._im_gens_(self, codomain, im_gens)\nFile: sage/structure/element.pyx (starting at line 581)\n\n        Return the image of ``self`` in codomain under the map that sends\n        the images of the generators of the parent of ``self`` to the\n        tuple of elements of im_gens.\n        ",
                    "args": [
                        "self",
                        "codomain",
                        "im_gens"
                    ],
                    "argspec": [
                        [
                            "self",
                            "codomain",
                            "im_gens"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_is_atomic": {
                    "__doc__": "Element._is_atomic(self)\nFile: sage/structure/element.pyx (starting at line 944)\n\n        Return ``True`` if and only if parenthesis are not required when\n        *printing* out any of `x - s`, `x + s`, `x^s` and `x/s`.\n\n        EXAMPLES::\n\n            sage: n = 5; n._is_atomic()\n            True\n            sage: n = x+1; n._is_atomic()\n            False\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_latex_coeff_repr": {
                    "__doc__": "Element._latex_coeff_repr(self)\nFile: sage/structure/element.pyx (starting at line 934)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_mpmath_": {
                    "__doc__": "Element._mpmath_(self, prec=53, rounding=None)\nFile: sage/structure/element.pyx (starting at line 842)\n\n        Evaluates numerically and returns an mpmath number.\n        Used as fallback for conversion by mpmath.mpmathify().\n\n        .. NOTE::\n\n            Currently, the rounding mode is ignored.\n\n        EXAMPLES::\n\n            sage: from sage.libs.mpmath.all import mp, mpmathify\n            sage: mp.dps = 30\n            sage: 25._mpmath_(53)\n            mpf('25.0')\n            sage: mpmathify(3+4*I)\n            mpc(real='3.0', imag='4.0')\n            sage: mpmathify(1+pi)\n            mpf('4.14159265358979323846264338327933')\n            sage: (1+pi)._mpmath_(10)\n            mpf('4.140625')\n            sage: (1+pi)._mpmath_(mp.prec)\n            mpf('4.14159265358979323846264338327933')\n        ",
                    "args": [
                        "self",
                        "prec",
                        "rounding"
                    ],
                    "argspec": [
                        [
                            "self",
                            "prec",
                            "rounding"
                        ],
                        null,
                        null,
                        [
                            53,
                            null
                        ]
                    ]
                },
                "_repr_": {
                    "__doc__": "Element._repr_(self)\nFile: sage/structure/element.pyx (starting at line 495)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_richcmp_": {
                    "__doc__": "Element._richcmp_(left, right, int op)\nFile: sage/structure/element.pyx (starting at line 1127)\n\n        Default implementation of rich comparisons for elements with\n        equal parents.\n\n        It tries to see if ``_cmp_`` is implemented. Otherwise it does a\n        comparison by id for ``==`` and ``!=``. Calling this default method\n        with ``<``, ``<=``, ``>`` or ``>=`` will raise a\n        ``NotImplementedError``.\n\n        EXAMPLES::\n\n            sage: from sage.structure.parent import Parent\n            sage: from sage.structure.element import Element\n            sage: P = Parent()\n            sage: e1 = Element(P); e2 = Element(P)\n            sage: e1 == e1    # indirect doctest\n            True\n            sage: e1 == e2    # indirect doctest\n            False\n            sage: e1 < e2     # indirect doctest\n            Traceback (most recent call last):\n            ...\n            NotImplementedError: comparison not implemented for <type 'sage.structure.element.Element'>\n        ",
                    "args": [
                        "left",
                        "right",
                        "op"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right",
                            "op"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_set_parent": {
                    "__doc__": "Element._set_parent(self, parent)\nFile: sage/structure/element.pyx (starting at line 388)\n\n        INPUT:\n\n        - ``parent`` - a SageObject\n        ",
                    "args": [
                        "self",
                        "parent"
                    ],
                    "argspec": [
                        [
                            "self",
                            "parent"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_test_eq": {
                    "__doc__": "Element._test_eq(self, **options)\nFile: sage/structure/element.pyx (starting at line 673)\n\n        Test that ``self`` is equal to ``self`` and different to ``None``.\n\n        See also: :class:`TestSuite`.\n\n        TESTS::\n\n            sage: from sage.structure.element import Element\n            sage: O = Element(Parent())\n            sage: O._test_eq()\n\n        Let us now write a broken class method::\n\n            sage: class CCls(Element):\n            ....:     def __eq__(self, other):\n            ....:         return True\n            sage: CCls(Parent())._test_eq()\n            Traceback (most recent call last):\n            ...\n            AssertionError: broken equality: Generic element of a structure == None\n\n        Let us now break inequality::\n\n            sage: class CCls(Element):\n            ....:     def __ne__(self, other):\n            ....:         return True\n            sage: CCls(Parent())._test_eq()\n            Traceback (most recent call last):\n            ...\n            AssertionError: broken non-equality: Generic element of a structure != itself\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "base_extend": {
                    "__doc__": "Element.base_extend(self, R)\nFile: sage/structure/element.pyx (starting at line 589)",
                    "args": [
                        "self",
                        "R"
                    ],
                    "argspec": [
                        [
                            "self",
                            "R"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "base_ring": {
                    "__doc__": "Element.base_ring(self)\nFile: sage/structure/element.pyx (starting at line 594)\n\n        Return the base ring of this element's parent (if that makes sense).\n\n        TESTS::\n\n            sage: QQ.base_ring()\n            Rational Field\n            sage: identity_matrix(3).base_ring()\n            Integer Ring\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_zero": {
                    "__doc__": "Element.is_zero(self)\nFile: sage/structure/element.pyx (starting at line 986)\n\n        Return ``True`` if ``self`` equals ``self.parent()(0)``.\n\n        The default implementation is to fall back to ``not\n        self.__nonzero__``.\n\n        .. WARNING::\n\n            Do not re-implement this method in your subclass but\n            implement ``__nonzero__`` instead.\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "n": {
                    "__doc__": "Element.n(self, prec=None, digits=None, algorithm=None)\nFile: sage/structure/element.pyx (starting at line 829)\n\n        Alias for :meth:`numerical_approx`.\n\n        EXAMPLES::\n\n            sage: (2/3).n()\n            0.666666666666667\n        ",
                    "args": [
                        "self",
                        "prec",
                        "digits",
                        "algorithm"
                    ],
                    "argspec": [
                        [
                            "self",
                            "prec",
                            "digits",
                            "algorithm"
                        ],
                        null,
                        null,
                        [
                            null,
                            null,
                            null
                        ]
                    ]
                },
                "numerical_approx": {
                    "__doc__": "Element.numerical_approx(self, prec=None, digits=None, algorithm=None)\nFile: sage/structure/element.pyx (starting at line 781)\n\n        Return a numerical approximation of ``self`` with ``prec`` bits\n        (or decimal ``digits``) of precision.\n\n        No guarantee is made about the accuracy of the result.\n\n        INPUT:\n\n        - ``prec`` -- precision in bits\n\n        - ``digits`` -- precision in decimal digits (only used if\n          ``prec`` is not given)\n\n        - ``algorithm`` -- which algorithm to use to compute this\n          approximation (the accepted algorithms depend on the object)\n\n        If neither ``prec`` nor ``digits`` is given, the default\n        precision is 53 bits (roughly 16 digits).\n\n        EXAMPLES::\n\n            sage: (2/3).numerical_approx()\n            0.666666666666667\n            sage: pi.n(digits=10)\n            3.141592654\n            sage: pi.n(prec=20)\n            3.1416\n\n        TESTS:\n\n        Check that :trac:`14778` is fixed::\n\n            sage: (0).n(algorithm='foo')\n            0.000000000000000\n\n        The ``.N`` method is a deprecated alias::\n\n            sage: 0.N()\n            doctest:...: DeprecationWarning: N is deprecated. Please use n instead.\n            See http://trac.sagemath.org/13055 for details.\n            0.000000000000000\n        ",
                    "args": [
                        "self",
                        "prec",
                        "digits",
                        "algorithm"
                    ],
                    "argspec": [
                        [
                            "self",
                            "prec",
                            "digits",
                            "algorithm"
                        ],
                        null,
                        null,
                        [
                            null,
                            null,
                            null
                        ]
                    ]
                },
                "subs": {
                    "__doc__": "Element.subs(self, in_dict=None, **kwds)\nFile: sage/structure/element.pyx (starting at line 729)\n\n        Substitutes given generators with given values while not touching\n        other generators. This is a generic wrapper around ``__call__``.\n        The syntax is meant to be compatible with the corresponding method\n        for symbolic expressions.\n\n        INPUT:\n\n        - ``in_dict`` - (optional) dictionary of inputs\n\n        - ``**kwds`` - named parameters\n\n        OUTPUT:\n\n        - new object if substitution is possible, otherwise self.\n\n        EXAMPLES::\n\n            sage: x, y = PolynomialRing(ZZ,2,'xy').gens()\n            sage: f = x^2 + y + x^2*y^2 + 5\n            sage: f((5,y))\n            25*y^2 + y + 30\n            sage: f.subs({x:5})\n            25*y^2 + y + 30\n            sage: f.subs(x=5)\n            25*y^2 + y + 30\n            sage: (1/f).subs(x=5)\n            1/(25*y^2 + y + 30)\n            sage: Integer(5).subs(x=4)\n            5\n        ",
                    "args": [
                        "self",
                        "in_dict"
                    ],
                    "argspec": [
                        [
                            "self",
                            "in_dict"
                        ],
                        null,
                        "kwds",
                        [
                            null
                        ]
                    ]
                },
                "substitute": {
                    "__doc__": "Element.substitute(self, in_dict=None, **kwds)\nFile: sage/structure/element.pyx (starting at line 868)\n\n        This is an alias for self.subs().\n\n        INPUT:\n\n        - ``in_dict`` - (optional) dictionary of inputs\n\n        - ``**kwds``  - named parameters\n\n        OUTPUT:\n\n        - new object if substitution is possible, otherwise self.\n\n        EXAMPLES::\n\n            sage: x, y = PolynomialRing(ZZ,2,'xy').gens()\n            sage: f = x^2 + y + x^2*y^2 + 5\n            sage: f((5,y))\n            25*y^2 + y + 30\n            sage: f.substitute({x:5})\n            25*y^2 + y + 30\n            sage: f.substitute(x=5)\n            25*y^2 + y + 30\n            sage: (1/f).substitute(x=5)\n            1/(25*y^2 + y + 30)\n            sage: Integer(5).substitute(x=4)\n            5\n         ",
                    "args": [
                        "self",
                        "in_dict"
                    ],
                    "argspec": [
                        [
                            "self",
                            "in_dict"
                        ],
                        null,
                        "kwds",
                        [
                            null
                        ]
                    ]
                }
            },
            "name": "sage.structure.element.Element"
        },
        "sage.structure.element.MonoidElement": {
            "__doc__": "File: sage/structure/element.pyx (starting at line 2251)\n\n    Generic element of a monoid.\n    ",
            "implied": [
                "sage.structure.element.Element"
            ],
            "methods": {
                "__pow__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 2272)\n\n        Return the (integral) power of self.\n        ",
                    "args": [
                        "self",
                        "n",
                        "dummy"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n",
                            "dummy"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__rpow__": {
                    "__doc__": "y.__rpow__(x[, z]) <==> pow(x, y[, z])",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "multiplicative_order": {
                    "__doc__": "MonoidElement.multiplicative_order(self)\nFile: sage/structure/element.pyx (starting at line 2266)\n\n        Return the multiplicative order of self.\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "order": {
                    "__doc__": "MonoidElement.order(self)\nFile: sage/structure/element.pyx (starting at line 2260)\n\n        Return the multiplicative order of self.\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "powers": {
                    "__doc__": "MonoidElement.powers(self, n)\nFile: sage/structure/element.pyx (starting at line 2280)\n\n        Return the list `[x^0, x^1, \\ldots, x^{n-1}]`.\n\n        EXAMPLES::\n\n            sage: G = SymmetricGroup(4)\n            sage: g = G([2, 3, 4, 1])\n            sage: g.powers(4)\n            [(), (1,2,3,4), (1,3)(2,4), (1,4,3,2)]\n        ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.structure.element.MonoidElement"
        },
        "sage.structure.element.MultiplicativeGroupElement": {
            "__doc__": "File: sage/structure/element.pyx (starting at line 2331)\n\n    Generic element of a multiplicative group.\n    ",
            "implied": [
                "sage.structure.element.MonoidElement"
            ],
            "methods": {
                "__invert__": {
                    "__doc__": "File: sage/structure/element.pyx (starting at line 2348)\n\n        Return the inverse of ``self``.\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_div_": {
                    "__doc__": "MultiplicativeGroupElement._div_(self, right)\nFile: sage/structure/element.pyx (starting at line 2341)\n\n        Default implementation of division using multiplication by\n        the inverse.\n        ",
                    "args": [
                        "self",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.structure.element.MultiplicativeGroupElement"
        },
        "sage.structure.parent.Parent": {
            "__doc__": "Parent(base=None, category=None, *, element_constructor=None, names=None, normalize=True, facade=None, **kwds)",
            "implied": [
                "sage.structure.category_object.CategoryObject"
            ],
            "methods": {
                "__contains__": {
                    "__doc__": "File: sage/structure/parent.pyx (starting at line 1054)\n\n        True if there is an element of self that is equal to x under\n        ==, or if x is already an element of self.  Also, True in other\n        cases involving the Symbolic Ring, which is handled specially.\n\n        For many structures we test this by using :meth:`__call__` and\n        then testing equality between x and the result.\n\n        The Symbolic Ring is treated differently because it is\n        ultra-permissive about letting other rings coerce in, but\n        ultra-strict about doing comparisons.\n\n        EXAMPLES::\n\n            sage: 2 in Integers(7)\n            True\n            sage: 2 in ZZ\n            True\n            sage: Integers(7)(3) in ZZ\n            True\n            sage: 3/1 in ZZ\n            True\n            sage: 5 in QQ\n            True\n            sage: I in RR\n            False\n            sage: SR(2) in ZZ\n            True\n            sage: RIF(1, 2) in RIF\n            True\n            sage: pi in RIF # there is no element of RIF equal to pi\n            False\n            sage: sqrt(2) in CC\n            True\n            sage: pi in RR\n            True\n            sage: pi in CC\n            True\n            sage: pi in RDF\n            True\n            sage: pi in CDF\n            True\n\n        Note that we have\n\n        ::\n\n            sage: 3/2 in RIF\n            True\n\n        because ``3/2`` has an exact representation in ``RIF`` (i.e. can be\n        represented as an interval that contains exactly one value)::\n\n            sage: RIF(3/2).is_exact()\n            True\n\n        On the other hand, we have\n\n        ::\n\n            sage: 2/3 in RIF\n            False\n\n        because ``2/3`` has no exact representation in ``RIF``. Since\n        ``RIF(2/3)`` is a nontrivial interval, it can not be equal to anything\n        (not even itself)::\n\n            sage: RIF(2/3).is_exact()\n            False\n            sage: RIF(2/3).endpoints()\n            (0.666666666666666, 0.666666666666667)\n            sage: RIF(2/3) == RIF(2/3)\n            False\n\n        TESTS:\n\n        Check that :trac:`13824` is fixed::\n\n            sage: 4/3 in GF(3)\n            False\n            sage: 15/50 in GF(25, 'a')\n            False\n            sage: 7/4 in Integers(4)\n            False\n            sage: 15/36 in Integers(6)\n            False\n        ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__getitem__": {
                    "__doc__": "File: sage/structure/parent.pyx (starting at line 1229)\n\n        Returns the `n^{th}` item or slice `n` of self,\n        by getting self as a list.\n\n        EXAMPLES::\n\n            sage: VectorSpace(GF(7), 3)[:10]\n            [(0, 0, 0),\n             (1, 0, 0),\n             (2, 0, 0),\n             (3, 0, 0),\n             (4, 0, 0),\n             (5, 0, 0),\n             (6, 0, 0),\n             (0, 1, 0),\n             (1, 1, 0),\n             (2, 1, 0)]\n\n        TESTS:\n\n        We test the workaround described in :trac:`12956` to let categories\n        override this default implementation::\n\n            sage: class As(Category):\n            ....:     def super_categories(self): return [Sets()]\n            ....:     class ParentMethods:\n            ....:         def __getitem__(self, n):\n            ....:             return 'coucou'\n            sage: class A(Parent):\n            ....:     def __init__(self):\n            ....:         Parent.__init__(self, category=As())\n            sage: a = A()\n            sage: a[1]\n            'coucou'\n        ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__make_element_class__": {
                    "__doc__": "Parent.__make_element_class__(self, cls, name=None, inherit=None)\nFile: sage/structure/parent.pyx (starting at line 587)\n\n        A utility to construct classes for the elements of this\n        parent, with appropriate inheritance from the element class of\n        the category (only for pure python types so far).\n        ",
                    "args": [
                        "self",
                        "cls",
                        "name",
                        "inherit"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cls",
                            "name",
                            "inherit"
                        ],
                        null,
                        null,
                        [
                            null,
                            null
                        ]
                    ]
                },
                "__mul__": {
                    "__doc__": "File: sage/structure/parent.pyx (starting at line 961)\n\n        This is a multiplication method that more or less directly\n        calls another attribute ``_mul_`` (single underscore). This\n        is because ``__mul__`` can not be implemented via inheritance\n        from the parent methods of the category, but ``_mul_`` can\n        be inherited. This is, e.g., used when creating twosided\n        ideals of matrix algebras. See :trac:`7797`.\n\n        EXAMPLES::\n\n            sage: MS = MatrixSpace(QQ,2,2)\n\n        This matrix space is in fact an algebra, and in particular\n        it is a ring, from the point of view of categories::\n\n            sage: MS.category()\n            Category of infinite algebras over (quotient fields and metric spaces)\n            sage: MS in Rings()\n            True\n\n        However, its class does not inherit from the base class\n        ``Ring``::\n\n            sage: isinstance(MS,Ring)\n            False\n\n        Its ``_mul_`` method is inherited from the category, and\n        can be used to create a left or right ideal::\n\n            sage: MS._mul_.__module__\n            'sage.categories.rings'\n            sage: MS*MS.1      # indirect doctest\n            Left Ideal\n            (\n              [0 1]\n              [0 0]\n            )\n             of Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n            sage: MS*[MS.1,2]\n            Left Ideal\n            (\n              [0 1]\n              [0 0],\n            <BLANKLINE>\n              [2 0]\n              [0 2]\n            )\n             of Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n            sage: MS.1*MS\n            Right Ideal\n            (\n              [0 1]\n              [0 0]\n            )\n             of Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n            sage: [MS.1,2]*MS\n            Right Ideal\n            (\n              [0 1]\n              [0 0],\n            <BLANKLINE>\n              [2 0]\n              [0 2]\n            )\n             of Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n\n        ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__nonzero__": {
                    "__doc__": "x.__nonzero__() <==> x != 0",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "__rmul__": {
                    "__doc__": "x.__rmul__(y) <==> y*x",
                    "args": [],
                    "argspec": [
                        [],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "_an_element_": {
                    "__doc__": "Parent._an_element_(self)\nFile: sage/structure/parent.pyx (starting at line 2571)\n\n        Returns an element of self. Want it in sufficient generality\n        that poorly-written functions won't work when they're not\n        supposed to. This is cached so doesn't have to be super fast.\n\n        EXAMPLES::\n\n            sage: QQ._an_element_()\n            1/2\n            sage: ZZ['x,y,z']._an_element_()\n            x\n\n        TESTS:\n\n        Since ``Parent`` comes before the parent classes provided by\n        categories in the hierarchy of classes, we make sure that this\n        default implementation of :meth:`_an_element_` does not\n        override some provided by the categories.  Eventually, this\n        default implementation should be moved into the categories to\n        avoid this workaround::\n\n            sage: S = FiniteEnumeratedSet([1,2,3])\n            sage: S.category()\n            Category of facade finite enumerated sets\n            sage: super(Parent, S)._an_element_\n            Cached version of <function _an_element_from_iterator at ...>\n            sage: S._an_element_()\n            1\n            sage: S = FiniteEnumeratedSet([])\n            sage: S._an_element_()\n            Traceback (most recent call last):\n            ...\n            EmptySetError\n\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_cmp_": {
                    "__doc__": "Parent._cmp_(left, right) -> int\nFile: sage/structure/parent.pyx (starting at line 1212)\n\n        Check for Python class defining ``__cmp__``\n        ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_coerce_map_from_": {
                    "__doc__": "Parent._coerce_map_from_(self, S)\nFile: sage/structure/parent.pyx (starting at line 1936)\n\n        Override this method to specify coercions beyond those specified\n        in coerce_list.\n\n        If no such coercion exists, return None or False. Otherwise, it may\n        return either an actual Map to use for the coercion, a callable\n        (in which case it will be wrapped in a Map), or True (in which case\n        a generic map will be provided).\n        ",
                    "args": [
                        "self",
                        "S"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_coerce_map_via": {
                    "__doc__": "Parent._coerce_map_via(self, v, S)\nFile: sage/structure/parent.pyx (starting at line 1850)\n\n        This attempts to construct a morphism from S to self by passing through\n        one of the items in v (tried in order).\n\n        S may appear in the list, in which case algorithm will never progress\n        beyond that point.\n\n        This is similar in spirit to the old {{{_coerce_try}}}, and useful when\n        defining _coerce_map_from_\n\n        INPUT:\n\n        - ``v`` - A list (iterator) of parents with coercions into self. There\n          MUST be maps provided from each item in the list to self.\n\n        - ``S`` - the starting parent\n\n        EXAMPLES:\n\n        By :trac:`14711`, coerce maps should be copied for usage outside\n        of the coercion system::\n\n            sage: copy(CDF._coerce_map_via([ZZ, RR, CC], int))\n            Composite map:\n              From: Set of Python objects of type 'int'\n              To:   Complex Double Field\n              Defn:   Native morphism:\n                      From: Set of Python objects of type 'int'\n                      To:   Integer Ring\n                    then\n                      Native morphism:\n                      From: Integer Ring\n                      To:   Complex Double Field\n\n            sage: copy(CDF._coerce_map_via([ZZ, RR, CC], QQ))\n            Composite map:\n              From: Rational Field\n              To:   Complex Double Field\n              Defn:   Generic map:\n                      From: Rational Field\n                      To:   Real Field with 53 bits of precision\n                    then\n                      Native morphism:\n                      From: Real Field with 53 bits of precision\n                      To:   Complex Double Field\n\n            sage: copy(CDF._coerce_map_via([ZZ, RR, CC], CC))\n            Generic map:\n              From: Complex Field with 53 bits of precision\n              To:   Complex Double Field\n        ",
                    "args": [
                        "self",
                        "v",
                        "S"
                    ],
                    "argspec": [
                        [
                            "self",
                            "v",
                            "S"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_convert_map_from_": {
                    "__doc__": "Parent._convert_map_from_(self, S)\nFile: sage/structure/parent.pyx (starting at line 2379)\n\n        Override this method to provide additional conversions beyond those\n        given in convert_list.\n\n        This function is called after coercions are attempted. If there is a\n        coercion morphism in the opposite direction, one should consider\n        adding a section method to that.\n\n        This MUST return a Map from S to self, or None. If None is returned\n        then a generic map will be provided.\n        ",
                    "args": [
                        "self",
                        "S"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_generic_convert_map": {
                    "__doc__": "Parent._generic_convert_map(self, S)\nFile: sage/structure/parent.pyx (starting at line 1816)\n\n        Returns the default conversion map based on the data provided to\n        :meth:`_populate_coercion_lists_`.\n\n        This is called when :meth:`_coerce_map_from_` returns ``True``.\n\n        If a ``convert_method_name`` is provided, it creates a\n        ``NamedConvertMap``, otherwise it creates a\n        ``DefaultConvertMap`` or ``DefaultConvertMap_unique``\n        depending on whether or not init_no_parent is set.\n\n        EXAMPLES:\n        ",
                    "args": [
                        "self",
                        "S"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_get_action_": {
                    "__doc__": "Parent._get_action_(self, S, op, bool self_on_left)\nFile: sage/structure/parent.pyx (starting at line 2509)\n\n        Override this method to provide an action of self on S or S on self\n        beyond what was specified in action_list.\n\n        This must return an action which accepts an element of self and an\n        element of S (in the order specified by self_on_left).\n        ",
                    "args": [
                        "self",
                        "S",
                        "op",
                        "self_on_left"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S",
                            "op",
                            "self_on_left"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_internal_coerce_map_from": {
                    "__doc__": "Parent._internal_coerce_map_from(self, S)\nFile: sage/structure/parent.pyx (starting at line 1985)\n\n        Return the :class:`Map` object to coerce from ``S`` to ``self`` that\n        is used internally by the coercion system if one exists, or ``None``\n        if no such coercion exists.\n\n        EXAMPLES:\n\n        By :trac:`14711`, coerce maps should be copied when using them\n        outside of the coercion system, because they may become defunct\n        by garbage collection::\n\n            sage: ZZ._internal_coerce_map_from(int)\n            (map internal to coercion system -- copy before use)\n            Native morphism:\n              From: Set of Python objects of type 'int'\n              To:   Integer Ring\n            sage: copy(ZZ._internal_coerce_map_from(int))\n            Native morphism:\n              From: Set of Python objects of type 'int'\n              To:   Integer Ring\n            sage: copy(QQ._internal_coerce_map_from(ZZ))\n            Natural morphism:\n              From: Integer Ring\n              To:   Rational Field\n\n            sage: R = QQ['q,t'].fraction_field()\n            sage: Sym = sage.combinat.sf.sf.SymmetricFunctions(R)\n            sage: P = Sym.macdonald().P()\n            sage: Ht = Sym.macdonald().Ht()\n            sage: Ht._internal_coerce_map_from(P)\n            (map internal to coercion system -- copy before use)\n            Composite map:\n              From: Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Macdonald P basis\n              To:   Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Macdonald Ht basis\n            sage: copy(Ht._internal_coerce_map_from(P))\n            Composite map:\n              From: Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Macdonald P basis\n              To:   Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Macdonald Ht basis\n              Defn:   Generic morphism:\n                      From: Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Macdonald P basis\n                      To:   Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Macdonald J basis\n                    then\n                      Generic morphism:\n                      From: Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Macdonald J basis\n                      To:   Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Schur basis\n                    then\n                      Generic morphism:\n                      From: Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Schur basis\n                      To:   Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Macdonald Ht basis\n\n        The following was fixed in :trac:`4740`::\n\n            sage: F = GF(13)\n            sage: F._internal_coerce_map_from(F) is F._internal_coerce_map_from(F)\n            True\n        ",
                    "args": [
                        "self",
                        "S"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_internal_convert_map_from": {
                    "__doc__": "Parent._internal_convert_map_from(self, S)\nFile: sage/structure/parent.pyx (starting at line 2306)\n\n        This function returns a :class:`Map` from `S` to `self`,\n        which may or may not succeed on all inputs.\n        If a coercion map from S to self exists,\n        then the it will be returned. If a coercion from `self` to `S` exists,\n        then it will attempt to return a section of that map.\n\n        Under the new coercion model, this is the fastest way to convert\n        elements of `S` to elements of `self` (short of manually constructing\n        the elements) and is used by :func:`__call__`.\n\n        EXAMPLES::\n\n            sage: m = ZZ._internal_convert_map_from(QQ)\n            sage: m\n            (map internal to coercion system -- copy before use)\n            Generic map:\n              From: Rational Field\n              To:   Integer Ring\n            sage: m(-35/7)\n            -5\n            sage: parent(m(-35/7))\n            Integer Ring\n        ",
                    "args": [
                        "self",
                        "S"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_introspect_coerce": {
                    "__doc__": "Parent._introspect_coerce(self)\nFile: sage/structure/parent.pyx (starting at line 751)\n\n        Used for debugging the coercion model.\n\n        EXAMPLES::\n\n            sage: sorted(QQ._introspect_coerce().items())\n            [('_action_hash', <sage.structure.coerce_dict.TripleDict object at ...>),\n             ('_action_list', []),\n             ('_coerce_from_hash', <sage.structure.coerce_dict.MonoDict object at ...>),\n             ('_coerce_from_list', []),\n             ('_convert_from_hash', <sage.structure.coerce_dict.MonoDict object at ...>),\n             ('_convert_from_list', [...]),\n             ('_element_init_pass_parent', False),\n             ('_embedding', None),\n             ('_initial_action_list', []),\n             ('_initial_coerce_list', []),\n             ('_initial_convert_list', [])]\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_is_valid_homomorphism_": {
                    "__doc__": "Parent._is_valid_homomorphism_(self, codomain, im_gens)\nFile: sage/structure/parent.pyx (starting at line 1279)\n\n       Return True if ``im_gens`` defines a valid homomorphism\n       from self to codomain; otherwise return False.\n\n       If determining whether or not a homomorphism is valid has not\n       been implemented for this ring, then a NotImplementedError exception\n       is raised.\n       ",
                    "args": [
                        "self",
                        "codomain",
                        "im_gens"
                    ],
                    "argspec": [
                        [
                            "self",
                            "codomain",
                            "im_gens"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_populate_coercion_lists_": {
                    "__doc__": "Parent._populate_coercion_lists_(self, coerce_list=[], action_list=[], convert_list=[], embedding=None, convert_method_name=None, element_constructor=None, init_no_parent=None, bool unpickling=False)\nFile: sage/structure/parent.pyx (starting at line 1422)\n\n        This function allows one to specify coercions, actions, conversions\n        and embeddings involving this parent.\n\n        IT SHOULD ONLY BE CALLED DURING THE __INIT__ method, often at the end.\n\n        INPUT:\n\n        - ``coerce_list`` -- a list of coercion Morphisms to self and\n          parents with canonical coercions to self\n\n        - ``action_list`` -- a list of actions on and by self\n\n        - ``convert_list`` -- a list of conversion Maps to self and\n           parents with conversions to self\n\n        - ``embedding`` -- a single Morphism from self\n\n        - ``convert_method_name`` -- a name to look for that other elements\n          can implement to create elements of self (e.g. _integer_)\n\n        - ``element_constructor`` -- A callable object used by the\n          __call__ method to construct new elements. Typically the\n          element class or a bound method (defaults to\n          self._element_constructor_).\n\n        - ``init_no_parent`` -- if True omit passing self in as the\n          first argument of element_constructor for conversion. This\n          is useful if parents are unique, or element_constructor is a\n          bound method (this latter case can be detected\n          automatically).\n        ",
                    "args": [
                        "self",
                        "coerce_list",
                        "action_list",
                        "convert_list",
                        "embedding",
                        "convert_method_name",
                        "element_constructor",
                        "init_no_parent",
                        "unpickling"
                    ],
                    "argspec": [
                        [
                            "self",
                            "coerce_list",
                            "action_list",
                            "convert_list",
                            "embedding",
                            "convert_method_name",
                            "element_constructor",
                            "init_no_parent",
                            "unpickling"
                        ],
                        null,
                        null,
                        [
                            [],
                            [],
                            [],
                            null,
                            null,
                            null,
                            null,
                            false
                        ]
                    ]
                },
                "_repr_option": {
                    "__doc__": "Parent._repr_option(self, key)\nFile: sage/structure/parent.pyx (starting at line 828)\n\n        Metadata about the :meth:`_repr_` output.\n\n        INPUT:\n\n        - ``key`` -- string. A key for different metadata informations\n          that can be inquired about.\n\n        Valid ``key`` arguments are:\n\n        - ``'ascii_art'``: The :meth:`_repr_` output is multi-line\n          ascii art and each line must be printed starting at the same\n          column, or the meaning is lost.\n\n        - ``'element_ascii_art'``: same but for the output of the\n          elements. Used in :mod:`sage.repl.display.formatter`.\n\n        - ``'element_is_atomic'``: the elements print atomically, that\n          is, parenthesis are not required when *printing* out any of\n          `x - y`, `x + y`, `x^y` and `x/y`.\n\n        OUTPUT:\n\n        Boolean.\n\n        EXAMPLES::\n\n            sage: ZZ._repr_option('ascii_art')\n            False\n            sage: MatrixSpace(ZZ, 2)._repr_option('element_ascii_art')\n            True\n        ",
                    "args": [
                        "self",
                        "key"
                    ],
                    "argspec": [
                        [
                            "self",
                            "key"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_set_element_constructor": {
                    "__doc__": "Parent._set_element_constructor(self)\nFile: sage/structure/parent.pyx (starting at line 604)\n\n        This function is used in translating from the old to the new coercion model.\n\n        It is called from sage.structure.parent_old.Parent.__init__\n        when an old style parent provides a _element_constructor_ method.\n\n        It just asserts that this _element_constructor_ is callable and\n        also sets self._element_init_pass_parent\n\n        EXAMPLES::\n\n            sage: k = GF(5); k._element_constructor # indirect doctest\n            <bound method FiniteField_prime_modn_with_category._element_constructor_ of Finite Field of size 5>\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_test_eq": {
                    "__doc__": "Parent._test_eq(self, **options)\nFile: sage/structure/parent.pyx (starting at line 690)\n\n        Test that ``self`` is equal to ``self`` and different to ``None``.\n\n        See also: :class:`TestSuite`.\n\n        TESTS::\n\n            sage: O = Parent()\n            sage: O._test_eq()\n\n        Let us now write a broken class method::\n\n            sage: class CCls(Parent):\n            ....:     def __eq__(self, other):\n            ....:         return True\n            sage: CCls()._test_eq()\n            Traceback (most recent call last):\n            ...\n            AssertionError: broken equality: <class '__main__.CCls'> == None\n\n        Let us now break inequality::\n\n            sage: class CCls(Parent):\n            ....:     def __ne__(self, other):\n            ....:         return True\n            sage: CCls()._test_eq()\n            Traceback (most recent call last):\n            ...\n            AssertionError: broken non-equality: <class '__main__.CCls'> != itself\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_unset_category": {
                    "__doc__": "Parent._unset_category(self)\nFile: sage/structure/parent.pyx (starting at line 483)\n\n        Remove the information on ``self``'s category.\n\n        NOTE:\n\n        This may change ``self``'s class!\n\n        EXAMPLES:\n\n        Let us create a parent in the category of rings::\n\n            sage: class MyParent(Parent):\n            ....:     def __init__(self):\n            ....:         Parent.__init__(self, category=Rings())\n            ....:\n            sage: P = MyParent()\n            sage: P.category()\n            Category of rings\n\n        Of course, its category is initialised::\n\n            sage: P._is_category_initialized()\n            True\n\n        We may now refine the category to the category of fields.\n        Note that this changes the class::\n\n            sage: C = type(P)\n            sage: C == MyParent\n            False\n            sage: P._refine_category_(Fields())\n            sage: P.category()\n            Category of fields\n            sage: C == type(P)\n            False\n\n        Now we may have noticed that the category refinement was a\n        mistake. We do not need to worry, because we can undo category\n        initialisation totally::\n\n            sage: P._unset_category()\n            sage: P._is_category_initialized()\n            False\n            sage: type(P) == MyParent\n            True\n\n        Hence, we can now initialise the parent again in the original\n        category, i.e., the category of rings. We find that not only\n        the category, but also the class of the parent is brought back\n        to what it was after the original category initialisation::\n\n            sage: P._init_category_(Rings())\n            sage: type(P) == C\n            True\n\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_unset_coercions_used": {
                    "__doc__": "Parent._unset_coercions_used(self)\nFile: sage/structure/parent.pyx (starting at line 1497)\n\n        Pretend that this parent has never been interrogated by the coercion\n        model, so that it is possible to add coercions, conversions, and\n        actions.  Does not remove any existing embedding.\n\n        WARNING::\n\n            For internal use only!\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_unset_embedding": {
                    "__doc__": "Parent._unset_embedding(self)\nFile: sage/structure/parent.pyx (starting at line 1510)\n\n        Pretend that this parent has never been interrogated by the\n        coercion model, and remove any existing embedding.\n\n        WARNING::\n\n            This does *not* make it safe to add an entirely new embedding!  It\n            is possible that a `Parent` has cached information about the\n            existing embedding; that cached information *is not* removed by\n            this call.\n\n            For internal use only!\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "an_element": {
                    "__doc__": "Parent.an_element(self)\nFile: sage/structure/parent.pyx (starting at line 2540)\n\n        Returns a (preferably typical) element of this parent.\n\n        This is used both for illustration and testing purposes. If\n        the set ``self`` is empty, :meth:`an_element` raises the\n        exception :class:`EmptySetError`.\n\n        This calls :meth:`_an_element_` (which see), and caches the\n        result. Parent are thus encouraged to override :meth:`_an_element_`.\n\n        EXAMPLES::\n\n            sage: CDF.an_element()\n            1.0*I\n            sage: ZZ[['t']].an_element()\n            t\n\n        In case the set is empty, an :class:`EmptySetError` is raised::\n\n            sage: Set([]).an_element()\n            Traceback (most recent call last):\n            ...\n            EmptySetError\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coerce": {
                    "__doc__": "Parent.coerce(self, x)\nFile: sage/structure/parent.pyx (starting at line 1168)\n\n        Return x as an element of self, if and only if there is a canonical\n        coercion from the parent of x to self.\n\n        EXAMPLES::\n\n            sage: QQ.coerce(ZZ(2))\n            2\n            sage: ZZ.coerce(QQ(2))\n            Traceback (most recent call last):\n            ...\n            TypeError: no canonical coercion from Rational Field to Integer Ring\n\n        We make an exception for zero::\n\n            sage: V = GF(7)^7\n            sage: V.coerce(0)\n            (0, 0, 0, 0, 0, 0, 0)\n        ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coerce_embedding": {
                    "__doc__": "Parent.coerce_embedding(self)\nFile: sage/structure/parent.pyx (starting at line 1789)\n\n        Return the embedding of ``self`` into some other parent, if such a\n        parent exists.\n\n        This does not mean that there are no coercion maps from ``self`` into\n        other fields, this is simply a specific morphism specified out of\n        ``self`` and usually denotes a special relationship (e.g. sub-objects,\n        choice of completion, etc.)\n\n        EXAMPLES::\n\n            sage: K.<a>=NumberField(x^3+x^2+1,embedding=1)\n            sage: K.coerce_embedding()\n            Generic morphism:\n              From: Number Field in a with defining polynomial x^3 + x^2 + 1\n              To:   Real Lazy Field\n              Defn: a -> -1.465571231876768?\n            sage: K.<a>=NumberField(x^3+x^2+1,embedding=CC.gen())\n            sage: K.coerce_embedding()\n            Generic morphism:\n              From: Number Field in a with defining polynomial x^3 + x^2 + 1\n              To:   Complex Lazy Field\n              Defn: a -> 0.2327856159383841? + 0.7925519925154479?*I\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coerce_map_from": {
                    "__doc__": "Parent.coerce_map_from(self, S)\nFile: sage/structure/parent.pyx (starting at line 1948)\n\n        Return a :class:`Map` object to coerce from ``S`` to ``self`` if one\n        exists, or ``None`` if no such coercion exists.\n\n        EXAMPLES:\n\n        By :trac:`12313`, a special kind of weak key dictionary is used to\n        store coercion and conversion maps, namely\n        :class:`~sage.structure.coerce_dict.MonoDict`. In that way, a memory\n        leak was fixed that would occur in the following test::\n\n            sage: import gc\n            sage: _ = gc.collect()\n            sage: K = GF(1<<55,'t')\n            sage: for i in range(50):\n            ....:   a = K.random_element()\n            ....:   E = EllipticCurve(j=a)\n            ....:   b = K.has_coerce_map_from(E)\n            sage: _ = gc.collect()\n            sage: len([x for x in gc.get_objects() if isinstance(x,type(E))])\n            1\n\n        TESTS:\n\n        The following was fixed in :trac:`12969`::\n\n            sage: R = QQ['q,t'].fraction_field()\n            sage: Sym = sage.combinat.sf.sf.SymmetricFunctions(R)\n            sage: H = Sym.macdonald().H()\n            sage: P = Sym.macdonald().P()\n            sage: m = Sym.monomial()\n            sage: Ht = Sym.macdonald().Ht()\n            sage: phi = m.coerce_map_from(P)\n        ",
                    "args": [
                        "self",
                        "S"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "construction": {
                    "__doc__": "Parent.construction(self)\nFile: sage/structure/parent.pyx (starting at line 2519)\n\n        Returns a pair (functor, parent) such that functor(parent) return self.\n        If this ring does not have a functorial construction, return None.\n\n        EXAMPLES::\n\n            sage: QQ.construction()\n            (FractionField, Integer Ring)\n            sage: f, R = QQ['x'].construction()\n            sage: f\n            Poly[x]\n            sage: R\n            Rational Field\n            sage: f(R)\n            Univariate Polynomial Ring in x over Rational Field\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "convert_map_from": {
                    "__doc__": "Parent.convert_map_from(self, S)\nFile: sage/structure/parent.pyx (starting at line 2279)\n\n        This function returns a :class:`Map` from `S` to `self`,\n        which may or may not succeed on all inputs.\n        If a coercion map from S to self exists,\n        then the it will be returned. If a coercion from `self` to `S` exists,\n        then it will attempt to return a section of that map.\n\n        Under the new coercion model, this is the fastest way to convert\n        elements of `S` to elements of `self` (short of manually constructing\n        the elements) and is used by :meth:`__call__`.\n\n        EXAMPLES::\n\n            sage: m = ZZ.convert_map_from(QQ)\n            sage: m\n            Generic map:\n              From: Rational Field\n              To:   Integer Ring\n            sage: m(-35/7)\n            -5\n            sage: parent(m(-35/7))\n            Integer Ring\n        ",
                    "args": [
                        "self",
                        "S"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "get_action": {
                    "__doc__": "Parent.get_action(self, S, op=operator.mul, bool self_on_left=True, self_el=None, S_el=None)\nFile: sage/structure/parent.pyx (starting at line 2393)\n\n        Returns an action of self on S or S on self.\n\n        To provide additional actions, override :meth:`_get_action_`.\n\n        TESTS::\n\n            sage: M = QQ['y']^3\n            sage: M.get_action(ZZ['x']['y'])\n            Right scalar multiplication by Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Integer Ring on Ambient free module of rank 3 over the principal ideal domain Univariate Polynomial Ring in y over Rational Field\n            sage: M.get_action(ZZ['x']) # should be None\n        ",
                    "args": [
                        "self",
                        "S",
                        "op",
                        "self_on_left",
                        "self_el",
                        "S_el"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S",
                            "op",
                            "self_on_left",
                            "self_el",
                            "S_el"
                        ],
                        null,
                        null,
                        [
                            null,
                            true,
                            null,
                            null
                        ]
                    ]
                },
                "has_coerce_map_from": {
                    "__doc__": "Parent.has_coerce_map_from(self, S) -> bool\nFile: sage/structure/parent.pyx (starting at line 1912)\n\n        Return True if there is a natural map from S to self.\n        Otherwise, return False.\n\n        EXAMPLES::\n\n            sage: RDF.has_coerce_map_from(QQ)\n            True\n            sage: RDF.has_coerce_map_from(QQ['x'])\n            False\n            sage: RDF['x'].has_coerce_map_from(QQ['x'])\n            True\n            sage: RDF['x,y'].has_coerce_map_from(QQ['x'])\n            True\n        ",
                    "args": [
                        "self",
                        "S"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "hom": {
                    "__doc__": "Parent.hom(self, im_gens, codomain=None, check=None)\nFile: sage/structure/parent.pyx (starting at line 1333)\n\n       Return the unique homomorphism from self to codomain that\n       sends ``self.gens()`` to the entries of ``im_gens``.\n       Raises a TypeError if there is no such homomorphism.\n\n       INPUT:\n\n       - ``im_gens`` -- the images in the codomain of the generators\n         of this object under the homomorphism\n\n       - ``codomain`` -- the codomain of the homomorphism\n\n       - ``check`` -- whether to verify that the images of generators\n         extend to define a map (using only canonical coercions).\n\n       OUTPUT:\n\n       A homomorphism self --> codomain\n\n       .. NOTE::\n\n          As a shortcut, one can also give an object X instead of\n          ``im_gens``, in which case return the (if it exists)\n          natural map to X.\n\n       EXAMPLES:\n\n       Polynomial Ring: We first illustrate construction of a few\n       homomorphisms involving a polynomial ring::\n\n           sage: R.<x> = PolynomialRing(ZZ)\n           sage: f = R.hom([5], QQ)\n           sage: f(x^2 - 19)\n           6\n\n           sage: R.<x> = PolynomialRing(QQ)\n           sage: f = R.hom([5], GF(7))\n           Traceback (most recent call last):\n           ...\n           TypeError: images do not define a valid homomorphism\n\n           sage: R.<x> = PolynomialRing(GF(7))\n           sage: f = R.hom([3], GF(49,'a'))\n           sage: f\n           Ring morphism:\n             From: Univariate Polynomial Ring in x over Finite Field of size 7\n             To:   Finite Field in a of size 7^2\n             Defn: x |--> 3\n           sage: f(x+6)\n           2\n           sage: f(x^2+1)\n           3\n\n       Natural morphism::\n\n           sage: f = ZZ.hom(GF(5))\n           sage: f(7)\n           2\n           sage: f\n           Ring Coercion morphism:\n             From: Integer Ring\n             To:   Finite Field of size 5\n\n       There might not be a natural morphism, in which case a\n       ``TypeError`` is raised::\n\n           sage: QQ.hom(ZZ)\n           Traceback (most recent call last):\n           ...\n           TypeError: Natural coercion morphism from Rational Field to Integer Ring not defined.\n       ",
                    "args": [
                        "self",
                        "im_gens",
                        "codomain",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "im_gens",
                            "codomain",
                            "check"
                        ],
                        null,
                        null,
                        [
                            null,
                            null
                        ]
                    ]
                },
                "is_atomic_repr": {
                    "__doc__": "Parent.is_atomic_repr(self)\nFile: sage/structure/parent.pyx (starting at line 870)\n\n        The old way to signal atomic string reps.\n\n        True if the elements have atomic string representations, in the\n        sense that if they print at s, then -s means the negative of s. For\n        example, integers are atomic but polynomials are not.\n\n        EXAMPLES::\n\n            sage: Parent().is_atomic_repr()\n            doctest:...: DeprecationWarning: Use _repr_option to return metadata about string rep\n            See http://trac.sagemath.org/14040 for details.\n            False\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_coercion_cached": {
                    "__doc__": "Parent.is_coercion_cached(self, domain) -> bool\nFile: sage/structure/parent.pyx (starting at line 1527)\n\n\n        ",
                    "args": [
                        "self",
                        "domain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "domain"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_conversion_cached": {
                    "__doc__": "Parent.is_conversion_cached(self, domain) -> bool\nFile: sage/structure/parent.pyx (starting at line 1533)\n\n        ",
                    "args": [
                        "self",
                        "domain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "domain"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_exact": {
                    "__doc__": "Parent.is_exact(self) -> bool\nFile: sage/structure/parent.pyx (starting at line 2638)\n\n        Test whether the ring is exact.\n\n        .. NOTE::\n\n            This defaults to true, so even if it does return ``True``\n            you have no guarantee (unless the ring has properly\n            overloaded this).\n\n        OUTPUT:\n\n        Return True if elements of this ring are represented exactly, i.e.,\n        there is no precision loss when doing arithmetic.\n\n        EXAMPLES::\n\n            sage: QQ.is_exact()\n            True\n            sage: ZZ.is_exact()\n            True\n            sage: Qp(7).is_exact()\n            False\n            sage: Zp(7, type='capped-abs').is_exact()\n            False\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "register_action": {
                    "__doc__": "Parent.register_action(self, action)\nFile: sage/structure/parent.pyx (starting at line 1584)\n\n        Update the coercion model to use ``action`` to act on self.\n\n        ``action`` should be of type ``sage.categories.action.Action``.\n\n        EXAMPLES::\n\n            sage: import sage.categories.action\n            sage: import operator\n\n            sage: class SymmetricGroupAction(sage.categories.action.Action):\n            ....:     \"Act on a multivariate polynomial ring by permuting the generators.\"\n            ....:     def __init__(self, G, M, is_left=True):\n            ....:         sage.categories.action.Action.__init__(self, G, M, is_left, operator.mul)\n            ....:\n            ....:     def _call_(self, g, a):\n            ....:         if not self.is_left():\n            ....:             g, a = a, g\n            ....:         D = {}\n            ....:         for k, v in a.dict().items():\n            ....:             nk = [0]*len(k)\n            ....:             for i in range(len(k)):\n            ....:                 nk[g(i+1)-1] = k[i]\n            ....:             D[tuple(nk)] = v\n            ....:         return a.parent()(D)\n\n            sage: R.<x, y, z> = QQ['x, y, z']\n            sage: G = SymmetricGroup(3)\n            sage: act = SymmetricGroupAction(G, R)\n            sage: t = x + 2*y + 3*z\n\n            sage: act(G((1, 2)), t)\n            2*x + y + 3*z\n            sage: act(G((2, 3)), t)\n            x + 3*y + 2*z\n            sage: act(G((1, 2, 3)), t)\n            3*x + y + 2*z\n\n        This should fail, since we haven't registered the left\n        action::\n\n            sage: G((1,2)) * t\n            Traceback (most recent call last):\n            ...\n            TypeError: ...\n\n        Now let's make it work::\n\n            sage: R._unset_coercions_used()\n            sage: R.register_action(act)\n            sage: G((1, 2)) * t\n            2*x + y + 3*z\n        ",
                    "args": [
                        "self",
                        "action"
                    ],
                    "argspec": [
                        [
                            "self",
                            "action"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "register_coercion": {
                    "__doc__": "Parent.register_coercion(self, mor)\nFile: sage/structure/parent.pyx (starting at line 1538)\n\n        Update the coercion model to use `mor : P \\to \\text{self}` to coerce\n        from a parent ``P`` into ``self``.\n\n        For safety, an error is raised if another coercion has already\n        been registered or discovered between ``P`` and ``self``.\n\n        EXAMPLES::\n\n            sage: K.<a> = ZZ['a']\n            sage: L.<b> = ZZ['b']\n            sage: L_into_K = L.hom([-a]) # non-trivial automorphism\n            sage: K.register_coercion(L_into_K)\n\n            sage: K(0) + b\n            -a\n            sage: a + b\n            0\n            sage: K(b) # check that convert calls coerce first; normally this is just a\n            -a\n\n            sage: L(0) + a in K # this goes through the coercion mechanism of K\n            True\n            sage: L(a) in L # this still goes through the convert mechanism of L\n            True\n\n            sage: K.register_coercion(L_into_K)\n            Traceback (most recent call last):\n            ...\n            AssertionError: coercion from Univariate Polynomial Ring in b over Integer Ring to Univariate Polynomial Ring in a over Integer Ring already registered or discovered\n        ",
                    "args": [
                        "self",
                        "mor"
                    ],
                    "argspec": [
                        [
                            "self",
                            "mor"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "register_conversion": {
                    "__doc__": "Parent.register_conversion(self, mor)\nFile: sage/structure/parent.pyx (starting at line 1652)\n\n        Update the coercion model to use `\\text{mor} : P \\to \\text{self}` to convert\n        from ``P`` into ``self``.\n\n        EXAMPLES::\n\n            sage: K.<a> = ZZ['a']\n            sage: M.<c> = ZZ['c']\n            sage: M_into_K = M.hom([a]) # trivial automorphism\n            sage: K._unset_coercions_used()\n            sage: K.register_conversion(M_into_K)\n\n            sage: K(c)\n            a\n            sage: K(0) + c\n            Traceback (most recent call last):\n            ...\n            TypeError: ...\n        ",
                    "args": [
                        "self",
                        "mor"
                    ],
                    "argspec": [
                        [
                            "self",
                            "mor"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "register_embedding": {
                    "__doc__": "Parent.register_embedding(self, embedding)\nFile: sage/structure/parent.pyx (starting at line 1687)\n\n        Add embedding to coercion model.\n\n        This method updates the coercion model to use\n        `\\text{embedding} : \\text{self} \\to P` to embed ``self`` into\n        the parent ``P``.\n\n        There can only be one embedding registered; it can only be registered\n        once; and it must be registered before using this parent in the\n        coercion model.\n\n        EXAMPLES::\n\n            sage: S3 = AlternatingGroup(3)\n            sage: G = SL(3, QQ)\n            sage: p = S3[2]; p.matrix()\n            [0 0 1]\n            [1 0 0]\n            [0 1 0]\n\n        In general one can't mix matrices and permutations::\n\n            sage: G(p)\n            Traceback (most recent call last):\n            ...\n            TypeError: entries must be coercible to a list or integer\n            sage: phi = S3.hom(lambda p: G(p.matrix()), codomain = G)\n            sage: phi(p)\n            [0 0 1]\n            [1 0 0]\n            [0 1 0]\n            sage: S3._unset_coercions_used()\n            sage: S3.register_embedding(phi)\n\n        By :trac:`14711`, coerce maps should be copied when using outside of\n        the coercion system::\n\n            sage: phi = copy(S3.coerce_embedding()); phi\n            Generic morphism:\n              From: Alternating group of order 3!/2 as a permutation group\n              To:   Special Linear Group of degree 3 over Rational Field\n            sage: phi(p)\n            [0 0 1]\n            [1 0 0]\n            [0 1 0]\n\n        This does not work since matrix groups are still old-style\n        parents (see :trac:`14014`)::\n\n            sage: G(p)                               # todo: not implemented\n\n        Though one can have a permutation act on the rows of a matrix::\n\n            sage: G(1) * p\n            [0 0 1]\n            [1 0 0]\n            [0 1 0]\n\n        Some more advanced examples::\n\n            sage: x = QQ['x'].0\n            sage: t = abs(ZZ.random_element(10^6))\n            sage: K = NumberField(x^2 + 2*3*7*11, \"a\"+str(t))\n            sage: a = K.gen()\n            sage: K_into_MS = K.hom([a.matrix()])\n            sage: K._unset_coercions_used()\n            sage: K.register_embedding(K_into_MS)\n\n            sage: L = NumberField(x^2 + 2*3*7*11*19*31, \"b\"+str(abs(ZZ.random_element(10^6))))\n            sage: b = L.gen()\n            sage: L_into_MS = L.hom([b.matrix()])\n            sage: L._unset_coercions_used()\n            sage: L.register_embedding(L_into_MS)\n\n            sage: K.coerce_embedding()(a)\n            [   0    1]\n            [-462    0]\n            sage: L.coerce_embedding()(b)\n            [      0       1]\n            [-272118       0]\n\n            sage: a.matrix() * b.matrix()\n            [-272118       0]\n            [      0    -462]\n            sage: a.matrix() * b.matrix()\n            [-272118       0]\n            [      0    -462]\n        ",
                    "args": [
                        "self",
                        "embedding"
                    ],
                    "argspec": [
                        [
                            "self",
                            "embedding"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.structure.parent.Parent"
        },
        "sage.structure.parent_base.ParentWithBase": {
            "__doc__": "ParentWithBase(base, coerce_from=[], actions=[], embeddings=[], category=None)\nFile: sage/structure/parent_base.pyx (starting at line 55)\n\n    This class is being deprecated, see parent.Parent for the new model.\n    ",
            "implied": [
                "sage.structure.parent_old.Parent"
            ],
            "methods": {
                "base_extend": {
                    "__doc__": "ParentWithBase.base_extend(self, X)\nFile: sage/structure/parent_base.pyx (starting at line 85)",
                    "args": [
                        "self",
                        "X"
                    ],
                    "argspec": [
                        [
                            "self",
                            "X"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.structure.parent_base.ParentWithBase"
        },
        "sage.structure.parent_gens.ParentWithGens": {
            "__doc__": "ParentWithGens(base, names=None, normalize=True, category=None)",
            "implied": [
                "sage.structure.parent_base.ParentWithBase"
            ],
            "methods": {
                "gen": {
                    "__doc__": "ParentWithGens.gen(self, i=0)\nFile: sage/structure/parent_gens.pyx (starting at line 142)",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        [
                            0
                        ]
                    ]
                },
                "gens": {
                    "__doc__": "ParentWithGens.gens(self)\nFile: sage/structure/parent_gens.pyx (starting at line 146)\n\n       Return a tuple whose entries are the generators for this\n       object, in order.\n       ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "ngens": {
                    "__doc__": "ParentWithGens.ngens(self)\nFile: sage/structure/parent_gens.pyx (starting at line 137)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.structure.parent_gens.ParentWithGens"
        },
        "sage.structure.parent_old.Parent": {
            "__doc__": "Parent(coerce_from=[], actions=[], embeddings=[], category=None)\nFile: sage/structure/parent_old.pyx (starting at line 58)\n\n    Parents are the SAGE/mathematical analogues of container objects\n    in computer science.\n\n    TESTS::\n\n        sage: V = VectorSpace(GF(2,'a'),2)\n        sage: V.list()\n        [(0, 0), (1, 0), (0, 1), (1, 1)]\n        sage: MatrixSpace(GF(3), 1, 1).list()\n        [[0], [1], [2]]\n        sage: DirichletGroup(3).list()\n        [Dirichlet character modulo 3 of conductor 1 mapping 2 |--> 1,\n        Dirichlet character modulo 3 of conductor 3 mapping 2 |--> -1]\n        sage: K = GF(7^6,'a')\n        sage: K.list()[:10] # long time\n        [0, 1, 2, 3, 4, 5, 6, a, a + 1, a + 2]\n        sage: K.<a> = GF(4)\n        sage: K.list()\n        [0, a, a + 1, 1]\n    ",
            "implied": [
                "sage.structure.parent.Parent"
            ],
            "methods": {
                "_an_element": {
                    "__doc__": "Parent._an_element(self)\nFile: sage/structure/parent_old.pyx (starting at line 358)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_an_element_c": {
                    "__doc__": "Parent._an_element_c(self)\nFile: sage/structure/parent_old.pyx (starting at line 362)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_an_element_impl": {
                    "__doc__": "Parent._an_element_impl(self)\nFile: sage/structure/parent_old.pyx (starting at line 328)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_coerce_": {
                    "__doc__": "Parent._coerce_(self, x)\nFile: sage/structure/parent_old.pyx (starting at line 239)",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_coerce_c": {
                    "__doc__": "Parent._coerce_c(self, x)\nFile: sage/structure/parent_old.pyx (starting at line 245)",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_coerce_impl": {
                    "__doc__": "Parent._coerce_impl(self, x)\nFile: sage/structure/parent_old.pyx (starting at line 268)\n\n        Canonically coerce x in assuming that the parent of x is not\n        equal to self.\n        ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_coerce_try": {
                    "__doc__": "Parent._coerce_try(self, x, v)\nFile: sage/structure/parent_old.pyx (starting at line 276)\n\n        Given a list v of rings, try to coerce x canonically into each\n        one in turn.  Return the __call__ coercion of the result into\n        self of the first canonical coercion that succeeds.  Raise a\n        TypeError if none of them succeed.\n\n        INPUT:\n             x -- Python object\n             v -- parent object or list (iterator) of parent objects\n        ",
                    "args": [
                        "self",
                        "x",
                        "v"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "v"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coerce_map_from_c": {
                    "__doc__": "Parent.coerce_map_from_c(self, S)\nFile: sage/structure/parent_old.pyx (starting at line 114)\n\n        EXAMPLES:\n\n        Check to make sure that we handle coerce maps from Python\n        native types correctly::\n\n            sage: QQ['q,t'].coerce_map_from(int)\n            Composite map:\n              From: Set of Python objects of type 'int'\n              To:   Multivariate Polynomial Ring in q, t over Rational Field\n              Defn:   Native morphism:\n                      From: Set of Python objects of type 'int'\n                      To:   Rational Field\n                    then\n                      Polynomial base injection morphism:\n                      From: Rational Field\n                      To:   Multivariate Polynomial Ring in q, t over Rational Field\n        ",
                    "args": [
                        "self",
                        "S"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "get_action_c": {
                    "__doc__": "Parent.get_action_c(self, S, op, bool self_on_left)\nFile: sage/structure/parent_old.pyx (starting at line 208)",
                    "args": [
                        "self",
                        "S",
                        "op",
                        "self_on_left"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S",
                            "op",
                            "self_on_left"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "get_action_impl": {
                    "__doc__": "Parent.get_action_impl(self, S, op, self_on_left)\nFile: sage/structure/parent_old.pyx (starting at line 227)",
                    "args": [
                        "self",
                        "S",
                        "op",
                        "self_on_left"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S",
                            "op",
                            "self_on_left"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "has_coerce_map_from_c": {
                    "__doc__": "Parent.has_coerce_map_from_c(self, S)\nFile: sage/structure/parent_old.pyx (starting at line 299)\n\n        Return True if there is a natural map from S to self.\n        Otherwise, return False.\n        ",
                    "args": [
                        "self",
                        "S"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            },
            "name": "sage.structure.parent_old.Parent"
        },
        "sage.structure.sage_object.SageObject": {
            "__doc__": "File: sage/structure/sage_object.pyx (starting at line 41)\n\n    Base class for all (user-visible) objects in Sage\n\n    Every object that can end up being returned to the user should\n    inherit from :class:`SageObject`.\n\n    .. automethod:: _ascii_art_\n    .. automethod:: _cache_key\n    ",
            "implied": [],
            "methods": {
                "_ascii_art_": {
                    "__doc__": "SageObject._ascii_art_(self)\nFile: sage/structure/sage_object.pyx (starting at line 199)\n\n        Return an ASCII art representation.\n\n        To implement multi-line ASCII art output in a derived class\n        you must override this method. Unlike :meth:`_repr_`, which is\n        sometimes used for the hash key, the output of\n        :meth:`_ascii_art_` may depend on settings and is allowed to\n        change during runtime.\n\n        OUTPUT:\n\n        An :class:`~sage.typeset.ascii_art.AsciiArt` object, see\n        :mod:`sage.typeset.ascii_art` for details.\n\n        EXAMPLES:\n\n        You can use the :func:`~sage.typeset.ascii_art.ascii_art` function\n        to get the ASCII art representation of any object in Sage::\n\n            sage: ascii_art(integral(exp(x+x^2)/(x+1), x))\n              /\n             |\n             |   2\n             |  x  + x\n             | e\n             | ------- dx\n             |  x + 1\n             |\n            /\n\n        Alternatively, you can use the ``%display ascii_art/simple`` magic to\n        switch all output to ASCII art and back::\n\n            sage: from sage.repl.interpreter import get_test_shell\n            sage: shell = get_test_shell()\n            sage: shell.run_cell('tab = StandardTableaux(3)[2]; tab')\n            [[1, 2], [3]]\n            sage: shell.run_cell('%display ascii_art')\n            sage: shell.run_cell('tab')\n            1  2\n            3\n            sage: shell.run_cell('Tableaux.options(ascii_art=\"table\", convention=\"French\")')\n            sage: shell.run_cell('tab')\n            +---+\n            | 3 |\n            +---+---+\n            | 1 | 2 |\n            +---+---+\n            sage: shell.run_cell('%display plain')\n            sage: shell.run_cell('Tableaux.options._reset()')\n            sage: shell.quit()\n\n        TESTS::\n\n            sage: 1._ascii_art_()\n            1\n            sage: type(_)\n            <class 'sage.typeset.ascii_art.AsciiArt'>\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_axiom_": {
                    "__doc__": "SageObject._axiom_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 731)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_axiom_init_": {
                    "__doc__": "SageObject._axiom_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 737)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_cache_key": {
                    "__doc__": "SageObject._cache_key(self)\nFile: sage/structure/sage_object.pyx (starting at line 339)\n\n        Return a hashable key which identifies this objects for caching. The\n        output must be hashable itself, or a tuple of objects which are\n        hashable or define a ``_cache_key``.\n\n        This method will only be called if the object itself is not hashable.\n\n        Some immutable objects (such as `p`-adic numbers) cannot implement a\n        reasonable hash function because their ``==`` operator has been\n        modified to return ``True`` for objects which might behave differently\n        in some computations::\n\n            sage: K.<a> = Qq(9)\n            sage: b = a + O(3)\n            sage: c = a + 3\n            sage: b\n            a + O(3)\n            sage: c\n            a + 3 + O(3^20)\n            sage: b == c\n            True\n            sage: b == a\n            True\n            sage: c == a\n            False\n\n        If such objects defined a non-trivial hash function, this would break\n        caching in many places. However, such objects should still be usable in\n        caches. This can be achieved by defining an appropriate\n        ``_cache_key``::\n\n            sage: hash(b)\n            Traceback (most recent call last):\n            ...\n            TypeError: unhashable type: 'sage.rings.padics.qadic_flint_CR.qAdicCappedRelativeElement'\n            sage: @cached_method\n            ....: def f(x): return x==a\n            sage: f(b)\n            True\n            sage: f(c) # if b and c were hashable, this would return True\n            False\n\n            sage: b._cache_key()\n            (..., ((0, 1),), 0, 1)\n            sage: c._cache_key()\n            (..., ((0, 1), (1,)), 0, 20)\n\n        An implementation must make sure that for elements ``a`` and ``b``,\n        if ``a != b``, then also ``a._cache_key() != b._cache_key()``.\n        In practice this means that the ``_cache_key`` should always include\n        the parent as its first argument::\n\n            sage: S.<a> = Qq(4)\n            sage: d = a + O(2)\n            sage: b._cache_key() == d._cache_key() # this would be True if the parents were not included\n            False\n\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_fricas_": {
                    "__doc__": "SageObject._fricas_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 742)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_fricas_init_": {
                    "__doc__": "SageObject._fricas_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 748)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_gap_": {
                    "__doc__": "SageObject._gap_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 700)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_gap_init_": {
                    "__doc__": "SageObject._gap_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 706)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_giac_": {
                    "__doc__": "SageObject._giac_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 753)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_giac_init_": {
                    "__doc__": "SageObject._giac_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 759)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_gp_": {
                    "__doc__": "SageObject._gp_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 711)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_gp_init_": {
                    "__doc__": "SageObject._gp_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 717)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_interface_": {
                    "__doc__": "SageObject._interface_(self, I)\nFile: sage/structure/sage_object.pyx (starting at line 648)\n\n        Return coercion of self to an object of the interface I.\n\n        The result of coercion is cached, unless self is not a C\n        extension class or ``self._interface_is_cached_()`` returns\n        False.\n        ",
                    "args": [
                        "self",
                        "I"
                    ],
                    "argspec": [
                        [
                            "self",
                            "I"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_interface_init_": {
                    "__doc__": "SageObject._interface_init_(self, I=None)\nFile: sage/structure/sage_object.pyx (starting at line 688)",
                    "args": [
                        "self",
                        "I"
                    ],
                    "argspec": [
                        [
                            "self",
                            "I"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_interface_is_cached_": {
                    "__doc__": "SageObject._interface_is_cached_(self)\nFile: sage/structure/sage_object.pyx (starting at line 691)\n\n        Return True if the interface objects are cached.\n\n        If you have an object x and do gp(x), the result is cached if\n        this function returns True.\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_kash_": {
                    "__doc__": "SageObject._kash_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 720)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_kash_init_": {
                    "__doc__": "SageObject._kash_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 726)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_macaulay2_": {
                    "__doc__": "SageObject._macaulay2_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 828)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_macaulay2_init_": {
                    "__doc__": "SageObject._macaulay2_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 834)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_magma_init_": {
                    "__doc__": "SageObject._magma_init_(self, magma)\nFile: sage/structure/sage_object.pyx (starting at line 782)\n\n        Given a Magma interpreter M, return a string that evaluates in\n        that interpreter to the Magma object corresponding to self.\n        This function may call the magma interpreter when it runs.\n\n        INPUT:\n\n        - ``magma`` -- a Magma interface\n\n        OUTPUT:\n\n        - string\n\n        EXAMPLES::\n\n            sage: n = -3/7\n            sage: n._magma_init_(magma)\n            '-3/7'\n\n        Some other examples that illustrate conversion to Magma.\n        ::\n\n            sage: n = -3/7\n            sage: m2 = Magma()\n            sage: magma(n)                        # optional - magma\n            -3/7\n            sage: magma(n).parent()               # optional - magma\n            Magma\n            sage: magma(n).parent() is m2         # optional - magma\n            False\n            sage: magma(n).parent() is magma      # optional - magma\n            True\n\n        This example illustrates caching, which happens automatically\n        since K is a Python object::\n\n            sage: K.<a> = NumberField(x^3 + 2)\n            sage: magma(K) is magma(K)        # optional - magma\n            True\n            sage: magma2 = Magma()\n            sage: magma(K) is magma2(K)       # optional - magma\n            False\n        ",
                    "args": [
                        "self",
                        "magma"
                    ],
                    "argspec": [
                        [
                            "self",
                            "magma"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_maple_": {
                    "__doc__": "SageObject._maple_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 839)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_maple_init_": {
                    "__doc__": "SageObject._maple_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 845)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_mathematica_": {
                    "__doc__": "SageObject._mathematica_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 850)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_mathematica_init_": {
                    "__doc__": "SageObject._mathematica_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 856)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_maxima_": {
                    "__doc__": "SageObject._maxima_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 764)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_maxima_init_": {
                    "__doc__": "SageObject._maxima_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 770)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_maxima_lib_": {
                    "__doc__": "SageObject._maxima_lib_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 775)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_maxima_lib_init_": {
                    "__doc__": "SageObject._maxima_lib_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 779)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_octave_": {
                    "__doc__": "SageObject._octave_(self, G=None)\nFile: sage/structure/sage_object.pyx (starting at line 861)",
                    "args": [
                        "self",
                        "G"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "_octave_init_": {
                    "__doc__": "SageObject._octave_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 867)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_pari_": {
                    "__doc__": "SageObject._pari_(self)\nFile: sage/structure/sage_object.pyx (starting at line 903)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_pari_init_": {
                    "__doc__": "SageObject._pari_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 919)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_r_init_": {
                    "__doc__": "SageObject._r_init_(self)\nFile: sage/structure/sage_object.pyx (starting at line 872)\n\n        Return default string expression that evaluates in R to this\n        object.\n\n        OUTPUT:\n\n        - string\n\n        EXAMPLES::\n\n            sage: a = 2/3\n            sage: a._r_init_()\n            '2/3'\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_sage_": {
                    "__doc__": "SageObject._sage_(self)\nFile: sage/structure/sage_object.pyx (starting at line 645)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_singular_": {
                    "__doc__": "SageObject._singular_(self, G=None, have_ring=False)\nFile: sage/structure/sage_object.pyx (starting at line 891)",
                    "args": [
                        "self",
                        "G",
                        "have_ring"
                    ],
                    "argspec": [
                        [
                            "self",
                            "G",
                            "have_ring"
                        ],
                        null,
                        null,
                        [
                            null,
                            false
                        ]
                    ]
                },
                "_singular_init_": {
                    "__doc__": "SageObject._singular_init_(self, have_ring=False)\nFile: sage/structure/sage_object.pyx (starting at line 897)",
                    "args": [
                        "self",
                        "have_ring"
                    ],
                    "argspec": [
                        [
                            "self",
                            "have_ring"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "_test_category": {
                    "__doc__": "SageObject._test_category(self, **options)\nFile: sage/structure/sage_object.pyx (starting at line 486)\n\n        Run generic tests on the method :meth:`.category`.\n\n        See also: :class:`TestSuite`.\n\n        EXAMPLES::\n\n            sage: O = SageObject()\n            sage: O._test_category()\n\n        Let us now write a broken :meth:`.category` method::\n\n            sage: class CCls(SageObject):\n            ....:     def category(self):\n            ....:         return 3\n            sage: CC = CCls()\n            sage: CC._test_category()\n            Traceback (most recent call last):\n            ...\n            AssertionError: False is not true\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_new": {
                    "__doc__": "SageObject._test_new(self, **options)\nFile: sage/structure/sage_object.pyx (starting at line 51)\n\n        Check that ``cls.__new__(cls)`` does not crash Python,\n        where ``cls = type(self)``.\n\n        It is perfectly legal for ``__new__`` to raise ordinary\n        exceptions.\n\n        EXAMPLES::\n\n            sage: SageObject()._test_new()\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_not_implemented_methods": {
                    "__doc__": "SageObject._test_not_implemented_methods(self, **options)\nFile: sage/structure/sage_object.pyx (starting at line 574)\n\n        Checks that all required methods for this object are implemented\n\n        TESTS::\n\n            sage: class Abstract(SageObject):\n            ....:     @abstract_method\n            ....:     def bla(self):\n            ....:         \"returns bla\"\n            sage: class Concrete(Abstract):\n            ....:     def bla(self):\n            ....:         return 1\n            sage: class IncompleteConcrete(Abstract):\n            ....:     pass\n            sage: Concrete()._test_not_implemented_methods()\n            sage: IncompleteConcrete()._test_not_implemented_methods()\n            Traceback (most recent call last):\n            ...\n            AssertionError: Not implemented method: bla\n\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_pickling": {
                    "__doc__": "SageObject._test_pickling(self, **options)\nFile: sage/structure/sage_object.pyx (starting at line 613)\n\n        Checks that this object can be pickled and unpickled properly.\n\n        EXAMPLES::\n\n            sage: ZZ._test_pickling()\n\n        .. SEEALSO::\n\n            :func:`dumps`, :func:`loads`\n\n        TESTS::\n\n            sage: class Bla(SageObject): pass\n            sage: Bla()._test_pickling()\n            Traceback (most recent call last):\n            ...\n            PicklingError: Can't pickle <class '__main__.Bla'>: attribute lookup __main__.Bla failed\n\n        TODO: for a stronger test, this could send the object to a\n        remote Sage session, and get it back.\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_tester": {
                    "__doc__": "SageObject._tester(self, **options)\nFile: sage/structure/sage_object.pyx (starting at line 535)\n\n        Returns a gadget attached to ``self`` providing testing utilities.\n\n        This is used by :class:`sage.misc.sage_unittest.TestSuite` and the\n        ``_test_*`` methods.\n\n        EXAMPLES::\n\n            sage: tester = ZZ._tester()\n\n            sage: tester.assert_(1 == 1)\n            sage: tester.assert_(1 == 0)\n            Traceback (most recent call last):\n            ...\n            AssertionError: False is not true\n            sage: tester.assert_(1 == 0, \"this is expected to fail\")\n            Traceback (most recent call last):\n            ...\n            AssertionError: this is expected to fail\n\n            sage: tester.assertEquals(1, 1)\n            sage: tester.assertEquals(1, 0)\n            Traceback (most recent call last):\n            ...\n            AssertionError: 1 != 0\n\n        The available assertion testing facilities are the same as in\n        :class:`unittest.TestCase`, which see (actually, by a slight\n        abuse, tester is currently an instance of this class).\n\n        TESTS::\n\n            sage: ZZ._tester(tester = tester) is tester\n            True\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_unicode_art_": {
                    "__doc__": "SageObject._unicode_art_(self)\nFile: sage/structure/sage_object.pyx (starting at line 262)\n\n        Return a unicode art representation.\n\n        To implement multi-line unicode art output in a derived class\n        you must override this method. Unlike :meth:`_repr_`, which is\n        sometimes used for the hash key, the output of\n        :meth:`_unicode_art_` may depend on settings and is allowed to\n        change during runtime.\n\n        OUTPUT:\n\n        An :class:`~sage.typeset.unicode_art.UnicodeArt` object, see\n        :mod:`sage.typeset.unicode_art` for details.\n\n        EXAMPLES:\n\n        You can use the :func:`~sage.typeset.unicode_art.unicode_art` function\n        to get the ASCII art representation of any object in Sage::\n\n            sage: unicode_art(integral(exp(x+x^2)/(x+1), x))\n            \u2320\n            \u23ae   2\n            \u23ae  x  + x\n            \u23ae \u212f\n            \u23ae \u2500\u2500\u2500\u2500\u2500\u2500\u2500 dx\n            \u23ae  x + 1\n            \u2321\n\n\n        Alternatively, you can use the ``%display ascii_art/simple`` magic to\n        switch all output to ASCII art and back::\n\n            sage: from sage.repl.interpreter import get_test_shell\n            sage: shell = get_test_shell()\n            sage: shell.run_cell('tab = StandardTableaux(3)[2]; tab')\n            [[1, 2], [3]]\n            sage: shell.run_cell('%display ascii_art')\n            sage: shell.run_cell('tab')\n            1  2\n            3\n            sage: shell.run_cell('Tableaux.options(ascii_art=\"table\", convention=\"French\")')\n            sage: shell.run_cell('tab')\n            +---+\n            | 3 |\n            +---+---+\n            | 1 | 2 |\n            +---+---+\n            sage: shell.run_cell('%display plain')\n            sage: shell.run_cell('Tableaux.options._reset()')\n            sage: shell.quit()\n\n        TESTS::\n\n            sage: 1._unicode_art_()\n            1\n            sage: type(_)\n            <class 'sage.typeset.unicode_art.UnicodeArt'>\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "category": {
                    "__doc__": "SageObject.category(self)\nFile: sage/structure/sage_object.pyx (starting at line 482)",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "db": {
                    "__doc__": "SageObject.db(self, name, compress=True)\nFile: sage/structure/sage_object.pyx (starting at line 460)\n\n        Dumps self into the Sage database.  Use db(name) by itself to\n        reload.\n\n        The database directory is ``$HOME/.sage/db``\n\n        TESTS::\n\n            sage: SageObject().db(\"Test\")\n            doctest:... DeprecationWarning: db() is deprecated.\n            See http://trac.sagemath.org/2536 for details.\n        ",
                    "args": [
                        "self",
                        "name",
                        "compress"
                    ],
                    "argspec": [
                        [
                            "self",
                            "name",
                            "compress"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "dump": {
                    "__doc__": "SageObject.dump(self, filename, compress=True)\nFile: sage/structure/sage_object.pyx (starting at line 432)\n\n        Same as self.save(filename, compress)\n        ",
                    "args": [
                        "self",
                        "filename",
                        "compress"
                    ],
                    "argspec": [
                        [
                            "self",
                            "filename",
                            "compress"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "dumps": {
                    "__doc__": "SageObject.dumps(self, compress=True)\nFile: sage/structure/sage_object.pyx (starting at line 438)\n\n        Dump ``self`` to a string ``s``, which can later be reconstituted\n        as ``self`` using ``loads(s)``.\n\n        There is an optional boolean argument ``compress`` which defaults to ``True``.\n\n        EXAMPLES::\n\n            sage: O=SageObject(); O.dumps()\n            'x\\x9ck`J.NLO\\xd5+.)*M.)-\\x02\\xb2\\x80\\xdc\\xf8\\xfc\\xa4\\xac\\xd4\\xe4\\x12\\xae` \\xdb\\x1f\\xc2,d\\xd4l,d\\xd2\\x03\\x00\\xb7X\\x10\\xf1'\n            sage: O.dumps(compress=False)\n            '\\x80\\x02csage.structure.sage_object\\nSageObject\\nq\\x01)\\x81q\\x02.'\n        ",
                    "args": [
                        "self",
                        "compress"
                    ],
                    "argspec": [
                        [
                            "self",
                            "compress"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "parent": {
                    "__doc__": "SageObject.parent(self)\nFile: sage/structure/sage_object.pyx (starting at line 516)\n\n        Return the type of ``self`` to support the coercion framework.\n\n        EXAMPLES::\n\n            sage: t = log(sqrt(2) - 1) + log(sqrt(2) + 1); t\n            log(sqrt(2) + 1) + log(sqrt(2) - 1)\n            sage: u = t.maxima_methods()\n            sage: u.parent()\n            <class 'sage.symbolic.maxima_wrapper.MaximaWrapper'>\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "rename": {
                    "__doc__": "SageObject.rename(self, x=None)\nFile: sage/structure/sage_object.pyx (starting at line 73)\n\n        Change self so it prints as x, where x is a string.\n\n        .. NOTE::\n\n           This is *only* supported for Python classes that derive\n           from SageObject.\n\n        EXAMPLES::\n\n            sage: x = PolynomialRing(QQ, 'x', sparse=True).gen()\n            sage: g = x^3 + x - 5\n            sage: g\n            x^3 + x - 5\n            sage: g.rename('a polynomial')\n            sage: g\n            a polynomial\n            sage: g + x\n            x^3 + 2*x - 5\n            sage: h = g^100\n            sage: str(h)[:20]\n            'x^300 + 100*x^298 - '\n            sage: h.rename('x^300 + ...')\n            sage: h\n            x^300 + ...\n\n        Real numbers are not Python classes, so rename is not supported::\n\n            sage: a = 3.14\n            sage: type(a)\n            <type 'sage.rings.real_mpfr.RealLiteral'>\n            sage: a.rename('pi')\n            Traceback (most recent call last):\n            ...\n            NotImplementedError: object does not support renaming: 3.14000000000000\n\n        .. NOTE::\n\n           The reason C-extension types are not supported by default\n           is if they were then every single one would have to carry\n           around an extra attribute, which would be slower and waste\n           a lot of memory.\n\n           To support them for a specific class, add a\n           ``cdef public __custom_name`` attribute.\n        ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "reset_name": {
                    "__doc__": "SageObject.reset_name(self)\nFile: sage/structure/sage_object.pyx (starting at line 130)\n\n        Remove the custom name of an object.\n\n        EXAMPLES::\n\n            sage: P.<x> = QQ[]\n            sage: P\n            Univariate Polynomial Ring in x over Rational Field\n            sage: P.rename('A polynomial ring')\n            sage: P\n            A polynomial ring\n            sage: P.reset_name()\n            sage: P\n            Univariate Polynomial Ring in x over Rational Field\n        ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "save": {
                    "__doc__": "SageObject.save(self, filename=None, compress=True)\nFile: sage/structure/sage_object.pyx (starting at line 409)\n\n        Save self to the given filename.\n\n        EXAMPLES::\n\n            sage: f = x^3 + 5\n            sage: f.save(os.path.join(SAGE_TMP, 'file'))\n            sage: load(os.path.join(SAGE_TMP, 'file.sobj'))\n            x^3 + 5\n        ",
                    "args": [
                        "self",
                        "filename",
                        "compress"
                    ],
                    "argspec": [
                        [
                            "self",
                            "filename",
                            "compress"
                        ],
                        null,
                        null,
                        [
                            null,
                            true
                        ]
                    ]
                }
            },
            "name": "sage.structure.sage_object.SageObject"
        }
    }
}