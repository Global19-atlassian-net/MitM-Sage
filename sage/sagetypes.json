[
    {
        "__doc__": "\n    The category of $G$-sets, for a group $G$.\n\n    EXAMPLES::\n\n        sage: S = SymmetricGroup(3)\n        sage: GSets(S)\n        Category of G-sets for Symmetric group of order 3! as a permutation group\n\n    TODO: should this derive from Category_over_base?\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.g_sets.GSets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.g_sets.GSets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of modular abelian varieties over a given field.\n\n    EXAMPLES::\n\n        sage: ModularAbelianVarieties(QQ)\n        Category of modular abelian varieties over Rational Field\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.modular_abelian_varieties.ModularAbelianVarieties",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modular_abelian_varieties.ModularAbelianVarieties"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of bialgebras\n\n    EXAMPLES::\n\n        sage: Bialgebras(ZZ)\n        Category of bialgebras over Integer Ring\n        sage: Bialgebras(ZZ).super_categories()\n        [Category of algebras over Integer Ring, Category of coalgebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Bialgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "name": "sage.categories.bialgebras.Bialgebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite posets i.e. finite sets with a partial\n    order structure.\n\n    EXAMPLES::\n\n        sage: FinitePosets()\n        Category of finite posets\n        sage: FinitePosets().super_categories()\n        [Category of posets, Category of finite sets]\n        sage: FinitePosets().example()\n        NotImplemented\n\n    .. seealso:: :class:`~sage.categories.posets.Posets`, :func:`Poset`\n\n    TESTS::\n\n        sage: C = FinitePosets()\n        sage: C is Posets().Finite()\n        True\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.posets.Posets",
            "sage.categories.finite_sets.FiniteSets"
        ],
        "name": "sage.categories.finite_posets.FinitePosets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [
                    "antichains",
                    "lower_covers",
                    "order_filter",
                    "order_ideal",
                    "upper_covers"
                ],
                "required": [
                    "__contains__",
                    "le"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.posets.Posets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of quotient fields over an integral domain\n\n    EXAMPLES::\n\n        sage: QuotientFields()\n        Category of quotient fields\n        sage: QuotientFields().super_categories()\n        [Category of fields]\n\n    TESTS::\n\n        sage: TestSuite(QuotientFields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.fields.Fields"
        ],
        "name": "sage.categories.quotient_fields.QuotientFields",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "denominator",
                    "numerator"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.magmas.Magmas",
            "sage.categories.quotient_fields.QuotientFields",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of semirings.\n\n    A semiring `(S,+,*)` is similar to a ring, but without the\n    requirement that each element must have an additive inverse. In\n    other words, it is a combination of a commutative additive monoid\n    `(S,+)` and a multiplicative monoid `(S,*)`, where `*` distributes\n    over `+`.\n\n    .. SEEALSO::\n\n        :wikipedia:`Semiring`\n\n    EXAMPLES::\n\n        sage: Semirings()\n        Category of semirings\n        sage: Semirings().super_categories()\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of monoids]\n\n        sage: sorted(Semirings().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital', 'Associative', 'Distributive', 'Unital']\n\n        sage: Semirings() is (CommutativeAdditiveMonoids() & Monoids()).Distributive()\n        True\n\n        sage: Semirings().AdditiveInverse()\n        Category of rings\n\n\n    TESTS::\n\n        sage: TestSuite(Semirings()).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital.Associative",
            "sage.categories.monoids.Monoids"
        ],
        "name": "sage.categories.semirings.Semirings",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of complete discrete valuation rings\n\n    EXAMPLES::\n\n        sage: Zp(7) in CompleteDiscreteValuationRings()\n        True\n        sage: QQ in CompleteDiscreteValuationRings()\n        False\n        sage: QQ[['u']] in CompleteDiscreteValuationRings()\n        True\n        sage: Qp(7) in CompleteDiscreteValuationRings()\n        False\n        sage: TestSuite(CompleteDiscreteValuationRings()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.discrete_valuation.DiscreteValuationRings"
        ],
        "name": "sage.categories.complete_discrete_valuation.CompleteDiscreteValuationRings",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "precision_absolute",
                    "precision_relative",
                    "valuation"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "residue_field",
                    "uniformizer"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.discrete_valuation.DiscreteValuationRings",
            "sage.categories.complete_discrete_valuation.CompleteDiscreteValuationRings",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of affine Weyl groups\n\n    .. todo:: add a description of this category\n\n    .. seealso::\n\n        - :wikipedia:`Affine_weyl_group`\n        - :class:`WeylGroups`, :class:`WeylGroup`\n\n    EXAMPLES::\n\n        sage: C = AffineWeylGroups(); C\n        Category of affine weyl groups\n        sage: C.super_categories()\n        [Category of infinite weyl groups]\n\n        sage: C.example()\n        NotImplemented\n        sage: W = WeylGroup([\"A\",4,1]); W\n        Weyl Group of type ['A', 4, 1] (as a matrix group acting on the root space)\n        sage: W.category()\n        Category of affine weyl groups\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Infinite",
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.category.JoinCategory"
        ],
        "name": "sage.categories.affine_weyl_groups.AffineWeylGroups",
        "required_methods": {
            "element": {
                "optional": [
                    "reflection_length"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "distinguished_reflection",
                    "hyperplane_index_set",
                    "irreducible_components",
                    "reflection",
                    "reflection_index_set"
                ],
                "required": [
                    "__contains__",
                    "index_set"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of gcd domains\n    domains where gcd can be computed but where there is no guarantee of\n    factorisation into irreducibles\n\n    EXAMPLES::\n\n        sage: GcdDomains()\n        Category of gcd domains\n        sage: GcdDomains().super_categories()\n        [Category of integral domains]\n\n    TESTS::\n\n        sage: TestSuite(GcdDomains()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.integral_domains.IntegralDomains"
        ],
        "name": "sage.categories.gcd_domains.GcdDomains",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of partially ordered monoids, that is partially ordered sets\n    which are also monoids, and such that multiplication preserves the\n    ordering: `x \\leq y` implies `x*z < y*z` and `z*x < z*y`.\n\n    http://en.wikipedia.org/wiki/Ordered_monoid\n\n    EXAMPLES::\n\n        sage: PartiallyOrderedMonoids()\n        Category of partially ordered monoids\n        sage: PartiallyOrderedMonoids().super_categories()\n        [Category of posets, Category of monoids]\n\n    TESTS::\n\n        sage: TestSuite(PartiallyOrderedMonoids()).run()\n    ",
        "axioms": [
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.posets.Posets",
            "sage.categories.monoids.Monoids"
        ],
        "name": "sage.categories.partially_ordered_monoids.PartiallyOrderedMonoids",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "lower_covers",
                    "order_filter",
                    "order_ideal",
                    "upper_covers"
                ],
                "required": [
                    "__contains__",
                    "le"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.partially_ordered_monoids.PartiallyOrderedMonoids",
            "sage.categories.posets.Posets",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of rngs.\n\n    An *rng* `(S, +, *)` is similar to a ring but not necessarilly\n    unital. In other words, it is a combination of a commutative\n    additive group `(S, +)` and a multiplicative semigroup `(S, *)`,\n    where `*` distributes over `+`.\n\n    EXAMPLES::\n\n        sage: C = Rngs(); C\n        Category of rngs\n        sage: sorted(C.super_categories(), key=str)\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of commutative additive groups]\n\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse',\n         'AdditiveUnital', 'Associative', 'Distributive']\n\n        sage: C is (CommutativeAdditiveGroups() & Semigroups()).Distributive()\n        True\n        sage: C.Unital()\n        Category of rings\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital.Associative",
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "name": "sage.categories.rngs.Rngs",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "semigroup_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of pointed sets.\n\n    EXAMPLES::\n\n        sage: PointedSets()\n        Category of pointed sets\n\n    TESTS::\n\n        sage: TestSuite(PointedSets()).run()\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.pointed_sets.PointedSets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.pointed_sets.PointedSets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of discrete valuation fields\n\n    EXAMPLES::\n\n        sage: Qp(7) in DiscreteValuationFields()\n        True\n        sage: TestSuite(DiscreteValuationFields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.fields.Fields"
        ],
        "name": "sage.categories.discrete_valuation.DiscreteValuationFields",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "valuation"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "residue_field",
                    "uniformizer"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.discrete_valuation.DiscreteValuationFields",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of lattices, i.e. partially ordered sets in which any\n    two elements have a unique supremum (the elements' least upper\n    bound; called their *join*) and a unique infimum (greatest lower bound;\n    called their *meet*).\n\n    EXAMPLES::\n\n        sage: LatticePosets()\n        Category of lattice posets\n        sage: LatticePosets().super_categories()\n        [Category of posets]\n        sage: LatticePosets().example()\n        NotImplemented\n\n    .. seealso:: :class:`~sage.categories.posets.Posets`, :class:`FiniteLatticePosets`, :func:`LatticePoset`\n\n    TESTS::\n\n        sage: C = LatticePosets()\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.posets.Posets"
        ],
        "name": "sage.categories.lattice_posets.LatticePosets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [
                    "lower_covers",
                    "order_filter",
                    "order_ideal",
                    "upper_covers"
                ],
                "required": [
                    "__contains__",
                    "join",
                    "le",
                    "meet"
                ]
            }
        },
        "structure": [
            "sage.categories.posets.Posets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.lattice_posets.LatticePosets",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all chain complexes over a base ring.\n\n    EXAMPLES::\n\n        sage: ChainComplexes(RationalField())\n        Category of chain complexes over Rational Field\n\n        sage: ChainComplexes(Integers(9))\n        Category of chain complexes over Ring of integers modulo 9\n\n     TESTS::\n\n        sage: TestSuite(ChainComplexes(RationalField())).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "name": "sage.categories.category_types.ChainComplexes",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.category_types.ChainComplexes",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (multiplicative) magmas.\n\n    A magma is a set with a binary operation `*`.\n\n    EXAMPLES::\n\n        sage: Magmas()\n        Category of magmas\n        sage: Magmas().super_categories()\n        [Category of sets]\n        sage: Magmas().all_super_categories()\n        [Category of magmas, Category of sets,\n         Category of sets with partial maps, Category of objects]\n\n    The following axioms are defined by this category::\n\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Unital()\n        Category of unital magmas\n        sage: Magmas().Commutative()\n        Category of commutative magmas\n        sage: Magmas().Unital().Inverse()\n        Category of inverse unital magmas\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Associative().Unital()\n        Category of monoids\n        sage: Magmas().Associative().Unital().Inverse()\n        Category of groups\n\n    TESTS::\n\n        sage: C = Magmas()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.magmas.Magmas",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.finite_sets.FiniteSets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (abstract) vector spaces over a given field\n\n    ??? with an embedding in an ambient vector space ???\n\n    EXAMPLES::\n\n        sage: VectorSpaces(QQ)\n        Category of vector spaces over Rational Field\n        sage: VectorSpaces(QQ).super_categories()\n        [Category of modules over Rational Field]\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "name": "sage.categories.vector_spaces.VectorSpaces",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of sets.\n\n    The base category for collections of elements with = (equality).\n\n    This is also the category whose objects are all parents.\n\n    EXAMPLES::\n\n        sage: Sets()\n        Category of sets\n        sage: Sets().super_categories()\n        [Category of sets with partial maps]\n        sage: Sets().all_super_categories()\n        [Category of sets, Category of sets with partial maps, Category of objects]\n\n    Let us consider an example of set::\n\n        sage: P = Sets().example(\"inherits\")\n        sage: P\n        Set of prime numbers\n\n    See ``P??`` for the code.\n\n\n    P is in the category of sets::\n\n        sage: P.category()\n        Category of sets\n\n    and therefore gets its methods from the following classes::\n\n        sage: for cl in P.__class__.mro(): print(cl)\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits_with_category'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Abstract'>\n        <class 'sage.structure.unique_representation.UniqueRepresentation'>\n        <class 'sage.structure.unique_representation.CachedRepresentation'>\n        <type 'sage.misc.fast_methods.WithEqualityById'>\n        <type 'sage.structure.parent.Parent'>\n        <type 'sage.structure.category_object.CategoryObject'>\n        <type 'sage.structure.sage_object.SageObject'>\n        <class 'sage.categories.sets_cat.Sets.parent_class'>\n        <class 'sage.categories.sets_with_partial_maps.SetsWithPartialMaps.parent_class'>\n        <class 'sage.categories.objects.Objects.parent_class'>\n        <type 'object'>\n\n    We run some generic checks on P::\n\n        sage: TestSuite(P).run(verbose=True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n\n    Now, we manipulate some elements of P::\n\n        sage: P.an_element()\n        47\n        sage: x = P(3)\n        sage: x.parent()\n        Set of prime numbers\n        sage: x in P, 4 in P\n        (True, False)\n        sage: x.is_prime()\n        True\n\n    They get their methods from the following classes::\n\n        sage: for cl in x.__class__.mro(): print(cl)\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits_with_category.element_class'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits.Element'>\n        <type 'sage.rings.integer.IntegerWrapper'>\n        <type 'sage.rings.integer.Integer'>\n        <type 'sage.structure.element.EuclideanDomainElement'>\n        <type 'sage.structure.element.PrincipalIdealDomainElement'>\n        <type 'sage.structure.element.DedekindDomainElement'>\n        <type 'sage.structure.element.IntegralDomainElement'>\n        <type 'sage.structure.element.CommutativeRingElement'>\n        <type 'sage.structure.element.RingElement'>\n        <type 'sage.structure.element.ModuleElement'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Abstract.Element'>\n        <type 'sage.structure.element.Element'>\n        <type 'sage.structure.sage_object.SageObject'>\n        <class 'sage.categories.sets_cat.Sets.element_class'>\n        <class 'sage.categories.sets_with_partial_maps.SetsWithPartialMaps.element_class'>\n        <class 'sage.categories.objects.Objects.element_class'>\n        <type 'object'>\n\n    FIXME: Objects.element_class is not very meaningful ...\n\n\n    TESTS::\n\n          sage: TestSuite(Sets()).run()\n\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "name": "sage.categories.sets_cat.Sets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of function fields.\n\n    EXAMPLES:\n\n    We create the category of function fields::\n\n        sage: C = FunctionFields()\n        sage: C\n        Category of function fields\n\n    TESTS::\n\n        sage: TestSuite(FunctionFields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.fields.Fields"
        ],
        "name": "sage.categories.function_fields.FunctionFields",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.magmas.Magmas",
            "sage.categories.function_fields.FunctionFields",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of sets with a grading.\n\n    A *set with a grading* is a set `S` equipped with a\n    grading by some other set `I` (by default the set `\\NN` of the\n    non-negative integers):\n\n    .. MATH::\n\n         S = \\biguplus_{i\\in I} S_i\n\n    where the *graded components* `S_i` are (usually finite)\n    sets. The *grading* function maps each element `s` of\n    `S` to its *grade* `i`, so that `s\\in S_i`.\n\n    From implementation point of view, if the graded set is enumerated then\n    each graded component should be enumerated (there is a check in the method\n    :meth:`~SetsWithGrading.ParentMethods._test_graded_components`). The\n    contrary needs not be true.\n\n    To implement this category, a parent must either implement\n    :meth:`~SetsWithGrading.ParentMethods.graded_component()` or\n    :meth:`~SetsWithGrading.ParentMethods.subset()`. If only\n    :meth:`~SetsWithGrading.ParentMethods.subset()` is implemented, the first\n    argument must be the grading for compatibility with\n    :meth:`~SetsWithGrading.ParentMethods.graded_component()`. Additionally\n    either the parent must implement\n    :meth:`~SetsWithGrading.ParentMethods.grading()` or its elements must\n    implement a method ``grade()``. See the example\n    :class:`sage.categories.examples.sets_with_grading.NonNegativeIntegers`.\n\n    Finally, if the graded set is enumerated (see\n    :class:`~sage.categories.enumerated_sets.EnumeratedSets`) then each graded\n    component should be enumerated. The contrary needs not be true.\n\n    EXAMPLES:\n\n    A typical example of a set with a grading is the set of non-negative\n    integers graded by themselves::\n\n        sage: N = SetsWithGrading().example(); N\n        Non negative integers\n        sage: N.category()\n        Category of facade sets with grading\n        sage: N.grading_set()\n        Non negative integers\n\n    The *grading function* is given by ``N.grading``::\n\n        sage: N.grading(4)\n        4\n\n    The graded component `S_i` is the set of all integer partitions of\n    `i`::\n\n        sage: N.graded_component(grade = 5)\n        {5}\n        sage: N.graded_component(grade = 42)\n        {42}\n\n    Here are some information about this category::\n\n        sage: SetsWithGrading()\n        Category of sets with grading\n        sage: SetsWithGrading().super_categories()\n        [Category of sets]\n        sage: SetsWithGrading().all_super_categories()\n        [Category of sets with grading,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    .. TODO::\n\n        - This should be moved to ``Sets().WithGrading()``.\n        - Should the grading set be a parameter for this category?\n        - Does the enumeration need to be compatible with the grading? Be\n          careful that the fact that graded components are allowed to be finite\n          or infinite make the answer complicated.\n\n    TESTS::\n\n        sage: C = SetsWithGrading()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.sets_with_grading.SetsWithGrading",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [
                    "subset"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_grading.SetsWithGrading"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of two-sided ideals in a fixed algebra `A`.\n\n    EXAMPLES::\n\n        sage: AlgebraIdeals(QQ['a'])\n        Category of algebra ideals in Univariate Polynomial Ring in a over Rational Field\n\n    .. TODO::\n\n        - Add support for non commutative rings (this is currently not\n          supported by the subcategory :class:`AlgebraModules`).\n        - Make ``AlgebraIdeals(R)``, return ``CommutativeAlgebraIdeals(R)``\n          when ``R`` is commutative.\n        - If useful, implement ``AlgebraLeftIdeals`` and\n          ``AlgebraRightIdeals`` of which ``AlgebraIdeals``\n          would be a subcategory.\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.algebra_modules.AlgebraModules"
        ],
        "name": "sage.categories.algebra_ideals.AlgebraIdeals",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.algebra_modules.AlgebraModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.algebra_ideals.AlgebraIdeals",
            "sage.categories.right_modules.RightModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.objects.Objects"
        ],
        "name": "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": []
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of right modules\n    right modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with right multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: RightModules(QQ)\n        Category of right modules over Rational Field\n        sage: RightModules(QQ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(RightModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "name": "sage.categories.right_modules.RightModules",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all schemes.\n\n    EXAMPLES::\n\n        sage: Schemes()\n        Category of schemes\n\n    ``Schemes`` can also be used to construct the category of schemes\n    over a given base::\n\n        sage: Schemes(Spec(ZZ))\n        Category of schemes over Integer Ring\n\n        sage: Schemes(ZZ)\n        Category of schemes over Integer Ring\n\n    .. TODO::\n\n        Make ``Schemes()`` a singleton category (and remove\n        :class:`Schemes` from the workaround in\n        :meth:`.category_types.Category_over_base._test_category_over_bases`).\n\n        This is currently incompatible with the dispatching below.\n\n    TESTS::\n\n        sage: TestSuite(Schemes()).run()\n\n    Check that Hom sets of schemes are in the correct category::\n\n        sage: Schemes().Homsets().super_categories()\n        [Category of homsets]\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.schemes.Schemes",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.schemes.Schemes"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite dimensional Hopf algebras with a\n    distinguished basis.\n\n    EXAMPLES::\n\n        sage: FiniteDimensionalHopfAlgebrasWithBasis(QQ) # fixme: Hopf should be capitalized\n        Category of finite dimensional hopf algebras with basis over Rational Field\n        sage: FiniteDimensionalHopfAlgebrasWithBasis(QQ).super_categories()\n        [Category of hopf algebras with basis over Rational Field,\n         Category of finite dimensional algebras with basis over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(FiniteDimensionalHopfAlgebrasWithBasis(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "FiniteDimensional",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis",
            "sage.categories.finite_dimensional_algebras_with_basis.FiniteDimensionalAlgebrasWithBasis"
        ],
        "name": "sage.categories.finite_dimensional_hopf_algebras_with_basis.FiniteDimensionalHopfAlgebrasWithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "antipode_on_basis",
                    "coproduct_on_basis",
                    "counit_on_basis",
                    "one_basis",
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of discrete valuation rings\n\n    EXAMPLES::\n\n        sage: GF(7)[['x']] in DiscreteValuationRings()\n        True\n        sage: TestSuite(DiscreteValuationRings()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.euclidean_domains.EuclideanDomains"
        ],
        "name": "sage.categories.discrete_valuation.DiscreteValuationRings",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "valuation"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "residue_field",
                    "uniformizer"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.discrete_valuation.DiscreteValuationRings",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of groupoids, for a set (usually a group) $G$.\n\n    FIXME:\n\n     - Groupoid or Groupoids ?\n     - definition and link with http://en.wikipedia.org/wiki/Groupoid\n     - Should Groupoid inherit from Category_over_base?\n\n    EXAMPLES::\n\n        sage: Groupoid(DihedralGroup(3))\n        Groupoid with underlying set Dihedral group of order 6 as a permutation group\n\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.groupoid.Groupoid",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.groupoid.Groupoid"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of modules over a fixed algebra $A$.\n\n    EXAMPLES::\n\n        sage: AlgebraModules(QQ['a'])\n        Category of algebra modules over Univariate Polynomial Ring in a over Rational Field\n        sage: AlgebraModules(QQ['a']).super_categories()\n        [Category of modules over Univariate Polynomial Ring in a over Rational Field]\n\n    Note: as of now, `A` is required to be commutative, ensuring that\n    the categories of left and right modules are isomorphic. Feedback\n    and use cases for potential generalizations to the non commutative\n    case are welcome.\n\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "name": "sage.categories.algebra_modules.AlgebraModules",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.algebra_modules.AlgebraModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of unique factorization domains\n    constructive unique factorization domains, i.e. where one can constructively\n    factor members into a product of a finite number of irreducible elements\n\n    EXAMPLES::\n\n        sage: UniqueFactorizationDomains()\n        Category of unique factorization domains\n        sage: UniqueFactorizationDomains().super_categories()\n        [Category of gcd domains]\n\n    TESTS::\n\n        sage: TestSuite(UniqueFactorizationDomains()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.gcd_domains.GcdDomains"
        ],
        "name": "sage.categories.unique_factorization_domains.UniqueFactorizationDomains",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (multiplicative) semigroups.\n\n    A *semigroup* is an associative :class:`magma <Magmas>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative (see :wikipedia:`Semigroup`).\n\n    The operation `*` is not required to have a neutral element. A\n    semigroup for which such an element exists is a :class:`monoid\n    <sage.categories.monoids.Monoids>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups(); C\n        Category of semigroups\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: C.all_super_categories()\n        [Category of semigroups, Category of magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n        sage: C.axioms()\n        frozenset({'Associative'})\n        sage: C.example()\n        An example of a semigroup: the left zero semigroup\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Associative"
        ],
        "implied": [
            "sage.categories.magmas.Magmas"
        ],
        "name": "sage.categories.semigroups.Semigroups",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "semigroup_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of rings\n\n    Associative rings with unit, not necessarily commutative\n\n    EXAMPLES::\n\n        sage: Rings()\n        Category of rings\n        sage: sorted(Rings().super_categories(), key=str)\n        [Category of rngs, Category of semirings]\n\n        sage: sorted(Rings().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse',\n         'AdditiveUnital', 'Associative', 'Distributive', 'Unital']\n\n        sage: Rings() is (CommutativeAdditiveGroups() & Monoids()).Distributive()\n        True\n        sage: Rings() is Rngs().Unital()\n        True\n        sage: Rings() is Semirings().AdditiveInverse()\n        True\n\n    TESTS::\n\n        sage: TestSuite(Rings()).run()\n\n    .. TODO::\n\n        (see: http://trac.sagemath.org/sage_trac/wiki/CategoriesRoadMap)\n\n        - Make Rings() into a subcategory or alias of Algebras(ZZ);\n\n        - A parent P in the category ``Rings()`` should automatically be\n          in the category ``Algebras(P)``.\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.rngs.Rngs",
            "sage.categories.semirings.Semirings"
        ],
        "name": "sage.categories.rings.Rings",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of classical crystals, that is crystals of finite Cartan type.\n\n    EXAMPLES::\n\n        sage: C = ClassicalCrystals()\n        sage: C\n        Category of classical crystals\n        sage: C.super_categories()\n        [Category of regular crystals,\n         Category of finite crystals,\n         Category of highest weight crystals]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = ClassicalCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.regular_crystals.RegularCrystals",
            "sage.categories.finite_crystals.FiniteCrystals",
            "sage.categories.highest_weight_crystals.HighestWeightCrystals"
        ],
        "name": "sage.categories.classical_crystals.ClassicalCrystals",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "e",
                    "f"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of Hopf algebras\n\n    EXAMPLES::\n\n        sage: HopfAlgebras(QQ)\n        Category of hopf algebras over Rational Field\n        sage: HopfAlgebras(QQ).super_categories()\n        [Category of bialgebras over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(HopfAlgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.bialgebras.Bialgebras"
        ],
        "name": "sage.categories.hopf_algebras.HopfAlgebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of associative and unital algebras over a given base ring.\n\n    An associative and unital algebra over a ring `R` is a module over\n    `R` which is itself a ring.\n\n    .. WARNING::\n\n        :class:`Algebras` will be eventually be replaced by\n        :class:`.magmatic_algebras.MagmaticAlgebras`\n        for consistency with e.g. :wikipedia:`Algebras` which assumes\n        neither associativity nor the existence of a unit (see\n        :trac:`15043`).\n\n    .. TODO:: Should `R` be a commutative ring?\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ)\n        Category of algebras over Integer Ring\n        sage: sorted(Algebras(ZZ).super_categories(), key=str)\n        [Category of associative algebras over Integer Ring,\n         Category of rings,\n         Category of unital algebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.rings.Rings",
            "sage.categories.associative_algebras.AssociativeAlgebras",
            "sage.categories.unital_algebras.UnitalAlgebras"
        ],
        "name": "sage.categories.algebras.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of abelian groups, i.e. additive abelian monoids\n    where each element has an inverse.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveGroups(); C\n        Category of commutative additive groups\n        sage: C.super_categories()\n        [Category of additive groups, Category of commutative additive monoids]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n        sage: C is CommutativeAdditiveMonoids().AdditiveInverse()\n        True\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: C is AdditiveGroups().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty. It's left there for backward\n        compatibility and because it is likely to grow in the future.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveGroups()).run()\n        sage: sorted(CommutativeAdditiveGroups().CartesianProducts().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n\n    The empty covariant functorial construction category classes\n    ``CartesianProducts`` and ``Algebras`` are left here for the sake\n    of nicer output since this is a commonly used category::\n\n        sage: CommutativeAdditiveGroups().CartesianProducts()\n        Category of Cartesian products of commutative additive groups\n        sage: CommutativeAdditiveGroups().Algebras(QQ)\n        Category of commutative additive group algebras over Rational Field\n\n    Also, it's likely that some code will end up there at some point.\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.additive_groups.AdditiveGroups",
            "sage.categories.commutative_additive_monoids.CommutativeAdditiveMonoids"
        ],
        "name": "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (constructive) principal ideal domains\n\n    By constructive, we mean that a single generator can be\n    constructively found for any ideal given by a finite set of\n    generators. Note that this constructive definition only implies\n    that finitely generated ideals are principal. It is not clear what\n    we would mean by an infinitely generated ideal.\n\n    EXAMPLES::\n\n      sage: PrincipalIdealDomains()\n      Category of principal ideal domains\n      sage: PrincipalIdealDomains().super_categories()\n      [Category of unique factorization domains]\n\n    See also: http://en.wikipedia.org/wiki/Principal_ideal_domain\n\n    TESTS::\n\n        sage: TestSuite(PrincipalIdealDomains()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.unique_factorization_domains.UniqueFactorizationDomains"
        ],
        "name": "sage.categories.principal_ideal_domains.PrincipalIdealDomains",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(QQ); C\n        Category of algebras with basis over Rational Field\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras over Rational Field,\n         Category of unital algebras with basis over Rational Field]\n\n    We construct a typical parent in this category, and do some\n    computations with it::\n\n        sage: A = C.example(); A\n        An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n\n        sage: A.category()\n        Category of algebras with basis over Rational Field\n\n        sage: A.one_basis()\n        word:\n        sage: A.one()\n        B[word: ]\n\n        sage: A.base_ring()\n        Rational Field\n        sage: A.basis().keys()\n        Finite words over {'a', 'b', 'c'}\n\n        sage: (a,b,c) = A.algebra_generators()\n        sage: a^3, b^2\n        (B[word: aaa], B[word: bb])\n        sage: a*c*b\n        B[word: acb]\n\n        sage: A.product\n        <bound method FreeAlgebra_with_category._product_from_product_on_basis_multiply of\n         An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field>\n        sage: A.product(a*b,b)\n        B[word: abb]\n\n        sage: TestSuite(A).run(verbose=True)\n        running ._test_additive_associativity() . . . pass\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_characteristic() . . . pass\n        running ._test_distributivity() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_nonzero_equal() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_zero() . . . pass\n        sage: A.__class__\n        <class 'sage.categories.examples.algebras_with_basis.FreeAlgebra_with_category'>\n        sage: A.element_class\n        <class 'sage.combinat.free_module.FreeAlgebra_with_category.element_class'>\n\n    Please see the source code of `A` (with ``A??``) for how to\n    implement other algebras with basis.\n\n    TESTS::\n\n        sage: TestSuite(AlgebrasWithBasis(QQ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.unital_algebras.UnitalAlgebras.WithBasis"
        ],
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "one_basis",
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of Hopf algebras with a distinguished basis\n\n    EXAMPLES::\n\n        sage: C = HopfAlgebrasWithBasis(QQ)\n        sage: C\n        Category of hopf algebras with basis over Rational Field\n        sage: C.super_categories()\n        [Category of hopf algebras over Rational Field,\n         Category of bialgebras with basis over Rational Field]\n\n    We now show how to use a simple Hopf algebra, namely the group algebra of the dihedral group\n    (see also AlgebrasWithBasis)::\n\n        sage: A = C.example(); A\n        An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n        sage: A.__custom_name = \"A\"\n        sage: A.category()\n        Category of finite dimensional hopf algebras with basis over Rational Field\n\n        sage: A.one_basis()\n        ()\n        sage: A.one()\n        B[()]\n\n        sage: A.base_ring()\n        Rational Field\n        sage: A.basis().keys()\n        Dihedral group of order 6 as a permutation group\n\n        sage: [a,b] = A.algebra_generators()\n        sage: a, b\n        (B[(1,2,3)], B[(1,3)])\n        sage: a^3, b^2\n        (B[()], B[()])\n        sage: a*b\n        B[(1,2)]\n\n        sage: A.product           # todo: not quite ...\n        <bound method MyGroupAlgebra_with_category._product_from_product_on_basis_multiply of A>\n        sage: A.product(b,b)\n        B[()]\n\n        sage: A.zero().coproduct()\n        0\n        sage: A.zero().coproduct().parent()\n        A # A\n        sage: a.coproduct()\n        B[(1,2,3)] # B[(1,2,3)]\n\n        sage: TestSuite(A).run(verbose=True)\n        running ._test_additive_associativity() . . . pass\n        running ._test_an_element() . . . pass\n        running ._test_antipode() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_characteristic() . . . pass\n        running ._test_distributivity() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_nonzero_equal() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_zero() . . . pass\n        sage: A.__class__\n        <class 'sage.categories.examples.hopf_algebras_with_basis.MyGroupAlgebra_with_category'>\n        sage: A.element_class\n        <class 'sage.combinat.free_module.MyGroupAlgebra_with_category.element_class'>\n\n    Let us look at the code for implementing A::\n\n        sage: A??                       # todo: not implemented\n\n    TESTS::\n\n        sage: TestSuite(A).run()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.bialgebras_with_basis.BialgebrasWithBasis"
        ],
        "name": "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "antipode_on_basis",
                    "coproduct_on_basis",
                    "counit_on_basis",
                    "one_basis",
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of ideals in a fixed commutative algebra `A`.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAlgebraIdeals(QQ['x'])\n        sage: C\n        Category of commutative algebra ideals in Univariate Polynomial Ring in x over Rational Field\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.algebra_ideals.AlgebraIdeals"
        ],
        "name": "sage.categories.commutative_algebra_ideals.CommutativeAlgebraIdeals",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.algebra_modules.AlgebraModules",
            "sage.categories.algebra_ideals.AlgebraIdeals",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.commutative_algebra_ideals.CommutativeAlgebraIdeals",
            "sage.categories.right_modules.RightModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite dimensional algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = FiniteDimensionalAlgebrasWithBasis(QQ); C\n        Category of finite dimensional algebras with basis over Rational Field\n        sage: C.super_categories()\n        [Category of algebras with basis over Rational Field,\n         Category of finite dimensional modules with basis over Rational Field]\n        sage: C.example()\n        An example of a finite dimensional algebra with basis:\n        the path algebra of the Kronecker quiver\n        (containing the arrows a:x->y and b:x->y) over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Algebras(QQ).FiniteDimensional().WithBasis()\n        True\n        sage: C is Algebras(QQ).WithBasis().FiniteDimensional()\n        True\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "FiniteDimensional",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis"
        ],
        "name": "sage.categories.finite_dimensional_algebras_with_basis.FiniteDimensionalAlgebrasWithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "one_basis",
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite permutation groups, i.e. groups concretely\n    represented as groups of permutations acting on a finite set.\n\n    It is currently assumed that any finite permutation group comes\n    endowed with a distinguished finite set of generators (method\n    ``group_generators``); this is the case for all the existing\n    implementations in Sage.\n\n    EXAMPLES::\n\n        sage: C = PermutationGroups().Finite(); C\n        Category of finite permutation groups\n        sage: C.super_categories()\n        [Category of permutation groups,\n         Category of finite groups,\n         Category of finite finitely generated semigroups]\n\n        sage: C.example()\n        Dihedral group of order 6 as a permutation group\n\n    TESTS::\n\n        sage: C is FinitePermutationGroups()\n        True\n        sage: TestSuite(C).run()\n\n        sage: G = FinitePermutationGroups().example()\n        sage: TestSuite(G).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_inverse() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n    ",
        "axioms": [
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Unital",
            "Finite",
            "Associative"
        ],
        "implied": [
            "sage.categories.permutation_groups.PermutationGroups",
            "sage.categories.finite_groups.FiniteGroups",
            "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite"
        ],
        "name": "sage.categories.finite_permutation_groups.FinitePermutationGroups",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.permutation_groups.PermutationGroups"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded Hopf algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = GradedHopfAlgebrasWithBasis(ZZ); C\n        Category of graded hopf algebras with basis over Integer Ring\n        sage: C.super_categories()\n        [Category of hopf algebras with basis over Integer Ring,\n         Category of graded algebras with basis over Integer Ring]\n\n        sage: C is HopfAlgebras(ZZ).WithBasis().Graded()\n        True\n        sage: C is HopfAlgebras(ZZ).Graded().WithBasis()\n        False\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis",
            "sage.categories.graded_algebras_with_basis.GradedAlgebrasWithBasis"
        ],
        "name": "sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_",
                    "degree_on_basis"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "antipode_on_basis",
                    "coproduct_on_basis",
                    "counit_on_basis",
                    "one_basis",
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of regular crystals.\n\n    A crystal is called *regular* if every vertex `b` satisfies\n\n    .. MATH::\n\n        \\varepsilon_i(b) = \\max\\{ k \\mid e_i^k(b) \\neq 0 \\} \\quad \\text{and}\n        \\quad \\varphi_i(b) = \\max\\{ k \\mid f_i^k(b) \\neq 0 \\}.\n\n    .. NOTE::\n\n        Regular crystals are sometimes referred to as *normal*. When only one\n        of the conditions (on either `\\varphi_i` or `\\varepsilon_i`) holds,\n        these crystals are sometimes called *seminormal* or *semiregular*.\n\n    EXAMPLES::\n\n        sage: C = RegularCrystals()\n        sage: C\n        Category of regular crystals\n        sage: C.super_categories()\n        [Category of crystals]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = RegularCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.crystals.Crystals"
        ],
        "name": "sage.categories.regular_crystals.RegularCrystals",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "e",
                    "f"
                ]
            },
            "parent": {
                "optional": [
                    "connected_components_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Finite",
            "Associative"
        ],
        "implied": [
            "sage.categories.semigroups.Semigroups",
            "sage.categories.finite_sets.FiniteSets"
        ],
        "name": "sage.categories.finite_semigroups.FiniteSemigroups",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "semigroup_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of two-sided ideals in a fixed ring.\n\n    EXAMPLES::\n\n        sage: Ideals(Integers(200))\n        Category of ring ideals in Ring of integers modulo 200\n        sage: C = Ideals(IntegerRing()); C\n        Category of ring ideals in Integer Ring\n        sage: I = C([8,12,18])\n        sage: I\n        Principal ideal (2) of Integer Ring\n\n    See also: :class:`CommutativeRingIdeals`.\n\n    TODO:\n     - If useful, implement RingLeftIdeals and RingRightIdeals\n       of which RingIdeals would be a subcategory\n\n     - Make RingIdeals(R), return CommutativeRingIdeals(R) when R is\n       commutative\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "name": "sage.categories.ring_ideals.RingIdeals",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.ring_ideals.RingIdeals",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of additive abelian semigroups, i.e. sets with an\n    associative and abelian operation +.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveSemigroups(); C\n        Category of commutative additive semigroups\n        sage: C.example()\n        An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd')\n\n        sage: sorted(C.super_categories(), key=str)\n        [Category of additive commutative additive magmas,\n         Category of additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative",
            "sage.categories.additive_semigroups.AdditiveSemigroups"
        ],
        "name": "sage.categories.commutative_additive_semigroups.CommutativeAdditiveSemigroups",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis"
        ],
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "name": "sage.categories.vector_spaces.VectorSpaces.WithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of division rings\n\n    A division ring (or skew field) is a not necessarily commutative\n    ring where all non-zero elements have multiplicative inverses\n\n    EXAMPLES::\n\n      sage: DivisionRings()\n      Category of division rings\n      sage: DivisionRings().super_categories()\n      [Category of domains]\n\n    TESTS::\n\n        sage: TestSuite(DivisionRings()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.domains.Domains"
        ],
        "name": "sage.categories.division_rings.DivisionRings",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (abstract) vector spaces over a given field\n\n    ??? with an embedding in an ambient vector space ???\n\n    EXAMPLES::\n\n        sage: VectorSpaces(QQ)\n        Category of vector spaces over Rational Field\n        sage: VectorSpaces(QQ).super_categories()\n        [Category of modules over Rational Field]\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "name": "sage.categories.vector_spaces.VectorSpaces",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of crystals.\n\n    See :mod:`sage.combinat.crystals.crystals` for an introduction to crystals.\n\n    EXAMPLES::\n\n        sage: C = Crystals()\n        sage: C\n        Category of crystals\n        sage: C.super_categories()\n        [Category of... enumerated sets]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    Parents in this category should implement the following methods:\n\n    - either an attribute ``_cartan_type`` or a method ``cartan_type``\n\n    - ``module_generators``: a list (or container) of distinct elements\n      which generate the crystal using `f_i`\n\n    Furthermore, their elements ``x`` should implement the following\n    methods:\n\n    - ``x.e(i)`` (returning `e_i(x)`)\n\n    - ``x.f(i)`` (returning `f_i(x)`)\n\n    - ``x.epsilon(i)`` (returning `\\varepsilon_i(x)`)\n\n    - ``x.phi(i)`` (returning `\\varphi_i(x)`)\n\n    EXAMPLES::\n\n        sage: from sage.misc.abstract_method import abstract_methods_of_class\n        sage: abstract_methods_of_class(Crystals().element_class)\n        {'optional': [], 'required': ['e', 'epsilon', 'f', 'phi', 'weight']}\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = Crystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.enumerated_sets.EnumeratedSets"
        ],
        "name": "sage.categories.crystals.Crystals",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "e",
                    "epsilon",
                    "f",
                    "phi",
                    "weight"
                ]
            },
            "parent": {
                "optional": [
                    "connected_components_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of complete discrete valuation fields\n\n    EXAMPLES::\n\n        sage: Zp(7) in CompleteDiscreteValuationFields()\n        False\n        sage: QQ in CompleteDiscreteValuationFields()\n        False\n        sage: LaurentSeriesRing(QQ,'u') in CompleteDiscreteValuationFields()\n        True\n        sage: Qp(7) in CompleteDiscreteValuationFields()\n        True\n        sage: TestSuite(CompleteDiscreteValuationFields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.discrete_valuation.DiscreteValuationFields"
        ],
        "name": "sage.categories.complete_discrete_valuation.CompleteDiscreteValuationFields",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "precision_absolute",
                    "precision_relative",
                    "valuation"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "residue_field",
                    "uniformizer"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.discrete_valuation.DiscreteValuationFields",
            "sage.categories.complete_discrete_valuation.CompleteDiscreteValuationFields",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of commutative rings\n\n    commutative rings with unity, i.e. rings with commutative * and\n    a multiplicative identity\n\n    EXAMPLES::\n\n         sage: C = CommutativeRings(); C\n         Category of commutative rings\n         sage: C.super_categories()\n         [Category of rings, Category of commutative monoids]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n\n        sage: QQ['x,y,z'] in CommutativeRings()\n        True\n        sage: GroupAlgebra(DihedralGroup(3), QQ) in CommutativeRings()\n        False\n        sage: MatrixSpace(QQ,2,2) in CommutativeRings()\n        False\n\n    GroupAlgebra should be fixed::\n\n        sage: GroupAlgebra(CyclicPermutationGroup(3), QQ) in CommutativeRings() # todo: not implemented\n        True\n\n    ",
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.rings.Rings",
            "sage.categories.monoids.Monoids.Commutative"
        ],
        "name": "sage.categories.commutative_rings.CommutativeRings",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of partially ordered monoids, that is partially ordered sets\n    which are also monoids, and such that multiplication preserves the\n    ordering: `x \\leq y` implies `x*z < y*z` and `z*x < z*y`.\n\n    http://en.wikipedia.org/wiki/Ordered_monoid\n\n    EXAMPLES::\n\n        sage: PartiallyOrderedMonoids()\n        Category of partially ordered monoids\n        sage: PartiallyOrderedMonoids().super_categories()\n        [Category of posets, Category of monoids]\n\n    TESTS::\n\n        sage: TestSuite(PartiallyOrderedMonoids()).run()\n    ",
        "axioms": [
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.posets.Posets",
            "sage.categories.monoids.Monoids"
        ],
        "name": "sage.categories.partially_ordered_monoids.PartiallyOrderedMonoids",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "lower_covers",
                    "order_filter",
                    "order_ideal",
                    "upper_covers"
                ],
                "required": [
                    "__contains__",
                    "le"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.partially_ordered_monoids.PartiallyOrderedMonoids",
            "sage.categories.posets.Posets",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite fields.\n\n    EXAMPLES::\n\n        sage: K = FiniteFields(); K\n        Category of finite fields\n\n    A finite field is a finite monoid with the structure of a field;\n    it is currently assumed to be enumerated::\n\n        sage: K.super_categories()\n        [Category of fields,\n         Category of finite commutative rings,\n         Category of finite enumerated sets]\n\n    Some examples of membership testing and coercion::\n\n        sage: FiniteField(17) in K\n        True\n        sage: RationalField() in K\n        False\n        sage: K(RationalField())\n        Traceback (most recent call last):\n        ...\n        TypeError: unable to canonically associate a finite field to Rational Field\n\n    TESTS::\n\n        sage: K is Fields().Finite()\n        True\n        sage: TestSuite(K).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Finite",
            "Associative"
        ],
        "implied": [
            "sage.categories.fields.Fields",
            "sage.categories.commutative_rings.CommutativeRings.Finite",
            "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets"
        ],
        "name": "sage.categories.finite_fields.FiniteFields",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of abstract simplicial complexes.\n\n    An abstract simplicial complex `A` is a collection of sets `X`\n    such that:\n\n    - `\\emptyset \\in A`,\n    - if `X \\subset Y \\in A`, then `X \\in A`.\n\n    .. TODO::\n\n        Implement the category of simplicial complexes considered\n        as :class:`CW complexes <sage.categories.cw_complexes.CWComplexes>`\n        and rename this to the category of ``AbstractSimplicialComplexes``\n        with appropriate functors.\n\n    EXAMPLES::\n\n        sage: from sage.categories.simplicial_complexes import SimplicialComplexes\n        sage: C = SimplicialComplexes(); C\n        Category of simplicial complexes\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.simplicial_complexes.SimplicialComplexes",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "faces",
                    "facets"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.simplicial_complexes.SimplicialComplexes"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all elements of a given parent.\n\n    EXAMPLES::\n\n        sage: a = IntegerRing()(5)\n        sage: C = a.category(); C\n        Category of elements of Integer Ring\n        sage: a in C\n        True\n        sage: 2/3 in C\n        False\n        sage: loads(C.dumps()) == C\n        True\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.objects.Objects"
        ],
        "name": "sage.categories.category_types.Elements",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": []
            }
        },
        "structure": [
            "sage.categories.category_types.Elements"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of integral domains\n\n    An integral domain is commutative ring with no zero divisors, or\n    equivalently a commutative domain.\n\n    EXAMPLES::\n\n        sage: C = IntegralDomains(); C\n        Category of integral domains\n        sage: sorted(C.super_categories(), key=str)\n        [Category of commutative rings, Category of domains]\n        sage: C is Domains().Commutative()\n        True\n        sage: C is Rings().Commutative().NoZeroDivisors()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.domains.Domains",
            "sage.categories.commutative_rings.CommutativeRings"
        ],
        "name": "sage.categories.integral_domains.IntegralDomains",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of posets i.e. sets with a partial order structure.\n\n    EXAMPLES::\n\n        sage: Posets()\n        Category of posets\n        sage: Posets().super_categories()\n        [Category of sets]\n        sage: P = Posets().example(); P\n        An example of a poset: sets ordered by inclusion\n\n    The partial order is implemented by the mandatory method\n    :meth:`~Posets.ParentMethods.le`::\n\n        sage: x = P(Set([1,3])); y = P(Set([1,2,3]))\n        sage: x, y\n        ({1, 3}, {1, 2, 3})\n        sage: P.le(x, y)\n        True\n        sage: P.le(x, x)\n        True\n        sage: P.le(y, x)\n        False\n\n    The other comparison methods are called\n    :meth:`~Posets.ParentMethods.lt`, :meth:`~Posets.ParentMethods.ge`,\n    :meth:`~Posets.ParentMethods.gt`, following Python's naming\n    convention in :mod:`operator`. Default implementations are\n    provided::\n\n        sage: P.lt(x, x)\n        False\n        sage: P.ge(y, x)\n        True\n\n    Unless the poset is a facade (see :class:`Sets.Facade`), one can\n    compare directly its elements using the usual Python operators::\n\n        sage: D = Poset((divisors(30), attrcall(\"divides\")), facade = False)\n        sage: D(3) <= D(6)\n        True\n        sage: D(3) <= D(3)\n        True\n        sage: D(3) <= D(5)\n        False\n        sage: D(3) < D(3)\n        False\n        sage: D(10) >= D(5)\n        True\n\n    At this point, this has to be implemented by hand. Once\n    :trac:`10130` will be resolved, this will be automatically\n    provided by this category::\n\n        sage: x < y      # todo: not implemented\n        True\n        sage: x < x      # todo: not implemented\n        False\n        sage: x <= x     # todo: not implemented\n        True\n        sage: y >= x     # todo: not implemented\n        True\n\n    .. seealso:: :func:`Poset`, :class:`FinitePosets`, :class:`LatticePosets`\n\n    TESTS::\n\n        sage: C = Posets()\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.posets.Posets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [
                    "lower_covers",
                    "order_filter",
                    "order_ideal",
                    "upper_covers"
                ],
                "required": [
                    "__contains__",
                    "le"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.posets.Posets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite Weyl groups.\n\n    EXAMPLES::\n\n        sage: C = FiniteWeylGroups()\n        sage: C\n        Category of finite weyl groups\n        sage: C.super_categories()\n        [Category of finite coxeter groups, Category of weyl groups]\n        sage: C.example()\n        The symmetric group on {0, ..., 3}\n\n    TESTS::\n\n        sage: W = FiniteWeylGroups().example()\n        sage: TestSuite(W).run()\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "FinitelyGeneratedAsMagma",
            "Unital",
            "Finite",
            "WellGenerated"
        ],
        "implied": [
            "sage.categories.finite_coxeter_groups.FiniteCoxeterGroups",
            "sage.categories.weyl_groups.WeylGroups"
        ],
        "name": "sage.categories.finite_weyl_groups.FiniteWeylGroups",
        "required_methods": {
            "element": {
                "optional": [
                    "reflection_length",
                    "to_matrix"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "distinguished_reflection",
                    "hyperplane_index_set",
                    "irreducible_components",
                    "reflection",
                    "reflection_index_set"
                ],
                "required": [
                    "__contains__",
                    "index_set"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (multiplicative) groups, i.e. monoids with\n    inverses.\n\n    EXAMPLES::\n\n        sage: Groups()\n        Category of groups\n        sage: Groups().super_categories()\n        [Category of monoids, Category of inverse unital magmas]\n\n    TESTS::\n\n        sage: TestSuite(Groups()).run()\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.magmas.Magmas.Unital.Inverse"
        ],
        "name": "sage.categories.groups.Groups",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.enumerated_sets.EnumeratedSets",
            "sage.categories.finite_sets.FiniteSets"
        ],
        "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of matrix algebras over a field.\n\n    EXAMPLES::\n\n        sage: MatrixAlgebras(RationalField())\n        Category of matrix algebras over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(MatrixAlgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras.Algebras"
        ],
        "name": "sage.categories.matrix_algebras.MatrixAlgebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.matrix_algebras.MatrixAlgebras",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of posets i.e. sets with a partial order structure.\n\n    EXAMPLES::\n\n        sage: Posets()\n        Category of posets\n        sage: Posets().super_categories()\n        [Category of sets]\n        sage: P = Posets().example(); P\n        An example of a poset: sets ordered by inclusion\n\n    The partial order is implemented by the mandatory method\n    :meth:`~Posets.ParentMethods.le`::\n\n        sage: x = P(Set([1,3])); y = P(Set([1,2,3]))\n        sage: x, y\n        ({1, 3}, {1, 2, 3})\n        sage: P.le(x, y)\n        True\n        sage: P.le(x, x)\n        True\n        sage: P.le(y, x)\n        False\n\n    The other comparison methods are called\n    :meth:`~Posets.ParentMethods.lt`, :meth:`~Posets.ParentMethods.ge`,\n    :meth:`~Posets.ParentMethods.gt`, following Python's naming\n    convention in :mod:`operator`. Default implementations are\n    provided::\n\n        sage: P.lt(x, x)\n        False\n        sage: P.ge(y, x)\n        True\n\n    Unless the poset is a facade (see :class:`Sets.Facade`), one can\n    compare directly its elements using the usual Python operators::\n\n        sage: D = Poset((divisors(30), attrcall(\"divides\")), facade = False)\n        sage: D(3) <= D(6)\n        True\n        sage: D(3) <= D(3)\n        True\n        sage: D(3) <= D(5)\n        False\n        sage: D(3) < D(3)\n        False\n        sage: D(10) >= D(5)\n        True\n\n    At this point, this has to be implemented by hand. Once\n    :trac:`10130` will be resolved, this will be automatically\n    provided by this category::\n\n        sage: x < y      # todo: not implemented\n        True\n        sage: x < x      # todo: not implemented\n        False\n        sage: x <= x     # todo: not implemented\n        True\n        sage: y >= x     # todo: not implemented\n        True\n\n    .. seealso:: :func:`Poset`, :class:`FinitePosets`, :class:`LatticePosets`\n\n    TESTS::\n\n        sage: C = Posets()\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.posets.Posets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [
                    "lower_covers",
                    "order_filter",
                    "order_ideal",
                    "upper_covers"
                ],
                "required": [
                    "__contains__",
                    "le"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.posets.Posets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of number fields.\n\n    EXAMPLES:\n\n    We create the category of number fields::\n\n        sage: C = NumberFields()\n        sage: C\n        Category of number fields\n\n    Notice that the rational numbers `\\QQ` *are* considered as\n    an object in this category::\n\n        sage: RationalField() in C\n        True\n\n    However, we can define a degree 1 extension of `\\QQ`, which is of\n    course also in this category::\n\n        sage: x = PolynomialRing(RationalField(), 'x').gen()\n        sage: K = NumberField(x - 1, 'a'); K\n        Number Field in a with defining polynomial x - 1\n        sage: K in C\n        True\n\n    Number fields all lie in this category, regardless of the name\n    of the variable::\n\n        sage: K = NumberField(x^2 + 1, 'a')\n        sage: K in C\n        True\n\n    TESTS::\n\n        sage: TestSuite(NumberFields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.fields.Fields"
        ],
        "name": "sage.categories.number_fields.NumberFields",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.number_fields.NumberFields",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "FiniteDimensional",
            "AdditiveCommutative",
            "WithBasis"
        ],
        "implied": [
            "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis",
            "sage.categories.vector_spaces.VectorSpaces.WithBasis"
        ],
        "name": "sage.categories.category.JoinCategory",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.groups.Groups"
        ],
        "name": "sage.categories.permutation_groups.PermutationGroups",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.permutation_groups.PermutationGroups",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of Coxeter groups.\n\n    A *Coxeter group* is a group `W` with a distinguished (finite)\n    family of involutions `(s_i)_{i\\in I}`, called the *simple\n    reflections*, subject to relations of the form `(s_is_j)^{m_{i,j}} = 1`.\n\n    `I` is the *index set* of `W` and `|I|` is the *rank* of `W`.\n\n    See :Wikipedia:`Coxeter_group` for details.\n\n    EXAMPLES::\n\n        sage: C = CoxeterGroups(); C\n        Category of coxeter groups\n        sage: C.super_categories()\n        [Category of generalized coxeter groups]\n\n        sage: W = C.example(); W\n        The symmetric group on {0, ..., 3}\n\n        sage: W.simple_reflections()\n        Finite family {0: (1, 0, 2, 3), 1: (0, 2, 1, 3), 2: (0, 1, 3, 2)}\n\n    Here are some further examples::\n\n        sage: FiniteCoxeterGroups().example()\n        The 5-th dihedral group of order 10\n        sage: FiniteWeylGroups().example()\n        The symmetric group on {0, ..., 3}\n        sage: WeylGroup([\"B\", 3])\n        Weyl Group of type ['B', 3] (as a matrix group acting on the ambient space)\n\n    Those will eventually be also in this category::\n\n        sage: SymmetricGroup(4)\n        Symmetric group of order 4! as a permutation group\n        sage: DihedralGroup(5)\n        Dihedral group of order 10 as a permutation group\n\n    .. TODO:: add a demo of usual computations on Coxeter groups.\n\n    .. SEEALSO::\n\n        - :mod:`sage.combinat.root_system`\n        - :class:`WeylGroups`\n        - :class:`GeneralizedCoxeterGroups`\n\n    .. WARNING::\n\n        It is assumed that morphisms in this category preserve the\n        distinguished choice of simple reflections. In particular,\n        subobjects in this category are parabolic subgroups. In this\n        sense, this category might be better named ``Coxeter\n        Systems``. In the long run we might want to have two distinct\n        categories, one for Coxeter groups (with morphisms being just\n        group morphisms) and one for Coxeter systems::\n\n            sage: CoxeterGroups().is_full_subcategory(Groups())\n            False\n            sage: from sage.categories.generalized_coxeter_groups import GeneralizedCoxeterGroups\n            sage: CoxeterGroups().is_full_subcategory(GeneralizedCoxeterGroups())\n            True\n\n    TESTS::\n\n        sage: W = CoxeterGroups().example()\n        sage: TestSuite(W).run()\n    ",
        "axioms": [
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.generalized_coxeter_groups.GeneralizedCoxeterGroups"
        ],
        "name": "sage.categories.coxeter_groups.CoxeterGroups",
        "required_methods": {
            "element": {
                "optional": [
                    "reflection_length"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "distinguished_reflection",
                    "hyperplane_index_set",
                    "irreducible_components",
                    "reflection",
                    "reflection_index_set"
                ],
                "required": [
                    "__contains__",
                    "index_set"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite crystals.\n\n    EXAMPLES::\n\n        sage: C = FiniteCrystals()\n        sage: C\n        Category of finite crystals\n        sage: C.super_categories()\n        [Category of crystals, Category of finite enumerated sets]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = FiniteCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.crystals.Crystals",
            "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets"
        ],
        "name": "sage.categories.finite_crystals.FiniteCrystals",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "e",
                    "epsilon",
                    "f",
                    "phi",
                    "weight"
                ]
            },
            "parent": {
                "optional": [
                    "connected_components_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of bialgebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = BialgebrasWithBasis(QQ); C\n        Category of bialgebras with basis over Rational Field\n\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras with basis over Rational Field,\n         Category of bialgebras over Rational Field,\n         Category of coalgebras with basis over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(BialgebrasWithBasis(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.bialgebras.Bialgebras",
            "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis"
        ],
        "name": "sage.categories.bialgebras_with_basis.BialgebrasWithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "coproduct_on_basis",
                    "counit_on_basis",
                    "one_basis",
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis"
        ],
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "name": "sage.categories.vector_spaces.VectorSpaces.WithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of additive magmas.\n\n    An additive magma is a set endowed with a binary operation `+`.\n\n    EXAMPLES::\n\n        sage: AdditiveMagmas()\n        Category of additive magmas\n        sage: AdditiveMagmas().super_categories()\n        [Category of sets]\n        sage: AdditiveMagmas().all_super_categories()\n        [Category of additive magmas, Category of sets, Category of sets with partial maps, Category of objects]\n\n    The following axioms are defined by this category::\n\n        sage: AdditiveMagmas().AdditiveAssociative()\n        Category of additive semigroups\n        sage: AdditiveMagmas().AdditiveUnital()\n        Category of additive unital additive magmas\n        sage: AdditiveMagmas().AdditiveCommutative()\n        Category of additive commutative additive magmas\n        sage: AdditiveMagmas().AdditiveUnital().AdditiveInverse()\n        Category of additive inverse additive unital additive magmas\n        sage: AdditiveMagmas().AdditiveAssociative().AdditiveCommutative()\n        Category of commutative additive semigroups\n        sage: AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital()\n        Category of commutative additive monoids\n        sage: AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse()\n        Category of commutative additive groups\n\n    TESTS::\n\n        sage: C = AdditiveMagmas()\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded modules with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis",
            "sage.categories.graded_modules.GradedModules"
        ],
        "name": "sage.categories.graded_modules_with_basis.GradedModulesWithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "degree_on_basis"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of enumerated sets\n\n    An *enumerated set* is a *finite* or *countable* set or multiset `S`\n    together with a canonical enumeration of its elements;\n    conceptually, this is very similar to an immutable list. The main\n    difference lies in the names and the return type of the methods,\n    and of course the fact that the list of elements is not supposed to\n    be expanded in memory. Whenever possible one should use one of the\n    two sub-categories :class:`FiniteEnumeratedSets` or\n    :class:`InfiniteEnumeratedSets`.\n\n    The purpose of this category is threefold:\n\n     - to fix a common interface for all these sets;\n     - to provide a bunch of default implementations;\n     - to provide consistency tests.\n\n    The standard methods for an enumerated set ``S`` are:\n\n       - ``S.cardinality()``: the number of elements of the set. This\n         is the equivalent for ``len`` on a list except that the\n         return value is specified to be a Sage :class:`Integer` or\n         ``infinity``, instead of a Python ``int``.\n\n       - ``iter(S)``: an iterator for the elements of the set;\n\n       - ``S.list()``: the list of the elements of the set, when\n         possible; raises a NotImplementedError if the list is\n         predictably too large to be expanded in memory.\n\n       - ``S.unrank(n)``: the  ``n-th`` element of the set when ``n`` is a sage\n         ``Integer``. This is the equivalent for ``l[n]`` on a list.\n\n       - ``S.rank(e)``: the position of the element ``e`` in the set;\n         This is equivalent to ``l.index(e)`` for a list except that\n         the return value is specified to be a Sage :class:`Integer`,\n         instead of a Python ``int``.\n\n       - ``S.first()``: the first object of the set; it is equivalent to\n         ``S.unrank(0)``.\n\n       - ``S.next(e)``: the object of the set which follows ``e``; It is\n         equivalent to ``S.unrank(S.rank(e)+1)``.\n\n       - ``S.random_element()``: a random generator for an element of\n         the set. Unless otherwise stated, and for finite enumerated\n         sets, the probability is uniform.\n\n    For examples and tests see:\n\n       - ``FiniteEnumeratedSets().example()``\n       - ``InfiniteEnumeratedSets().example()``\n\n\n    EXAMPLES::\n\n        sage: EnumeratedSets()\n        Category of enumerated sets\n        sage: EnumeratedSets().super_categories()\n        [Category of sets]\n        sage: EnumeratedSets().all_super_categories()\n        [Category of enumerated sets, Category of sets, Category of sets with partial maps, Category of objects]\n\n    TESTS::\n\n        sage: C = EnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.enumerated_sets.EnumeratedSets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.commutative_rings.CommutativeRings"
        ],
        "name": "sage.categories.commutative_algebras.CommutativeAlgebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of coalgebras\n\n    EXAMPLES::\n\n        sage: Coalgebras(QQ)\n        Category of coalgebras over Rational Field\n        sage: Coalgebras(QQ).super_categories()\n        [Category of vector spaces over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(Coalgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "name": "sage.categories.coalgebras.Coalgebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of coalgebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: CoalgebrasWithBasis(ZZ)\n        Category of coalgebras with basis over Integer Ring\n        sage: sorted(CoalgebrasWithBasis(ZZ).super_categories(), key=str)\n        [Category of coalgebras over Integer Ring,\n         Category of modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(CoalgebrasWithBasis(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis"
        ],
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces.WithBasis",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "name": "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "coproduct_on_basis",
                    "counit_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of posets i.e. sets with a partial order structure.\n\n    EXAMPLES::\n\n        sage: Posets()\n        Category of posets\n        sage: Posets().super_categories()\n        [Category of sets]\n        sage: P = Posets().example(); P\n        An example of a poset: sets ordered by inclusion\n\n    The partial order is implemented by the mandatory method\n    :meth:`~Posets.ParentMethods.le`::\n\n        sage: x = P(Set([1,3])); y = P(Set([1,2,3]))\n        sage: x, y\n        ({1, 3}, {1, 2, 3})\n        sage: P.le(x, y)\n        True\n        sage: P.le(x, x)\n        True\n        sage: P.le(y, x)\n        False\n\n    The other comparison methods are called\n    :meth:`~Posets.ParentMethods.lt`, :meth:`~Posets.ParentMethods.ge`,\n    :meth:`~Posets.ParentMethods.gt`, following Python's naming\n    convention in :mod:`operator`. Default implementations are\n    provided::\n\n        sage: P.lt(x, x)\n        False\n        sage: P.ge(y, x)\n        True\n\n    Unless the poset is a facade (see :class:`Sets.Facade`), one can\n    compare directly its elements using the usual Python operators::\n\n        sage: D = Poset((divisors(30), attrcall(\"divides\")), facade = False)\n        sage: D(3) <= D(6)\n        True\n        sage: D(3) <= D(3)\n        True\n        sage: D(3) <= D(5)\n        False\n        sage: D(3) < D(3)\n        False\n        sage: D(10) >= D(5)\n        True\n\n    At this point, this has to be implemented by hand. Once\n    :trac:`10130` will be resolved, this will be automatically\n    provided by this category::\n\n        sage: x < y      # todo: not implemented\n        True\n        sage: x < x      # todo: not implemented\n        False\n        sage: x <= x     # todo: not implemented\n        True\n        sage: y >= x     # todo: not implemented\n        True\n\n    .. seealso:: :func:`Poset`, :class:`FinitePosets`, :class:`LatticePosets`\n\n    TESTS::\n\n        sage: C = Posets()\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.posets.Posets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [
                    "lower_covers",
                    "order_filter",
                    "order_ideal",
                    "upper_covers"
                ],
                "required": [
                    "__contains__",
                    "le"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.posets.Posets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded modules.\n\n    We consider every graded module `M = \\bigoplus_i M_i` as a\n    filtered module under the (natural) filtration given by\n\n    .. MATH::\n\n        F_i = \\bigoplus_{j < i} M_j.\n\n    EXAMPLES::\n\n        sage: GradedModules(ZZ)\n        Category of graded modules over Integer Ring\n        sage: GradedModules(ZZ).super_categories()\n        [Category of filtered modules over Integer Ring]\n\n    The category of graded modules defines the graded structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Graded().additional_structure()\n        Category of graded modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(GradedModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "name": "sage.categories.graded_modules.GradedModules",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of left modules\n    left modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with left multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: LeftModules(ZZ)\n        Category of left modules over Integer Ring\n        sage: LeftModules(ZZ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(LeftModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "name": "sage.categories.left_modules.LeftModules",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of Hecke modules.\n\n    A Hecke module is a module `M` over the \\emph{anemic} Hecke\n    algebra, i.e., the Hecke algebra generated by Hecke operators\n    `T_n` with `n` coprime to the level of `M`.  (Every Hecke module\n    defines a level function, which is a positive integer.)  The\n    reason we require that `M` only be a module over the anemic Hecke\n    algebra is that many natural maps, e.g., degeneracy maps,\n    Atkin-Lehner operators, etc., are `\\Bold{T}`-module homomorphisms; but\n    they are homomorphisms over the anemic Hecke algebra.\n\n    EXAMPLES:\n\n    We create the category of Hecke modules over `\\QQ`::\n\n        sage: C = HeckeModules(RationalField()); C\n        Category of Hecke modules over Rational Field\n\n    TODO: check that this is what we want::\n\n        sage: C.super_categories()\n        [Category of vector spaces with basis over Rational Field]\n\n    # [Category of vector spaces over Rational Field]\n\n    Note that the base ring can be an arbitrary commutative ring::\n\n        sage: HeckeModules(IntegerRing())\n        Category of Hecke modules over Integer Ring\n        sage: HeckeModules(FiniteField(5))\n        Category of Hecke modules over Finite Field of size 5\n\n    The base ring doesn't have to be a principal ideal domain::\n\n        sage: HeckeModules(PolynomialRing(IntegerRing(), 'x'))\n        Category of Hecke modules over Univariate Polynomial Ring in x over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(HeckeModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces.WithBasis"
        ],
        "name": "sage.categories.hecke_modules.HeckeModules",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hecke_modules.HeckeModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of highest weight crystals.\n\n    A crystal is highest weight if it is acyclic; in particular, every\n    connected component has a unique highest weight element, and that\n    element generate the component.\n\n    EXAMPLES::\n\n        sage: C = HighestWeightCrystals()\n        sage: C\n        Category of highest weight crystals\n        sage: C.super_categories()\n        [Category of crystals]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = HighestWeightCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.crystals.Crystals"
        ],
        "name": "sage.categories.highest_weight_crystals.HighestWeightCrystals",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "e",
                    "epsilon",
                    "f",
                    "phi",
                    "weight"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of commutative additive monoids, that is abelian\n    additive semigroups with a unit\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveMonoids(); C\n        Category of commutative additive monoids\n        sage: C.super_categories()\n        [Category of additive monoids, Category of commutative additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveMonoids()).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital"
        ],
        "implied": [
            "sage.categories.additive_monoids.AdditiveMonoids",
            "sage.categories.commutative_additive_semigroups.CommutativeAdditiveSemigroups"
        ],
        "name": "sage.categories.commutative_additive_monoids.CommutativeAdditiveMonoids",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all objects\n    the basic category\n\n    EXAMPLES::\n\n        sage: Objects()\n        Category of objects\n        sage: Objects().super_categories()\n        []\n\n    TESTS::\n\n        sage: TestSuite(Objects()).run()\n    ",
        "axioms": [],
        "implied": [],
        "name": "sage.categories.objects.Objects",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": []
            }
        },
        "structure": [],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite lattices, i.e. finite partially ordered\n    sets which are also lattices.\n\n    EXAMPLES::\n\n        sage: FiniteLatticePosets()\n        Category of finite lattice posets\n        sage: FiniteLatticePosets().super_categories()\n        [Category of lattice posets, Category of finite posets]\n        sage: FiniteLatticePosets().example()\n        NotImplemented\n\n    .. SEEALSO::\n\n        :class:`FinitePosets`, :class:`LatticePosets`, :class:`LatticePoset`\n\n    TESTS::\n\n        sage: C = FiniteLatticePosets()\n        sage: C is FiniteLatticePosets().Finite()\n        True\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.lattice_posets.LatticePosets",
            "sage.categories.finite_posets.FinitePosets"
        ],
        "name": "sage.categories.finite_lattice_posets.FiniteLatticePosets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [
                    "antichains",
                    "lower_covers",
                    "order_filter",
                    "order_ideal",
                    "upper_covers"
                ],
                "required": [
                    "__contains__",
                    "join",
                    "le",
                    "meet"
                ]
            }
        },
        "structure": [
            "sage.categories.posets.Posets",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.lattice_posets.LatticePosets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of `(R,S)`-bimodules\n\n    For `R` and `S` rings, a `(R,S)`-bimodule `X` is a left `R`-module\n    and right `S`-module such that the left and right actions commute:\n    `r*(x*s) = (r*x)*s`.\n\n    EXAMPLES::\n\n        sage: Bimodules(QQ, ZZ)\n        Category of bimodules over Rational Field on the left and Integer Ring on the right\n        sage: Bimodules(QQ, ZZ).super_categories()\n        [Category of left modules over Rational Field, Category of right modules over Integer Ring]\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules"
        ],
        "name": "sage.categories.bimodules.Bimodules",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of two-sided ideals in a fixed ring.\n\n    EXAMPLES::\n\n        sage: Ideals(Integers(200))\n        Category of ring ideals in Ring of integers modulo 200\n        sage: C = Ideals(IntegerRing()); C\n        Category of ring ideals in Integer Ring\n        sage: I = C([8,12,18])\n        sage: I\n        Principal ideal (2) of Integer Ring\n\n    See also: :class:`CommutativeRingIdeals`.\n\n    TODO:\n     - If useful, implement RingLeftIdeals and RingRightIdeals\n       of which RingIdeals would be a subcategory\n\n     - Make RingIdeals(R), return CommutativeRingIdeals(R) when R is\n       commutative\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "name": "sage.categories.ring_ideals.RingIdeals",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.ring_ideals.RingIdeals",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of ideals in a fixed commutative ring.\n\n    EXAMPLES::\n\n        sage: C = CommutativeRingIdeals(IntegerRing())\n        sage: C\n        Category of commutative ring ideals in Integer Ring\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.ring_ideals.RingIdeals"
        ],
        "name": "sage.categories.commutative_ring_ideals.CommutativeRingIdeals",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.commutative_ring_ideals.CommutativeRingIdeals",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.ring_ideals.RingIdeals",
            "sage.categories.right_modules.RightModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (commutative) fields, i.e. commutative rings where\n    all non-zero elements have multiplicative inverses\n\n    EXAMPLES::\n\n        sage: K = Fields()\n        sage: K\n        Category of fields\n        sage: Fields().super_categories()\n        [Category of euclidean domains, Category of division rings]\n\n        sage: K(IntegerRing())\n        Rational Field\n        sage: K(PolynomialRing(GF(3), 'x'))\n        Fraction Field of Univariate Polynomial Ring in x over\n        Finite Field of size 3\n        sage: K(RealField())\n        Real Field with 53 bits of precision\n\n    TESTS::\n\n        sage: TestSuite(Fields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.division_rings.DivisionRings"
        ],
        "name": "sage.categories.fields.Fields",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (abstract) vector spaces over a given field\n\n    ??? with an embedding in an ambient vector space ???\n\n    EXAMPLES::\n\n        sage: VectorSpaces(QQ)\n        Category of vector spaces over Rational Field\n        sage: VectorSpaces(QQ).super_categories()\n        [Category of modules over Rational Field]\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "name": "sage.categories.vector_spaces.VectorSpaces",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded algebras\n\n    EXAMPLES::\n\n        sage: GradedAlgebras(ZZ)\n        Category of graded algebras over Integer Ring\n        sage: GradedAlgebras(ZZ).super_categories()\n        [Category of filtered algebras over Integer Ring,\n         Category of graded modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(GradedAlgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.filtered_algebras.FilteredAlgebras",
            "sage.categories.graded_modules.GradedModules"
        ],
        "name": "sage.categories.graded_algebras.GradedAlgebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of domains\n\n    A domain (or non-commutative integral domain), is a ring, not\n    necessarily commutative, with no nonzero zero divisors.\n\n    EXAMPLES::\n\n        sage: C = Domains(); C\n        Category of domains\n        sage: C.super_categories()\n        [Category of rings]\n        sage: C is Rings().NoZeroDivisors()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.rings.Rings"
        ],
        "name": "sage.categories.domains.Domains",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite (multiplicative) :class:`monoids <Monoids>`.\n\n    A finite monoid is a :class:`finite sets <FiniteSets>` endowed\n    with an associative unital binary operation `*`.\n\n    EXAMPLES::\n\n        sage: FiniteMonoids()\n        Category of finite monoids\n        sage: FiniteMonoids().super_categories()\n        [Category of monoids, Category of finite semigroups]\n\n    TESTS::\n\n        sage: TestSuite(FiniteMonoids()).run()\n    ",
        "axioms": [
            "Finite",
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.finite_semigroups.FiniteSemigroups"
        ],
        "name": "sage.categories.finite_monoids.FiniteMonoids",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (multiplicative) monoids.\n\n    A *monoid* is a unital :class:`semigroup <Semigroups>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative and admits a unit (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: Monoids()\n        Category of monoids\n        sage: Monoids().super_categories()\n        [Category of semigroups, Category of unital magmas]\n        sage: Monoids().all_super_categories()\n        [Category of monoids,\n         Category of semigroups,\n         Category of unital magmas, Category of magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: Monoids().axioms()\n        frozenset({'Associative', 'Unital'})\n        sage: Semigroups().Unital()\n        Category of monoids\n\n        sage: Monoids().example()\n        An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: C = Monoids()\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.semigroups.Semigroups",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "name": "sage.categories.monoids.Monoids",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Infinite"
        ],
        "implied": [
            "sage.categories.enumerated_sets.EnumeratedSets",
            "sage.categories.sets_cat.Sets.Infinite"
        ],
        "name": "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded algebras with a distinguished basis\n\n    EXAMPLES::\n\n        sage: C = GradedAlgebrasWithBasis(ZZ); C\n        Category of graded algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered algebras with basis over Integer Ring,\n         Category of graded algebras over Integer Ring,\n         Category of graded modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.filtered_algebras_with_basis.FilteredAlgebrasWithBasis",
            "sage.categories.graded_algebras.GradedAlgebras",
            "sage.categories.graded_modules_with_basis.GradedModulesWithBasis"
        ],
        "name": "sage.categories.graded_algebras_with_basis.GradedAlgebrasWithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_",
                    "degree_on_basis"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "one_basis",
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite (multiplicative) groups.\n\n    EXAMPLES::\n\n        sage: C = FiniteGroups(); C\n        Category of finite groups\n        sage: C.super_categories()\n        [Category of finite monoids, Category of groups]\n        sage: C.example()\n        General Linear Group of degree 2 over Finite Field of size 3\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Finite",
            "Inverse",
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.finite_monoids.FiniteMonoids",
            "sage.categories.groups.Groups"
        ],
        "name": "sage.categories.finite_groups.FiniteGroups",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of Weyl groups\n\n    See the :wikipedia:`Wikipedia page of Weyl Groups <Weyl_group>`.\n\n    EXAMPLES::\n\n        sage: WeylGroups()\n        Category of weyl groups\n        sage: WeylGroups().super_categories()\n        [Category of coxeter groups]\n\n    Here are some examples::\n\n        sage: WeylGroups().example()            # todo: not implemented\n        sage: FiniteWeylGroups().example()\n        The symmetric group on {0, ..., 3}\n        sage: AffineWeylGroups().example()      # todo: not implemented\n        sage: WeylGroup([\"B\", 3])\n        Weyl Group of type ['B', 3] (as a matrix group acting on the ambient space)\n\n    This one will eventually be also in this category::\n\n        sage: SymmetricGroup(4)\n        Symmetric group of order 4! as a permutation group\n\n    TESTS::\n\n        sage: C = WeylGroups()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "FinitelyGeneratedAsMagma",
            "Unital"
        ],
        "implied": [
            "sage.categories.coxeter_groups.CoxeterGroups"
        ],
        "name": "sage.categories.weyl_groups.WeylGroups",
        "required_methods": {
            "element": {
                "optional": [
                    "reflection_length"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "distinguished_reflection",
                    "hyperplane_index_set",
                    "irreducible_components",
                    "reflection",
                    "reflection_index_set"
                ],
                "required": [
                    "__contains__",
                    "index_set"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of constructive euclidean domains, i.e., one can divide\n    producing a quotient and a remainder where the remainder is either zero or\n    its :meth:`ElementMethods.euclidean_degree` is smaller than the divisor.\n\n    EXAMPLES::\n\n      sage: EuclideanDomains()\n      Category of euclidean domains\n      sage: EuclideanDomains().super_categories()\n      [Category of principal ideal domains]\n\n    TESTS::\n\n        sage: TestSuite(EuclideanDomains()).run()\n\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.principal_ideal_domains.PrincipalIdealDomains"
        ],
        "name": "sage.categories.euclidean_domains.EuclideanDomains",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "euclidean_degree",
                    "quo_rem"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Unital"
        ],
        "implied": [
            "sage.categories.magmas.Magmas"
        ],
        "name": "sage.categories.magmas.Magmas.Unital",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.semigroups.Semigroups.Subquotients"
        ],
        "name": "sage.categories.monoids.Monoids.Subquotients",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "ambient",
                    "lift",
                    "retract"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.vector_spaces.VectorSpaces.DualObjects"
        ],
        "name": "sage.categories.coalgebras.Coalgebras.DualObjects",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces.TensorProducts",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "name": "sage.categories.coalgebras.Coalgebras.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered algebras with a distinguished\n    homogeneous basis.\n\n    A filtered algebra with basis over a commutative ring `R`\n    is a filtered algebra over `R` endowed with the structure\n    of a filtered module with basis (with the same underlying\n    filtered-module structure). See\n    :class:`~sage.categories.filtered_algebras.FilteredAlgebras` and\n    :class:`~sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis`\n    for these two notions.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(ZZ).Filtered(); C\n        Category of filtered algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras with basis over Integer Ring,\n         Category of filtered algebras over Integer Ring,\n         Category of filtered modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.filtered_algebras.FilteredAlgebras",
            "sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis"
        ],
        "name": "sage.categories.filtered_algebras_with_basis.FilteredAlgebrasWithBasis",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_",
                    "degree_on_basis"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "one_basis",
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.commutative_rings.CommutativeRings",
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.CartesianProducts",
            "sage.categories.monoids.Monoids.CartesianProducts",
            "sage.categories.magmas.Magmas.Commutative.CartesianProducts",
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups.CartesianProducts"
        ],
        "name": "sage.categories.commutative_rings.CommutativeRings.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces.DualObjects",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "name": "sage.categories.algebras.Algebras.DualObjects",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets",
            "sage.categories.enumerated_sets.EnumeratedSets.CartesianProducts"
        ],
        "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "name": "sage.categories.filtered_algebras.FilteredAlgebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators",
                    "graded_algebra"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        Category of finite simplicial complexes.\n        ",
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.finite_sets.FiniteSets",
            "sage.categories.simplicial_complexes.SimplicialComplexes"
        ],
        "name": "sage.categories.simplicial_complexes.SimplicialComplexes.Finite",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "faces",
                    "facets"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.simplicial_complexes.SimplicialComplexes"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Associative"
        ],
        "implied": [
            "sage.categories.semigroups.Semigroups.Subquotients",
            "sage.categories.sets_cat.Sets.Quotients"
        ],
        "name": "sage.categories.semigroups.Semigroups.Quotients",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "ambient",
                    "lift",
                    "retract"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.sets_cat.Sets.Quotients"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.monoids.Monoids.Subquotients",
            "sage.categories.semigroups.Semigroups.Quotients"
        ],
        "name": "sage.categories.algebras.Algebras.Quotients",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "ambient",
                    "lift",
                    "retract"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.sets_cat.Sets.Quotients",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        Category of topological groups.\n\n        A topological group `G` is a group which has a topology such that\n        multiplication and taking inverses are continuous functions.\n\n        REFERENCES:\n\n        - :wikipedia:`Topological_group`\n        ",
        "axioms": [
            "Inverse",
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.groups.Groups",
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "name": "sage.categories.groups.Groups.Topological",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.topological_spaces.TopologicalSpaces",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        TESTS::\n\n            sage: TestSuite(HeckeModules(ZZ).Homsets()).run()\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces",
            "sage.categories.homsets.Homsets"
        ],
        "name": "sage.categories.hecke_modules.HeckeModules.Homsets",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hecke_modules.HeckeModules.Homsets",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.sets_cat.Sets.Realizations"
        ],
        "name": "sage.categories.coalgebras.Coalgebras.Realizations",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Associative",
            "FinitelyGeneratedAsMagma"
        ],
        "implied": [
            "sage.categories.semigroups.Semigroups",
            "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas",
            "sage.categories.enumerated_sets.EnumeratedSets"
        ],
        "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "semigroup_generators"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of groups constructed as Cartesian products of groups.\n\n        This construction gives the direct product of groups. See\n        :wikipedia:`Direct_product` and :wikipedia:`Direct_product_of_groups`\n        for more information.\n        ",
        "axioms": [
            "Inverse",
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.monoids.Monoids.CartesianProducts",
            "sage.categories.groups.Groups",
            "sage.categories.magmas.Magmas.Unital.Inverse.CartesianProducts"
        ],
        "name": "sage.categories.groups.Groups.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.vector_spaces.VectorSpaces.TensorProducts"
        ],
        "name": "sage.categories.algebras.Algebras.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.commutative_algebras.CommutativeAlgebras",
            "sage.categories.additive_semigroups.AdditiveSemigroups.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Algebras"
        ],
        "name": "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras with basis constructed by tensor product of algebras with basis\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.algebras.Algebras.TensorProducts",
            "sage.categories.vector_spaces.VectorSpaces.WithBasis.TensorProducts"
        ],
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "FiniteDimensional",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.finite_dimensional_hopf_algebras_with_basis.FiniteDimensionalHopfAlgebrasWithBasis",
            "sage.categories.groups.Groups.Algebras",
            "sage.categories.finite_dimensional_semisimple_algebras_with_basis.FiniteDimensionalSemisimpleAlgebrasWithBasis",
            "sage.categories.finite_sets.FiniteSets.Algebras"
        ],
        "name": "sage.categories.finite_groups.FiniteGroups.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.semisimple_algebras.SemisimpleAlgebras",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts",
            "sage.categories.vector_spaces.VectorSpaces.WithBasis",
            "sage.categories.vector_spaces.VectorSpaces.TensorProducts"
        ],
        "name": "sage.categories.vector_spaces.VectorSpaces.WithBasis.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Infinite"
        ],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.sets_cat.Sets.Infinite",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets",
            "sage.categories.finite_sets.FiniteSets.Subquotients",
            "sage.categories.sets_cat.Sets.IsomorphicObjects"
        ],
        "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.IsomorphicObjects",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "ambient",
                    "lift",
                    "retract"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Quotients",
            "sage.categories.sets_cat.Sets.IsomorphicObjects",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.sets_cat.Sets.Subobjects"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.sets_cat.Sets.Realizations",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        Category of commutative (abelian) groups.\n\n        A group `G` is *commutative* if `xy = yx` for all `x,y \\in G`.\n        ",
        "axioms": [
            "Inverse",
            "Commutative",
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.groups.Groups",
            "sage.categories.monoids.Monoids.Commutative"
        ],
        "name": "sage.categories.groups.Groups.Commutative",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.semigroups.Semigroups.Algebras",
            "sage.categories.magmas.Magmas.Unital.Algebras"
        ],
        "name": "sage.categories.monoids.Monoids.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade"
        ],
        "implied": [
            "sage.categories.facade_sets.FacadeSets"
        ],
        "name": "sage.categories.sets_cat.Sets.WithRealizations",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [
                    "a_realization"
                ],
                "required": []
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade",
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.WithRealizations",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "name": "sage.categories.coalgebras.Coalgebras.WithRealizations",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "a_realization"
                ],
                "required": []
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of crystals constructed by tensor product of crystals.\n        ",
        "axioms": [],
        "implied": [
            "sage.categories.crystals.Crystals"
        ],
        "name": "sage.categories.crystals.Crystals.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "e",
                    "epsilon",
                    "f",
                    "phi",
                    "weight"
                ]
            },
            "parent": {
                "optional": [
                    "connected_components_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.crystals.Crystals",
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals.TensorProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        Check that Sage knows that Cartesian products of finite commutative\n        rings is a finite commutative ring.\n\n        EXAMPLES::\n\n            sage: cartesian_product([Zmod(34), GF(5)]) in Rings().Commutative().Finite()\n            True\n        ",
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Finite",
            "Associative"
        ],
        "implied": [
            "sage.categories.commutative_rings.CommutativeRings",
            "sage.categories.finite_monoids.FiniteMonoids"
        ],
        "name": "sage.categories.commutative_rings.CommutativeRings.Finite",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of subquotient magmas.\n\n        See :meth:`Sets.SubcategoryMethods.Subquotients` for the\n        general setup for subquotients. In the case of a subquotient\n        magma `S` of a magma `G`, the condition that `r` be a\n        morphism in ``As`` can be rewritten as follows:\n\n         - for any two `a,b \\in S` the identity\n           `a \\times_S b = r(l(a) \\times_G l(b))` holds.\n\n        This is used by this category to implement the product\n        `\\times_S` of `S` from `l` and `r` and the product of `G`.\n\n        EXAMPLES::\n\n            sage: Semigroups().Subquotients().all_super_categories()\n            [Category of subquotients of semigroups, Category of semigroups,\n             Category of subquotients of magmas, Category of magmas,\n             Category of subquotients of sets, Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [],
        "implied": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "name": "sage.categories.magmas.Magmas.Subquotients",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "ambient",
                    "lift",
                    "retract"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of finite crystals constructed by tensor\n        product of finite crystals.\n        ",
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.finite_crystals.FiniteCrystals",
            "sage.categories.crystals.Crystals.TensorProducts"
        ],
        "name": "sage.categories.finite_crystals.FiniteCrystals.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "e",
                    "epsilon",
                    "f",
                    "phi",
                    "weight"
                ]
            },
            "parent": {
                "optional": [
                    "connected_components_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.crystals.Crystals",
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals.TensorProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of Hopf algebras constructed by tensor product of Hopf algebras\n        ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.algebras.Algebras.TensorProducts",
            "sage.categories.coalgebras.Coalgebras.TensorProducts"
        ],
        "name": "sage.categories.hopf_algebras.HopfAlgebras.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis",
            "sage.categories.sets_cat.Sets.Algebras"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces.WithBasis"
        ],
        "name": "sage.categories.sets_cat.Sets.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "implied": [
            "sage.categories.homsets.Homsets"
        ],
        "name": "sage.categories.modular_abelian_varieties.ModularAbelianVarieties.Homsets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.homsets.Homsets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.modular_abelian_varieties.ModularAbelianVarieties.Homsets",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite Coxeter groups.\n\n    EXAMPLES::\n\n        sage: CoxeterGroups.Finite()\n        Category of finite coxeter groups\n        sage: FiniteCoxeterGroups().super_categories()\n        [Category of finite generalized coxeter groups,\n         Category of coxeter groups]\n\n        sage: G = CoxeterGroups().Finite().example()\n        sage: G.cayley_graph(side = \"right\").plot()\n        Graphics object consisting of 40 graphics primitives\n\n    Here are some further examples::\n\n        sage: WeylGroups().Finite().example()\n        The symmetric group on {0, ..., 3}\n\n        sage: WeylGroup([\"B\", 3])\n        Weyl Group of type ['B', 3] (as a matrix group acting on the ambient space)\n\n    Those other examples will eventually be also in this category::\n\n        sage: SymmetricGroup(4)\n        Symmetric group of order 4! as a permutation group\n        sage: DihedralGroup(5)\n        Dihedral group of order 10 as a permutation group\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "FinitelyGeneratedAsMagma",
            "Unital",
            "Finite",
            "WellGenerated"
        ],
        "implied": [
            "sage.categories.generalized_coxeter_groups.GeneralizedCoxeterGroups.Finite",
            "sage.categories.coxeter_groups.CoxeterGroups"
        ],
        "name": "sage.categories.finite_coxeter_groups.FiniteCoxeterGroups",
        "required_methods": {
            "element": {
                "optional": [
                    "reflection_length",
                    "to_matrix"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "distinguished_reflection",
                    "hyperplane_index_set",
                    "irreducible_components",
                    "reflection",
                    "reflection_index_set"
                ],
                "required": [
                    "__contains__",
                    "index_set"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.super_algebras.SuperAlgebras",
            "sage.categories.coalgebras.Coalgebras.Super"
        ],
        "name": "sage.categories.bialgebras.Bialgebras.Super",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        A category for isomorphic objects of sets.\n\n        EXAMPLES::\n\n            sage: Sets().IsomorphicObjects()\n            Category of isomorphic objects of sets\n            sage: Sets().IsomorphicObjects().all_super_categories()\n            [Category of isomorphic objects of sets,\n             Category of subobjects of sets, Category of quotients of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets.Subobjects",
            "sage.categories.sets_cat.Sets.Quotients"
        ],
        "name": "sage.categories.sets_cat.Sets.IsomorphicObjects",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "ambient",
                    "lift",
                    "retract"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets.IsomorphicObjects",
            "sage.categories.sets_cat.Sets.Quotients",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.Subobjects",
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "FiniteDimensional",
            "AdditiveCommutative",
            "WithBasis"
        ],
        "implied": [
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis"
        ],
        "name": "sage.categories.finite_sets.FiniteSets.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.finite_sets.FiniteSets",
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "name": "sage.categories.finite_sets.FiniteSets.Subquotients",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "ambient",
                    "lift",
                    "retract"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of regular crystals constructed by tensor\n        product of regular crystals.\n        ",
        "axioms": [],
        "implied": [
            "sage.categories.crystals.Crystals.TensorProducts",
            "sage.categories.regular_crystals.RegularCrystals"
        ],
        "name": "sage.categories.regular_crystals.RegularCrystals.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "e",
                    "f"
                ]
            },
            "parent": {
                "optional": [
                    "connected_components_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals",
            "sage.categories.crystals.Crystals.TensorProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis",
            "sage.categories.sets_cat.Sets.Algebras"
        ],
        "name": "sage.categories.magmas.Magmas.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of topological spaces.\n\n    EXAMPLES::\n\n        sage: Sets().Topological()\n        Category of topological spaces\n        sage: Sets().Topological().super_categories()\n        [Category of sets]\n\n    The category of topological spaces defines the topological structure,\n    which shall be preserved by morphisms::\n\n        sage: Sets().Topological().additional_structure()\n        Category of topological spaces\n\n    TESTS::\n\n        sage: TestSuite(Sets().Topological()).run()\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.topological_spaces.TopologicalSpaces",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        TESTS::\n\n            sage: TestSuite(Semigroups().Algebras(QQ)).run()\n            sage: TestSuite(Semigroups().Finite().Algebras(QQ)).run()\n        ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.associative_algebras.AssociativeAlgebras",
            "sage.categories.magmas.Magmas.Algebras"
        ],
        "name": "sage.categories.semigroups.Semigroups.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "semigroup_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of classical crystals constructed by tensor\n        product of classical crystals.\n        ",
        "axioms": [
            "Finite"
        ],
        "implied": [
            "sage.categories.classical_crystals.ClassicalCrystals",
            "sage.categories.finite_crystals.FiniteCrystals.TensorProducts",
            "sage.categories.regular_crystals.RegularCrystals.TensorProducts",
            "sage.categories.highest_weight_crystals.HighestWeightCrystals.TensorProducts"
        ],
        "name": "sage.categories.classical_crystals.ClassicalCrystals.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "e",
                    "f"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.crystals.Crystals",
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals.TensorProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "name": "sage.categories.vector_spaces.VectorSpaces.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Connected",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis",
            "sage.categories.filtered_modules.FilteredModules.Connected"
        ],
        "name": "sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis.Connected",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_",
                    "degree_on_basis"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "coproduct_on_basis",
                    "one_basis",
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of hopf algebras with basis constructed by tensor product of hopf algebras with basis\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis",
            "sage.categories.hopf_algebras.HopfAlgebras.TensorProducts",
            "sage.categories.algebras_with_basis.AlgebrasWithBasis.TensorProducts"
        ],
        "name": "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "antipode_on_basis",
                    "coproduct_on_basis",
                    "counit_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of monoids constructed as Cartesian products of monoids.\n\n        This construction gives the direct product of monoids. See\n        :wikipedia:`Direct_product` for more information.\n        ",
        "axioms": [
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.semigroups.Semigroups.CartesianProducts",
            "sage.categories.magmas.Magmas.Unital.CartesianProducts"
        ],
        "name": "sage.categories.monoids.Monoids.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        A category for subquotients of sets.\n\n        .. SEEALSO:: :meth:`Sets().Subquotients`\n\n        EXAMPLES::\n\n            sage: Sets().Subquotients()\n            Category of subquotients of sets\n            sage: Sets().Subquotients().all_super_categories()\n            [Category of subquotients of sets, Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.sets_cat.Sets.Subquotients",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "ambient",
                    "lift",
                    "retract"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts",
            "sage.categories.vector_spaces.VectorSpaces.WithBasis",
            "sage.categories.vector_spaces.VectorSpaces.CartesianProducts"
        ],
        "name": "sage.categories.vector_spaces.VectorSpaces.WithBasis.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.homsets.Homsets"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.Homsets",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas.Homsets",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "implied": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "name": "sage.categories.magmas.Magmas.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of highest weight crystals constructed by tensor\n        product of highest weight crystals.\n        ",
        "axioms": [],
        "implied": [
            "sage.categories.crystals.Crystals.TensorProducts",
            "sage.categories.highest_weight_crystals.HighestWeightCrystals"
        ],
        "name": "sage.categories.highest_weight_crystals.HighestWeightCrystals.TensorProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "e",
                    "epsilon",
                    "f",
                    "phi",
                    "weight"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals",
            "sage.categories.crystals.Crystals.TensorProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "name": "sage.categories.enumerated_sets.EnumeratedSets.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of metric spaces.\n\n    A *metric* on a set `S` is a function `d : S \\times S \\to \\RR`\n    such that:\n\n    - `d(a, b) \\geq 0`,\n    - `d(a, b) = 0` if and only if `a = b`.\n\n    A metric space is a set `S` with a distinguished metric.\n\n    .. RUBRIC:: Implementation\n\n    Objects in this category must implement either a ``dist`` on the parent\n    or the elements or ``metric`` on the parent; otherwise this will cause\n    an infinite recursion.\n\n    .. TODO::\n\n        - Implement a general geodesics class.\n        - Implement a category for metric additive groups\n          and move the generic distance `d(a, b) = |a - b|` there.\n        - Incorperate the length of a geodesic as part of the default\n          distance cycle.\n\n    EXAMPLES::\n\n        sage: from sage.categories.metric_spaces import MetricSpaces\n        sage: C = MetricSpaces()\n        sage: C\n        Category of metric spaces\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "implied": [
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "name": "sage.categories.metric_spaces.MetricSpaces",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.topological_spaces.TopologicalSpaces",
            "sage.categories.sets_cat.Sets",
            "sage.categories.metric_spaces.MetricSpaces"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.modules.Modules.CartesianProducts",
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "name": "sage.categories.vector_spaces.VectorSpaces.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "implied": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Realizations"
        ],
        "name": "sage.categories.magmas.Magmas.Realizations",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas.Unital.Realizations",
            "sage.categories.coalgebras.Coalgebras.Realizations"
        ],
        "name": "sage.categories.hopf_algebras.HopfAlgebras.Realizations",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade"
        ],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.facade_sets.FacadeSets",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": []
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.bialgebras.Bialgebras.Super"
        ],
        "name": "sage.categories.hopf_algebras.HopfAlgebras.Super",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.super_modules.SuperModules",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "name": "sage.categories.coalgebras.Coalgebras.Super",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        A category for subobjects of sets.\n\n        .. SEEALSO:: :meth:`Sets().Subobjects`\n\n        EXAMPLES::\n\n            sage: Sets().Subobjects()\n            Category of subobjects of sets\n            sage: Sets().Subobjects().all_super_categories()\n            [Category of subobjects of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "name": "sage.categories.sets_cat.Sets.Subobjects",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "ambient",
                    "lift",
                    "retract"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.Subobjects",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        Category of commutative (abelian) monoids.\n\n        A monoid `M` is *commutative* if `xy = yx` for all `x,y \\in M`.\n        ",
        "axioms": [
            "Commutative",
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.magmas.Magmas.Commutative"
        ],
        "name": "sage.categories.monoids.Monoids.Commutative",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of subquotient semi-groups.\n\n        EXAMPLES::\n\n            sage: Semigroups().Subquotients().all_super_categories()\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [
            "Associative"
        ],
        "implied": [
            "sage.categories.semigroups.Semigroups",
            "sage.categories.magmas.Magmas.Subquotients"
        ],
        "name": "sage.categories.semigroups.Semigroups.Subquotients",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "semigroup_generators"
                ],
                "required": [
                    "__contains__",
                    "ambient",
                    "lift",
                    "retract"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "JTrivial"
        ],
        "implied": [
            "sage.categories.magmas.Magmas"
        ],
        "name": "sage.categories.magmas.Magmas.JTrivial",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.CartesianProducts",
            "sage.categories.monoids.Monoids.CartesianProducts",
            "sage.categories.vector_spaces.VectorSpaces.CartesianProducts"
        ],
        "name": "sage.categories.algebras.Algebras.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "name": "sage.categories.vector_spaces.VectorSpaces.DualObjects",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.super_modules_with_basis.SuperModulesWithBasis",
            "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis",
            "sage.categories.coalgebras.Coalgebras.Super"
        ],
        "name": "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis.Super",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "coproduct_on_basis",
                    "counit_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Commutative"
        ],
        "implied": [
            "sage.categories.magmas.Magmas"
        ],
        "name": "sage.categories.magmas.Magmas.Commutative",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        A category for quotients of sets.\n\n        .. SEEALSO:: :meth:`Sets().Quotients`\n\n        EXAMPLES::\n\n            sage: Sets().Quotients()\n            Category of quotients of sets\n            sage: Sets().Quotients().all_super_categories()\n            [Category of quotients of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "name": "sage.categories.sets_cat.Sets.Quotients",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "ambient",
                    "lift",
                    "retract"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.sets_cat.Sets.Quotients"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.algebras.Algebras.CartesianProducts",
            "sage.categories.vector_spaces.VectorSpaces.WithBasis.CartesianProducts"
        ],
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "one_basis",
                    "product_on_basis"
                ],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of group algebras over a given base ring.\n\n        EXAMPLES::\n\n            sage: GroupAlgebras(IntegerRing())\n            Category of group algebras over Integer Ring\n            sage: GroupAlgebras(IntegerRing()).super_categories()\n            [Category of hopf algebras with basis over Integer Ring,\n             Category of monoid algebras over Integer Ring]\n\n        Here is how to create the group algebra of a group `G`::\n\n            sage: G = DihedralGroup(5)\n            sage: QG = G.algebra(QQ); QG\n            Group algebra of Dihedral group of order 10 as a permutation group over Rational Field\n\n        and an example of computation::\n\n            sage: g = G.an_element(); g\n            (1,2,3,4,5)\n            sage: (QG.term(g) + 1)**3\n            B[()] + 3*B[(1,2,3,4,5)] + 3*B[(1,3,5,2,4)] + B[(1,4,2,5,3)]\n\n        .. TODO::\n\n            - Check which methods would be better located in\n              ``Monoid.Algebras`` or ``Groups.Finite.Algebras``.\n\n        TESTS::\n\n            sage: A = GroupAlgebras(QQ).example(GL(3, GF(11)))\n            sage: A.one_basis()\n            [1 0 0]\n            [0 1 0]\n            [0 0 1]\n            sage: A = SymmetricGroupAlgebra(QQ,4)\n            sage: x = Permutation([4,3,2,1])\n            sage: A.product_on_basis(x,x)\n            [1, 2, 3, 4]\n\n            sage: C = GroupAlgebras(ZZ)\n            sage: TestSuite(C).run()\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis",
            "sage.categories.monoids.Monoids.Algebras"
        ],
        "name": "sage.categories.groups.Groups.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.category.JoinCategory"
        ],
        "name": "sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis.WithRealizations",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__",
                    "coproduct",
                    "counit"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade",
            "Associative",
            "Unital"
        ],
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.sets_cat.Sets.WithRealizations"
        ],
        "name": "sage.categories.monoids.Monoids.WithRealizations",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "a_realization"
                ],
                "required": []
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.AdditiveInverse.CartesianProducts",
            "sage.categories.additive_semigroups.AdditiveSemigroups.CartesianProducts",
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "name": "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Associative"
        ],
        "implied": [
            "sage.categories.semigroups.Semigroups",
            "sage.categories.magmas.Magmas.CartesianProducts"
        ],
        "name": "sage.categories.semigroups.Semigroups.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [
                    "semigroup_generators"
                ],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of additive semigroups.\n\n    An *additive semigroup* is an associative :class:`additive magma\n    <AdditiveMagmas>`, that is a set endowed with an operation `+`\n    which is associative.\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_semigroups import AdditiveSemigroups\n        sage: C = AdditiveSemigroups(); C\n        Category of additive semigroups\n        sage: C.super_categories()\n        [Category of additive magmas]\n        sage: C.all_super_categories()\n        [Category of additive semigroups,\n         Category of additive magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: C.axioms()\n        frozenset({'AdditiveAssociative'})\n        sage: C is AdditiveMagmas().AdditiveAssociative()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveAssociative"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "name": "sage.categories.additive_semigroups.AdditiveSemigroups",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.graded_algebras.GradedAlgebras",
            "sage.categories.super_modules.SuperModules"
        ],
        "name": "sage.categories.super_algebras.SuperAlgebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "algebra_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        EXAMPLES::\n\n            sage: C = Sets().CartesianProducts().example()\n            sage: C\n            The Cartesian product of (Set of prime numbers (basic implementation),\n             An example of an infinite enumerated set: the non negative integers,\n             An example of a finite enumerated set: {1,2,3})\n            sage: C.category()\n            Category of Cartesian products of sets\n            sage: C.categories()\n            [Category of Cartesian products of sets, Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n            sage: TestSuite(C).run()\n        ",
        "axioms": [],
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "name": "sage.categories.sets_cat.Sets.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "FinitelyGeneratedAsMagma"
        ],
        "implied": [
            "sage.categories.magmas.Magmas"
        ],
        "name": "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "magma_generators"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "implied": [
            "sage.categories.magmas.Magmas.Algebras",
            "sage.categories.magmas.Magmas.Commutative"
        ],
        "name": "sage.categories.magmas.Magmas.Commutative.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of compact topological spaces.\n        ",
        "axioms": [
            "Compact"
        ],
        "implied": [
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "name": "sage.categories.topological_spaces.TopologicalSpaces.Compact",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveAssociative"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.Homsets",
            "sage.categories.additive_semigroups.AdditiveSemigroups"
        ],
        "name": "sage.categories.additive_semigroups.AdditiveSemigroups.Homsets",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_semigroups.AdditiveSemigroups.Homsets",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas.Homsets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "implied": [
            "sage.categories.magmas.Magmas.Algebras",
            "sage.categories.unital_algebras.UnitalAlgebras.WithBasis"
        ],
        "name": "sage.categories.magmas.Magmas.Unital.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "one_basis",
                    "product_on_basis"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.AdditiveInverse",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of complete metric spaces.\n        ",
        "axioms": [
            "Complete"
        ],
        "implied": [
            "sage.categories.metric_spaces.MetricSpaces"
        ],
        "name": "sage.categories.metric_spaces.MetricSpaces.Complete",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.topological_spaces.TopologicalSpaces",
            "sage.categories.metric_spaces.MetricSpaces"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade",
            "AdditiveUnital"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets.WithRealizations"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.WithRealizations",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [
                    "a_realization"
                ],
                "required": []
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Inverse",
            "Unital"
        ],
        "implied": [
            "sage.categories.magmas.Magmas.Unital"
        ],
        "name": "sage.categories.magmas.Magmas.Unital.Inverse",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.Algebras",
            "sage.categories.unital_algebras.UnitalAlgebras.WithBasis"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Unital"
        ],
        "implied": [
            "sage.categories.magmas.Magmas.Realizations",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "name": "sage.categories.magmas.Magmas.Unital.Realizations",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveAssociative"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.CartesianProducts",
            "sage.categories.additive_semigroups.AdditiveSemigroups"
        ],
        "name": "sage.categories.additive_semigroups.AdditiveSemigroups.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.associative_algebras.AssociativeAlgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.Algebras"
        ],
        "name": "sage.categories.additive_semigroups.AdditiveSemigroups.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [
                    "semigroup_generators"
                ],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Unital"
        ],
        "implied": [
            "sage.categories.magmas.Magmas.CartesianProducts",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "name": "sage.categories.magmas.Magmas.Unital.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Endset",
            "Distributive",
            "Associative"
        ],
        "implied": [
            "sage.categories.rings.Rings",
            "sage.categories.homsets.Homsets.Endset",
            "sage.categories.modular_abelian_varieties.ModularAbelianVarieties.Homsets"
        ],
        "name": "sage.categories.modular_abelian_varieties.ModularAbelianVarieties.Homsets.Endset",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.modular_abelian_varieties.ModularAbelianVarieties.Homsets",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.Algebras",
            "sage.categories.magmas.Magmas.Commutative"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative.Algebras",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_",
                    "_mul_"
                ],
                "required": [
                    "__nonzero__",
                    "monomial_coefficients"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Finite",
            "Associative",
            "FinitelyGeneratedAsMagma"
        ],
        "implied": [
            "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups",
            "sage.categories.finite_semigroups.FiniteSemigroups",
            "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets"
        ],
        "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "semigroup_generators"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of connected topological spaces.\n        ",
        "axioms": [
            "Connected"
        ],
        "implied": [
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "name": "sage.categories.topological_spaces.TopologicalSpaces.Connected",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.homsets.Homsets"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Homsets",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Homsets",
            "sage.categories.homsets.Homsets",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Commutative"
        ],
        "implied": [
            "sage.categories.magmas.Magmas.CartesianProducts",
            "sage.categories.magmas.Magmas.Commutative"
        ],
        "name": "sage.categories.magmas.Magmas.Commutative.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of additive monoids.\n\n    An *additive monoid* is a unital :class:`additive semigroup\n    <sage.categories.additive_semigroups.AdditiveSemigroups>`, that\n    is a set endowed with a binary operation `+` which is associative\n    and admits a zero (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_monoids import AdditiveMonoids\n        sage: C = AdditiveMonoids(); C\n        Category of additive monoids\n        sage: C.super_categories()\n        [Category of additive unital additive magmas, Category of additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveUnital']\n        sage: from sage.categories.additive_semigroups import AdditiveSemigroups\n        sage: C is AdditiveSemigroups().AdditiveUnital()\n        True\n\n    TESTS::\n\n        sage: C.Algebras(QQ).is_subcategory(AlgebrasWithBasis(QQ))\n        True\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveAssociative",
            "AdditiveUnital"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_semigroups.AdditiveSemigroups"
        ],
        "name": "sage.categories.additive_monoids.AdditiveMonoids",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade"
        ],
        "implied": [
            "sage.categories.sets_cat.Sets.WithRealizations",
            "sage.categories.metric_spaces.MetricSpaces"
        ],
        "name": "sage.categories.metric_spaces.MetricSpaces.WithRealizations",
        "required_methods": {
            "element": {
                "optional": [],
                "required": []
            },
            "parent": {
                "optional": [
                    "a_realization"
                ],
                "required": []
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.topological_spaces.TopologicalSpaces",
            "sage.categories.sets_cat.Sets",
            "sage.categories.metric_spaces.MetricSpaces"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveAssociative",
            "AdditiveUnital"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Homsets",
            "sage.categories.additive_monoids.AdditiveMonoids"
        ],
        "name": "sage.categories.additive_monoids.AdditiveMonoids.Homsets",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_monoids.AdditiveMonoids.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Homsets",
            "sage.categories.homsets.Homsets",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Inverse",
            "Unital"
        ],
        "implied": [
            "sage.categories.magmas.Magmas.Unital.CartesianProducts",
            "sage.categories.magmas.Magmas.Unital.Inverse"
        ],
        "name": "sage.categories.magmas.Magmas.Unital.Inverse.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [
                    "_mul_"
                ],
                "required": []
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.AdditiveInverse"
        ],
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.AdditiveInverse.CartesianProducts",
        "required_methods": {
            "element": {
                "optional": [],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__",
                    "_cartesian_product_of_elements",
                    "_sets_keys",
                    "cartesian_factors",
                    "cartesian_projection"
                ]
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of additive groups.\n\n    An *additive group* is a set with an internal binary operation `+` which\n    is associative, admits a zero, and where every element can be negated.\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: from sage.categories.additive_monoids import AdditiveMonoids\n        sage: AdditiveGroups()\n        Category of additive groups\n        sage: AdditiveGroups().super_categories()\n        [Category of additive inverse additive unital additive magmas,\n         Category of additive monoids]\n        sage: AdditiveGroups().all_super_categories()\n        [Category of additive groups,\n         Category of additive inverse additive unital additive magmas,\n         Category of additive monoids,\n         Category of additive unital additive magmas,\n         Category of additive semigroups,\n         Category of additive magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: AdditiveGroups().axioms()\n        frozenset({'AdditiveAssociative', 'AdditiveInverse', 'AdditiveUnital'})\n        sage: AdditiveGroups() is AdditiveMonoids().AdditiveInverse()\n        True\n\n    TESTS::\n\n        sage: C = AdditiveGroups()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.AdditiveInverse",
            "sage.categories.additive_monoids.AdditiveMonoids"
        ],
        "name": "sage.categories.additive_groups.AdditiveGroups",
        "required_methods": {
            "element": {
                "optional": [
                    "_add_"
                ],
                "required": [
                    "__nonzero__"
                ]
            },
            "parent": {
                "optional": [],
                "required": [
                    "__contains__"
                ]
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "type": "Sage_Category"
    }
]