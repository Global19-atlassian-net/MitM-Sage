[
    {
        "__doc__": "\n    The category of (multiplicative) magmas.\n\n    A magma is a set with a binary operation `*`.\n\n    EXAMPLES::\n\n        sage: Magmas()\n        Category of magmas\n        sage: Magmas().super_categories()\n        [Category of sets]\n        sage: Magmas().all_super_categories()\n        [Category of magmas, Category of sets,\n         Category of sets with partial maps, Category of objects]\n\n    The following axioms are defined by this category::\n\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Unital()\n        Category of unital magmas\n        sage: Magmas().Commutative()\n        Category of commutative magmas\n        sage: Magmas().Unital().Inverse()\n        Category of inverse unital magmas\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Associative().Unital()\n        Category of monoids\n        sage: Magmas().Associative().Unital().Inverse()\n        Category of groups\n\n    TESTS::\n\n        sage: C = Magmas()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {
                "__mul__": {
                    "__doc__": "__mul__(Element self, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 160)\n\n    Return the product of ``self`` and ``right``.\n\n    INPUT:\n\n    - ``self`` -- an element of a :class:`magma <Magmas>`\n    - ``right`` -- an object\n\n    This calls the ``_mul_`` method of ``self``, if it is\n    available and the two elements have the same parent\n    (see :meth:`Magmas.ElementMethods._mul_`).\n\n    Otherwise, the job is delegated to the coercion model.\n\n    Do not override; instead implement a ``_mul_`` method in the\n    element class or a ``product`` method in the parent class.\n\n    EXAMPLES::\n\n        sage: S = Semigroups().example(\"free\")\n        sage: x = S('a'); y = S('b')\n        sage: x * y\n        'ab'\n\n    .. SEEALSO::\n\n        - :meth:`Magmas.ElementMethods._mul_`\n        - :meth:`Magmas.ElementMethods._mul_parent`\n        - :meth:`Magmas.ParentMethods.product`\n\n    This is :meth:`Magmas.ElementMethods.__mul__`, implemented as a\n    Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__mul__.im_func is Magmas.ElementMethods.__mul__.im_func\n        True\n        sage: x.__mul__.im_func is sage.categories.coercion_methods.__mul__\n        True\n    ",
                    "args": [
                        "self",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_mul_": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method _mul_ at 0x7fe452e0a9b0>",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "\\*",
                    "mmt_name": "*"
                },
                "_mul_parent": {
                    "__doc__": "_mul_parent(Element self, other)\nFile: sage/categories/coercion_methods.pyx (starting at line 207)\n\n    Return the product of the two elements, calculated using\n    the ``product`` method of the parent.\n\n    This is the default implementation of ``_mul_`` if\n    ``product`` is implemented in the parent.\n\n    INPUT:\n\n    - ``other`` -- an element of the parent of ``self``\n\n    OUTPUT:\n\n    - an element of the parent of ``self``\n\n    EXAMPLES::\n\n        sage: S = Semigroups().example(\"free\")\n        sage: x = S('a'); y = S('b')\n        sage: x._mul_parent(y)\n        'ab'\n\n    .. SEEALSO::\n\n        - :meth:`Magmas.ElementMethods._mul_`\n        - :meth:`Magmas.ElementMethods._mul_parent`\n        - :meth:`Magmas.ParentMethods.product`\n\n    This is :meth:`Magmas.ElementMethods._mul_parent`, implemented as\n    a Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x._mul_parent.im_func is Magmas.ElementMethods._mul_parent.im_func\n        True\n        sage: x._mul_parent.im_func is sage.categories.coercion_methods._mul_parent\n        True\n    ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_idempotent": {
                    "__doc__": "\n            Test whether ``self`` is idempotent.\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\"); S\n                An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n                sage: a = S('a')\n                sage: a^2\n                'aa'\n                sage: a.is_idempotent()\n                False\n\n            ::\n\n                sage: L = Semigroups().example(\"leftzero\"); L\n                An example of a semigroup: the left zero semigroup\n                sage: x = L('x')\n                sage: x^2\n                'x'\n                sage: x.is_idempotent()\n                True\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": "Magma",
        "morphism_class": {
            "__doc__": "\n    The category of (multiplicative) magmas.\n\n    A magma is a set with a binary operation `*`.\n\n    EXAMPLES::\n\n        sage: Magmas()\n        Category of magmas\n        sage: Magmas().super_categories()\n        [Category of sets]\n        sage: Magmas().all_super_categories()\n        [Category of magmas, Category of sets,\n         Category of sets with partial maps, Category of objects]\n\n    The following axioms are defined by this category::\n\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Unital()\n        Category of unital magmas\n        sage: Magmas().Commutative()\n        Category of commutative magmas\n        sage: Magmas().Unital().Inverse()\n        Category of inverse unital magmas\n        sage: Magmas().Associative()\n        Category of semigroups\n        sage: Magmas().Associative().Unital()\n        Category of monoids\n        sage: Magmas().Associative().Unital().Inverse()\n        Category of groups\n\n    TESTS::\n\n        sage: C = Magmas()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "__init_extra__": {
                    "__doc__": "\n                sage: S = Semigroups().example(\"free\")\n                sage: S('a') * S('b') # indirect doctest\n                'ab'\n                sage: S('a').__class__._mul_ == S('a').__class__._mul_parent\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "multiplication_table": {
                    "__doc__": "\n            Returns a table describing the multiplication operation.\n\n            .. note:: The order of the elements in the row and column\n              headings is equal to the order given by the table's\n              :meth:`~sage.matrix.operation_table.OperationTable.list`\n              method.  The association can also be retrieved with the\n              :meth:`~sage.matrix.operation_table.OperationTable.dict`\n              method.\n\n            INPUT:\n\n            - ``names`` - the type of names used\n\n              * ``'letters'`` - lowercase ASCII letters are used\n                for a base 26 representation of the elements'\n                positions in the list given by\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`,\n                padded to a common width with leading 'a's.\n              * ``'digits'`` - base 10 representation of the\n                elements' positions in the list given by\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`,\n                padded to a common width with leading zeros.\n              * ``'elements'`` - the string representations\n                of the elements themselves.\n              * a list - a list of strings, where the length\n                of the list equals the number of elements.\n            - ``elements`` - default = ``None``.  A list of\n              elements of the magma, in forms that can be\n              coerced into the structure, eg. their string\n              representations. This may be used to impose an\n              alternate ordering on the elements, perhaps when\n              this is used in the context of a particular structure.\n              The default is to use whatever ordering the ``S.list``\n              method returns. Or the ``elements`` can be a subset\n              which is closed under the operation. In particular,\n              this can be used when the base set is infinite.\n\n            OUTPUT:\n            The multiplication table as an object of the class\n            :class:`~sage.matrix.operation_table.OperationTable`\n            which defines several methods for manipulating and\n            displaying the table.  See the documentation there\n            for full details to supplement the documentation\n            here.\n\n            EXAMPLES:\n\n            The default is to represent elements as lowercase\n            ASCII letters.  ::\n\n                sage: G=CyclicPermutationGroup(5)\n                sage: G.multiplication_table()\n                *  a b c d e\n                 +----------\n                a| a b c d e\n                b| b c d e a\n                c| c d e a b\n                d| d e a b c\n                e| e a b c d\n\n            All that is required is that an algebraic structure\n            has a multiplication defined.  A\n            :class:`~sage.categories.examples.finite_semigroups.LeftRegularBand`\n            is an example of a finite semigroup.  The ``names`` argument allows\n            displaying the elements in different ways.  ::\n\n                sage: from sage.categories.examples.finite_semigroups import LeftRegularBand\n                sage: L=LeftRegularBand(('a','b'))\n                sage: T=L.multiplication_table(names='digits')\n                sage: T.column_keys()\n                ('a', 'b', 'ab', 'ba')\n                sage: T\n                *  0 1 2 3\n                 +--------\n                0| 0 2 2 2\n                1| 3 1 3 3\n                2| 2 2 2 2\n                3| 3 3 3 3\n\n            Specifying the elements in an alternative order can provide\n            more insight into how the operation behaves.  ::\n\n                sage: L=LeftRegularBand(('a','b','c'))\n                sage: elts = sorted(L.list())\n                sage: L.multiplication_table(elements=elts)\n                *  a b c d e f g h i j k l m n o\n                 +------------------------------\n                a| a b c d e b b c c c d d e e e\n                b| b b c c c b b c c c c c c c c\n                c| c c c c c c c c c c c c c c c\n                d| d e e d e e e e e e d d e e e\n                e| e e e e e e e e e e e e e e e\n                f| g g h h h f g h i j i j j i j\n                g| g g h h h g g h h h h h h h h\n                h| h h h h h h h h h h h h h h h\n                i| j j j j j i j j i j i j j i j\n                j| j j j j j j j j j j j j j j j\n                k| l m m l m n o o n o k l m n o\n                l| l m m l m m m m m m l l m m m\n                m| m m m m m m m m m m m m m m m\n                n| o o o o o n o o n o n o o n o\n                o| o o o o o o o o o o o o o o o\n\n            The ``elements`` argument can be used to provide\n            a subset of the elements of the structure.  The subset\n            must be closed under the operation.  Elements need only\n            be in a form that can be coerced into the set.  The\n            ``names`` argument can also be used to request that\n            the elements be represented with their usual string\n            representation.  ::\n\n                sage: L=LeftRegularBand(('a','b','c'))\n                sage: elts=['a', 'c', 'ac', 'ca']\n                sage: L.multiplication_table(names='elements', elements=elts)\n                   *   'a'  'c' 'ac' 'ca'\n                    +--------------------\n                 'a'|  'a' 'ac' 'ac' 'ac'\n                 'c'| 'ca'  'c' 'ca' 'ca'\n                'ac'| 'ac' 'ac' 'ac' 'ac'\n                'ca'| 'ca' 'ca' 'ca' 'ca'\n\n            The table returned can be manipulated in various ways.  See\n            the documentation for\n            :class:`~sage.matrix.operation_table.OperationTable` for more\n            comprehensive documentation. ::\n\n                sage: G=AlternatingGroup(3)\n                sage: T=G.multiplication_table()\n                sage: T.column_keys()\n                ((), (1,2,3), (1,3,2))\n                sage: sorted(T.translation().items())\n                [('a', ()), ('b', (1,2,3)), ('c', (1,3,2))]\n                sage: T.change_names(['x', 'y', 'z'])\n                sage: sorted(T.translation().items())\n                [('x', ()), ('y', (1,2,3)), ('z', (1,3,2))]\n                sage: T\n                *  x y z\n                 +------\n                x| x y z\n                y| y z x\n                z| z x y\n            ",
                    "args": [
                        "self",
                        "names",
                        "elements"
                    ],
                    "argspec": [
                        [
                            "self",
                            "names",
                            "elements"
                        ],
                        null,
                        null,
                        [
                            "letters",
                            null
                        ]
                    ]
                },
                "product": {
                    "__doc__": "\n            The binary multiplication of the magma.\n\n            INPUT:\n\n            - ``x``, ``y`` -- elements of this magma\n\n            OUTPUT:\n\n            - an element of the magma (the product of ``x`` and ``y``)\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\")\n                sage: x = S('a'); y = S('b')\n                sage: S.product(x, y)\n                'ab'\n\n            A parent in ``Magmas()`` must either implement\n            :meth:`.product` in the parent class or ``_mul_`` in the\n            element class. By default, the addition method on elements\n            ``x._mul_(y)`` calls ``S.product(x,y)``, and reciprocally.\n\n            As a bonus, ``S.product`` models the binary function from\n            ``S`` to ``S``::\n\n                sage: bin = S.product\n                sage: bin(x,y)\n                'ab'\n\n            Currently, ``S.product`` is just a bound method::\n\n                sage: bin\n                <bound method FreeSemigroup_with_category.product of An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')>\n\n            When Sage will support multivariate morphisms, it will be\n            possible, and in fact recommended, to enrich ``S.product``\n            with extra mathematical structure. This will typically be\n            implemented using lazy attributes.::\n\n                sage: bin                 # todo: not implemented\n                Generic binary morphism:\n                From: (S x S)\n                To:   S\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "product_from_element_class_mul": {
                    "__doc__": "\n            The binary multiplication of the magma.\n\n            INPUT:\n\n            - ``x``, ``y`` -- elements of this magma\n\n            OUTPUT:\n\n            - an element of the magma (the product of ``x`` and ``y``)\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\")\n                sage: x = S('a'); y = S('b')\n                sage: S.product(x, y)\n                'ab'\n\n            A parent in ``Magmas()`` must either implement\n            :meth:`.product` in the parent class or ``_mul_`` in the\n            element class. By default, the addition method on elements\n            ``x._mul_(y)`` calls ``S.product(x,y)``, and reciprocally.\n\n            As a bonus, ``S.product`` models the binary function from\n            ``S`` to ``S``::\n\n                sage: bin = S.product\n                sage: bin(x,y)\n                'ab'\n\n            Currently, ``S.product`` is just a bound method::\n\n                sage: bin\n                <bound method FreeSemigroup_with_category.product of An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')>\n\n            When Sage will support multivariate morphisms, it will be\n            possible, and in fact recommended, to enrich ``S.product``\n            with extra mathematical structure. This will typically be\n            implemented using lazy attributes.::\n\n                sage: bin                 # todo: not implemented\n                Generic binary morphism:\n                From: (S x S)\n                To:   S\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "__mul__": {
                    "__doc__": "__mul__(Element self, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 160)\n\n    Return the product of ``self`` and ``right``.\n\n    INPUT:\n\n    - ``self`` -- an element of a :class:`magma <Magmas>`\n    - ``right`` -- an object\n\n    This calls the ``_mul_`` method of ``self``, if it is\n    available and the two elements have the same parent\n    (see :meth:`Magmas.ElementMethods._mul_`).\n\n    Otherwise, the job is delegated to the coercion model.\n\n    Do not override; instead implement a ``_mul_`` method in the\n    element class or a ``product`` method in the parent class.\n\n    EXAMPLES::\n\n        sage: S = Semigroups().example(\"free\")\n        sage: x = S('a'); y = S('b')\n        sage: x * y\n        'ab'\n\n    .. SEEALSO::\n\n        - :meth:`Magmas.ElementMethods._mul_`\n        - :meth:`Magmas.ElementMethods._mul_parent`\n        - :meth:`Magmas.ParentMethods.product`\n\n    This is :meth:`Magmas.ElementMethods.__mul__`, implemented as a\n    Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__mul__.im_func is Magmas.ElementMethods.__mul__.im_func\n        True\n        sage: x.__mul__.im_func is sage.categories.coercion_methods.__mul__\n        True\n    ",
                    "args": [
                        "self",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_mul_": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method _mul_ at 0x7fe452e0a9b0>",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "\\*",
                    "mmt_name": "*"
                },
                "_mul_parent": {
                    "__doc__": "_mul_parent(Element self, other)\nFile: sage/categories/coercion_methods.pyx (starting at line 207)\n\n    Return the product of the two elements, calculated using\n    the ``product`` method of the parent.\n\n    This is the default implementation of ``_mul_`` if\n    ``product`` is implemented in the parent.\n\n    INPUT:\n\n    - ``other`` -- an element of the parent of ``self``\n\n    OUTPUT:\n\n    - an element of the parent of ``self``\n\n    EXAMPLES::\n\n        sage: S = Semigroups().example(\"free\")\n        sage: x = S('a'); y = S('b')\n        sage: x._mul_parent(y)\n        'ab'\n\n    .. SEEALSO::\n\n        - :meth:`Magmas.ElementMethods._mul_`\n        - :meth:`Magmas.ElementMethods._mul_parent`\n        - :meth:`Magmas.ParentMethods.product`\n\n    This is :meth:`Magmas.ElementMethods._mul_parent`, implemented as\n    a Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x._mul_parent.im_func is Magmas.ElementMethods._mul_parent.im_func\n        True\n        sage: x._mul_parent.im_func is sage.categories.coercion_methods._mul_parent\n        True\n    ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_idempotent": {
                    "__doc__": "\n            Test whether ``self`` is idempotent.\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\"); S\n                An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n                sage: a = S('a')\n                sage: a^2\n                'aa'\n                sage: a.is_idempotent()\n                False\n\n            ::\n\n                sage: L = Semigroups().example(\"leftzero\"); L\n                An example of a semigroup: the left zero semigroup\n                sage: x = L('x')\n                sage: x^2\n                'x'\n                sage: x.is_idempotent()\n                True\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of pointed sets.\n\n    EXAMPLES::\n\n        sage: PointedSets()\n        Category of pointed sets\n\n    TESTS::\n\n        sage: TestSuite(PointedSets()).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of pointed sets.\n\n    EXAMPLES::\n\n        sage: PointedSets()\n        Category of pointed sets\n\n    TESTS::\n\n        sage: TestSuite(PointedSets()).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of pointed sets.\n\n    EXAMPLES::\n\n        sage: PointedSets()\n        Category of pointed sets\n\n    TESTS::\n\n        sage: TestSuite(PointedSets()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.pointed_sets.PointedSets",
        "parent_class": {
            "__doc__": "\n    The category of pointed sets.\n\n    EXAMPLES::\n\n        sage: PointedSets()\n        Category of pointed sets\n\n    TESTS::\n\n        sage: TestSuite(PointedSets()).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.pointed_sets.PointedSets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of pointed sets.\n\n    EXAMPLES::\n\n        sage: PointedSets()\n        Category of pointed sets\n\n    TESTS::\n\n        sage: TestSuite(PointedSets()).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of sets with a grading.\n\n    A *set with a grading* is a set `S` equipped with a\n    grading by some other set `I` (by default the set `\\NN` of the\n    non-negative integers):\n\n    .. MATH::\n\n         S = \\biguplus_{i\\in I} S_i\n\n    where the *graded components* `S_i` are (usually finite)\n    sets. The *grading* function maps each element `s` of\n    `S` to its *grade* `i`, so that `s\\in S_i`.\n\n    From implementation point of view, if the graded set is enumerated then\n    each graded component should be enumerated (there is a check in the method\n    :meth:`~SetsWithGrading.ParentMethods._test_graded_components`). The\n    contrary needs not be true.\n\n    To implement this category, a parent must either implement\n    :meth:`~SetsWithGrading.ParentMethods.graded_component()` or\n    :meth:`~SetsWithGrading.ParentMethods.subset()`. If only\n    :meth:`~SetsWithGrading.ParentMethods.subset()` is implemented, the first\n    argument must be the grading for compatibility with\n    :meth:`~SetsWithGrading.ParentMethods.graded_component()`. Additionally\n    either the parent must implement\n    :meth:`~SetsWithGrading.ParentMethods.grading()` or its elements must\n    implement a method ``grade()``. See the example\n    :class:`sage.categories.examples.sets_with_grading.NonNegativeIntegers`.\n\n    Finally, if the graded set is enumerated (see\n    :class:`~sage.categories.enumerated_sets.EnumeratedSets`) then each graded\n    component should be enumerated. The contrary needs not be true.\n\n    EXAMPLES:\n\n    A typical example of a set with a grading is the set of non-negative\n    integers graded by themselves::\n\n        sage: N = SetsWithGrading().example(); N\n        Non negative integers\n        sage: N.category()\n        Category of facade sets with grading\n        sage: N.grading_set()\n        Non negative integers\n\n    The *grading function* is given by ``N.grading``::\n\n        sage: N.grading(4)\n        4\n\n    The graded component `S_i` is the set of all integer partitions of\n    `i`::\n\n        sage: N.graded_component(grade = 5)\n        {5}\n        sage: N.graded_component(grade = 42)\n        {42}\n\n    Here are some information about this category::\n\n        sage: SetsWithGrading()\n        Category of sets with grading\n        sage: SetsWithGrading().super_categories()\n        [Category of sets]\n        sage: SetsWithGrading().all_super_categories()\n        [Category of sets with grading,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    .. TODO::\n\n        - This should be moved to ``Sets().WithGrading()``.\n        - Should the grading set be a parameter for this category?\n        - Does the enumeration need to be compatible with the grading? Be\n          careful that the fact that graded components are allowed to be finite\n          or infinite make the answer complicated.\n\n    TESTS::\n\n        sage: C = SetsWithGrading()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of sets with a grading.\n\n    A *set with a grading* is a set `S` equipped with a\n    grading by some other set `I` (by default the set `\\NN` of the\n    non-negative integers):\n\n    .. MATH::\n\n         S = \\biguplus_{i\\in I} S_i\n\n    where the *graded components* `S_i` are (usually finite)\n    sets. The *grading* function maps each element `s` of\n    `S` to its *grade* `i`, so that `s\\in S_i`.\n\n    From implementation point of view, if the graded set is enumerated then\n    each graded component should be enumerated (there is a check in the method\n    :meth:`~SetsWithGrading.ParentMethods._test_graded_components`). The\n    contrary needs not be true.\n\n    To implement this category, a parent must either implement\n    :meth:`~SetsWithGrading.ParentMethods.graded_component()` or\n    :meth:`~SetsWithGrading.ParentMethods.subset()`. If only\n    :meth:`~SetsWithGrading.ParentMethods.subset()` is implemented, the first\n    argument must be the grading for compatibility with\n    :meth:`~SetsWithGrading.ParentMethods.graded_component()`. Additionally\n    either the parent must implement\n    :meth:`~SetsWithGrading.ParentMethods.grading()` or its elements must\n    implement a method ``grade()``. See the example\n    :class:`sage.categories.examples.sets_with_grading.NonNegativeIntegers`.\n\n    Finally, if the graded set is enumerated (see\n    :class:`~sage.categories.enumerated_sets.EnumeratedSets`) then each graded\n    component should be enumerated. The contrary needs not be true.\n\n    EXAMPLES:\n\n    A typical example of a set with a grading is the set of non-negative\n    integers graded by themselves::\n\n        sage: N = SetsWithGrading().example(); N\n        Non negative integers\n        sage: N.category()\n        Category of facade sets with grading\n        sage: N.grading_set()\n        Non negative integers\n\n    The *grading function* is given by ``N.grading``::\n\n        sage: N.grading(4)\n        4\n\n    The graded component `S_i` is the set of all integer partitions of\n    `i`::\n\n        sage: N.graded_component(grade = 5)\n        {5}\n        sage: N.graded_component(grade = 42)\n        {42}\n\n    Here are some information about this category::\n\n        sage: SetsWithGrading()\n        Category of sets with grading\n        sage: SetsWithGrading().super_categories()\n        [Category of sets]\n        sage: SetsWithGrading().all_super_categories()\n        [Category of sets with grading,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    .. TODO::\n\n        - This should be moved to ``Sets().WithGrading()``.\n        - Should the grading set be a parameter for this category?\n        - Does the enumeration need to be compatible with the grading? Be\n          careful that the fact that graded components are allowed to be finite\n          or infinite make the answer complicated.\n\n    TESTS::\n\n        sage: C = SetsWithGrading()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of sets with a grading.\n\n    A *set with a grading* is a set `S` equipped with a\n    grading by some other set `I` (by default the set `\\NN` of the\n    non-negative integers):\n\n    .. MATH::\n\n         S = \\biguplus_{i\\in I} S_i\n\n    where the *graded components* `S_i` are (usually finite)\n    sets. The *grading* function maps each element `s` of\n    `S` to its *grade* `i`, so that `s\\in S_i`.\n\n    From implementation point of view, if the graded set is enumerated then\n    each graded component should be enumerated (there is a check in the method\n    :meth:`~SetsWithGrading.ParentMethods._test_graded_components`). The\n    contrary needs not be true.\n\n    To implement this category, a parent must either implement\n    :meth:`~SetsWithGrading.ParentMethods.graded_component()` or\n    :meth:`~SetsWithGrading.ParentMethods.subset()`. If only\n    :meth:`~SetsWithGrading.ParentMethods.subset()` is implemented, the first\n    argument must be the grading for compatibility with\n    :meth:`~SetsWithGrading.ParentMethods.graded_component()`. Additionally\n    either the parent must implement\n    :meth:`~SetsWithGrading.ParentMethods.grading()` or its elements must\n    implement a method ``grade()``. See the example\n    :class:`sage.categories.examples.sets_with_grading.NonNegativeIntegers`.\n\n    Finally, if the graded set is enumerated (see\n    :class:`~sage.categories.enumerated_sets.EnumeratedSets`) then each graded\n    component should be enumerated. The contrary needs not be true.\n\n    EXAMPLES:\n\n    A typical example of a set with a grading is the set of non-negative\n    integers graded by themselves::\n\n        sage: N = SetsWithGrading().example(); N\n        Non negative integers\n        sage: N.category()\n        Category of facade sets with grading\n        sage: N.grading_set()\n        Non negative integers\n\n    The *grading function* is given by ``N.grading``::\n\n        sage: N.grading(4)\n        4\n\n    The graded component `S_i` is the set of all integer partitions of\n    `i`::\n\n        sage: N.graded_component(grade = 5)\n        {5}\n        sage: N.graded_component(grade = 42)\n        {42}\n\n    Here are some information about this category::\n\n        sage: SetsWithGrading()\n        Category of sets with grading\n        sage: SetsWithGrading().super_categories()\n        [Category of sets]\n        sage: SetsWithGrading().all_super_categories()\n        [Category of sets with grading,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    .. TODO::\n\n        - This should be moved to ``Sets().WithGrading()``.\n        - Should the grading set be a parameter for this category?\n        - Does the enumeration need to be compatible with the grading? Be\n          careful that the fact that graded components are allowed to be finite\n          or infinite make the answer complicated.\n\n    TESTS::\n\n        sage: C = SetsWithGrading()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.sets_with_grading.SetsWithGrading",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_graded_components": {
                    "__doc__": "\n            Test that some graded components of ``self`` are parent with\n            initialized category and that the parent has a properly implemented\n            ``grading()`` method.\n\n            EXAMPLES::\n\n                sage: SetsWithGrading().example()._test_graded_components()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "generating_series": {
                    "__doc__": "\n            Default implementation for generating series.\n\n            OUTPUT:\n\n            A series, indexed by the grading set.\n\n            EXAMPLES::\n\n                sage: N = SetsWithGrading().example(); N\n                Non negative integers\n                sage: N.generating_series()\n                1/(-z + 1)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "graded_component": {
                    "__doc__": "\n            Return the graded component of ``self`` with grade ``grade``.\n\n            The default implementation just calls the method :meth:`subset()`\n            with the first argument ``grade``.\n\n            EXAMPLES::\n\n                sage: N = SetsWithGrading().example(); N\n                Non negative integers\n                sage: N.graded_component(3)\n                {3}\n            ",
                    "args": [
                        "self",
                        "grade"
                    ],
                    "argspec": [
                        [
                            "self",
                            "grade"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "grading": {
                    "__doc__": "\n            Return the grading of the element ``elt`` of ``self``.\n\n            This default implementation calls ``elt.grade()``.\n\n            EXAMPLES::\n\n                sage: N = SetsWithGrading().example(); N\n                Non negative integers\n                sage: N.grading(4)\n                4\n            ",
                    "args": [
                        "self",
                        "elt"
                    ],
                    "argspec": [
                        [
                            "self",
                            "elt"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "grading_set": {
                    "__doc__": "\n            Return the set ``self`` is graded by. By default, this is\n            the set of non-negative integers.\n\n            EXAMPLES::\n\n                sage: SetsWithGrading().example().grading_set()\n                Non negative integers\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "subset": {
                    "__doc__": "\n            Return the subset of ``self`` described by the given parameters.\n\n            .. SEEALSO::\n\n                -:meth:`graded_component()`\n\n            EXAMPLES::\n\n                sage: W = WeightedIntegerVectors([3,2,1]); W\n                Integer vectors weighted by [3, 2, 1]\n                sage: W.subset(4)\n                Integer vectors of 4 weighted by [3, 2, 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "options",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_grading.SetsWithGrading",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of sets with a grading.\n\n    A *set with a grading* is a set `S` equipped with a\n    grading by some other set `I` (by default the set `\\NN` of the\n    non-negative integers):\n\n    .. MATH::\n\n         S = \\biguplus_{i\\in I} S_i\n\n    where the *graded components* `S_i` are (usually finite)\n    sets. The *grading* function maps each element `s` of\n    `S` to its *grade* `i`, so that `s\\in S_i`.\n\n    From implementation point of view, if the graded set is enumerated then\n    each graded component should be enumerated (there is a check in the method\n    :meth:`~SetsWithGrading.ParentMethods._test_graded_components`). The\n    contrary needs not be true.\n\n    To implement this category, a parent must either implement\n    :meth:`~SetsWithGrading.ParentMethods.graded_component()` or\n    :meth:`~SetsWithGrading.ParentMethods.subset()`. If only\n    :meth:`~SetsWithGrading.ParentMethods.subset()` is implemented, the first\n    argument must be the grading for compatibility with\n    :meth:`~SetsWithGrading.ParentMethods.graded_component()`. Additionally\n    either the parent must implement\n    :meth:`~SetsWithGrading.ParentMethods.grading()` or its elements must\n    implement a method ``grade()``. See the example\n    :class:`sage.categories.examples.sets_with_grading.NonNegativeIntegers`.\n\n    Finally, if the graded set is enumerated (see\n    :class:`~sage.categories.enumerated_sets.EnumeratedSets`) then each graded\n    component should be enumerated. The contrary needs not be true.\n\n    EXAMPLES:\n\n    A typical example of a set with a grading is the set of non-negative\n    integers graded by themselves::\n\n        sage: N = SetsWithGrading().example(); N\n        Non negative integers\n        sage: N.category()\n        Category of facade sets with grading\n        sage: N.grading_set()\n        Non negative integers\n\n    The *grading function* is given by ``N.grading``::\n\n        sage: N.grading(4)\n        4\n\n    The graded component `S_i` is the set of all integer partitions of\n    `i`::\n\n        sage: N.graded_component(grade = 5)\n        {5}\n        sage: N.graded_component(grade = 42)\n        {42}\n\n    Here are some information about this category::\n\n        sage: SetsWithGrading()\n        Category of sets with grading\n        sage: SetsWithGrading().super_categories()\n        [Category of sets]\n        sage: SetsWithGrading().all_super_categories()\n        [Category of sets with grading,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    .. TODO::\n\n        - This should be moved to ``Sets().WithGrading()``.\n        - Should the grading set be a parameter for this category?\n        - Does the enumeration need to be compatible with the grading? Be\n          careful that the fact that graded components are allowed to be finite\n          or infinite make the answer complicated.\n\n    TESTS::\n\n        sage: C = SetsWithGrading()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite posets i.e. finite sets with a partial\n    order structure.\n\n    EXAMPLES::\n\n        sage: FinitePosets()\n        Category of finite posets\n        sage: FinitePosets().super_categories()\n        [Category of posets, Category of finite sets]\n        sage: FinitePosets().example()\n        NotImplemented\n\n    .. seealso:: :class:`~sage.categories.posets.Posets`, :func:`Poset`\n\n    TESTS::\n\n        sage: C = FinitePosets()\n        sage: C is Posets().Finite()\n        True\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": "\n    The category of finite posets i.e. finite sets with a partial\n    order structure.\n\n    EXAMPLES::\n\n        sage: FinitePosets()\n        Category of finite posets\n        sage: FinitePosets().super_categories()\n        [Category of posets, Category of finite sets]\n        sage: FinitePosets().example()\n        NotImplemented\n\n    .. seealso:: :class:`~sage.categories.posets.Posets`, :func:`Poset`\n\n    TESTS::\n\n        sage: C = FinitePosets()\n        sage: C is Posets().Finite()\n        True\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.posets.Posets",
            "sage.categories.finite_sets.FiniteSets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite posets i.e. finite sets with a partial\n    order structure.\n\n    EXAMPLES::\n\n        sage: FinitePosets()\n        Category of finite posets\n        sage: FinitePosets().super_categories()\n        [Category of posets, Category of finite sets]\n        sage: FinitePosets().example()\n        NotImplemented\n\n    .. seealso:: :class:`~sage.categories.posets.Posets`, :func:`Poset`\n\n    TESTS::\n\n        sage: C = FinitePosets()\n        sage: C is Posets().Finite()\n        True\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_posets.FinitePosets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "antichains": {
                    "__doc__": "\n            Return all antichains of ``self``.\n\n            EXAMPLES::\n\n                sage: A = Posets.PentagonPoset().antichains(); A\n                Set of antichains of Finite lattice containing 5 elements\n                sage: list(A)\n                [[], [0], [1], [1, 2], [1, 3], [2], [3], [4]]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "birational_free_labelling": {
                    "__doc__": "\n            Return the birational free labelling of ``self``.\n\n            Let us hold back defining this, and introduce birational\n            toggles and birational rowmotion first. These notions have\n            been introduced in [EP13]_ as generalizations of the notions\n            of toggles (:meth:`order_ideal_toggle`) and :meth:`rowmotion\n            <rowmotion>` on order ideals of a finite poset. They\n            have been studied further in [GR13]_.\n\n            Let `\\mathbf{K}` be a field, and `P` be a finite poset. Let\n            `\\widehat{P}` denote the poset obtained from `P` by adding a\n            new element `1` which is greater than all existing elements\n            of `P`, and a new element `0` which is smaller than all\n            existing elements of `P` and `1`. Now, a `\\mathbf{K}`-*labelling\n            of* `P` will mean any function from `\\widehat{P}` to `\\mathbf{K}`.\n            The image of an element `v` of `\\widehat{P}` under this labelling\n            will be called the *label* of this labelling at `v`. The set\n            of all `\\mathbf{K}`-labellings of `P` is clearly\n            `\\mathbf{K}^{\\widehat{P}}`.\n\n            For any `v \\in P`, we now define a rational map\n            `T_v : \\mathbf{K}^{\\widehat{P}} \\dashrightarrow\n            \\mathbf{K}^{\\widehat{P}}` as follows: For every `f \\in\n            \\mathbf{K}^{\\widehat{P}}`, the image `T_v f` should send every\n            element `u \\in \\widehat{P}` distinct from `v` to `f(u)` (so the\n            labels at all `u \\neq v` don't change), while `v` is sent to\n\n            .. MATH::\n\n                \\frac{1}{f(v)} \\cdot\n                \\frac{\\sum_{u \\lessdot v} f(u)}\n                {\\sum_{u \\gtrdot v} \\frac{1}{f(u)}}\n\n            (both sums are over all `u \\in \\widehat{P}` satisfying the\n            respectively given conditions). Here, `\\lessdot` and `\\gtrdot`\n            mean (respectively) \"covered by\" and \"covers\", interpreted with\n            respect to the poset `\\widehat{P}`. This rational map `T_v`\n            is an involution and is called the *(birational)* `v`-*toggle*; see\n            :meth:`birational_toggle` for its implementation.\n\n            Now, *birational rowmotion* is defined as the composition\n            `T_{v_1} \\circ T_{v_2} \\circ \\cdots \\circ T_{v_n}`, where\n            `(v_1, v_2, \\ldots, v_n)` is a linear extension of `P`\n            (written as a linear ordering of the elements of `P`). This\n            is a rational map\n            `\\mathbf{K}^{\\widehat{P}} \\dashrightarrow \\mathbf{K}^{\\widehat{P}}`\n            which does not depend on the choice of the linear extension;\n            it is denoted by `R`. See :meth:`birational_rowmotion` for\n            its implementation.\n\n            The definitions of birational toggles and birational\n            rowmotion extend to the case of `\\mathbf{K}` being any semifield\n            rather than necessarily a field (although it becomes less\n            clear what constitutes a rational map in this generality).\n            The most useful case is that of the :class:`tropical semiring\n            <sage.rings.semirings.tropical_semiring.TropicalSemiring>`,\n            in which case birational rowmotion relates to classical\n            constructions such as promotion of rectangular semistandard\n            Young tableaux (page 5 of [EP13b]_ and future work, via the\n            related notion of birational *promotion*) and rowmotion on\n            order ideals of the poset ([EP13]_).\n\n            The *birational free labelling* is a special labelling\n            defined for every finite poset `P` and every linear extension\n            `(v_1, v_2, \\ldots, v_n)` of `P`. It is given by sending\n            every element `v_i` in `P` to `x_i`, sending the element `0`\n            of `\\widehat{P}` to `a`, and sending the element `1` of\n            `\\widehat{P}` to `b`, where the ground field `\\mathbf{K}` is the\n            field of rational functions in `n+2` indeterminates\n            `a, x_1, x_2, \\ldots, x_n, b` over `\\mathbb Q`.\n\n            In Sage, a labelling `f` of a poset `P` is encoded as a\n            `4`-tuple `(\\mathbf{K}, d, u, v)`, where `\\mathbf{K}` is the\n            ground field of the labelling (i. e., its target), `d` is the\n            dictionary containing the values of `f` at the elements of\n            `P` (the keys being the respective elements of `P`), `u`\n            is the label of `f` at `0`, and `v` is the label of `f` at\n            `1`.\n\n            .. WARNING::\n\n                The dictionary `d` is labelled by the elements of `P`.\n                If `P` is a poset with ``facade`` option set to\n                ``False``, these might not be what they seem to be!\n                (For instance, if\n                ``P == Poset({1: [2, 3]}, facade=False)``, then the\n                value of `d` at `1` has to be accessed by ``d[P(1)]``, not\n                by ``d[1]``.)\n\n            .. WARNING::\n\n                Dictionaries are mutable. They do compare correctly,\n                but are not hashable and need to be cloned to avoid\n                spooky action at a distance. Be careful!\n\n            INPUT:\n\n            - ``linear_extension`` -- (default: the default linear\n              extension of ``self``) a linear extension of ``self``\n              (as a linear extension or as a list), or more generally\n              a list of all elements of all elements of ``self`` each\n              occurring exactly once\n\n            - ``prefix`` -- (default: ``'x'``) the prefix to name\n              the indeterminates corresponding to the elements of\n              ``self`` in the labelling (so, setting it to\n              ``'frog'`` will result in these indeterminates being\n              called ``frog1, frog2, ..., frogn`` rather than\n              ``x1, x2, ..., xn``).\n\n            - ``base_field`` -- (default: ``QQ``) the base field to\n              be used instead of `\\QQ` to define the rational\n              function field over; this is not going to be the base\n              field of the labelling, because the latter will have\n              indeterminates adjoined!\n\n            - ``reduced`` -- (default: ``False``) if set to\n              ``True``, the result will be the *reduced* birational\n              free labelling, which differs from the regular one by\n              having `0` and `1` both sent to `1` instead of `a` and\n              `b` (the indeterminates `a` and `b` then also won't\n              appear in the ground field)\n\n            - ``addvars`` -- (default: ``''``) a string containing\n              names of extra variables to be adjoined to the ground\n              field (these don't have an effect on the labels)\n\n            OUTPUT:\n\n            The birational free labelling of the poset ``self`` and the\n            linear extension ``linear_extension``. Or, if ``reduced``\n            is set to ``True``, the reduced birational free labelling.\n\n            REFERENCES:\n\n            .. [EP13] David Einstein, James Propp.\n               *Combinatorial, piecewise-linear, and birational homomesy\n               for products of two chains*.\n               :arxiv:`1310.5294v1`.\n\n            .. [EP13b] David Einstein, James Propp.\n               *Piecewise-linear and birational toggling*.\n               Extended abstract for FPSAC 2014.\n               http://faculty.uml.edu/jpropp/fpsac14.pdf\n\n            .. [GR13] Darij Grinberg, Tom Roby.\n               *Iterative properties of birational rowmotion I*.\n               http://web.mit.edu/~darij/www/algebra/skeletal.pdf\n\n            EXAMPLES:\n\n            We construct the birational free labelling on a simple\n            poset::\n\n                sage: P = Poset({1: [2, 3]})\n                sage: l = P.birational_free_labelling(); l\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: sorted(l[1].items())\n                [(1, x1), (2, x2), (3, x3)]\n\n                sage: l = P.birational_free_labelling(linear_extension=[1, 3, 2]); l\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: sorted(l[1].items())\n                [(1, x1), (2, x3), (3, x2)]\n\n                sage: l = P.birational_free_labelling(linear_extension=[1, 3, 2], reduced=True, addvars=\"spam, eggs\"); l\n                (Fraction Field of Multivariate Polynomial Ring in x1, x2, x3, spam, eggs over Rational Field,\n                 {...},\n                 1,\n                 1)\n                sage: sorted(l[1].items())\n                [(1, x1), (2, x3), (3, x2)]\n\n                sage: l = P.birational_free_labelling(linear_extension=[1, 3, 2], prefix=\"wut\", reduced=True, addvars=\"spam, eggs\"); l\n                (Fraction Field of Multivariate Polynomial Ring in wut1, wut2, wut3, spam, eggs over Rational Field,\n                 {...},\n                 1,\n                 1)\n                sage: sorted(l[1].items())\n                [(1, wut1), (2, wut3), (3, wut2)]\n\n                sage: l = P.birational_free_labelling(linear_extension=[1, 3, 2], reduced=False, addvars=\"spam, eggs\"); l\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b, spam, eggs over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: sorted(l[1].items())\n                [(1, x1), (2, x3), (3, x2)]\n                sage: l[1][2]\n                x3\n\n            Illustrating the warning about facade::\n\n                sage: P = Poset({1: [2, 3]}, facade=False)\n                sage: l = P.birational_free_labelling(linear_extension=[1, 3, 2], reduced=False, addvars=\"spam, eggs\"); l\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b, spam, eggs over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: l[1][2]\n                Traceback (most recent call last):\n                ...\n                KeyError: 2\n                sage: l[1][P(2)]\n                x3\n\n            Another poset::\n\n                sage: P = Posets.SSTPoset([2,1])\n                sage: lext = sorted(P)\n                sage: l = P.birational_free_labelling(linear_extension=lext, addvars=\"ohai\")\n                sage: l\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, x5, x6, x7, x8, b, ohai over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: sorted(l[1].items())\n                [([[1, 1], [2]], x1), ([[1, 1], [3]], x2), ([[1, 2], [2]], x3), ([[1, 2], [3]], x4),\n                 ([[1, 3], [2]], x5), ([[1, 3], [3]], x6), ([[2, 2], [3]], x7), ([[2, 3], [3]], x8)]\n\n            See :meth:`birational_rowmotion`, :meth:`birational_toggle` and\n            :meth:`birational_toggles` for more substantial examples of what\n            one can do with the birational free labelling.\n\n            TESTS:\n\n            The ``linear_extension`` keyword does not have to be given an\n            actual linear extension::\n\n                sage: P = Posets.ChainPoset(2).product(Posets.ChainPoset(3))\n                sage: P\n                Finite lattice containing 6 elements\n                sage: lex = [(1,0),(0,0),(1,1),(0,1),(1,2),(0,2)]\n                sage: l = P.birational_free_labelling(linear_extension=lex,\n                ....:                                 prefix=\"u\", reduced=True)\n                sage: l\n                (Fraction Field of Multivariate Polynomial Ring in u1, u2, u3, u4, u5, u6 over Rational Field,\n                 {...},\n                 1,\n                 1)\n                sage: sorted(l[1].items())\n                [((0, 0), u2),\n                 ((0, 1), u4),\n                 ((0, 2), u6),\n                 ((1, 0), u1),\n                 ((1, 1), u3),\n                 ((1, 2), u5)]\n\n            For comparison, the standard linear extension::\n\n                sage: l = P.birational_free_labelling(prefix=\"u\", reduced=True); l\n                (Fraction Field of Multivariate Polynomial Ring in u1, u2, u3, u4, u5, u6 over Rational Field,\n                 {...},\n                 1,\n                 1)\n                sage: sorted(l[1].items())\n                [((0, 0), u1),\n                 ((0, 1), u2),\n                 ((0, 2), u3),\n                 ((1, 0), u4),\n                 ((1, 1), u5),\n                 ((1, 2), u6)]\n\n            If you want your linear extension to be tested for being a\n            linear extension, just call the ``linear_extension`` method\n            on the poset::\n\n                sage: lex = [(0,0),(0,1),(1,0),(1,1),(0,2),(1,2)]\n                sage: l = P.birational_free_labelling(linear_extension=P.linear_extension(lex),\n                ....:                                 prefix=\"u\", reduced=True)\n                sage: l\n                (Fraction Field of Multivariate Polynomial Ring in u1, u2, u3, u4, u5, u6 over Rational Field,\n                 {...},\n                 1,\n                 1)\n                sage: sorted(l[1].items())\n                [((0, 0), u1),\n                 ((0, 1), u2),\n                 ((0, 2), u5),\n                 ((1, 0), u3),\n                 ((1, 1), u4),\n                 ((1, 2), u6)]\n\n            Nonstandard base field::\n\n                sage: P = Poset({1: [3], 2: [3,4]})\n                sage: lex = [1, 2, 4, 3]\n                sage: l = P.birational_free_labelling(linear_extension=lex,\n                ....:                                 prefix=\"aaa\",\n                ....:                                 base_field=Zmod(13))\n                sage: l\n                (Fraction Field of Multivariate Polynomial Ring in a, aaa1, aaa2, aaa3, aaa4, b over Ring of integers modulo 13,\n                 {...},\n                 a,\n                 b)\n                sage: l[1][4]\n                aaa3\n\n            The empty poset::\n\n                sage: P = Poset({})\n                sage: P.birational_free_labelling(reduced=False, addvars=\"spam, eggs\")\n                (Fraction Field of Multivariate Polynomial Ring in a, b, spam, eggs over Rational Field,\n                 {},\n                 a,\n                 b)\n                sage: P.birational_free_labelling(reduced=True, addvars=\"spam, eggs\")\n                (Fraction Field of Multivariate Polynomial Ring in spam, eggs over Rational Field,\n                 {},\n                 1,\n                 1)\n                sage: P.birational_free_labelling(reduced=True)\n                (Multivariate Polynomial Ring in no variables over Rational Field,\n                 {},\n                 1,\n                 1)\n                sage: P.birational_free_labelling(prefix=\"zzz\")\n                (Fraction Field of Multivariate Polynomial Ring in a, b over Rational Field,\n                 {},\n                 a,\n                 b)\n            ",
                    "args": [
                        "self",
                        "linear_extension",
                        "prefix",
                        "base_field",
                        "reduced",
                        "addvars"
                    ],
                    "argspec": [
                        [
                            "self",
                            "linear_extension",
                            "prefix",
                            "base_field",
                            "reduced",
                            "addvars"
                        ],
                        null,
                        null,
                        [
                            null,
                            "x",
                            null,
                            false,
                            null
                        ]
                    ]
                },
                "birational_rowmotion": {
                    "__doc__": "\n            Return the result of applying birational rowmotion to the\n            `\\mathbf{K}`-labelling ``labelling`` of the poset ``self``.\n\n            See the documentation of :meth:`birational_free_labelling`\n            for a definition of birational rowmotion and\n            `\\mathbf{K}`-labellings and for an explanation of how\n            `\\mathbf{K}`-labellings are to be encoded to be understood\n            by Sage. This implementation allows `\\mathbf{K}` to be a\n            semifield, not just a field. Birational rowmotion is only a\n            rational map, so an exception (most likely, ``ZeroDivisionError``)\n            will be thrown if the denominator is zero.\n\n            INPUT:\n\n            - ``labelling`` -- a `\\mathbf{K}`-labelling of ``self`` in the\n              sense as defined in the documentation of\n              :meth:`birational_free_labelling`\n\n            OUTPUT:\n\n            The image of the `\\mathbf{K}`-labelling `f` under birational\n            rowmotion.\n\n            EXAMPLES::\n\n                sage: P = Poset({1: [2, 3], 2: [4], 3: [4]})\n                sage: lex = [1, 2, 3, 4]\n                sage: t = P.birational_free_labelling(linear_extension=lex); t\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: sorted(t[1].items())\n                [(1, x1), (2, x2), (3, x3), (4, x4)]\n                sage: t = P.birational_rowmotion(t); t\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: sorted(t[1].items())\n                [(1, a*b/x4), (2, (x1*x2*b + x1*x3*b)/(x2*x4)),\n                 (3, (x1*x2*b + x1*x3*b)/(x3*x4)), (4, (x2*b + x3*b)/x4)]\n\n            A result of [GR13]_ states that applying birational rowmotion\n            `n+m` times to a `\\mathbf{K}`-labelling `f` of the poset\n            `[n] \\times [m]` gives back `f`. Let us check this::\n\n                sage: def test_rectangle_periodicity(n, m, k):\n                ....:     P = Posets.ChainPoset(n).product(Posets.ChainPoset(m))\n                ....:     t0 = P.birational_free_labelling(P)\n                ....:     t = t0\n                ....:     for i in range(k):\n                ....:         t = P.birational_rowmotion(t)\n                ....:     return t == t0\n                sage: test_rectangle_periodicity(2, 2, 4)\n                True\n                sage: test_rectangle_periodicity(2, 2, 2)\n                False\n                sage: test_rectangle_periodicity(2, 3, 5)  # long time\n                True\n\n            While computations with the birational free labelling quickly\n            run out of memory due to the complexity of the rational\n            functions involved, it is computationally cheap to check\n            properties of birational rowmotion on examples in the tropical\n            semiring::\n\n                sage: def test_rectangle_periodicity_tropical(n, m, k):\n                ....:     P = Posets.ChainPoset(n).product(Posets.ChainPoset(m))\n                ....:     TT = TropicalSemiring(ZZ)\n                ....:     t0 = (TT, {v: TT(floor(random()*100)) for v in P}, TT(0), TT(124))\n                ....:     t = t0\n                ....:     for i in range(k):\n                ....:         t = P.birational_rowmotion(t)\n                ....:     return t == t0\n                sage: test_rectangle_periodicity_tropical(7, 6, 13)\n                True\n\n            Tropicalization is also what relates birational rowmotion to\n            classical rowmotion on order ideals. In fact, if `T` denotes\n            the :class:`tropical semiring\n            <sage.rings.semirings.tropical_semiring.TropicalSemiring>` of\n            `\\ZZ` and `P` is a finite poset, then we can define an embedding\n            `\\phi` from the set `J(P)` of all order ideals of `P` into the\n            set `T^{\\widehat{P}}` of all `T`-labellings of `P` by sending\n            every `I \\in J(P)` to the indicator function of `I` extended by\n            the value `1` at the element `0` and the value `0` at the\n            element `1`. This map `\\phi` has the property that\n            `R \\circ \\phi = \\phi \\circ r`, where `R` denotes birational\n            rowmotion, and `r` denotes :meth:`classical rowmotion <rowmotion>`\n            on `J(P)`. An example::\n\n                sage: P = Posets.IntegerPartitions(5)\n                sage: TT = TropicalSemiring(ZZ)\n                sage: def indicator_labelling(I):\n                ....:     # send order ideal `I` to a `T`-labelling of `P`.\n                ....:     dct = {v: TT(v in I) for v in P}\n                ....:     return (TT, dct, TT(1), TT(0))\n                sage: all(indicator_labelling(P.rowmotion(I))\n                ....:     == P.birational_rowmotion(indicator_labelling(I))\n                ....:     for I in P.order_ideals_lattice(facade=True))\n                True\n\n            TESTS:\n\n            Facade set to false works::\n\n                sage: P = Poset({1: [2, 3], 2: [4], 3: [4]}, facade=False)\n                sage: lex = [1, 2, 3, 4]\n                sage: t = P.birational_free_labelling(linear_extension=lex); t\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: t = P.birational_rowmotion(t); t\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: t[1][P(2)]\n                (x1*x2*b + x1*x3*b)/(x2*x4)\n                sage: t = P.birational_rowmotion(t)\n                sage: t[1][P(2)]\n                a*b/x3\n            ",
                    "args": [
                        "self",
                        "labelling"
                    ],
                    "argspec": [
                        [
                            "self",
                            "labelling"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "birational_toggle": {
                    "__doc__": "\n            Return the result of applying the birational `v`-toggle `T_v`\n            to the `\\mathbf{K}`-labelling ``labelling`` of the poset ``self``.\n\n            See the documentation of :meth:`birational_free_labelling`\n            for a definition of this toggle and of `\\mathbf{K}`-labellings as\n            well as an explanation of how `\\mathbf{K}`-labellings are to be\n            encoded to be understood by Sage. This implementation allows\n            `\\mathbf{K}` to be a semifield, not just a field. The birational\n            `v`-toggle is only a rational map, so an exception (most\n            likely, ``ZeroDivisionError``) will be thrown if the\n            denominator is zero.\n\n            INPUT:\n\n            - ``v`` -- an element of ``self`` (must have ``self`` as\n              parent if ``self`` is a ``facade=False`` poset)\n\n            - ``labelling`` -- a `\\mathbf{K}`-labelling of ``self`` in the\n              sense as defined in the documentation of\n              :meth:`birational_free_labelling`\n\n            OUTPUT:\n\n            The `\\mathbf{K}`-labelling `T_v f` of ``self``, where `f` is\n            ``labelling``.\n\n            EXAMPLES:\n\n            Let us start with the birational free labelling of the\n            \"V\"-poset (the three-element poset with Hasse diagram looking\n            like a \"V\")::\n\n                sage: V = Poset({1: [2, 3]})\n                sage: s = V.birational_free_labelling(); s\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: sorted(s[1].items())\n                [(1, x1), (2, x2), (3, x3)]\n\n            The image of `s` under the `1`-toggle `T_1` is::\n\n                sage: s1 = V.birational_toggle(1, s); s1\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: sorted(s1[1].items())\n                [(1, a*x2*x3/(x1*x2 + x1*x3)), (2, x2), (3, x3)]\n\n            Now let us apply the `2`-toggle `T_2` (to the old ``s``)::\n\n                sage: s2 = V.birational_toggle(2, s); s2\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: sorted(s2[1].items())\n                [(1, x1), (2, x1*b/x2), (3, x3)]\n\n            On the other hand, we can also apply `T_2` to the image of `s`\n            under `T_1`::\n\n                sage: s12 = V.birational_toggle(2, s1); s12\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: sorted(s12[1].items())\n                [(1, a*x2*x3/(x1*x2 + x1*x3)), (2, a*x3*b/(x1*x2 + x1*x3)), (3, x3)]\n\n            Each toggle is an involution::\n\n                sage: all( V.birational_toggle(i, V.birational_toggle(i, s)) == s\n                ....:      for i in V )\n                True\n\n            We can also start with a less generic labelling::\n\n                sage: t = (QQ, {1: 3, 2: 6, 3: 7}, 2, 10)\n                sage: t1 = V.birational_toggle(1, t); t1\n                (Rational Field, {...}, 2, 10)\n                sage: sorted(t1[1].items())\n                [(1, 28/13), (2, 6), (3, 7)]\n                sage: t13 = V.birational_toggle(3, t1); t13\n                (Rational Field, {...}, 2, 10)\n                sage: sorted(t13[1].items())\n                [(1, 28/13), (2, 6), (3, 40/13)]\n\n            However, labellings have to be sufficiently generic, lest\n            denominators vanish::\n\n                sage: t = (QQ, {1: 3, 2: 5, 3: -5}, 1, 15)\n                sage: t1 = V.birational_toggle(1, t)\n                Traceback (most recent call last):\n                ...\n                ZeroDivisionError: rational division by zero\n\n            We don't get into zero-division issues in the tropical\n            semiring (unless the zero of the tropical semiring appears\n            in the labelling)::\n\n                sage: TT = TropicalSemiring(QQ)\n                sage: t = (TT, {1: TT(2), 2: TT(4), 3: TT(1)}, TT(6), TT(0))\n                sage: t1 = V.birational_toggle(1, t); t1\n                (Tropical semiring over Rational Field, {...}, 6, 0)\n                sage: sorted(t1[1].items())\n                [(1, 8), (2, 4), (3, 1)]\n                sage: t12 = V.birational_toggle(2, t1); t12\n                (Tropical semiring over Rational Field, {...}, 6, 0)\n                sage: sorted(t12[1].items())\n                [(1, 8), (2, 4), (3, 1)]\n                sage: t123 = V.birational_toggle(3, t12); t123\n                (Tropical semiring over Rational Field, {...}, 6, 0)\n                sage: sorted(t123[1].items())\n                [(1, 8), (2, 4), (3, 7)]\n\n            We turn to more interesting posets. Here is the `6`-element\n            poset arising from the weak order on `S_3`::\n\n                sage: P = Posets.SymmetricGroupWeakOrderPoset(3)\n                sage: sorted(list(P))\n                ['123', '132', '213', '231', '312', '321']\n                sage: t = (TT, {'123': TT(4), '132': TT(2), '213': TT(3), '231': TT(1), '321': TT(1), '312': TT(2)}, TT(7), TT(1))\n                sage: t1 = P.birational_toggle('123', t); t1\n                (Tropical semiring over Rational Field, {...}, 7, 1)\n                sage: sorted(t1[1].items())\n                [('123', 6), ('132', 2), ('213', 3), ('231', 1), ('312', 2), ('321', 1)]\n                sage: t13 = P.birational_toggle('213', t1); t13\n                (Tropical semiring over Rational Field, {...}, 7, 1)\n                sage: sorted(t13[1].items())\n                [('123', 6), ('132', 2), ('213', 4), ('231', 1), ('312', 2), ('321', 1)]\n\n            Let us verify on this example some basic properties of\n            toggles. First of all, again let us check that `T_v` is an\n            involution for every `v`::\n\n                sage: all( P.birational_toggle(v, P.birational_toggle(v, t)) == t\n                ....:      for v in P )\n                True\n\n            Furthermore, two toggles `T_v` and `T_w` commute unless\n            one of `v` or `w` covers the other::\n\n                sage: all( P.covers(v, w) or P.covers(w, v)\n                ....:      or P.birational_toggle(v, P.birational_toggle(w, t))\n                ....:         == P.birational_toggle(w, P.birational_toggle(v, t))\n                ....:      for v in P for w in P )\n                True\n\n            TESTS:\n\n            Setting ``facade`` to ``False`` does not break\n            ``birational_toggle``::\n\n                sage: P = Poset({'x': ['y', 'w'], 'y': ['z'], 'w': ['z']}, facade=False)\n                sage: lex = ['x', 'y', 'w', 'z']\n                sage: t = P.birational_free_labelling(linear_extension=lex)\n                sage: all( P.birational_toggle(v, P.birational_toggle(v, t)) == t\n                ....:      for v in P )\n                True\n                sage: t4 = P.birational_toggle(P('z'), t); t4\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: t4[1][P('x')]\n                x1\n                sage: t4[1][P('y')]\n                x2\n                sage: t4[1][P('w')]\n                x3\n                sage: t4[1][P('z')]\n                (x2*b + x3*b)/x4\n\n            The one-element poset::\n\n                sage: P = Poset({8: []})\n                sage: t = P.birational_free_labelling()\n                sage: t8 = P.birational_toggle(8, t); t8\n                (Fraction Field of Multivariate Polynomial Ring in a, x1, b over Rational Field,\n                 {...},\n                 a,\n                 b)\n                sage: t8[1][8]\n                a*b/x1\n            ",
                    "args": [
                        "self",
                        "v",
                        "labelling"
                    ],
                    "argspec": [
                        [
                            "self",
                            "v",
                            "labelling"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "birational_toggles": {
                    "__doc__": "\n            Return the result of applying a sequence of birational\n            toggles (specified by ``vs``) to the `\\mathbf{K}`-labelling\n            ``labelling`` of the poset ``self``.\n\n            See the documentation of :meth:`birational_free_labelling`\n            for a definition of birational toggles and `\\mathbf{K}`-labellings\n            and for an explanation of how `\\mathbf{K}`-labellings are to be\n            encoded to be understood by Sage. This implementation allows\n            `\\mathbf{K}` to be a semifield, not just a field. The birational\n            `v`-toggle is only a rational map, so an exception (most\n            likely, ``ZeroDivisionError``) will be thrown if the\n            denominator is zero.\n\n            INPUT:\n\n            - ``vs`` -- an iterable comprising elements of ``self``\n              (which must have ``self`` as parent if ``self`` is a\n              ``facade=False`` poset)\n\n            - ``labelling`` -- a `\\mathbf{K}`-labelling of ``self`` in the\n              sense as defined in the documentation of\n              :meth:`birational_free_labelling`\n\n            OUTPUT:\n\n            The `\\mathbf{K}`-labelling `T_{v_n} T_{v_{n-1}} \\cdots T_{v_1} f`\n            of ``self``, where `f` is ``labelling`` and\n            `(v_1, v_2, \\ldots, v_n)` is ``vs`` (written as list).\n\n            EXAMPLES::\n\n                sage: P = Posets.SymmetricGroupBruhatOrderPoset(3)\n                sage: sorted(list(P))\n                ['123', '132', '213', '231', '312', '321']\n                sage: TT = TropicalSemiring(ZZ)\n                sage: t = (TT, {'123': TT(4), '132': TT(2), '213': TT(3), '231': TT(1), '321': TT(1), '312': TT(2)}, TT(7), TT(1))\n                sage: tA = P.birational_toggles(['123', '231', '312'], t); tA\n                (Tropical semiring over Integer Ring, {...}, 7, 1)\n                sage: sorted(tA[1].items())\n                [('123', 6), ('132', 2), ('213', 3), ('231', 2), ('312', 1), ('321', 1)]\n                sage: tAB = P.birational_toggles(['132', '213', '321'], tA); tAB\n                (Tropical semiring over Integer Ring, {...}, 7, 1)\n                sage: sorted(tAB[1].items())\n                [('123', 6), ('132', 6), ('213', 5), ('231', 2), ('312', 1), ('321', 1)]\n\n                sage: P = Poset({1: [2, 3], 2: [4], 3: [4]})\n                sage: Qx = PolynomialRing(QQ, 'x').fraction_field()\n                sage: x = Qx.gen()\n                sage: t = (Qx, {1: 1, 2: x, 3: (x+1)/x, 4: x^2}, 1, 1)\n                sage: t1 = P.birational_toggles((i for i in range(1, 5)), t); t1\n                (Fraction Field of Univariate Polynomial Ring in x over Rational Field,\n                 {...},\n                 1,\n                 1)\n                sage: sorted(t1[1].items())\n                [(1, (x^2 + x)/(x^2 + x + 1)), (2, (x^3 + x^2)/(x^2 + x + 1)), (3, x^4/(x^2 + x + 1)), (4, 1)]\n                sage: t2 = P.birational_toggles(reversed(range(1, 5)), t)\n                sage: sorted(t2[1].items())\n                [(1, 1/x^2), (2, (x^2 + x + 1)/x^4), (3, (x^2 + x + 1)/(x^3 + x^2)), (4, (x^2 + x + 1)/x^3)]\n\n            Facade set to ``False`` works::\n\n                sage: P = Poset({'x': ['y', 'w'], 'y': ['z'], 'w': ['z']}, facade=False)\n                sage: lex = ['x', 'y', 'w', 'z']\n                sage: t = P.birational_free_labelling(linear_extension=lex)\n                sage: sorted(P.birational_toggles([P('x'), P('y')], t)[1].items())\n                [(x, a*x2*x3/(x1*x2 + x1*x3)), (y, a*x3*x4/(x1*x2 + x1*x3)), (w, x3), (z, x4)]\n            ",
                    "args": [
                        "self",
                        "vs",
                        "labelling"
                    ],
                    "argspec": [
                        [
                            "self",
                            "vs",
                            "labelling"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "directed_subsets": {
                    "__doc__": "\n            Return the order filters (resp. order ideals) of ``self``, as lists.\n\n            If ``direction`` is 'up', returns the order filters (upper sets).\n\n            If ``direction`` is 'down', returns the order ideals (lower sets).\n\n            INPUT:\n\n            - ``direction`` -- 'up' or 'down'\n\n            EXAMPLES::\n\n                sage: P = Poset((divisors(12), attrcall(\"divides\")), facade=True)\n                sage: A = P.directed_subsets('up')\n                sage: sorted(list(A))\n                [[], [1, 2, 4, 3, 6, 12], [2, 4, 3, 6, 12], [2, 4, 6, 12], [3, 6, 12], [4, 3, 6, 12], [4, 6, 12], [4, 12], [6, 12], [12]]\n\n            TESTS::\n\n                sage: list(Poset().directed_subsets('up'))\n                [[]]\n            ",
                    "args": [
                        "self",
                        "direction"
                    ],
                    "argspec": [
                        [
                            "self",
                            "direction"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_lattice": {
                    "__doc__": "\n            Returns whether this poset is both a meet and a join semilattice.\n\n            EXAMPLES::\n\n                sage: P = Poset([[1,3,2],[4],[4,5,6],[6],[7],[7],[7],[]])\n                sage: P.is_lattice()\n                True\n\n                sage: P = Poset([[1,2],[3],[3],[]])\n                sage: P.is_lattice()\n                True\n\n                sage: P = Poset({0:[2,3],1:[2,3]})\n                sage: P.is_lattice()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_poset_isomorphism": {
                    "__doc__": "\n            Return whether `f` is an isomorphism of posets from\n            ``self`` to ``codomain``.\n\n            INPUT:\n\n            - ``f`` -- a function from ``self`` to ``codomain``\n            - ``codomain`` -- a poset\n\n            EXAMPLES:\n\n            We build the poset `D` of divisors of 30, and check that\n            it is isomorphic to the boolean lattice `B` of the subsets\n            of `\\{2,3,5\\}` ordered by inclusion, via the reverse\n            function `f: B \\to D, b \\mapsto \\prod_{x\\in b} x`::\n\n                sage: D = Poset((divisors(30), attrcall(\"divides\")))\n                sage: B = Poset(([frozenset(s) for s in Subsets([2,3,5])], attrcall(\"issubset\")))\n                sage: def f(b): return D(prod(b))\n                sage: B.is_poset_isomorphism(f, D)\n                True\n\n            On the other hand, `f` is not an isomorphism to the chain\n            of divisors of 30, ordered by usual comparison::\n\n                sage: P = Poset((divisors(30), operator.le))\n                sage: def f(b): return P(prod(b))\n                sage: B.is_poset_isomorphism(f, P)\n                False\n\n            A non surjective case::\n\n                sage: B = Poset(([frozenset(s) for s in Subsets([2,3])], attrcall(\"issubset\")))\n                sage: def f(b): return D(prod(b))\n                sage: B.is_poset_isomorphism(f, D)\n                False\n\n            A non injective case::\n\n                sage: B = Poset(([frozenset(s) for s in Subsets([2,3,5,6])], attrcall(\"issubset\")))\n                sage: def f(b): return D(gcd(prod(b), 30))\n                sage: B.is_poset_isomorphism(f, D)\n                False\n\n            .. note:: since ``D`` and ``B`` are not facade posets, ``f`` is\n               responsible for the conversions between integers and subsets to\n               elements of ``D`` and ``B`` and back.\n\n            .. seealso:: :meth:`FiniteLatticePosets.ParentMethods.is_lattice_morphism`\n            ",
                    "args": [
                        "self",
                        "f",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "codomain"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_poset_morphism": {
                    "__doc__": "\n            Return whether `f` is a morphism of posets from ``self``\n            to ``codomain``, that is\n\n            .. MATH::\n\n                x\\leq y \\Longrightarrow f(x) \\leq f(y)\n\n            for all `x` and `y` in ``self``.\n\n            INPUT:\n\n            - ``f`` -- a function from ``self`` to ``codomain``\n            - ``codomain`` -- a poset\n\n            EXAMPLES:\n\n            We build the boolean lattice of the subsets of\n            `\\{2,3,5,6\\}` and the lattice of divisors of `30`, and\n            check that the map `b \\mapsto \\gcd(\\prod_{x\\in b} x, 30)`\n            is a morphism of posets::\n\n                sage: D = Poset((divisors(30), attrcall(\"divides\")))\n                sage: B = Poset(([frozenset(s) for s in Subsets([2,3,5,6])], attrcall(\"issubset\")))\n                sage: def f(b): return D(gcd(prod(b), 30))\n                sage: B.is_poset_morphism(f, D)\n                True\n\n            .. note:: since ``D`` and ``B`` are not facade posets, ``f`` is responsible\n               for the conversions between integers and subsets to elements of\n               ``D`` and ``B`` and back.\n\n            `f` is also a morphism of posets to the chain of divisors\n            of 30, ordered by usual comparison::\n\n                sage: P = Poset((divisors(30), operator.le))\n                sage: def f(b): return P(gcd(prod(b), 30))\n                sage: B.is_poset_morphism(f, P)\n                True\n\n            FIXME: should this be ``is_order_preserving_morphism``?\n\n            .. seealso:: :meth:`is_poset_isomorphism`\n\n            TESTS:\n\n            Base cases::\n\n                sage: P = Posets.ChainPoset(2)\n                sage: Q = Posets.AntichainPoset(2)\n                sage: f = lambda x: 1-x\n                sage: P.is_poset_morphism(f, P)\n                False\n                sage: P.is_poset_morphism(f, Q)\n                False\n                sage: Q.is_poset_morphism(f, Q)\n                True\n                sage: Q.is_poset_morphism(f, P)\n                True\n\n                sage: P = Poset(); P\n                Finite poset containing 0 elements\n                sage: P.is_poset_morphism(f, P)\n                True\n\n            ",
                    "args": [
                        "self",
                        "f",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "codomain"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_selfdual": {
                    "__doc__": "\n            Returns whether this poset is *self-dual*, that is\n            isomorphic to its dual poset.\n\n            EXAMPLES::\n\n                sage: P = Poset(([1,2,3],[[1,3],[2,3]]),cover_relations=True)\n                sage: P.is_selfdual()\n                False\n\n                sage: P = Poset(([1,2,3,4],[[1,3],[1,4],[2,3],[2,4]]),cover_relations=True)\n                sage: P.is_selfdual()\n                True\n\n                sage: P = Poset( {} )\n                sage: P.is_selfdual()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "order_filter_generators": {
                    "__doc__": "\n            Generators for an order filter\n\n            INPUT:\n\n            - ``filter`` -- an order filter of ``self``, as a list (or iterable)\n\n            EXAMPLES::\n\n                sage: P = Poset((Subsets([1,2,3]), attrcall(\"issubset\")))\n                sage: I = P.order_filter([Set([1,2]), Set([2,3]), Set([1])]); I\n                [{2, 3}, {1}, {1, 2}, {1, 3}, {1, 2, 3}]\n                sage: P.order_filter_generators(I)\n                {{2, 3}, {1}}\n\n            .. seealso:: :meth:`order_ideal_generators`\n            ",
                    "args": [
                        "self",
                        "filter"
                    ],
                    "argspec": [
                        [
                            "self",
                            "filter"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "order_ideal_complement_generators": {
                    "__doc__": "\n            Return the Panyushev complement of the antichain\n            ``antichain``.\n\n            Given an antichain `A` of a poset `P`, the Panyushev\n            complement of `A` is defined to be the antichain consisting\n            of the minimal elements of the order filter `B`, where `B`\n            is the (set-theoretic) complement of the order ideal of\n            `P` generated by `A`.\n\n            Setting the optional keyword variable ``direction`` to\n            ``'down'`` leads to the inverse Panyushev complement being\n            computed instead of the Panyushev complement. The inverse\n            Panyushev complement of an antichain `A` is the antichain\n            whose Panyushev complement is `A`. It can be found as the\n            antichain consisting of the maximal elements of the order\n            ideal `C`, where `C` is the (set-theoretic) complement of\n            the order filter of `P` generated by `A`.\n\n            :meth:`panyushev_complement` is an alias for this method.\n\n            Panyushev complementation is related (actually, isomorphic)\n            to rowmotion (:meth:`rowmotion`).\n\n            INPUT:\n\n            - ``antichain`` -- an antichain of ``self``, as a list (or\n              iterable), or, more generally, generators of an order ideal\n              (resp. order filter)\n            - ``direction`` -- 'up' or 'down' (default: 'up')\n\n            OUTPUT:\n\n            - the generating antichain of the complement order filter\n              (resp. order ideal) of the order ideal (resp. order filter)\n              generated by the antichain ``antichain``\n\n            EXAMPLES::\n\n                sage: P = Poset( ( [1,2,3], [ [1,3], [2,3] ] ) )\n                sage: P.order_ideal_complement_generators([1])\n                {2}\n                sage: P.order_ideal_complement_generators([3])\n                set()\n                sage: P.order_ideal_complement_generators([1,2])\n                {3}\n                sage: P.order_ideal_complement_generators([1,2,3])\n                set()\n\n                sage: P.order_ideal_complement_generators([1], direction=\"down\")\n                {2}\n                sage: P.order_ideal_complement_generators([3], direction=\"down\")\n                {1, 2}\n                sage: P.order_ideal_complement_generators([1,2], direction=\"down\")\n                set()\n                sage: P.order_ideal_complement_generators([1,2,3], direction=\"down\")\n                set()\n\n            .. WARNING::\n\n                This is a brute force implementation, building the\n                order ideal generated by the antichain, and searching\n                for order filter generators of its complement\n            ",
                    "args": [
                        "self",
                        "antichain",
                        "direction"
                    ],
                    "argspec": [
                        [
                            "self",
                            "antichain",
                            "direction"
                        ],
                        null,
                        null,
                        [
                            "up"
                        ]
                    ]
                },
                "order_ideal_generators": {
                    "__doc__": "\n            Return the antichain of (minimal) generators of the order\n            ideal (resp. order filter) ``ideal``.\n\n            INPUT:\n\n            - ``ideal`` -- an order ideal `I` (resp. order filter)\n              of ``self``, as a list (or iterable); this should be\n              an order ideal if ``direction`` is set to ``'down'``,\n              and an order filter if ``direction`` is set to\n              ``'up'``.\n            - ``direction`` -- ``'up'`` or ``'down'`` (default:\n              ``'down'``).\n\n            The antichain of (minimal) generators of an order ideal\n            `I` in a poset `P` is the set of all minimal elements of\n            `P`. In the case of an order filter, the definition is\n            similar, but with \"maximal\" used instead of \"minimal\".\n\n            EXAMPLES:\n\n            We build the boolean lattice of all subsets of `\\{1,2,3\\}`\n            ordered by inclusion, and compute an order ideal there::\n\n                sage: P = Poset((Subsets([1,2,3]), attrcall(\"issubset\")))\n                sage: I = P.order_ideal([Set([1,2]), Set([2,3]), Set([1])]); I\n                [{}, {3}, {2}, {2, 3}, {1}, {1, 2}]\n\n            Then, we retrieve the generators of this ideal::\n\n                sage: P.order_ideal_generators(I)\n                {{1, 2}, {2, 3}}\n\n            If ``direction`` is 'up', then this instead computes\n            the minimal generators for an order filter::\n\n                sage: I = P.order_filter([Set([1,2]), Set([2,3]), Set([1])]); I\n                [{2, 3}, {1}, {1, 2}, {1, 3}, {1, 2, 3}]\n                sage: P.order_ideal_generators(I, direction='up')\n                {{2, 3}, {1}}\n\n            Complexity: `O(n+m)` where `n` is the cardinality of `I`,\n            and `m` the number of upper covers of elements of `I`.\n            ",
                    "args": [
                        "self",
                        "ideal",
                        "direction"
                    ],
                    "argspec": [
                        [
                            "self",
                            "ideal",
                            "direction"
                        ],
                        null,
                        null,
                        [
                            "down"
                        ]
                    ]
                },
                "order_ideals_lattice": {
                    "__doc__": "\n            Return the lattice of order ideals of a poset ``self``,\n            ordered by inclusion.\n\n            The lattice of order ideals of a poset `P` is usually\n            denoted by `J(P)`. Its underlying set is the set of order\n            ideals of `P`, and its partial order is given by\n            inclusion.\n\n            The order ideals of `P` are in a canonical bijection\n            with the antichains of `P`. The bijection maps every\n            order ideal to the antichain formed by its maximal\n            elements. By setting the ``as_ideals`` keyword variable to\n            ``False``, one can make this method apply this bijection\n            before returning the lattice.\n\n            INPUT:\n\n            - ``as_ideals`` -- Boolean, if ``True`` (default) returns\n              a poset on the set of order ideals, otherwise on the set\n              of antichains\n            - ``facade`` -- Boolean or ``None`` (default). Whether to\n              return a facade lattice or not. By default return facade\n              lattice if the poset is a facade poset.\n\n            EXAMPLES::\n\n                sage: P = Posets.PentagonPoset()\n                sage: P.cover_relations()\n                [[0, 1], [0, 2], [1, 4], [2, 3], [3, 4]]\n                sage: J = P.order_ideals_lattice(); J\n                Finite lattice containing 8 elements\n                sage: list(J)\n                [{}, {0}, {0, 2}, {0, 2, 3}, {0, 1}, {0, 1, 2}, {0, 1, 2, 3}, {0, 1, 2, 3, 4}]\n\n            As a lattice on antichains::\n\n                sage: J2 = P.order_ideals_lattice(False); J2\n                Finite lattice containing 8 elements\n                sage: list(J2)\n                [(0,), (1, 2), (1, 3), (1,), (2,), (3,), (4,), ()]\n\n            TESTS::\n\n                sage: J = Posets.DiamondPoset(4, facade = True).order_ideals_lattice(); J\n                Finite lattice containing 6 elements\n                sage: list(J)\n                [{}, {0}, {0, 2}, {0, 1}, {0, 1, 2}, {0, 1, 2, 3}]\n                sage: J.cover_relations()\n                [[{}, {0}], [{0}, {0, 2}], [{0}, {0, 1}], [{0, 2}, {0, 1, 2}], [{0, 1}, {0, 1, 2}], [{0, 1, 2}, {0, 1, 2, 3}]]\n\n                sage: P = Poset({1:[2]})\n                sage: J_facade = P.order_ideals_lattice()\n                sage: J_nonfacade = P.order_ideals_lattice(facade=False)\n                sage: type(J_facade[0]) == type(J_nonfacade[0])\n                False\n            ",
                    "args": [
                        "self",
                        "as_ideals",
                        "facade"
                    ],
                    "argspec": [
                        [
                            "self",
                            "as_ideals",
                            "facade"
                        ],
                        null,
                        null,
                        [
                            true,
                            null
                        ]
                    ]
                },
                "panyushev_complement": {
                    "__doc__": "\n            Return the Panyushev complement of the antichain\n            ``antichain``.\n\n            Given an antichain `A` of a poset `P`, the Panyushev\n            complement of `A` is defined to be the antichain consisting\n            of the minimal elements of the order filter `B`, where `B`\n            is the (set-theoretic) complement of the order ideal of\n            `P` generated by `A`.\n\n            Setting the optional keyword variable ``direction`` to\n            ``'down'`` leads to the inverse Panyushev complement being\n            computed instead of the Panyushev complement. The inverse\n            Panyushev complement of an antichain `A` is the antichain\n            whose Panyushev complement is `A`. It can be found as the\n            antichain consisting of the maximal elements of the order\n            ideal `C`, where `C` is the (set-theoretic) complement of\n            the order filter of `P` generated by `A`.\n\n            :meth:`panyushev_complement` is an alias for this method.\n\n            Panyushev complementation is related (actually, isomorphic)\n            to rowmotion (:meth:`rowmotion`).\n\n            INPUT:\n\n            - ``antichain`` -- an antichain of ``self``, as a list (or\n              iterable), or, more generally, generators of an order ideal\n              (resp. order filter)\n            - ``direction`` -- 'up' or 'down' (default: 'up')\n\n            OUTPUT:\n\n            - the generating antichain of the complement order filter\n              (resp. order ideal) of the order ideal (resp. order filter)\n              generated by the antichain ``antichain``\n\n            EXAMPLES::\n\n                sage: P = Poset( ( [1,2,3], [ [1,3], [2,3] ] ) )\n                sage: P.order_ideal_complement_generators([1])\n                {2}\n                sage: P.order_ideal_complement_generators([3])\n                set()\n                sage: P.order_ideal_complement_generators([1,2])\n                {3}\n                sage: P.order_ideal_complement_generators([1,2,3])\n                set()\n\n                sage: P.order_ideal_complement_generators([1], direction=\"down\")\n                {2}\n                sage: P.order_ideal_complement_generators([3], direction=\"down\")\n                {1, 2}\n                sage: P.order_ideal_complement_generators([1,2], direction=\"down\")\n                set()\n                sage: P.order_ideal_complement_generators([1,2,3], direction=\"down\")\n                set()\n\n            .. WARNING::\n\n                This is a brute force implementation, building the\n                order ideal generated by the antichain, and searching\n                for order filter generators of its complement\n            ",
                    "args": [
                        "self",
                        "antichain",
                        "direction"
                    ],
                    "argspec": [
                        [
                            "self",
                            "antichain",
                            "direction"
                        ],
                        null,
                        null,
                        [
                            "up"
                        ]
                    ]
                },
                "panyushev_orbit_iter": {
                    "__doc__": "\n            Iterate over the Panyushev orbit of an antichain\n            ``antichain`` of ``self``.\n\n            The Panyushev orbit of an antichain is its orbit under\n            Panyushev complementation (see\n            :meth:`panyushev_complement`).\n\n            INPUT:\n\n            - ``antichain`` -- an antichain of ``self``, given as an\n              iterable.\n\n            - ``element_constructor`` (defaults to ``set``) -- a type\n              constructor (``set``, ``tuple``, ``list``, ``frozenset``,\n              ``iter``, etc.) which is to be applied to the antichains\n              before they are yielded.\n\n            - ``stop`` -- a Boolean (default: ``True``) determining\n              whether the iterator should stop once it completes its\n              cycle (this happens when it is set to ``True``) or go on\n              forever (this happens when it is set to ``False``).\n\n            - ``check`` -- a Boolean (default: ``True``) determining\n              whether ``antichain`` should be checked for being an\n              antichain.\n\n            OUTPUT:\n\n            - an iterator over the orbit of the antichain ``antichain``\n              under Panyushev complementation. This iterator `I` has the\n              property that ``I[0] == antichain`` and each `i` satisfies\n              ``self.order_ideal_complement_generators(I[i]) == I[i+1]``,\n              where ``I[i+1]`` has to be understood as ``I[0]`` if it is\n              undefined.\n              The entries ``I[i]`` are sets by default, but depending on\n              the optional keyword variable ``element_constructors``\n              they can also be tuples, lists etc.\n\n            EXAMPLES::\n\n                sage: P = Poset( ( [1,2,3], [ [1,3], [2,3] ] ) )\n                sage: list(P.panyushev_orbit_iter(set([1, 2])))\n                [{1, 2}, {3}, set()]\n                sage: list(P.panyushev_orbit_iter([1, 2]))\n                [{1, 2}, {3}, set()]\n                sage: list(P.panyushev_orbit_iter([2, 1]))\n                [{1, 2}, {3}, set()]\n                sage: list(P.panyushev_orbit_iter(set([1, 2]), element_constructor=list))\n                [[1, 2], [3], []]\n                sage: list(P.panyushev_orbit_iter(set([1, 2]), element_constructor=frozenset))\n                [frozenset({1, 2}), frozenset({3}), frozenset()]\n                sage: list(P.panyushev_orbit_iter(set([1, 2]), element_constructor=tuple))\n                [(1, 2), (3,), ()]\n\n                sage: P = Poset( {} )\n                sage: list(P.panyushev_orbit_iter([]))\n                [set()]\n\n                sage: P = Poset({ 1: [2, 3], 2: [4], 3: [4], 4: [] })\n                sage: Piter = P.panyushev_orbit_iter([2], stop=False)\n                sage: next(Piter)\n                {2}\n                sage: next(Piter)\n                {3}\n                sage: next(Piter)\n                {2}\n                sage: next(Piter)\n                {3}\n            ",
                    "args": [
                        "self",
                        "antichain",
                        "element_constructor",
                        "stop",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "antichain",
                            "element_constructor",
                            "stop",
                            "check"
                        ],
                        null,
                        null,
                        [
                            "<type 'set'>",
                            true,
                            true
                        ]
                    ]
                },
                "panyushev_orbits": {
                    "__doc__": "\n            Return the Panyushev orbits of antichains in ``self``.\n\n            The Panyushev orbit of an antichain is its orbit under\n            Panyushev complementation (see\n            :meth:`panyushev_complement`).\n\n            INPUT:\n\n            - ``element_constructor`` (defaults to ``set``) -- a type\n              constructor (``set``, ``tuple``, ``list``, ``frozenset``,\n              ``iter``, etc.) which is to be applied to the antichains\n              before they are returned.\n\n            OUTPUT:\n\n            - the partition of the set of all antichains of ``self`` into\n              orbits under Panyushev complementation. This is returned as\n              a list of lists ``L`` such that for each ``L`` and ``i``,\n              cyclically:\n              ``self.order_ideal_complement_generators(L[i]) == L[i+1]``.\n              The entries ``L[i]`` are sets by default, but depending on\n              the optional keyword variable ``element_constructors``\n              they can also be tuples, lists etc.\n\n            EXAMPLES::\n\n                sage: P = Poset( ( [1,2,3], [ [1,3], [2,3] ] ) )\n                sage: P.panyushev_orbits()\n                [[{2}, {1}], [set(), {1, 2}, {3}]]\n                sage: P.panyushev_orbits(element_constructor=list)\n                [[[2], [1]], [[], [1, 2], [3]]]\n                sage: P.panyushev_orbits(element_constructor=frozenset)\n                [[frozenset({2}), frozenset({1})],\n                 [frozenset(), frozenset({1, 2}), frozenset({3})]]\n                sage: P.panyushev_orbits(element_constructor=tuple)\n                [[(2,), (1,)], [(), (1, 2), (3,)]]\n                sage: P = Poset( {} )\n                sage: P.panyushev_orbits()\n                [[set()]]\n            ",
                    "args": [
                        "self",
                        "element_constructor"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element_constructor"
                        ],
                        null,
                        null,
                        [
                            "<type 'set'>"
                        ]
                    ]
                },
                "rowmotion": {
                    "__doc__": "\n            The image of the order ideal ``order_ideal`` under rowmotion\n            in ``self``.\n\n            Rowmotion on a finite poset `P` is an automorphism of the set\n            `J(P)` of all order ideals of `P`. One way to define it is as\n            follows: Given an order ideal `I \\in J(P)`, we let `F` be the\n            set-theoretic complement of `I` in `P`. Furthermore we let\n            `A` be the antichain consisting of all minimal elements of\n            `F`. Then, the rowmotion of `I` is defined to be the order\n            ideal of `P` generated by the antichain `A` (that is, the\n            order ideal consisting of each element of `P` which has some\n            element of `A` above it).\n\n            Rowmotion is related (actually, isomorphic) to Panyushev\n            complementation (:meth:`panyushev_complement`).\n\n            INPUT:\n\n            - ``order_ideal`` -- an order ideal of ``self``, as a set\n\n            OUTPUT:\n\n            - the image of ``order_ideal`` under rowmotion, as a set again\n\n            EXAMPLES::\n\n                sage: P = Poset( {1: [2, 3], 2: [], 3: [], 4: [8], 5: [], 6: [5], 7: [1, 4], 8: []} )\n                sage: I = Set({2, 6, 1, 7})\n                sage: P.rowmotion(I)\n                {1, 3, 4, 5, 6, 7}\n\n                sage: P = Poset( {} )\n                sage: I = Set({})\n                sage: P.rowmotion(I)\n                Set of elements of {}\n            ",
                    "args": [
                        "self",
                        "order_ideal"
                    ],
                    "argspec": [
                        [
                            "self",
                            "order_ideal"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "rowmotion_orbit_iter": {
                    "__doc__": "\n            Iterate over the rowmotion orbit of an order ideal\n            ``oideal`` of ``self``.\n\n            The rowmotion orbit of an order ideal is its orbit under\n            rowmotion (see :meth:`rowmotion`).\n\n            INPUT:\n\n            - ``oideal`` -- an order ideal of ``self``, given as an\n              iterable.\n\n            - ``element_constructor`` (defaults to ``set``) -- a type\n              constructor (``set``, ``tuple``, ``list``, ``frozenset``,\n              ``iter``, etc.) which is to be applied to the order\n              ideals before they are yielded.\n\n            - ``stop`` -- a Boolean (default: ``True``) determining\n              whether the iterator should stop once it completes its\n              cycle (this happens when it is set to ``True``) or go on\n              forever (this happens when it is set to ``False``).\n\n            - ``check`` -- a Boolean (default: ``True``) determining\n              whether ``oideal`` should be checked for being an\n              order ideal.\n\n            OUTPUT:\n\n            - an iterator over the orbit of the order ideal ``oideal``\n              under rowmotion. This iterator `I` has the property that\n              ``I[0] == oideal`` and that every `i` satisfies\n              ``self.rowmotion(I[i]) == I[i+1]``, where ``I[i+1]`` has\n              to be understood as ``I[0]`` if it is undefined.\n              The entries ``I[i]`` are sets by default, but depending on\n              the optional keyword variable ``element_constructors``\n              they can also be tuples, lists etc.\n\n            EXAMPLES::\n\n                sage: P = Poset( ( [1,2,3], [ [1,3], [2,3] ] ) )\n                sage: list(P.rowmotion_orbit_iter(set([1, 2])))\n                [{1, 2}, {1, 2, 3}, set()]\n                sage: list(P.rowmotion_orbit_iter([1, 2]))\n                [{1, 2}, {1, 2, 3}, set()]\n                sage: list(P.rowmotion_orbit_iter([2, 1]))\n                [{1, 2}, {1, 2, 3}, set()]\n                sage: list(P.rowmotion_orbit_iter(set([1, 2]), element_constructor=list))\n                [[1, 2], [1, 2, 3], []]\n                sage: list(P.rowmotion_orbit_iter(set([1, 2]), element_constructor=frozenset))\n                [frozenset({1, 2}), frozenset({1, 2, 3}), frozenset()]\n                sage: list(P.rowmotion_orbit_iter(set([1, 2]), element_constructor=tuple))\n                [(1, 2), (1, 2, 3), ()]\n\n                sage: P = Poset( {} )\n                sage: list(P.rowmotion_orbit_iter([]))\n                [set()]\n\n                sage: P = Poset({ 1: [2, 3], 2: [4], 3: [4], 4: [] })\n                sage: Piter = P.rowmotion_orbit_iter([1, 2, 3], stop=False)\n                sage: next(Piter)\n                {1, 2, 3}\n                sage: next(Piter)\n                {1, 2, 3, 4}\n                sage: next(Piter)\n                set()\n                sage: next(Piter)\n                {1}\n                sage: next(Piter)\n                {1, 2, 3}\n\n                sage: P = Poset({ 1: [4], 2: [4, 5], 3: [5] })\n                sage: list(P.rowmotion_orbit_iter([1, 2], element_constructor=list))\n                [[1, 2], [1, 2, 3, 4], [2, 3, 5], [1], [2, 3], [1, 2, 3, 5], [1, 2, 4], [3]]\n            ",
                    "args": [
                        "self",
                        "oideal",
                        "element_constructor",
                        "stop",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "oideal",
                            "element_constructor",
                            "stop",
                            "check"
                        ],
                        null,
                        null,
                        [
                            "<type 'set'>",
                            true,
                            true
                        ]
                    ]
                },
                "rowmotion_orbits": {
                    "__doc__": "\n            Return the rowmotion orbits of order ideals in ``self``.\n\n            The rowmotion orbit of an order ideal is its orbit under\n            rowmotion (see :meth:`rowmotion`).\n\n            INPUT:\n\n            - ``element_constructor`` (defaults to ``set``) -- a type\n              constructor (``set``, ``tuple``, ``list``, ``frozenset``,\n              ``iter``, etc.) which is to be applied to the antichains\n              before they are returned.\n\n            OUTPUT:\n\n            - the partition of the set of all order ideals of ``self``\n              into orbits under rowmotion. This is returned as\n              a list of lists ``L`` such that for each ``L`` and ``i``,\n              cyclically: ``self.rowmotion(L[i]) == L[i+1]``.\n              The entries ``L[i]`` are sets by default, but depending on\n              the optional keyword variable ``element_constructors``\n              they can also be tuples, lists etc.\n\n            EXAMPLES::\n\n                sage: P = Poset( {1: [2, 3], 2: [], 3: [], 4: [2]} )\n                sage: sorted(len(o) for o in P.rowmotion_orbits())\n                [3, 5]\n                sage: sorted(P.rowmotion_orbits(element_constructor=list))\n                [[[1, 3], [4], [1], [4, 1, 3], [4, 1, 2]], [[4, 1], [4, 1, 2, 3], []]]\n                sage: sorted(P.rowmotion_orbits(element_constructor=tuple))\n                [[(1, 3), (4,), (1,), (4, 1, 3), (4, 1, 2)], [(4, 1), (4, 1, 2, 3), ()]]\n                sage: P = Poset({})\n                sage: sorted(P.rowmotion_orbits(element_constructor=tuple))\n                [[()]]\n            ",
                    "args": [
                        "self",
                        "element_constructor"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element_constructor"
                        ],
                        null,
                        null,
                        [
                            "<type 'set'>"
                        ]
                    ]
                },
                "toggling_orbit_iter": {
                    "__doc__": "\n            Iterate over the orbit of an order ideal ``oideal`` of\n            ``self`` under the operation of toggling the vertices\n            ``vs[0], vs[1], ...`` in this order.\n\n            See :meth:`order_ideal_toggle` for a definition of toggling.\n\n            .. WARNING::\n\n                The orbit is that under the composition of toggles,\n                *not* under the single toggles themselves. Thus, for\n                example, if ``vs == [1,2]``, then the orbit has the\n                form `(I, T_2 T_1 I, T_2 T_1 T_2 T_1 I, \\ldots)`\n                (where `I` denotes ``oideal`` and `T_i` means\n                toggling at `i`) rather than\n                `(I, T_1 I, T_2 T_1 I, T_1 T_2 T_1 I, \\ldots)`.\n\n            INPUT:\n\n            - ``vs``: a list (or other iterable) of elements of ``self``\n              (but since the output depends on the order, sets should\n              not be used as ``vs``).\n\n            - ``oideal`` -- an order ideal of ``self``, given as an\n              iterable.\n\n            - ``element_constructor`` (defaults to ``set``) -- a type\n              constructor (``set``, ``tuple``, ``list``, ``frozenset``,\n              ``iter``, etc.) which is to be applied to the order\n              ideals before they are yielded.\n\n            - ``stop`` -- a Boolean (default: ``True``) determining\n              whether the iterator should stop once it completes its\n              cycle (this happens when it is set to ``True``) or go on\n              forever (this happens when it is set to ``False``).\n\n            - ``check`` -- a Boolean (default: ``True``) determining\n              whether ``oideal`` should be checked for being an\n              order ideal.\n\n            OUTPUT:\n\n            - an iterator over the orbit of the order ideal ``oideal``\n              under toggling the vertices in the list ``vs`` in this\n              order. This iterator `I` has the property that\n              ``I[0] == oideal`` and that every `i` satisfies\n              ``self.order_ideal_toggles(I[i], vs) == I[i+1]``, where\n              ``I[i+1]`` has to be understood as ``I[0]`` if it is\n              undefined.\n              The entries ``I[i]`` are sets by default, but depending on\n              the optional keyword variable ``element_constructors``\n              they can also be tuples, lists etc.\n\n            EXAMPLES::\n\n                sage: P = Poset( ( [1,2,3], [ [1,3], [2,3] ] ) )\n                sage: list(P.toggling_orbit_iter([1, 3, 1], set([1, 2])))\n                [{1, 2}]\n                sage: list(P.toggling_orbit_iter([1, 2, 3], set([1, 2])))\n                [{1, 2}, set(), {1, 2, 3}]\n                sage: list(P.toggling_orbit_iter([3, 2, 1], set([1, 2])))\n                [{1, 2}, {1, 2, 3}, set()]\n                sage: list(P.toggling_orbit_iter([3, 2, 1], set([1, 2]), element_constructor=list))\n                [[1, 2], [1, 2, 3], []]\n                sage: list(P.toggling_orbit_iter([3, 2, 1], set([1, 2]), element_constructor=frozenset))\n                [frozenset({1, 2}), frozenset({1, 2, 3}), frozenset()]\n                sage: list(P.toggling_orbit_iter([3, 2, 1], set([1, 2]), element_constructor=tuple))\n                [(1, 2), (1, 2, 3), ()]\n                sage: list(P.toggling_orbit_iter([3, 2, 1], [2, 1], element_constructor=tuple))\n                [(1, 2), (1, 2, 3), ()]\n\n                sage: P = Poset( {} )\n                sage: list(P.toggling_orbit_iter([], []))\n                [set()]\n\n                sage: P = Poset({ 1: [2, 3], 2: [4], 3: [4], 4: [] })\n                sage: Piter = P.toggling_orbit_iter([1, 2, 4, 3], [1, 2, 3], stop=False)\n                sage: next(Piter)\n                {1, 2, 3}\n                sage: next(Piter)\n                {1}\n                sage: next(Piter)\n                set()\n                sage: next(Piter)\n                {1, 2, 3}\n                sage: next(Piter)\n                {1}\n            ",
                    "args": [
                        "self",
                        "vs",
                        "oideal",
                        "element_constructor",
                        "stop",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "vs",
                            "oideal",
                            "element_constructor",
                            "stop",
                            "check"
                        ],
                        null,
                        null,
                        [
                            "<type 'set'>",
                            true,
                            true
                        ]
                    ]
                },
                "toggling_orbits": {
                    "__doc__": "\n            Return the orbits of order ideals in ``self`` under the\n            operation of toggling the vertices ``vs[0], vs[1], ...``\n            in this order.\n\n            See :meth:`order_ideal_toggle` for a definition of toggling.\n\n            .. WARNING::\n\n                The orbits are those under the composition of toggles,\n                *not* under the single toggles themselves. Thus, for\n                example, if ``vs == [1,2]``, then the orbits have the\n                form `(I, T_2 T_1 I, T_2 T_1 T_2 T_1 I, \\ldots)`\n                (where `I` denotes an order ideal and `T_i` means\n                toggling at `i`) rather than\n                `(I, T_1 I, T_2 T_1 I, T_1 T_2 T_1 I, \\ldots)`.\n\n            INPUT:\n\n            - ``vs``: a list (or other iterable) of elements of ``self``\n              (but since the output depends on the order, sets should\n              not be used as ``vs``).\n\n            OUTPUT:\n\n            - a partition of the order ideals of ``self``, as a list of\n              sets ``L`` such that for each ``L`` and ``i``, cyclically:\n              ``self.order_ideal_toggles(L[i], vs) == L[i+1]``.\n\n            EXAMPLES::\n\n                sage: P = Poset( {1: [2, 4], 2: [], 3: [4], 4: []} )\n                sage: sorted(len(o) for o in P.toggling_orbits([1, 2]))\n                [2, 3, 3]\n                sage: P = Poset( {1: [3], 2: [1, 4], 3: [], 4: [3]} )\n                sage: sorted(len(o) for o in P.toggling_orbits((1, 2, 4, 3)))\n                [3, 3]\n            ",
                    "args": [
                        "self",
                        "vs",
                        "element_constructor"
                    ],
                    "argspec": [
                        [
                            "self",
                            "vs",
                            "element_constructor"
                        ],
                        null,
                        null,
                        [
                            "<type 'set'>"
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.posets.Posets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of finite posets i.e. finite sets with a partial\n    order structure.\n\n    EXAMPLES::\n\n        sage: FinitePosets()\n        Category of finite posets\n        sage: FinitePosets().super_categories()\n        [Category of posets, Category of finite sets]\n        sage: FinitePosets().example()\n        NotImplemented\n\n    .. seealso:: :class:`~sage.categories.posets.Posets`, :func:`Poset`\n\n    TESTS::\n\n        sage: C = FinitePosets()\n        sage: C is Posets().Finite()\n        True\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of integral domains\n\n    An integral domain is commutative ring with no zero divisors, or\n    equivalently a commutative domain.\n\n    EXAMPLES::\n\n        sage: C = IntegralDomains(); C\n        Category of integral domains\n        sage: sorted(C.super_categories(), key=str)\n        [Category of commutative rings, Category of domains]\n        sage: C is Domains().Commutative()\n        True\n        sage: C is Rings().Commutative().NoZeroDivisors()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.domains.Domains",
            "sage.categories.commutative_rings.CommutativeRings"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of integral domains\n\n    An integral domain is commutative ring with no zero divisors, or\n    equivalently a commutative domain.\n\n    EXAMPLES::\n\n        sage: C = IntegralDomains(); C\n        Category of integral domains\n        sage: sorted(C.super_categories(), key=str)\n        [Category of commutative rings, Category of domains]\n        sage: C is Domains().Commutative()\n        True\n        sage: C is Rings().Commutative().NoZeroDivisors()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.integral_domains.IntegralDomains",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "is_integral_domain": {
                    "__doc__": "\n            Return True, since this in an object of the category of integral domains.\n\n            EXAMPLES::\n\n                sage: QQ.is_integral_domain()\n                True\n                sage: Parent(QQ,category=IntegralDomains()).is_integral_domain()\n                True\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of partially ordered monoids, that is partially ordered sets\n    which are also monoids, and such that multiplication preserves the\n    ordering: `x \\leq y` implies `x*z < y*z` and `z*x < z*y`.\n\n    http://en.wikipedia.org/wiki/Ordered_monoid\n\n    EXAMPLES::\n\n        sage: PartiallyOrderedMonoids()\n        Category of partially ordered monoids\n        sage: PartiallyOrderedMonoids().super_categories()\n        [Category of posets, Category of monoids]\n\n    TESTS::\n\n        sage: TestSuite(PartiallyOrderedMonoids()).run()\n    ",
        "axioms": [
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.posets.Posets",
            "sage.categories.monoids.Monoids"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of partially ordered monoids, that is partially ordered sets\n    which are also monoids, and such that multiplication preserves the\n    ordering: `x \\leq y` implies `x*z < y*z` and `z*x < z*y`.\n\n    http://en.wikipedia.org/wiki/Ordered_monoid\n\n    EXAMPLES::\n\n        sage: PartiallyOrderedMonoids()\n        Category of partially ordered monoids\n        sage: PartiallyOrderedMonoids().super_categories()\n        [Category of posets, Category of monoids]\n\n    TESTS::\n\n        sage: TestSuite(PartiallyOrderedMonoids()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.partially_ordered_monoids.PartiallyOrderedMonoids",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.partially_ordered_monoids.PartiallyOrderedMonoids",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.posets.Posets",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite fields.\n\n    EXAMPLES::\n\n        sage: K = FiniteFields(); K\n        Category of finite fields\n\n    A finite field is a finite monoid with the structure of a field;\n    it is currently assumed to be enumerated::\n\n        sage: K.super_categories()\n        [Category of fields,\n         Category of finite commutative rings,\n         Category of finite enumerated sets]\n\n    Some examples of membership testing and coercion::\n\n        sage: FiniteField(17) in K\n        True\n        sage: RationalField() in K\n        False\n        sage: K(RationalField())\n        Traceback (most recent call last):\n        ...\n        TypeError: unable to canonically associate a finite field to Rational Field\n\n    TESTS::\n\n        sage: K is Fields().Finite()\n        True\n        sage: TestSuite(K).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Finite",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.fields.Fields",
            "sage.categories.commutative_rings.CommutativeRings.Finite",
            "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite fields.\n\n    EXAMPLES::\n\n        sage: K = FiniteFields(); K\n        Category of finite fields\n\n    A finite field is a finite monoid with the structure of a field;\n    it is currently assumed to be enumerated::\n\n        sage: K.super_categories()\n        [Category of fields,\n         Category of finite commutative rings,\n         Category of finite enumerated sets]\n\n    Some examples of membership testing and coercion::\n\n        sage: FiniteField(17) in K\n        True\n        sage: RationalField() in K\n        False\n        sage: K(RationalField())\n        Traceback (most recent call last):\n        ...\n        TypeError: unable to canonically associate a finite field to Rational Field\n\n    TESTS::\n\n        sage: K is Fields().Finite()\n        True\n        sage: TestSuite(K).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_fields.FiniteFields",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.euclidean_domains.EuclideanDomains"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of affine Weyl groups\n\n    .. todo:: add a description of this category\n\n    .. seealso::\n\n        - :wikipedia:`Affine_weyl_group`\n        - :class:`WeylGroups`, :class:`WeylGroup`\n\n    EXAMPLES::\n\n        sage: C = AffineWeylGroups(); C\n        Category of affine weyl groups\n        sage: C.super_categories()\n        [Category of infinite weyl groups]\n\n        sage: C.example()\n        NotImplemented\n        sage: W = WeylGroup([\"A\",4,1]); W\n        Weyl Group of type ['A', 4, 1] (as a matrix group acting on the root space)\n        sage: W.category()\n        Category of affine weyl groups\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Infinite",
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "affine_grassmannian_to_core": {
                    "__doc__": "\n            Bijection between affine Grassmannian elements of type `A_k^{(1)}` and `(k+1)`-cores.\n\n            INPUT:\n\n            - ``self`` -- an affine Grassmannian element of some affine Weyl group of type `A_k^{(1)}`\n\n            Recall that an element `w` of an affine Weyl group is\n            affine Grassmannian if all its all reduced words end in 0, see :meth:`is_affine_grassmannian`.\n\n            OUTPUT:\n\n            - a `(k+1)`-core\n\n            See also :meth:`affine_grassmannian_to_partition`.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',2,1])\n                sage: w = W.from_reduced_word([0,2,1,0])\n                sage: la = w.affine_grassmannian_to_core(); la\n                [4, 2]\n                sage: type(la)\n                <class 'sage.combinat.core.Cores_length_with_category.element_class'>\n                sage: la.to_grassmannian() == w\n                True\n\n                sage: w = W.from_reduced_word([0,2,1])\n                sage: w.affine_grassmannian_to_core()\n                Traceback (most recent call last):\n                ...\n                ValueError: Error! this only works on type 'A' affine Grassmannian elements\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "affine_grassmannian_to_partition": {
                    "__doc__": "\n            Bijection between affine Grassmannian elements of type `A_k^{(1)}` and `k`-bounded partitions.\n\n            INPUT:\n\n            - ``self`` is affine Grassmannian element of the affine Weyl group of type `A_k^{(1)}` (i.e. all reduced words end in 0)\n\n            OUTPUT:\n\n            - `k`-bounded partition\n\n            See also :meth:`affine_grassmannian_to_core`.\n\n            EXAMPLES::\n\n                sage: k = 2\n                sage: W = WeylGroup(['A',k,1])\n                sage: w = W.from_reduced_word([0,2,1,0])\n                sage: la = w.affine_grassmannian_to_partition(); la\n                [2, 2]\n                sage: la.from_kbounded_to_grassmannian(k) == w\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_affine_grassmannian": {
                    "__doc__": "\n            Tests whether ``self`` is affine Grassmannian\n\n            An element of an affine Weyl group is *affine Grassmannian*\n            if any of the following equivalent properties holds:\n\n             - all reduced words for self end with 0.\n             - self is the identity, or 0 is its single right descent.\n             - self is a mimimal coset representative for W / cl W.\n\n            EXAMPLES::\n\n                sage: W=WeylGroup(['A',3,1])\n                sage: w=W.from_reduced_word([2,1,0])\n                sage: w.is_affine_grassmannian()\n                True\n                sage: w=W.from_reduced_word([2,0])\n                sage: w.is_affine_grassmannian()\n                False\n                sage: W.one().is_affine_grassmannian()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.category.JoinCategory"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of affine Weyl groups\n\n    .. todo:: add a description of this category\n\n    .. seealso::\n\n        - :wikipedia:`Affine_weyl_group`\n        - :class:`WeylGroups`, :class:`WeylGroup`\n\n    EXAMPLES::\n\n        sage: C = AffineWeylGroups(); C\n        Category of affine weyl groups\n        sage: C.super_categories()\n        [Category of infinite weyl groups]\n\n        sage: C.example()\n        NotImplemented\n        sage: W = WeylGroup([\"A\",4,1]); W\n        Weyl Group of type ['A', 4, 1] (as a matrix group acting on the root space)\n        sage: W.category()\n        Category of affine weyl groups\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.affine_weyl_groups.AffineWeylGroups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "affine_grassmannian_elements_of_given_length": {
                    "__doc__": "\n            Returns the affine Grassmannian elements of length `k`, as a list.\n\n            EXAMPLES::\n\n                sage: W=WeylGroup(['A',3,1])\n                sage: [x.reduced_word() for x in W.affine_grassmannian_elements_of_given_length(3)]\n                [[2, 1, 0], [3, 1, 0], [2, 3, 0]]\n\n            .. SEEALSO::\n\n                :meth:`AffineWeylGroups.ElementMethods.is_affine_grassmannian`\n\n            .. TODO:: should return an enumerated set, with iterator, ...\n            ",
                    "args": [
                        "self",
                        "k"
                    ],
                    "argspec": [
                        [
                            "self",
                            "k"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "special_node": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "affine_grassmannian_to_core": {
                    "__doc__": "\n            Bijection between affine Grassmannian elements of type `A_k^{(1)}` and `(k+1)`-cores.\n\n            INPUT:\n\n            - ``self`` -- an affine Grassmannian element of some affine Weyl group of type `A_k^{(1)}`\n\n            Recall that an element `w` of an affine Weyl group is\n            affine Grassmannian if all its all reduced words end in 0, see :meth:`is_affine_grassmannian`.\n\n            OUTPUT:\n\n            - a `(k+1)`-core\n\n            See also :meth:`affine_grassmannian_to_partition`.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',2,1])\n                sage: w = W.from_reduced_word([0,2,1,0])\n                sage: la = w.affine_grassmannian_to_core(); la\n                [4, 2]\n                sage: type(la)\n                <class 'sage.combinat.core.Cores_length_with_category.element_class'>\n                sage: la.to_grassmannian() == w\n                True\n\n                sage: w = W.from_reduced_word([0,2,1])\n                sage: w.affine_grassmannian_to_core()\n                Traceback (most recent call last):\n                ...\n                ValueError: Error! this only works on type 'A' affine Grassmannian elements\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "affine_grassmannian_to_partition": {
                    "__doc__": "\n            Bijection between affine Grassmannian elements of type `A_k^{(1)}` and `k`-bounded partitions.\n\n            INPUT:\n\n            - ``self`` is affine Grassmannian element of the affine Weyl group of type `A_k^{(1)}` (i.e. all reduced words end in 0)\n\n            OUTPUT:\n\n            - `k`-bounded partition\n\n            See also :meth:`affine_grassmannian_to_core`.\n\n            EXAMPLES::\n\n                sage: k = 2\n                sage: W = WeylGroup(['A',k,1])\n                sage: w = W.from_reduced_word([0,2,1,0])\n                sage: la = w.affine_grassmannian_to_partition(); la\n                [2, 2]\n                sage: la.from_kbounded_to_grassmannian(k) == w\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_affine_grassmannian": {
                    "__doc__": "\n            Tests whether ``self`` is affine Grassmannian\n\n            An element of an affine Weyl group is *affine Grassmannian*\n            if any of the following equivalent properties holds:\n\n             - all reduced words for self end with 0.\n             - self is the identity, or 0 is its single right descent.\n             - self is a mimimal coset representative for W / cl W.\n\n            EXAMPLES::\n\n                sage: W=WeylGroup(['A',3,1])\n                sage: w=W.from_reduced_word([2,1,0])\n                sage: w.is_affine_grassmannian()\n                True\n                sage: w=W.from_reduced_word([2,0])\n                sage: w.is_affine_grassmannian()\n                False\n                sage: W.one().is_affine_grassmannian()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all modules over a base ring `R`.\n\n    An `R`-module `M` is a left and right `R`-module over a\n    commutative ring `R` such that:\n\n    .. MATH::\n\n        r*(x*s) = (r*x)*s \\qquad  \\forall r,s \\in R \\text{ and } x \\in M\n\n    INPUT:\n\n    - ``base_ring`` -- a ring `R` or subcategory of ``Rings()``\n    - ``dispatch`` -- a boolean (for internal use; default: ``True``)\n\n    When the base ring is a field, the category of vector spaces is\n    returned instead (unless ``dispatch == False``).\n\n    .. WARNING::\n\n        Outside of the context of symmetric modules over a commutative\n        ring, the specifications of this category are fuzzy and not\n        yet set in stone (see below). The code in this category and\n        its subcategories is therefore prone to bugs or arbitrary\n        limitations in this case.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ)\n        Category of modules over Integer Ring\n        sage: Modules(QQ)\n        Category of vector spaces over Rational Field\n\n        sage: Modules(Rings())\n        Category of modules over rings\n        sage: Modules(FiniteFields())\n        Category of vector spaces over finite fields\n\n        sage: Modules(Integers(9))\n        Category of modules over Ring of integers modulo 9\n\n        sage: Modules(Integers(9)).super_categories()\n        [Category of bimodules over Ring of integers modulo 9 on the left and Ring of integers modulo 9 on the right]\n\n        sage: Modules(ZZ).super_categories()\n        [Category of bimodules over Integer Ring on the left and Integer Ring on the right]\n\n        sage: Modules == RingModules\n        True\n\n        sage: Modules(ZZ['x']).is_abelian()   # see #6081\n        True\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ)).run()\n\n    .. TODO::\n\n        - Clarify the distinction, if any, with ``BiModules(R, R)``.\n          In particular, if `R` is a commutative ring (e.g. a field),\n          some pieces of the code possibly assume that `M` is a\n          *symmetric `R`-`R`-bimodule*:\n\n          .. MATH::\n\n              r*x = x*r \\qquad  \\forall r \\in R \\text{ and } x \\in M\n\n        - Make sure that non symmetric modules are properly supported\n          by all the code, and advertise it.\n\n        - Make sure that non commutative rings are properly supported\n          by all the code, and advertise it.\n\n        - Add support for base semirings.\n\n        - Implement a ``FreeModules(R)`` category, when so prompted by a\n          concrete use case: e.g.  modeling a free module with several\n          bases (using :meth:`Sets.SubcategoryMethods.Realizations`)\n          or with an atlas of local maps (see e.g. :trac:`15916`).\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "__mul__": {
                    "__doc__": "Modules__mul__(Element left, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 86)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``left`` -- an element of a :class:`module <Modules>`\n    - ``right`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the right\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: x * int(2)\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__rmul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a\n    Cython method in :mod:`sage.categories.magmas_cython`::\n\n        sage: x.__mul__.im_func is Modules.ElementMethods.__mul__.im_func\n        True\n        sage: x.__mul__.im_func is sage.categories.coercion_methods.Modules__mul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__rmul__": {
                    "__doc__": "Modules__rmul__(Element right, left)\nFile: sage/categories/coercion_methods.pyx (starting at line 122)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``right`` -- an element of a :class:`module <Modules>`\n    - ``left`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the left\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: int(2) * x\n        2*B['a']\n        sage: x.__rmul__(int(2))\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__mul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a Cython\n    method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__rmul__.im_func is Modules.ElementMethods.__rmul__.im_func\n        True\n        sage: x.__rmul__.im_func is sage.categories.coercion_methods.Modules__rmul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "right",
                        "left"
                    ],
                    "argspec": [
                        [
                            "right",
                            "left"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.bimodules.Bimodules"
        ],
        "mmt": "Modules",
        "morphism_class": {
            "__doc__": "\n    The category of all modules over a base ring `R`.\n\n    An `R`-module `M` is a left and right `R`-module over a\n    commutative ring `R` such that:\n\n    .. MATH::\n\n        r*(x*s) = (r*x)*s \\qquad  \\forall r,s \\in R \\text{ and } x \\in M\n\n    INPUT:\n\n    - ``base_ring`` -- a ring `R` or subcategory of ``Rings()``\n    - ``dispatch`` -- a boolean (for internal use; default: ``True``)\n\n    When the base ring is a field, the category of vector spaces is\n    returned instead (unless ``dispatch == False``).\n\n    .. WARNING::\n\n        Outside of the context of symmetric modules over a commutative\n        ring, the specifications of this category are fuzzy and not\n        yet set in stone (see below). The code in this category and\n        its subcategories is therefore prone to bugs or arbitrary\n        limitations in this case.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ)\n        Category of modules over Integer Ring\n        sage: Modules(QQ)\n        Category of vector spaces over Rational Field\n\n        sage: Modules(Rings())\n        Category of modules over rings\n        sage: Modules(FiniteFields())\n        Category of vector spaces over finite fields\n\n        sage: Modules(Integers(9))\n        Category of modules over Ring of integers modulo 9\n\n        sage: Modules(Integers(9)).super_categories()\n        [Category of bimodules over Ring of integers modulo 9 on the left and Ring of integers modulo 9 on the right]\n\n        sage: Modules(ZZ).super_categories()\n        [Category of bimodules over Integer Ring on the left and Integer Ring on the right]\n\n        sage: Modules == RingModules\n        True\n\n        sage: Modules(ZZ['x']).is_abelian()   # see #6081\n        True\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ)).run()\n\n    .. TODO::\n\n        - Clarify the distinction, if any, with ``BiModules(R, R)``.\n          In particular, if `R` is a commutative ring (e.g. a field),\n          some pieces of the code possibly assume that `M` is a\n          *symmetric `R`-`R`-bimodule*:\n\n          .. MATH::\n\n              r*x = x*r \\qquad  \\forall r \\in R \\text{ and } x \\in M\n\n        - Make sure that non symmetric modules are properly supported\n          by all the code, and advertise it.\n\n        - Make sure that non commutative rings are properly supported\n          by all the code, and advertise it.\n\n        - Add support for base semirings.\n\n        - Implement a ``FreeModules(R)`` category, when so prompted by a\n          concrete use case: e.g.  modeling a free module with several\n          bases (using :meth:`Sets.SubcategoryMethods.Realizations`)\n          or with an atlas of local maps (see e.g. :trac:`15916`).\n    ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "tensor_square": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "__mul__": {
                    "__doc__": "Modules__mul__(Element left, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 86)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``left`` -- an element of a :class:`module <Modules>`\n    - ``right`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the right\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: x * int(2)\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__rmul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a\n    Cython method in :mod:`sage.categories.magmas_cython`::\n\n        sage: x.__mul__.im_func is Modules.ElementMethods.__mul__.im_func\n        True\n        sage: x.__mul__.im_func is sage.categories.coercion_methods.Modules__mul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__rmul__": {
                    "__doc__": "Modules__rmul__(Element right, left)\nFile: sage/categories/coercion_methods.pyx (starting at line 122)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``right`` -- an element of a :class:`module <Modules>`\n    - ``left`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the left\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: int(2) * x\n        2*B['a']\n        sage: x.__rmul__(int(2))\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__mul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a Cython\n    method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__rmul__.im_func is Modules.ElementMethods.__rmul__.im_func\n        True\n        sage: x.__rmul__.im_func is sage.categories.coercion_methods.Modules__rmul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "right",
                        "left"
                    ],
                    "argspec": [
                        [
                            "right",
                            "left"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of lattices, i.e. partially ordered sets in which any\n    two elements have a unique supremum (the elements' least upper\n    bound; called their *join*) and a unique infimum (greatest lower bound;\n    called their *meet*).\n\n    EXAMPLES::\n\n        sage: LatticePosets()\n        Category of lattice posets\n        sage: LatticePosets().super_categories()\n        [Category of posets]\n        sage: LatticePosets().example()\n        NotImplemented\n\n    .. seealso:: :class:`~sage.categories.posets.Posets`, :class:`FiniteLatticePosets`, :func:`LatticePoset`\n\n    TESTS::\n\n        sage: C = LatticePosets()\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of lattices, i.e. partially ordered sets in which any\n    two elements have a unique supremum (the elements' least upper\n    bound; called their *join*) and a unique infimum (greatest lower bound;\n    called their *meet*).\n\n    EXAMPLES::\n\n        sage: LatticePosets()\n        Category of lattice posets\n        sage: LatticePosets().super_categories()\n        [Category of posets]\n        sage: LatticePosets().example()\n        NotImplemented\n\n    .. seealso:: :class:`~sage.categories.posets.Posets`, :class:`FiniteLatticePosets`, :func:`LatticePoset`\n\n    TESTS::\n\n        sage: C = LatticePosets()\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.posets.Posets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of lattices, i.e. partially ordered sets in which any\n    two elements have a unique supremum (the elements' least upper\n    bound; called their *join*) and a unique infimum (greatest lower bound;\n    called their *meet*).\n\n    EXAMPLES::\n\n        sage: LatticePosets()\n        Category of lattice posets\n        sage: LatticePosets().super_categories()\n        [Category of posets]\n        sage: LatticePosets().example()\n        NotImplemented\n\n    .. seealso:: :class:`~sage.categories.posets.Posets`, :class:`FiniteLatticePosets`, :func:`LatticePoset`\n\n    TESTS::\n\n        sage: C = LatticePosets()\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "name": "sage.categories.lattice_posets.LatticePosets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "join": {
                    "__doc__": "\n            Returns the join of `x` and `y` in this lattice\n\n            INPUT:\n\n             - ``x``, ``y`` -- elements of ``self``\n\n            EXAMPLES::\n\n                sage: D = LatticePoset((divisors(60), attrcall(\"divides\")))\n                sage: D.join( D(6), D(10) )\n                30\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "meet": {
                    "__doc__": "\n            Returns the meet of `x` and `y` in this lattice\n\n            INPUT:\n\n             - ``x``, ``y`` -- elements of ``self``\n\n            EXAMPLES::\n\n                sage: D = LatticePoset((divisors(30), attrcall(\"divides\")))\n                sage: D.meet( D(6), D(15) )\n                3\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.lattice_posets.LatticePosets",
            "sage.categories.posets.Posets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of lattices, i.e. partially ordered sets in which any\n    two elements have a unique supremum (the elements' least upper\n    bound; called their *join*) and a unique infimum (greatest lower bound;\n    called their *meet*).\n\n    EXAMPLES::\n\n        sage: LatticePosets()\n        Category of lattice posets\n        sage: LatticePosets().super_categories()\n        [Category of posets]\n        sage: LatticePosets().example()\n        NotImplemented\n\n    .. seealso:: :class:`~sage.categories.posets.Posets`, :class:`FiniteLatticePosets`, :func:`LatticePoset`\n\n    TESTS::\n\n        sage: C = LatticePosets()\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite dimensional Hopf algebras with a\n    distinguished basis.\n\n    EXAMPLES::\n\n        sage: FiniteDimensionalHopfAlgebrasWithBasis(QQ) # fixme: Hopf should be capitalized\n        Category of finite dimensional hopf algebras with basis over Rational Field\n        sage: FiniteDimensionalHopfAlgebrasWithBasis(QQ).super_categories()\n        [Category of hopf algebras with basis over Rational Field,\n         Category of finite dimensional algebras with basis over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(FiniteDimensionalHopfAlgebrasWithBasis(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "FiniteDimensional",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis",
            "sage.categories.finite_dimensional_algebras_with_basis.FiniteDimensionalAlgebrasWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite dimensional Hopf algebras with a\n    distinguished basis.\n\n    EXAMPLES::\n\n        sage: FiniteDimensionalHopfAlgebrasWithBasis(QQ) # fixme: Hopf should be capitalized\n        Category of finite dimensional hopf algebras with basis over Rational Field\n        sage: FiniteDimensionalHopfAlgebrasWithBasis(QQ).super_categories()\n        [Category of hopf algebras with basis over Rational Field,\n         Category of finite dimensional algebras with basis over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(FiniteDimensionalHopfAlgebrasWithBasis(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_dimensional_hopf_algebras_with_basis.FiniteDimensionalHopfAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of additive magmas.\n\n    An additive magma is a set endowed with a binary operation `+`.\n\n    EXAMPLES::\n\n        sage: AdditiveMagmas()\n        Category of additive magmas\n        sage: AdditiveMagmas().super_categories()\n        [Category of sets]\n        sage: AdditiveMagmas().all_super_categories()\n        [Category of additive magmas, Category of sets, Category of sets with partial maps, Category of objects]\n\n    The following axioms are defined by this category::\n\n        sage: AdditiveMagmas().AdditiveAssociative()\n        Category of additive semigroups\n        sage: AdditiveMagmas().AdditiveUnital()\n        Category of additive unital additive magmas\n        sage: AdditiveMagmas().AdditiveCommutative()\n        Category of additive commutative additive magmas\n        sage: AdditiveMagmas().AdditiveUnital().AdditiveInverse()\n        Category of additive inverse additive unital additive magmas\n        sage: AdditiveMagmas().AdditiveAssociative().AdditiveCommutative()\n        Category of commutative additive semigroups\n        sage: AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital()\n        Category of commutative additive monoids\n        sage: AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse()\n        Category of commutative additive groups\n\n    TESTS::\n\n        sage: C = AdditiveMagmas()\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {
                "__add__": {
                    "__doc__": "__add__(Element self, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 24)\n\n    Return the sum of ``self`` and ``right``.\n\n    This calls the ``_add_`` method of ``self``, if it is\n    available and the two elements have the same parent.\n\n    Otherwise, the job is delegated to the coercion model.\n\n    Do not override; instead implement an ``_add_`` method in the\n    element class or a ``summation`` method in the parent class.\n\n    .. SEEALSO:: :meth:`AdditiveMagmas.ElementMethods._add_`\n\n    EXAMPLES::\n\n        sage: F = CommutativeAdditiveSemigroups().example()\n        sage: (a,b,c,d) = F.additive_semigroup_generators()\n        sage: a + b\n        a + b\n        sage: a.__add__(b)\n        a + b\n\n    This is :meth:`AdditiveMagmas.ElementMethods.__add__`, implemented as a\n    Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: a.__add__.im_func is AdditiveMagmas.ElementMethods.__add__.im_func\n        True\n        sage: a.__add__.im_func is sage.categories.coercion_methods.__add__\n        True\n    ",
                    "args": [
                        "self",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__radd__": {
                    "__doc__": "__radd__(Element self, left)\nFile: sage/categories/coercion_methods.pyx (starting at line 60)\n\n    Handles the sum of two elements, when the left hand side\n    needs to be coerced first.\n\n    EXAMPLES::\n\n        sage: F = CommutativeAdditiveSemigroups().example()\n        sage: (a,b,c,d) = F.additive_semigroup_generators()\n        sage: a.__radd__(b)\n        a + b\n\n    This is :meth:`AdditiveMagmas.ElementMethods.__radd__`, implemented\n    as a Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: a.__radd__.im_func is AdditiveMagmas.ElementMethods.__radd__.im_func\n        True\n        sage: a.__radd__.im_func is sage.categories.coercion_methods.__radd__\n        True\n    ",
                    "args": [
                        "self",
                        "left"
                    ],
                    "argspec": [
                        [
                            "self",
                            "left"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_add_": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method _add_ at 0x7fe375eb2398>",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "\\+",
                    "mmt_name": "\u2218"
                },
                "_add_parent": {
                    "__doc__": "\n            Return the sum of the two elements, calculated using\n            the ``summation`` method of the parent.\n\n            This is the default implementation of _add_ if\n            ``summation`` is implemented in the parent.\n\n            INPUT:\n\n            - ``other`` -- an element of the parent of ``self``\n\n            OUTPUT:\n\n            - an element of the parent of ``self``\n\n            EXAMPLES::\n\n                sage: S = CommutativeAdditiveSemigroups().example()\n                sage: (a,b,c,d) = S.additive_semigroup_generators()\n                sage: a._add_parent(b)\n                a + b\n            ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": "Magma",
        "morphism_class": {
            "__doc__": "\n    The category of additive magmas.\n\n    An additive magma is a set endowed with a binary operation `+`.\n\n    EXAMPLES::\n\n        sage: AdditiveMagmas()\n        Category of additive magmas\n        sage: AdditiveMagmas().super_categories()\n        [Category of sets]\n        sage: AdditiveMagmas().all_super_categories()\n        [Category of additive magmas, Category of sets, Category of sets with partial maps, Category of objects]\n\n    The following axioms are defined by this category::\n\n        sage: AdditiveMagmas().AdditiveAssociative()\n        Category of additive semigroups\n        sage: AdditiveMagmas().AdditiveUnital()\n        Category of additive unital additive magmas\n        sage: AdditiveMagmas().AdditiveCommutative()\n        Category of additive commutative additive magmas\n        sage: AdditiveMagmas().AdditiveUnital().AdditiveInverse()\n        Category of additive inverse additive unital additive magmas\n        sage: AdditiveMagmas().AdditiveAssociative().AdditiveCommutative()\n        Category of commutative additive semigroups\n        sage: AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital()\n        Category of commutative additive monoids\n        sage: AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse()\n        Category of commutative additive groups\n\n    TESTS::\n\n        sage: C = AdditiveMagmas()\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "__init_extra__": {
                    "__doc__": "\n            TESTS::\n\n                sage: S = CommutativeAdditiveSemigroups().example()\n                sage: (a,b,c,d) = S.additive_semigroup_generators()\n                sage: a + b # indirect doctest\n                a + b\n                sage: a.__class__._add_ == a.__class__._add_parent\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "addition_table": {
                    "__doc__": "\n            Return a table describing the addition operation.\n\n            .. NOTE::\n\n                The order of the elements in the row and column\n                headings is equal to the order given by the table's\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`\n                method.  The association can also be retrieved with the\n                :meth:`~sage.matrix.operation_table.OperationTable.translation`\n                method.\n\n            INPUT:\n\n            - ``names`` -- the type of names used:\n\n              * ``'letters'`` - lowercase ASCII letters are used\n                for a base 26 representation of the elements'\n                positions in the list given by\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`,\n                padded to a common width with leading 'a's.\n              * ``'digits'`` - base 10 representation of the\n                elements' positions in the list given by\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`,\n                padded to a common width with leading zeros.\n              * ``'elements'`` - the string representations\n                of the elements themselves.\n              * a list - a list of strings, where the length\n                of the list equals the number of elements.\n\n            - ``elements`` -- (default: ``None``)  A list of\n              elements of the additive magma, in forms that\n              can be coerced into the structure, eg. their\n              string representations. This may be used to\n              impose an alternate ordering on the elements,\n              perhaps when this is used in the context of a\n              particular structure. The default is to use\n              whatever ordering the ``S.list`` method returns.\n              Or the ``elements`` can be a subset which is\n              closed under the operation. In particular,\n              this can be used when the base set is infinite.\n\n            OUTPUT:\n\n            The addition table as an object of the class\n            :class:`~sage.matrix.operation_table.OperationTable`\n            which defines several methods for manipulating and\n            displaying the table.  See the documentation there\n            for full details to supplement the documentation\n            here.\n\n            EXAMPLES:\n\n            All that is required is that an algebraic structure\n            has an addition defined.The default is to represent\n            elements as lowercase ASCII letters.  ::\n\n                sage: R=IntegerModRing(5)\n                sage: R.addition_table()\n                +  a b c d e\n                 +----------\n                a| a b c d e\n                b| b c d e a\n                c| c d e a b\n                d| d e a b c\n                e| e a b c d\n\n            The ``names`` argument allows displaying the elements in\n            different ways.  Requesting ``elements`` will use the\n            representation of the elements of the set.  Requesting\n            ``digits`` will include leading zeros as padding.  ::\n\n                sage: R=IntegerModRing(11)\n                sage: P=R.addition_table(names='elements')\n                sage: P\n                 +   0  1  2  3  4  5  6  7  8  9 10\n                  +---------------------------------\n                 0|  0  1  2  3  4  5  6  7  8  9 10\n                 1|  1  2  3  4  5  6  7  8  9 10  0\n                 2|  2  3  4  5  6  7  8  9 10  0  1\n                 3|  3  4  5  6  7  8  9 10  0  1  2\n                 4|  4  5  6  7  8  9 10  0  1  2  3\n                 5|  5  6  7  8  9 10  0  1  2  3  4\n                 6|  6  7  8  9 10  0  1  2  3  4  5\n                 7|  7  8  9 10  0  1  2  3  4  5  6\n                 8|  8  9 10  0  1  2  3  4  5  6  7\n                 9|  9 10  0  1  2  3  4  5  6  7  8\n                10| 10  0  1  2  3  4  5  6  7  8  9\n\n                sage: T=R.addition_table(names='digits')\n                sage: T\n                +  00 01 02 03 04 05 06 07 08 09 10\n                  +---------------------------------\n                00| 00 01 02 03 04 05 06 07 08 09 10\n                01| 01 02 03 04 05 06 07 08 09 10 00\n                02| 02 03 04 05 06 07 08 09 10 00 01\n                03| 03 04 05 06 07 08 09 10 00 01 02\n                04| 04 05 06 07 08 09 10 00 01 02 03\n                05| 05 06 07 08 09 10 00 01 02 03 04\n                06| 06 07 08 09 10 00 01 02 03 04 05\n                07| 07 08 09 10 00 01 02 03 04 05 06\n                08| 08 09 10 00 01 02 03 04 05 06 07\n                09| 09 10 00 01 02 03 04 05 06 07 08\n                10| 10 00 01 02 03 04 05 06 07 08 09\n\n            Specifying the elements in an alternative order can provide\n            more insight into how the operation behaves.  ::\n\n                sage: S=IntegerModRing(7)\n                sage: elts = [0, 3, 6, 2, 5, 1, 4]\n                sage: S.addition_table(elements=elts)\n                +  a b c d e f g\n                 +--------------\n                a| a b c d e f g\n                b| b c d e f g a\n                c| c d e f g a b\n                d| d e f g a b c\n                e| e f g a b c d\n                f| f g a b c d e\n                g| g a b c d e f\n\n            The ``elements`` argument can be used to provide\n            a subset of the elements of the structure.  The subset\n            must be closed under the operation.  Elements need only\n            be in a form that can be coerced into the set.  The\n            ``names`` argument can also be used to request that\n            the elements be represented with their usual string\n            representation.  ::\n\n                sage: T=IntegerModRing(12)\n                sage: elts=[0, 3, 6, 9]\n                sage: T.addition_table(names='elements', elements=elts)\n                +  0 3 6 9\n                 +--------\n                0| 0 3 6 9\n                3| 3 6 9 0\n                6| 6 9 0 3\n                9| 9 0 3 6\n\n            The table returned can be manipulated in various ways.  See\n            the documentation for\n            :class:`~sage.matrix.operation_table.OperationTable` for more\n            comprehensive documentation. ::\n\n                sage: R=IntegerModRing(3)\n                sage: T=R.addition_table()\n                sage: T.column_keys()\n                (0, 1, 2)\n                sage: sorted(T.translation().items())\n                [('a', 0), ('b', 1), ('c', 2)]\n                sage: T.change_names(['x', 'y', 'z'])\n                sage: sorted(T.translation().items())\n                [('x', 0), ('y', 1), ('z', 2)]\n                sage: T\n                +  x y z\n                 +------\n                x| x y z\n                y| y z x\n                z| z x y\n            ",
                    "args": [
                        "self",
                        "names",
                        "elements"
                    ],
                    "argspec": [
                        [
                            "self",
                            "names",
                            "elements"
                        ],
                        null,
                        null,
                        [
                            "letters",
                            null
                        ]
                    ]
                },
                "summation": {
                    "__doc__": "\n            Return the sum of ``x`` and ``y``.\n\n            The binary addition operator of this additive magma.\n\n            INPUT:\n\n             - ``x``, ``y`` -- elements of this additive magma\n\n            EXAMPLES::\n\n                sage: S = CommutativeAdditiveSemigroups().example()\n                sage: (a,b,c,d) = S.additive_semigroup_generators()\n                sage: S.summation(a, b)\n                a + b\n\n            A parent in ``AdditiveMagmas()`` must\n            either implement :meth:`.summation` in the parent class or\n            ``_add_`` in the element class. By default, the addition\n            method on elements ``x._add_(y)`` calls\n            ``S.summation(x,y)``, and reciprocally.\n\n            As a bonus effect, ``S.summation`` by itself models the\n            binary function from ``S`` to ``S``::\n\n                sage: bin = S.summation\n                sage: bin(a,b)\n                a + b\n\n            Here, ``S.summation`` is just a bound method. Whenever\n            possible, it is recommended to enrich ``S.summation`` with\n            extra mathematical structure. Lazy attributes can come\n            handy for this.\n\n            .. TODO:: Add an example.\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "summation_from_element_class_add": {
                    "__doc__": "\n            Return the sum of ``x`` and ``y``.\n\n            The binary addition operator of this additive magma.\n\n            INPUT:\n\n             - ``x``, ``y`` -- elements of this additive magma\n\n            EXAMPLES::\n\n                sage: S = CommutativeAdditiveSemigroups().example()\n                sage: (a,b,c,d) = S.additive_semigroup_generators()\n                sage: S.summation(a, b)\n                a + b\n\n            A parent in ``AdditiveMagmas()`` must\n            either implement :meth:`.summation` in the parent class or\n            ``_add_`` in the element class. By default, the addition\n            method on elements ``x._add_(y)`` calls\n            ``S.summation(x,y)``, and reciprocally.\n\n            As a bonus effect, ``S.summation`` by itself models the\n            binary function from ``S`` to ``S``::\n\n                sage: bin = S.summation\n                sage: bin(a,b)\n                a + b\n\n            Here, ``S.summation`` is just a bound method. Whenever\n            possible, it is recommended to enrich ``S.summation`` with\n            extra mathematical structure. Lazy attributes can come\n            handy for this.\n\n            .. TODO:: Add an example.\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "__add__": {
                    "__doc__": "__add__(Element self, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 24)\n\n    Return the sum of ``self`` and ``right``.\n\n    This calls the ``_add_`` method of ``self``, if it is\n    available and the two elements have the same parent.\n\n    Otherwise, the job is delegated to the coercion model.\n\n    Do not override; instead implement an ``_add_`` method in the\n    element class or a ``summation`` method in the parent class.\n\n    .. SEEALSO:: :meth:`AdditiveMagmas.ElementMethods._add_`\n\n    EXAMPLES::\n\n        sage: F = CommutativeAdditiveSemigroups().example()\n        sage: (a,b,c,d) = F.additive_semigroup_generators()\n        sage: a + b\n        a + b\n        sage: a.__add__(b)\n        a + b\n\n    This is :meth:`AdditiveMagmas.ElementMethods.__add__`, implemented as a\n    Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: a.__add__.im_func is AdditiveMagmas.ElementMethods.__add__.im_func\n        True\n        sage: a.__add__.im_func is sage.categories.coercion_methods.__add__\n        True\n    ",
                    "args": [
                        "self",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__radd__": {
                    "__doc__": "__radd__(Element self, left)\nFile: sage/categories/coercion_methods.pyx (starting at line 60)\n\n    Handles the sum of two elements, when the left hand side\n    needs to be coerced first.\n\n    EXAMPLES::\n\n        sage: F = CommutativeAdditiveSemigroups().example()\n        sage: (a,b,c,d) = F.additive_semigroup_generators()\n        sage: a.__radd__(b)\n        a + b\n\n    This is :meth:`AdditiveMagmas.ElementMethods.__radd__`, implemented\n    as a Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: a.__radd__.im_func is AdditiveMagmas.ElementMethods.__radd__.im_func\n        True\n        sage: a.__radd__.im_func is sage.categories.coercion_methods.__radd__\n        True\n    ",
                    "args": [
                        "self",
                        "left"
                    ],
                    "argspec": [
                        [
                            "self",
                            "left"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_add_": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method _add_ at 0x7fe375eb2398>",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "\\+",
                    "mmt_name": "\u2218"
                },
                "_add_parent": {
                    "__doc__": "\n            Return the sum of the two elements, calculated using\n            the ``summation`` method of the parent.\n\n            This is the default implementation of _add_ if\n            ``summation`` is implemented in the parent.\n\n            INPUT:\n\n            - ``other`` -- an element of the parent of ``self``\n\n            OUTPUT:\n\n            - an element of the parent of ``self``\n\n            EXAMPLES::\n\n                sage: S = CommutativeAdditiveSemigroups().example()\n                sage: (a,b,c,d) = S.additive_semigroup_generators()\n                sage: a._add_parent(b)\n                a + b\n            ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all chain complexes over a base ring.\n\n    EXAMPLES::\n\n        sage: ChainComplexes(RationalField())\n        Category of chain complexes over Rational Field\n\n        sage: ChainComplexes(Integers(9))\n        Category of chain complexes over Ring of integers modulo 9\n\n     TESTS::\n\n        sage: TestSuite(ChainComplexes(RationalField())).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of all chain complexes over a base ring.\n\n    EXAMPLES::\n\n        sage: ChainComplexes(RationalField())\n        Category of chain complexes over Rational Field\n\n        sage: ChainComplexes(Integers(9))\n        Category of chain complexes over Ring of integers modulo 9\n\n     TESTS::\n\n        sage: TestSuite(ChainComplexes(RationalField())).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of all chain complexes over a base ring.\n\n    EXAMPLES::\n\n        sage: ChainComplexes(RationalField())\n        Category of chain complexes over Rational Field\n\n        sage: ChainComplexes(Integers(9))\n        Category of chain complexes over Ring of integers modulo 9\n\n     TESTS::\n\n        sage: TestSuite(ChainComplexes(RationalField())).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.category_types.ChainComplexes",
        "parent_class": {
            "__doc__": "\n    The category of all chain complexes over a base ring.\n\n    EXAMPLES::\n\n        sage: ChainComplexes(RationalField())\n        Category of chain complexes over Rational Field\n\n        sage: ChainComplexes(Integers(9))\n        Category of chain complexes over Ring of integers modulo 9\n\n     TESTS::\n\n        sage: TestSuite(ChainComplexes(RationalField())).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.category_types.ChainComplexes",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of all chain complexes over a base ring.\n\n    EXAMPLES::\n\n        sage: ChainComplexes(RationalField())\n        Category of chain complexes over Rational Field\n\n        sage: ChainComplexes(Integers(9))\n        Category of chain complexes over Ring of integers modulo 9\n\n     TESTS::\n\n        sage: TestSuite(ChainComplexes(RationalField())).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of ideals in a fixed commutative algebra `A`.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAlgebraIdeals(QQ['x'])\n        sage: C\n        Category of commutative algebra ideals in Univariate Polynomial Ring in x over Rational Field\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of ideals in a fixed commutative algebra `A`.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAlgebraIdeals(QQ['x'])\n        sage: C\n        Category of commutative algebra ideals in Univariate Polynomial Ring in x over Rational Field\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebra_ideals.AlgebraIdeals"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of ideals in a fixed commutative algebra `A`.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAlgebraIdeals(QQ['x'])\n        sage: C\n        Category of commutative algebra ideals in Univariate Polynomial Ring in x over Rational Field\n    ",
            "methods": {}
        },
        "name": "sage.categories.commutative_algebra_ideals.CommutativeAlgebraIdeals",
        "parent_class": {
            "__doc__": "\n    The category of ideals in a fixed commutative algebra `A`.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAlgebraIdeals(QQ['x'])\n        sage: C\n        Category of commutative algebra ideals in Univariate Polynomial Ring in x over Rational Field\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.algebra_modules.AlgebraModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.commutative_algebra_ideals.CommutativeAlgebraIdeals",
            "sage.categories.algebra_ideals.AlgebraIdeals",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of ideals in a fixed commutative algebra `A`.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAlgebraIdeals(QQ['x'])\n        sage: C\n        Category of commutative algebra ideals in Univariate Polynomial Ring in x over Rational Field\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite Weyl groups.\n\n    EXAMPLES::\n\n        sage: C = FiniteWeylGroups()\n        sage: C\n        Category of finite weyl groups\n        sage: C.super_categories()\n        [Category of finite coxeter groups, Category of weyl groups]\n        sage: C.example()\n        The symmetric group on {0, ..., 3}\n\n    TESTS::\n\n        sage: W = FiniteWeylGroups().example()\n        sage: TestSuite(W).run()\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "FinitelyGeneratedAsMagma",
            "Unital",
            "Finite",
            "WellGenerated"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_coxeter_groups.FiniteCoxeterGroups",
            "sage.categories.weyl_groups.WeylGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite Weyl groups.\n\n    EXAMPLES::\n\n        sage: C = FiniteWeylGroups()\n        sage: C\n        Category of finite weyl groups\n        sage: C.super_categories()\n        [Category of finite coxeter groups, Category of weyl groups]\n        sage: C.example()\n        The symmetric group on {0, ..., 3}\n\n    TESTS::\n\n        sage: W = FiniteWeylGroups().example()\n        sage: TestSuite(W).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_weyl_groups.FiniteWeylGroups",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of two-sided ideals in a fixed algebra `A`.\n\n    EXAMPLES::\n\n        sage: AlgebraIdeals(QQ['a'])\n        Category of algebra ideals in Univariate Polynomial Ring in a over Rational Field\n\n    .. TODO::\n\n        - Add support for non commutative rings (this is currently not\n          supported by the subcategory :class:`AlgebraModules`).\n        - Make ``AlgebraIdeals(R)``, return ``CommutativeAlgebraIdeals(R)``\n          when ``R`` is commutative.\n        - If useful, implement ``AlgebraLeftIdeals`` and\n          ``AlgebraRightIdeals`` of which ``AlgebraIdeals``\n          would be a subcategory.\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of two-sided ideals in a fixed algebra `A`.\n\n    EXAMPLES::\n\n        sage: AlgebraIdeals(QQ['a'])\n        Category of algebra ideals in Univariate Polynomial Ring in a over Rational Field\n\n    .. TODO::\n\n        - Add support for non commutative rings (this is currently not\n          supported by the subcategory :class:`AlgebraModules`).\n        - Make ``AlgebraIdeals(R)``, return ``CommutativeAlgebraIdeals(R)``\n          when ``R`` is commutative.\n        - If useful, implement ``AlgebraLeftIdeals`` and\n          ``AlgebraRightIdeals`` of which ``AlgebraIdeals``\n          would be a subcategory.\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebra_modules.AlgebraModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of two-sided ideals in a fixed algebra `A`.\n\n    EXAMPLES::\n\n        sage: AlgebraIdeals(QQ['a'])\n        Category of algebra ideals in Univariate Polynomial Ring in a over Rational Field\n\n    .. TODO::\n\n        - Add support for non commutative rings (this is currently not\n          supported by the subcategory :class:`AlgebraModules`).\n        - Make ``AlgebraIdeals(R)``, return ``CommutativeAlgebraIdeals(R)``\n          when ``R`` is commutative.\n        - If useful, implement ``AlgebraLeftIdeals`` and\n          ``AlgebraRightIdeals`` of which ``AlgebraIdeals``\n          would be a subcategory.\n    ",
            "methods": {}
        },
        "name": "sage.categories.algebra_ideals.AlgebraIdeals",
        "parent_class": {
            "__doc__": "\n    The category of two-sided ideals in a fixed algebra `A`.\n\n    EXAMPLES::\n\n        sage: AlgebraIdeals(QQ['a'])\n        Category of algebra ideals in Univariate Polynomial Ring in a over Rational Field\n\n    .. TODO::\n\n        - Add support for non commutative rings (this is currently not\n          supported by the subcategory :class:`AlgebraModules`).\n        - Make ``AlgebraIdeals(R)``, return ``CommutativeAlgebraIdeals(R)``\n          when ``R`` is commutative.\n        - If useful, implement ``AlgebraLeftIdeals`` and\n          ``AlgebraRightIdeals`` of which ``AlgebraIdeals``\n          would be a subcategory.\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.algebra_modules.AlgebraModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.algebra_ideals.AlgebraIdeals",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of two-sided ideals in a fixed algebra `A`.\n\n    EXAMPLES::\n\n        sage: AlgebraIdeals(QQ['a'])\n        Category of algebra ideals in Univariate Polynomial Ring in a over Rational Field\n\n    .. TODO::\n\n        - Add support for non commutative rings (this is currently not\n          supported by the subcategory :class:`AlgebraModules`).\n        - Make ``AlgebraIdeals(R)``, return ``CommutativeAlgebraIdeals(R)``\n          when ``R`` is commutative.\n        - If useful, implement ``AlgebraLeftIdeals`` and\n          ``AlgebraRightIdeals`` of which ``AlgebraIdeals``\n          would be a subcategory.\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all schemes.\n\n    EXAMPLES::\n\n        sage: Schemes()\n        Category of schemes\n\n    ``Schemes`` can also be used to construct the category of schemes\n    over a given base::\n\n        sage: Schemes(Spec(ZZ))\n        Category of schemes over Integer Ring\n\n        sage: Schemes(ZZ)\n        Category of schemes over Integer Ring\n\n    .. TODO::\n\n        Make ``Schemes()`` a singleton category (and remove\n        :class:`Schemes` from the workaround in\n        :meth:`.category_types.Category_over_base._test_category_over_bases`).\n\n        This is currently incompatible with the dispatching below.\n\n    TESTS::\n\n        sage: TestSuite(Schemes()).run()\n\n    Check that Hom sets of schemes are in the correct category::\n\n        sage: Schemes().Homsets().super_categories()\n        [Category of homsets]\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of all schemes.\n\n    EXAMPLES::\n\n        sage: Schemes()\n        Category of schemes\n\n    ``Schemes`` can also be used to construct the category of schemes\n    over a given base::\n\n        sage: Schemes(Spec(ZZ))\n        Category of schemes over Integer Ring\n\n        sage: Schemes(ZZ)\n        Category of schemes over Integer Ring\n\n    .. TODO::\n\n        Make ``Schemes()`` a singleton category (and remove\n        :class:`Schemes` from the workaround in\n        :meth:`.category_types.Category_over_base._test_category_over_bases`).\n\n        This is currently incompatible with the dispatching below.\n\n    TESTS::\n\n        sage: TestSuite(Schemes()).run()\n\n    Check that Hom sets of schemes are in the correct category::\n\n        sage: Schemes().Homsets().super_categories()\n        [Category of homsets]\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of all schemes.\n\n    EXAMPLES::\n\n        sage: Schemes()\n        Category of schemes\n\n    ``Schemes`` can also be used to construct the category of schemes\n    over a given base::\n\n        sage: Schemes(Spec(ZZ))\n        Category of schemes over Integer Ring\n\n        sage: Schemes(ZZ)\n        Category of schemes over Integer Ring\n\n    .. TODO::\n\n        Make ``Schemes()`` a singleton category (and remove\n        :class:`Schemes` from the workaround in\n        :meth:`.category_types.Category_over_base._test_category_over_bases`).\n\n        This is currently incompatible with the dispatching below.\n\n    TESTS::\n\n        sage: TestSuite(Schemes()).run()\n\n    Check that Hom sets of schemes are in the correct category::\n\n        sage: Schemes().Homsets().super_categories()\n        [Category of homsets]\n    ",
            "methods": {}
        },
        "name": "sage.categories.schemes.Schemes",
        "parent_class": {
            "__doc__": "\n    The category of all schemes.\n\n    EXAMPLES::\n\n        sage: Schemes()\n        Category of schemes\n\n    ``Schemes`` can also be used to construct the category of schemes\n    over a given base::\n\n        sage: Schemes(Spec(ZZ))\n        Category of schemes over Integer Ring\n\n        sage: Schemes(ZZ)\n        Category of schemes over Integer Ring\n\n    .. TODO::\n\n        Make ``Schemes()`` a singleton category (and remove\n        :class:`Schemes` from the workaround in\n        :meth:`.category_types.Category_over_base._test_category_over_bases`).\n\n        This is currently incompatible with the dispatching below.\n\n    TESTS::\n\n        sage: TestSuite(Schemes()).run()\n\n    Check that Hom sets of schemes are in the correct category::\n\n        sage: Schemes().Homsets().super_categories()\n        [Category of homsets]\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.schemes.Schemes",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of all schemes.\n\n    EXAMPLES::\n\n        sage: Schemes()\n        Category of schemes\n\n    ``Schemes`` can also be used to construct the category of schemes\n    over a given base::\n\n        sage: Schemes(Spec(ZZ))\n        Category of schemes over Integer Ring\n\n        sage: Schemes(ZZ)\n        Category of schemes over Integer Ring\n\n    .. TODO::\n\n        Make ``Schemes()`` a singleton category (and remove\n        :class:`Schemes` from the workaround in\n        :meth:`.category_types.Category_over_base._test_category_over_bases`).\n\n        This is currently incompatible with the dispatching below.\n\n    TESTS::\n\n        sage: TestSuite(Schemes()).run()\n\n    Check that Hom sets of schemes are in the correct category::\n\n        sage: Schemes().Homsets().super_categories()\n        [Category of homsets]\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of matrix algebras over a field.\n\n    EXAMPLES::\n\n        sage: MatrixAlgebras(RationalField())\n        Category of matrix algebras over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(MatrixAlgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of matrix algebras over a field.\n\n    EXAMPLES::\n\n        sage: MatrixAlgebras(RationalField())\n        Category of matrix algebras over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(MatrixAlgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of matrix algebras over a field.\n\n    EXAMPLES::\n\n        sage: MatrixAlgebras(RationalField())\n        Category of matrix algebras over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(MatrixAlgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.matrix_algebras.MatrixAlgebras",
        "parent_class": {
            "__doc__": "\n    The category of matrix algebras over a field.\n\n    EXAMPLES::\n\n        sage: MatrixAlgebras(RationalField())\n        Category of matrix algebras over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(MatrixAlgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.matrix_algebras.MatrixAlgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of matrix algebras over a field.\n\n    EXAMPLES::\n\n        sage: MatrixAlgebras(RationalField())\n        Category of matrix algebras over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(MatrixAlgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of modules over a fixed algebra $A$.\n\n    EXAMPLES::\n\n        sage: AlgebraModules(QQ['a'])\n        Category of algebra modules over Univariate Polynomial Ring in a over Rational Field\n        sage: AlgebraModules(QQ['a']).super_categories()\n        [Category of modules over Univariate Polynomial Ring in a over Rational Field]\n\n    Note: as of now, `A` is required to be commutative, ensuring that\n    the categories of left and right modules are isomorphic. Feedback\n    and use cases for potential generalizations to the non commutative\n    case are welcome.\n\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of modules over a fixed algebra $A$.\n\n    EXAMPLES::\n\n        sage: AlgebraModules(QQ['a'])\n        Category of algebra modules over Univariate Polynomial Ring in a over Rational Field\n        sage: AlgebraModules(QQ['a']).super_categories()\n        [Category of modules over Univariate Polynomial Ring in a over Rational Field]\n\n    Note: as of now, `A` is required to be commutative, ensuring that\n    the categories of left and right modules are isomorphic. Feedback\n    and use cases for potential generalizations to the non commutative\n    case are welcome.\n\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of modules over a fixed algebra $A$.\n\n    EXAMPLES::\n\n        sage: AlgebraModules(QQ['a'])\n        Category of algebra modules over Univariate Polynomial Ring in a over Rational Field\n        sage: AlgebraModules(QQ['a']).super_categories()\n        [Category of modules over Univariate Polynomial Ring in a over Rational Field]\n\n    Note: as of now, `A` is required to be commutative, ensuring that\n    the categories of left and right modules are isomorphic. Feedback\n    and use cases for potential generalizations to the non commutative\n    case are welcome.\n\n    ",
            "methods": {}
        },
        "name": "sage.categories.algebra_modules.AlgebraModules",
        "parent_class": {
            "__doc__": "\n    The category of modules over a fixed algebra $A$.\n\n    EXAMPLES::\n\n        sage: AlgebraModules(QQ['a'])\n        Category of algebra modules over Univariate Polynomial Ring in a over Rational Field\n        sage: AlgebraModules(QQ['a']).super_categories()\n        [Category of modules over Univariate Polynomial Ring in a over Rational Field]\n\n    Note: as of now, `A` is required to be commutative, ensuring that\n    the categories of left and right modules are isomorphic. Feedback\n    and use cases for potential generalizations to the non commutative\n    case are welcome.\n\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.algebra_modules.AlgebraModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of modules over a fixed algebra $A$.\n\n    EXAMPLES::\n\n        sage: AlgebraModules(QQ['a'])\n        Category of algebra modules over Univariate Polynomial Ring in a over Rational Field\n        sage: AlgebraModules(QQ['a']).super_categories()\n        [Category of modules over Univariate Polynomial Ring in a over Rational Field]\n\n    Note: as of now, `A` is required to be commutative, ensuring that\n    the categories of left and right modules are isomorphic. Feedback\n    and use cases for potential generalizations to the non commutative\n    case are welcome.\n\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of additive abelian semigroups, i.e. sets with an\n    associative and abelian operation +.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveSemigroups(); C\n        Category of commutative additive semigroups\n        sage: C.example()\n        An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd')\n\n        sage: sorted(C.super_categories(), key=str)\n        [Category of additive commutative additive magmas,\n         Category of additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative"
        ],
        "element_class": {
            "__doc__": "\n    The category of additive abelian semigroups, i.e. sets with an\n    associative and abelian operation +.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveSemigroups(); C\n        Category of commutative additive semigroups\n        sage: C.example()\n        An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd')\n\n        sage: sorted(C.super_categories(), key=str)\n        [Category of additive commutative additive magmas,\n         Category of additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative",
            "sage.categories.additive_semigroups.AdditiveSemigroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of additive abelian semigroups, i.e. sets with an\n    associative and abelian operation +.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveSemigroups(); C\n        Category of commutative additive semigroups\n        sage: C.example()\n        An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd')\n\n        sage: sorted(C.super_categories(), key=str)\n        [Category of additive commutative additive magmas,\n         Category of additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.commutative_additive_semigroups.CommutativeAdditiveSemigroups",
        "parent_class": {
            "__doc__": "\n    The category of additive abelian semigroups, i.e. sets with an\n    associative and abelian operation +.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveSemigroups(); C\n        Category of commutative additive semigroups\n        sage: C.example()\n        An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd')\n\n        sage: sorted(C.super_categories(), key=str)\n        [Category of additive commutative additive magmas,\n         Category of additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of additive abelian semigroups, i.e. sets with an\n    associative and abelian operation +.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveSemigroups(); C\n        Category of commutative additive semigroups\n        sage: C.example()\n        An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd')\n\n        sage: sorted(C.super_categories(), key=str)\n        [Category of additive commutative additive magmas,\n         Category of additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.groups.Groups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.permutation_groups.PermutationGroups",
        "parent_class": {
            "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.permutation_groups.PermutationGroups",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of permutation groups.\n\n    A *permutation group* is a group whose elements are concretely\n    represented by permutations of some set. In other words, the group\n    comes endowed with a distinguished action on some set.\n\n    This distinguished action should be preserved by permutation group\n    morphisms. For details, see\n    :Wikipedia:`Permutation_group#Permutation_isomorphic_groups`.\n\n    .. TODO:: shall we accept only permutations with finite support or not?\n\n    EXAMPLES::\n\n        sage: PermutationGroups()\n        Category of permutation groups\n        sage: PermutationGroups().super_categories()\n        [Category of groups]\n\n    The category of permutation groups defines additional structure\n    that should be preserved by morphisms, namely the distinguished\n    action::\n\n        sage: PermutationGroups().additional_structure()\n        Category of permutation groups\n\n    TESTS::\n\n        sage: C = PermutationGroups()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of modules with a distinguished basis.\n\n    The elements are represented by expanding them in the distinguished basis.\n    The morphisms are not required to respect the distinguished basis.\n\n    EXAMPLES::\n\n        sage: ModulesWithBasis(ZZ)\n        Category of modules with basis over Integer Ring\n        sage: ModulesWithBasis(ZZ).super_categories()\n        [Category of modules over Integer Ring]\n\n    If the base ring is actually a field, this constructs instead the\n    category of vector spaces with basis::\n\n        sage: ModulesWithBasis(QQ)\n        Category of vector spaces with basis over Rational Field\n\n        sage: ModulesWithBasis(QQ).super_categories()\n        [Category of modules with basis over Rational Field,\n         Category of vector spaces over Rational Field]\n\n    Let `X` and `Y` be two modules with basis. We can build `Hom(X,Y)`::\n\n        sage: X = CombinatorialFreeModule(QQ, [1,2]); X.__custom_name = \"X\"\n        sage: Y = CombinatorialFreeModule(QQ, [3,4]); Y.__custom_name = \"Y\"\n        sage: H = Hom(X, Y); H\n        Set of Morphisms from X to Y in Category of finite dimensional vector spaces with basis over Rational Field\n\n    The simplest morphism is the zero map::\n\n        sage: H.zero()         # todo: move this test into module once we have an example\n        Generic morphism:\n          From: X\n          To:   Y\n\n    which we can apply to elements of `X`::\n\n        sage: x = X.monomial(1) + 3 * X.monomial(2)\n        sage: H.zero()(x)\n        0\n\n    EXAMPLES:\n\n    We now construct a more interesting morphism by extending a\n    function by linearity::\n\n        sage: phi = H(on_basis = lambda i: Y.monomial(i+2)); phi\n        Generic morphism:\n          From: X\n          To:   Y\n        sage: phi(x)\n        B[3] + 3*B[4]\n\n    We can retrieve the function acting on indices of the basis::\n\n        sage: f = phi.on_basis()\n        sage: f(1), f(2)\n        (B[3], B[4])\n\n    `Hom(X,Y)` has a natural module structure (except for the zero,\n    the operations are not yet implemented though). However since the\n    dimension is not necessarily finite, it is not a module with\n    basis; but see :class:`FiniteDimensionalModulesWithBasis` and\n    :class:`GradedModulesWithBasis`::\n\n        sage: H in ModulesWithBasis(QQ), H in Modules(QQ)\n        (False, True)\n\n    Some more playing around with categories and higher order homsets::\n\n        sage: H.category()\n        Category of homsets of modules with basis over Rational Field\n        sage: Hom(H, H).category()\n        Category of endsets of homsets of modules with basis over Rational Field\n\n    .. TODO:: ``End(X)`` is an algebra.\n\n    .. NOTE::\n\n        This category currently requires an implementation of an\n        element method ``support``. Once :trac:`18066` is merged, an\n        implementation of an ``items`` method will be required.\n\n    TESTS::\n\n        sage: f = H.zero().on_basis()\n        sage: f(1)\n        0\n        sage: f(2)\n        0\n\n        sage: TestSuite(ModulesWithBasis(ZZ)).run()\n\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "__getitem__": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self``.\n\n            EXAMPLES::\n\n                sage: p = Partition([2,1])\n                sage: q = Partition([1,1,1])\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s(p)\n                sage: a._coefficient_fast([2,1])\n                Traceback (most recent call last):\n                ...\n                TypeError: unhashable type: 'list'\n\n            ::\n\n                sage: a._coefficient_fast(p)\n                1\n                sage: a._coefficient_fast(q)\n                0\n                sage: a[p]\n                1\n                sage: a[q]\n                0\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__len__": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: len(f)\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: len(z)\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficient": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self`` and raise an error\n            if ``m`` is not in the basis indexing set.\n\n            INPUT:\n\n            - ``m`` -- a basis index of the parent of ``self``\n\n            OUTPUT:\n\n            The ``B[m]``-coordinate of ``self`` with respect to the basis\n            ``B``. Here, ``B`` denotes the given basis of the parent of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: s = CombinatorialFreeModule(QQ, Partitions())\n                sage: z = s([4]) - 2*s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficient([4])\n                1\n                sage: z.coefficient([2,1])\n                -2\n                sage: z.coefficient(Partition([2,1]))\n                -2\n                sage: z.coefficient([1,2])\n                Traceback (most recent call last):\n                ...\n                AssertionError: [1, 2] should be an element of Partitions\n                sage: z.coefficient(Composition([2,1]))\n                Traceback (most recent call last):\n                ...\n                AssertionError: [2, 1] should be an element of Partitions\n\n            Test that ``coefficient`` also works for those parents that do\n            not yet have an element_class::\n\n                sage: G = DihedralGroup(3)\n                sage: F = CombinatorialFreeModule(QQ, G)\n                sage: hasattr(G, \"element_class\")\n                False\n                sage: g = G.an_element()\n                sage: (2*F.monomial(g)).coefficient(g)\n                2\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficients": {
                    "__doc__": "\n            Return a list of the (non-zero) coefficients appearing on\n            the basis elements in ``self`` (in an arbitrary order).\n\n            INPUT:\n\n            - ``sort`` -- (default: ``True``) to sort the coefficients\n              based upon the default ordering of the indexing set\n\n            .. SEEALSO::\n\n                :meth:`~sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis.ElementMethods.dense_coefficient_list`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.coefficients()\n                [1, -3]\n                sage: f = B['c'] - 3*B['a']\n                sage: f.coefficients()\n                [-3, 1]\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficients()\n                [1, 1, 1, 1]\n            ",
                    "args": [
                        "self",
                        "sort"
                    ],
                    "argspec": [
                        [
                            "self",
                            "sort"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "is_zero": {
                    "__doc__": "\n            Return ``True`` if and only if ``self == 0``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.is_zero()\n                False\n                sage: F.zero().is_zero()\n                True\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: s([2,1]).is_zero()\n                False\n                sage: s(0).is_zero()\n                True\n                sage: (s([2,1]) - s([2,1])).is_zero()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "leading_coefficient": {
                    "__doc__": "\n            Returns the leading coefficient of ``self``.\n\n            This is the coefficient of the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\")\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_coefficient()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_coefficient(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_coefficient()\n                -5\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_item": {
                    "__doc__": "\n            Return the pair ``(k, c)`` where\n\n            .. MATH::\n\n                c \\cdot (\\mbox{the basis element indexed by } k)\n\n            is the leading term of ``self``.\n\n            Here 'leading term' means that the corresponding basis element is\n            maximal.  Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be\n            provided.  This should return a negative value if ``x < y``, ``0``\n            if ``x == y`` and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_item()\n                (3, 4)\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_item(cmp=cmp)\n                (1, 3)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_item()\n                ([3], -5)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_monomial": {
                    "__doc__": "\n            Return the leading monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_monomial()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_monomial(cmp=cmp)\n                B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_monomial()\n                s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_support": {
                    "__doc__": "\n            Return the maximal element of the support of ``self``. Note\n            that this may not be the term which actually appears first when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_support()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_support(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_support()\n                [3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_term": {
                    "__doc__": "\n            Return the leading term of ``self``.\n\n            This is the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_term()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_term(cmp=cmp)\n                3*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_term()\n                -5*s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "length": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.length()\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.length()\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_coefficients": {
                    "__doc__": "\n            Mapping a function on coefficients.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the coefficient ring of the\n              free module\n\n            Return a new element of ``self.parent()`` obtained by applying the\n            function ``f`` to all of the coefficients of ``self``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.map_coefficients(lambda x: x+5)\n                6*B['a'] + 2*B['c']\n\n            Killed coefficients are handled properly::\n\n                sage: f.map_coefficients(lambda x: 0)\n                0\n                sage: list(f.map_coefficients(lambda x: 0))\n                []\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_coefficients(lambda x: x*2)\n                2*s[2, 1] + 4*s[3, 2]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_item": {
                    "__doc__": "\n            Mapping a function on items.\n\n            INPUT:\n\n            - ``f`` -- a function mapping pairs ``(index, coeff)`` to\n              other such pairs\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function `f` to all items ``(index, coeff)`` of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_item(lambda i, c: (-i, 2*c))\n                6*B[-1] + 4*B[0] + 4*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_item(lambda i, c: (1, 2*c))\n                14*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = lambda m,c: (m.conjugate(), 2*c)\n                sage: a = s([2,1]) + s([1,1,1])\n                sage: a.map_item(f)\n                2*s[2, 1] + 2*s[3]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function ``f`` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support(lambda i: -i)\n                3*B[-1] + 2*B[0] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support(lambda i: 1)\n                7*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_support(lambda x: x.conjugate())\n                s[2, 1] + 2*s[2, 2, 1]\n\n            TESTS::\n\n                sage: B.zero()      # This actually failed at some point!!! See #8890\n                0\n\n                sage: y = B.zero().map_support(lambda i: i/0); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support_skip_none": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Returns a new element of ``self.parent()`` obtained by\n            applying the function `f` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support_skip_none(lambda i: -i if i else None)\n                3*B[-1] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support_skip_none(lambda i: 1 if i else None)\n                5*B[1]\n\n            TESTS::\n\n                sage: y = x.map_support_skip_none(lambda i: None); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "monomial_coefficients": {
                    "__doc__": "\n            Return a dictionary whose keys are indices of basis elements\n            in the support of ``self`` and whose values are the\n            corresponding coefficients.\n\n            INPUT:\n\n            - ``copy`` -- (default: ``True``) if ``self`` is internally\n              represented by a dictionary ``d``, then make a copy of ``d``;\n              if ``False``, then this can cause undesired behavior by\n              mutating ``d``\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a']\n                1\n                sage: d['c']\n                3\n\n            TESTS:\n\n            We check that we make a copy of the coefficient dictionary::\n\n                sage: F = CombinatorialFreeModule(ZZ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a'] = 5\n                sage: f\n                B['a'] + 3*B['c']\n            ",
                    "args": [
                        "self",
                        "copy"
                    ],
                    "argspec": [
                        [
                            "self",
                            "copy"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "monomials": {
                    "__doc__": "\n            Return a list of the monomials of ``self`` (in an arbitrary\n            order).\n\n            The monomials of an element `a` are defined to be the basis\n            elements whose corresponding coefficients of `a` are\n            non-zero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.monomials()\n                [B['a'], B['c']]\n\n                sage: (F.zero()).monomials()\n                []\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support": {
                    "__doc__": "\n            Return a list of the objects indexing the basis of\n            ``self.parent()`` whose corresponding coefficients of\n            ``self`` are non-zero.\n\n            This method returns these objects in an arbitrary order.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: sorted(f.support())\n                ['a', 'c']\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: sorted(z.support())\n                [[1], [1, 1, 1], [2, 1], [4]]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support_of_term": {
                    "__doc__": "\n            Return the support of ``self``, where ``self`` is a monomial\n            (possibly with coefficient).\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3,4]); X.rename(\"X\")\n                sage: X.monomial(2).support_of_term()\n                2\n                sage: X.term(3, 2).support_of_term()\n                3\n\n            An exception is raised if ``self`` has more than one term::\n\n                sage: (X.monomial(2) + X.monomial(3)).support_of_term()\n                Traceback (most recent call last):\n                ...\n                ValueError: B[2] + B[3] is not a single term\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "tensor": {
                    "__doc__": "\n            Return the tensor product of its arguments, as an element of\n            the tensor product of the parents of those elements.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example()\n                sage: (a,b,c) = A.algebra_generators()\n                sage: a.tensor(b, c)\n                B[word: a] # B[word: b] # B[word: c]\n\n            FIXME: is this a policy that we want to enforce on all parents?\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "elements",
                        null,
                        null
                    ]
                },
                "terms": {
                    "__doc__": "\n            Return a list of the (non-zero) terms of ``self`` (in an\n            arbitrary order).\n\n            .. SEEALSO:: :meth:`monomials`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.terms()\n                [B['a'], 2*B['c']]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "trailing_coefficient": {
                    "__doc__": "\n            Return the trailing coefficient of ``self``.\n\n            This is the coefficient of the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_coefficient()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_coefficient(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_coefficient()\n                2\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_item": {
                    "__doc__": "\n            Returns the pair ``(c, k)`` where ``c*self.parent().monomial(k)``\n            is the trailing term of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_item()\n                (1, 3)\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_item(cmp=cmp)\n                (3, 1)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_item()\n                ([1], 2)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_monomial": {
                    "__doc__": "\n            Return the trailing monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_monomial()\n                B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_monomial(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_monomial()\n                s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_support": {
                    "__doc__": "\n            Return the minimal element of the support of ``self``. Note\n            that this may not be the term which actually appears last when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, `0` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.trailing_support()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_support(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_support()\n                [1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_term": {
                    "__doc__": "\n            Return the trailing term of ``self``.\n\n            This is the term whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_term()\n                3*B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_term(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_term()\n                2*s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {
                "_on_basis": {
                    "__doc__": "\n            Return the image of ``self`` on the basis element indexed by ``i``.\n\n            INPUT:\n\n            - ``i`` -- the index of an element of the basis of the domain of ``self``\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3]); X.rename(\"X\")\n                sage: phi = End(X)(lambda x: 2*x)\n                sage: phi._on_basis(3)\n                2*B[3]\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "on_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_apply_module_endomorphism": {
                    "__doc__": "\n            This takes in a function ``on_basis`` from the basis indices\n            to the elements of ``self``, and applies it linearly to ``x``.\n\n            EXAMPLES::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = lambda part: 2*s(part.conjugate())\n                sage: s._apply_module_endomorphism( s([2,1]) + s([1,1,1]), f)\n                2*s[2, 1] + 2*s[3]\n            ",
                    "args": [
                        "self",
                        "x",
                        "on_basis"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "on_basis"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_apply_module_morphism": {
                    "__doc__": "\n            Return the image of ``x`` under the module morphism defined by\n            extending :func:`on_basis` by linearity.\n\n            INPUT:\n\n            - ``x`` -- a element of ``self``\n\n            - ``on_basis`` -- a function that takes in an object indexing\n              a basis element and returns an element of the codomain\n\n            - ``codomain`` -- (optional) the codomain of the morphism (by\n              default, it is computed using :func:`on_basis`)\n\n            If ``codomain`` is not specified, then the function tries to\n            compute the codomain of the module morphism by finding the image\n            of one of the elements in the support; hence :func:`on_basis`\n            should return an element whose parent is the codomain.\n\n            EXAMPLES::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([3]) + s([2,1]) + s([1,1,1])\n                sage: b = 2*a\n                sage: f = lambda part: Integer( len(part) )\n                sage: s._apply_module_morphism(a, f) #1+2+3\n                6\n                sage: s._apply_module_morphism(b, f) #2*(1+2+3)\n                12\n                sage: s._apply_module_morphism(s(0), f)\n                0\n                sage: s._apply_module_morphism(s(1), f)\n                0\n                sage: s._apply_module_morphism(s(1), lambda part: len(part), ZZ)\n                0\n                sage: s._apply_module_morphism(s(1), lambda part: len(part))\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain could not be determined\n            ",
                    "args": [
                        "self",
                        "x",
                        "on_basis",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "on_basis",
                            "codomain"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "_module_morphism": {
                    "__doc__": "\n            Construct a module morphism from ``self`` to ``codomain``.\n\n            Let ``self`` be a module `X` with a basis indexed by `I`.\n            This constructs a morphism `f: X \\to Y` by linearity from\n            a map `I \\to Y` which is to be its restriction to the\n            basis `(x_i)_{i \\in I}` of `X`. Some variants are possible\n            too.\n\n            INPUT:\n\n            - ``self`` -- a parent `X` in ``ModulesWithBasis(R)`` with\n              basis `x=(x_i)_{i\\in I}`.\n\n            Exactly one of the four following options must be\n            specified in order to define the morphism:\n\n            - ``on_basis`` -- a function `f` from `I` to `Y`\n            - ``diagonal`` -- a function `d` from `I` to `R`\n            - ``function`` -- a function `f` from `X` to `Y`\n            - ``matrix``   -- a matrix of size `\\dim Y \\times \\dim X`\n              (if the keyword ``side`` is set to ``'left'``) or\n              `\\dim Y \\times \\dim X` (if this keyword is ``'right'``)\n\n            Further options include:\n\n            - ``codomain`` -- the codomain `Y` of the morphism (default:\n              ``f.codomain()`` if it's defined; otherwise it must be specified)\n\n            - ``category`` -- a category or ``None`` (default: `None``)\n\n            - ``zero`` -- the zero of the codomain (default: ``codomain.zero()``);\n              can be used (with care) to define affine maps.\n              Only meaningful with ``on_basis``.\n\n            - ``position`` -- a non-negative integer specifying which\n              positional argument in used as the input of the function `f`\n              (default: 0); this is currently only used with ``on_basis``.\n\n            - ``triangular`` --  (default: ``None``) ``\"upper\"`` or\n              ``\"lower\"`` or ``None``:\n\n              * ``\"upper\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.leading_support`\n                of the image of the basis vector `x_i` is `i`, or\n\n              * ``\"lower\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.trailing_support`\n                of the image of the basis vector `x_i` is `i`.\n\n            - ``unitriangular`` -- (default: ``False``) a boolean.\n              Only meaningful for a triangular morphism.\n              As a shorthand, one may use ``unitriangular=\"lower\"``\n              for ``triangular=\"lower\", unitriangular=True``.\n\n            - ``side`` -- \"left\" or \"right\" (default: \"left\")\n              Only meaningful for a morphism built from a matrix.\n\n            EXAMPLES:\n\n            With the ``on_basis`` option, this returns a function `g`\n            obtained by extending `f` by linearity on the\n            ``position``-th positional argument. For example, for\n            ``position == 1`` and a ternary function `f`, one has:\n\n            .. MATH::\n\n                g\\left( a,\\ \\sum_i \\lambda_i x_i,\\ c \\right)\n                = \\sum_i \\lambda_i f(a, i, c).\n\n            ::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1), codomain = Y)\n                sage: x = X.basis(); y = Y.basis()\n                sage: phi(x[1] + x[3])\n                B[1] + 2*B[2] + B[3] + 2*B[4]\n\n                sage: phi\n                Generic morphism:\n                From: X\n                To:   Y\n\n            By default, the category is the first of\n            ``Modules(R).WithBasis().FiniteDimensional()``,\n            ``Modules(R).WithBasis()``, ``Modules(R)``, and\n            ``CommutativeAdditiveMonoids()`` that contains both the\n            domain and the codomain::\n\n                sage: phi.category_for()\n                Category of finite dimensional vector spaces with basis over Rational Field\n\n            With the ``zero`` argument, one can define affine morphisms::\n\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1),\n                ....:                         codomain = Y, zero = 10*y[1])\n                sage: phi(x[1] + x[3])\n                11*B[1] + 2*B[2] + B[3] + 2*B[4]\n\n            In this special case, the default category is ``Sets()``::\n\n                sage: phi.category_for()\n                Category of sets\n\n            One can construct morphisms with the base ring as codomain::\n\n                sage: X = CombinatorialFreeModule(ZZ,[1,-1])\n                sage: phi = X.module_morphism( on_basis=lambda i: i, codomain=ZZ )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (ZZ is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n            Or more generaly any ring admitting a coercion map from\n            the base ring::\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=RR )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1.00000000000000\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (RR is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                3\n\n                sage: phi = Y.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Ring of integers modulo 4) should be a module over the base ring of the domain(=Y)\n\n            On can also define module morphisms between free modules\n            over different base rings; here we implement the natural\n            map from `X = \\RR^2` to `Y = \\CC`::\n\n                sage: X = CombinatorialFreeModule(RR,['x','y'])\n                sage: Y = CombinatorialFreeModule(CC,['z'])\n                sage: x = X.monomial('x')\n                sage: y = X.monomial('y')\n                sage: z = Y.monomial('z')\n                sage: def on_basis( a ):\n                ....:     if a == 'x':\n                ....:         return CC(1) * z\n                ....:     elif a == 'y':\n                ....:         return CC(I) * z\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: v = 3 * x + 2 * y; v\n                3.00000000000000*B['x'] + 2.00000000000000*B['y']\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (CC is currently not in Modules(RR)!)\n                Category of vector spaces over Real Field with 53 bits of precision\n\n                sage: Y = CombinatorialFreeModule(CC['q'],['z'])\n                sage: z = Y.monomial('z')\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n\n            Of course, there should be a coercion between the\n            respective base rings of the domain and the codomain for\n            this to be meaningful::\n\n                sage: Y = CombinatorialFreeModule(QQ,['z'])\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'z'} over Rational Field)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n\n                sage: Y = CombinatorialFreeModule(RR['q'],['z'])\n                sage: phi = Y.module_morphism( on_basis=on_basis, codomain=X )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'z'} over Univariate Polynomial Ring in q over Real Field with 53 bits of precision)\n\n\n            With the ``diagonal=d`` argument, this constructs the\n            module morphism `g` such that\n\n            .. MATH::\n\n                `g(x_i) = d(i) y_i`.\n\n            This assumes that the respective bases `x` and `y` of `X`\n            and `Y` have the same index set `I`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, codomain=X)\n                sage: x = X.basis()\n                sage: phi(x[1]), phi(x[2]), phi(x[3])\n                (B[1], 2*B[2], 6*B[3])\n\n            See also: :class:`sage.modules.with_basis.morphism.DiagonalModuleMorphism`.\n\n            With the ``matrix=m`` argument, this constructs the module\n            morphism whose matrix in the distinguished basis of `X`\n            and `Y` is `m`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(ZZ, [3,4]); Y.rename(\"Y\"); y = Y.basis()\n                sage: m = matrix([[0,1,2],[3,5,0]])\n                sage: phi = X.module_morphism(matrix=m, codomain=Y)\n                sage: phi(x[1])\n                3*B[4]\n                sage: phi(x[2])\n                B[3] + 5*B[4]\n\n\n            See also: :class:`sage.modules.with_basis.morphism.ModuleMorphismFromMatrix`.\n\n            With ``triangular=\"upper\"``, the constructed module morphism is\n            assumed to be upper triangular; that is its matrix in the\n            distinguished basis of `X` and `Y` would be upper triangular with\n            invertible elements on its diagonal. This is used to compute\n            preimages and to invert the morphism::\n\n                sage: I = range(1,200)\n                sage: X = CombinatorialFreeModule(QQ, I); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(QQ, I); Y.rename(\"Y\"); y = Y.basis()\n                sage: f = Y.sum_of_monomials * divisors\n                sage: phi = X.module_morphism(f, triangular=\"upper\", codomain = Y)\n                sage: phi(x[2])\n                B[1] + B[2]\n                sage: phi(x[6])\n                B[1] + B[2] + B[3] + B[6]\n                sage: phi(x[30])\n                B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]\n                sage: phi.preimage(y[2])\n                -B[1] + B[2]\n                sage: phi.preimage(y[6])\n                B[1] - B[2] - B[3] + B[6]\n                sage: phi.preimage(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n                sage: (phi^-1)(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n\n            Since :trac:`8678`, one can also define a triangular\n            morphism from a function::\n\n                sage: X = CombinatorialFreeModule(QQ, [0,1,2,3,4]); x = X.basis()\n                sage: from sage.modules.with_basis.morphism import TriangularModuleMorphismFromFunction\n                sage: def f(x): return x + X.term(0, sum(x.coefficients()))\n                sage: phi = X.module_morphism(function=f, codomain=X, triangular=\"upper\")\n                sage: phi(x[2] + 3*x[4])\n                4*B[0] + B[2] + 3*B[4]\n                sage: phi.preimage(_)\n                B[2] + 3*B[4]\n\n            For details and further optional arguments, see\n            :class:`sage.modules.with_basis.morphism.TriangularModuleMorphism`.\n\n            .. WARNING::\n\n                As a temporary measure, until multivariate morphisms\n                are implemented, the constructed morphism is in\n                ``Hom(codomain, domain, category)``. This is only\n                correct for unary functions.\n\n            .. TODO::\n\n               - Should codomain be ``self`` by default in the\n                 diagonal, triangular, and matrix cases?\n\n               - Support for diagonal morphisms between modules not\n                 sharing the same index set\n\n            TESTS::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, matrix=matrix(), codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(matrix=factorial, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: matrix (=factorial) should be a matrix\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=3, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: diagonal (=3) should be a function\n\n            ",
                    "args": [
                        "self",
                        "on_basis",
                        "matrix",
                        "function",
                        "diagonal",
                        "triangular",
                        "unitriangular"
                    ],
                    "argspec": [
                        [
                            "self",
                            "on_basis",
                            "matrix",
                            "function",
                            "diagonal",
                            "triangular",
                            "unitriangular"
                        ],
                        null,
                        "keywords",
                        [
                            null,
                            null,
                            null,
                            null,
                            null,
                            false
                        ]
                    ]
                },
                "_repr_": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: class FooBar(CombinatorialFreeModule): pass\n                sage: C = FooBar(QQ, (1,2,3)); C # indirect doctest\n                Free module generated by {1, 2, 3} over Rational Field\n\n                sage: C._name = \"foobar\"; C\n                foobar over Rational Field\n\n                sage: C.rename(\"barfoo\"); C\n                barfoo\n\n                sage: class FooBar(Parent):\n                ....:     def basis(self): return Family({1:\"foo\", 2:\"bar\"})\n                ....:     def base_ring(self): return QQ\n                sage: FooBar(category = ModulesWithBasis(QQ))\n                Free module generated by [1, 2] over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_sum_of_monomials": {
                    "__doc__": "\n            TESTS::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])\n                sage: F._sum_of_monomials(['a', 'b'])\n                B['a'] + B['b']\n            ",
                    "args": [
                        "self",
                        "indices"
                    ],
                    "argspec": [
                        [
                            "self",
                            "indices"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "echelon_form": {
                    "__doc__": "\n            Return a basis in echelon form of the subspace spanned by\n            a finite set of elements.\n\n            INPUT:\n\n            - ``elements`` -- a list or finite iterable of elements of ``self``\n            - ``row_reduced`` -- (default: ``False``) whether to compute the\n              basis for the row reduced echelon form\n\n            OUTPUT:\n\n            A list of elements of ``self`` whose expressions as\n            vectors form a matrix in echelon form. If ``base_ring`` is\n            specified, then the calculation is achieved in this base\n            ring.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: V = X.echelon_form([x[0]-x[1], x[0]-x[2],x[1]-x[2]]); V\n                [x[0] - x[2], x[1] - x[2]]\n                sage: matrix(map(vector, V))\n                [ 1  0 -1]\n                [ 0  1 -1]\n\n            ::\n\n                sage: F = CombinatorialFreeModule(ZZ, [1,2,3,4])\n                sage: B = F.basis()\n                sage: elements = [B[1]-17*B[2]+6*B[3], B[1]-17*B[2]+B[4]]\n                sage: F.echelon_form(elements)\n                [B[1] - 17*B[2] + B[4], 6*B[3] - B[4]]\n\n            ::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: a,b,c = F.basis()\n                sage: F.echelon_form([8*a+b+10*c, -3*a+b-c, a-b-c])\n                [B['a'] + B['c'], B['b'] + 2*B['c']]\n\n            ::\n\n                sage: R.<x,y> = QQ[]\n                sage: C = CombinatorialFreeModule(R, range(3), prefix='x')\n                sage: x = C.basis()\n                sage: C.echelon_form([x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]])\n                [x[0] - x[2], x[1] - x[2]]\n            ",
                    "args": [
                        "self",
                        "elements",
                        "row_reduced"
                    ],
                    "argspec": [
                        [
                            "self",
                            "elements",
                            "row_reduced"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "linear_combination": {
                    "__doc__": "\n            Return the linear combination `\\lambda_1 v_1 + \\cdots +\n            \\lambda_k v_k` (resp.  the linear combination `v_1 \\lambda_1 +\n            \\cdots + v_k \\lambda_k`) where ``iter_of_elements_coeff`` iterates\n            through the sequence `((\\lambda_1, v_1), ..., (\\lambda_k, v_k))`.\n\n            INPUT:\n\n            - ``iter_of_elements_coeff`` -- iterator of pairs\n              ``(element, coeff)`` with ``element`` in ``self`` and\n              ``coeff`` in ``self.base_ring()``\n\n            - ``factor_on_left`` -- (optional) if ``True``, the coefficients\n              are multiplied from the left; if ``False``, the coefficients\n              are multiplied from the right\n\n            EXAMPLES::\n\n                sage: m = matrix([[0,1],[1,1]])\n                sage: J.<a,b,c> = JordanAlgebra(m)\n                sage: J.linear_combination(((a+b, 1), (-2*b + c, -1)))\n                1 + (3, -1)\n            ",
                    "args": [
                        "self",
                        "iter_of_elements_coeff",
                        "factor_on_left"
                    ],
                    "argspec": [
                        [
                            "self",
                            "iter_of_elements_coeff",
                            "factor_on_left"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "module_morphism": {
                    "__doc__": "\n            Construct a module morphism from ``self`` to ``codomain``.\n\n            Let ``self`` be a module `X` with a basis indexed by `I`.\n            This constructs a morphism `f: X \\to Y` by linearity from\n            a map `I \\to Y` which is to be its restriction to the\n            basis `(x_i)_{i \\in I}` of `X`. Some variants are possible\n            too.\n\n            INPUT:\n\n            - ``self`` -- a parent `X` in ``ModulesWithBasis(R)`` with\n              basis `x=(x_i)_{i\\in I}`.\n\n            Exactly one of the four following options must be\n            specified in order to define the morphism:\n\n            - ``on_basis`` -- a function `f` from `I` to `Y`\n            - ``diagonal`` -- a function `d` from `I` to `R`\n            - ``function`` -- a function `f` from `X` to `Y`\n            - ``matrix``   -- a matrix of size `\\dim Y \\times \\dim X`\n              (if the keyword ``side`` is set to ``'left'``) or\n              `\\dim Y \\times \\dim X` (if this keyword is ``'right'``)\n\n            Further options include:\n\n            - ``codomain`` -- the codomain `Y` of the morphism (default:\n              ``f.codomain()`` if it's defined; otherwise it must be specified)\n\n            - ``category`` -- a category or ``None`` (default: `None``)\n\n            - ``zero`` -- the zero of the codomain (default: ``codomain.zero()``);\n              can be used (with care) to define affine maps.\n              Only meaningful with ``on_basis``.\n\n            - ``position`` -- a non-negative integer specifying which\n              positional argument in used as the input of the function `f`\n              (default: 0); this is currently only used with ``on_basis``.\n\n            - ``triangular`` --  (default: ``None``) ``\"upper\"`` or\n              ``\"lower\"`` or ``None``:\n\n              * ``\"upper\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.leading_support`\n                of the image of the basis vector `x_i` is `i`, or\n\n              * ``\"lower\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.trailing_support`\n                of the image of the basis vector `x_i` is `i`.\n\n            - ``unitriangular`` -- (default: ``False``) a boolean.\n              Only meaningful for a triangular morphism.\n              As a shorthand, one may use ``unitriangular=\"lower\"``\n              for ``triangular=\"lower\", unitriangular=True``.\n\n            - ``side`` -- \"left\" or \"right\" (default: \"left\")\n              Only meaningful for a morphism built from a matrix.\n\n            EXAMPLES:\n\n            With the ``on_basis`` option, this returns a function `g`\n            obtained by extending `f` by linearity on the\n            ``position``-th positional argument. For example, for\n            ``position == 1`` and a ternary function `f`, one has:\n\n            .. MATH::\n\n                g\\left( a,\\ \\sum_i \\lambda_i x_i,\\ c \\right)\n                = \\sum_i \\lambda_i f(a, i, c).\n\n            ::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1), codomain = Y)\n                sage: x = X.basis(); y = Y.basis()\n                sage: phi(x[1] + x[3])\n                B[1] + 2*B[2] + B[3] + 2*B[4]\n\n                sage: phi\n                Generic morphism:\n                From: X\n                To:   Y\n\n            By default, the category is the first of\n            ``Modules(R).WithBasis().FiniteDimensional()``,\n            ``Modules(R).WithBasis()``, ``Modules(R)``, and\n            ``CommutativeAdditiveMonoids()`` that contains both the\n            domain and the codomain::\n\n                sage: phi.category_for()\n                Category of finite dimensional vector spaces with basis over Rational Field\n\n            With the ``zero`` argument, one can define affine morphisms::\n\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1),\n                ....:                         codomain = Y, zero = 10*y[1])\n                sage: phi(x[1] + x[3])\n                11*B[1] + 2*B[2] + B[3] + 2*B[4]\n\n            In this special case, the default category is ``Sets()``::\n\n                sage: phi.category_for()\n                Category of sets\n\n            One can construct morphisms with the base ring as codomain::\n\n                sage: X = CombinatorialFreeModule(ZZ,[1,-1])\n                sage: phi = X.module_morphism( on_basis=lambda i: i, codomain=ZZ )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (ZZ is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n            Or more generaly any ring admitting a coercion map from\n            the base ring::\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=RR )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1.00000000000000\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (RR is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                3\n\n                sage: phi = Y.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Ring of integers modulo 4) should be a module over the base ring of the domain(=Y)\n\n            On can also define module morphisms between free modules\n            over different base rings; here we implement the natural\n            map from `X = \\RR^2` to `Y = \\CC`::\n\n                sage: X = CombinatorialFreeModule(RR,['x','y'])\n                sage: Y = CombinatorialFreeModule(CC,['z'])\n                sage: x = X.monomial('x')\n                sage: y = X.monomial('y')\n                sage: z = Y.monomial('z')\n                sage: def on_basis( a ):\n                ....:     if a == 'x':\n                ....:         return CC(1) * z\n                ....:     elif a == 'y':\n                ....:         return CC(I) * z\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: v = 3 * x + 2 * y; v\n                3.00000000000000*B['x'] + 2.00000000000000*B['y']\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (CC is currently not in Modules(RR)!)\n                Category of vector spaces over Real Field with 53 bits of precision\n\n                sage: Y = CombinatorialFreeModule(CC['q'],['z'])\n                sage: z = Y.monomial('z')\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n\n            Of course, there should be a coercion between the\n            respective base rings of the domain and the codomain for\n            this to be meaningful::\n\n                sage: Y = CombinatorialFreeModule(QQ,['z'])\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'z'} over Rational Field)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n\n                sage: Y = CombinatorialFreeModule(RR['q'],['z'])\n                sage: phi = Y.module_morphism( on_basis=on_basis, codomain=X )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'z'} over Univariate Polynomial Ring in q over Real Field with 53 bits of precision)\n\n\n            With the ``diagonal=d`` argument, this constructs the\n            module morphism `g` such that\n\n            .. MATH::\n\n                `g(x_i) = d(i) y_i`.\n\n            This assumes that the respective bases `x` and `y` of `X`\n            and `Y` have the same index set `I`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, codomain=X)\n                sage: x = X.basis()\n                sage: phi(x[1]), phi(x[2]), phi(x[3])\n                (B[1], 2*B[2], 6*B[3])\n\n            See also: :class:`sage.modules.with_basis.morphism.DiagonalModuleMorphism`.\n\n            With the ``matrix=m`` argument, this constructs the module\n            morphism whose matrix in the distinguished basis of `X`\n            and `Y` is `m`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(ZZ, [3,4]); Y.rename(\"Y\"); y = Y.basis()\n                sage: m = matrix([[0,1,2],[3,5,0]])\n                sage: phi = X.module_morphism(matrix=m, codomain=Y)\n                sage: phi(x[1])\n                3*B[4]\n                sage: phi(x[2])\n                B[3] + 5*B[4]\n\n\n            See also: :class:`sage.modules.with_basis.morphism.ModuleMorphismFromMatrix`.\n\n            With ``triangular=\"upper\"``, the constructed module morphism is\n            assumed to be upper triangular; that is its matrix in the\n            distinguished basis of `X` and `Y` would be upper triangular with\n            invertible elements on its diagonal. This is used to compute\n            preimages and to invert the morphism::\n\n                sage: I = range(1,200)\n                sage: X = CombinatorialFreeModule(QQ, I); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(QQ, I); Y.rename(\"Y\"); y = Y.basis()\n                sage: f = Y.sum_of_monomials * divisors\n                sage: phi = X.module_morphism(f, triangular=\"upper\", codomain = Y)\n                sage: phi(x[2])\n                B[1] + B[2]\n                sage: phi(x[6])\n                B[1] + B[2] + B[3] + B[6]\n                sage: phi(x[30])\n                B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]\n                sage: phi.preimage(y[2])\n                -B[1] + B[2]\n                sage: phi.preimage(y[6])\n                B[1] - B[2] - B[3] + B[6]\n                sage: phi.preimage(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n                sage: (phi^-1)(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n\n            Since :trac:`8678`, one can also define a triangular\n            morphism from a function::\n\n                sage: X = CombinatorialFreeModule(QQ, [0,1,2,3,4]); x = X.basis()\n                sage: from sage.modules.with_basis.morphism import TriangularModuleMorphismFromFunction\n                sage: def f(x): return x + X.term(0, sum(x.coefficients()))\n                sage: phi = X.module_morphism(function=f, codomain=X, triangular=\"upper\")\n                sage: phi(x[2] + 3*x[4])\n                4*B[0] + B[2] + 3*B[4]\n                sage: phi.preimage(_)\n                B[2] + 3*B[4]\n\n            For details and further optional arguments, see\n            :class:`sage.modules.with_basis.morphism.TriangularModuleMorphism`.\n\n            .. WARNING::\n\n                As a temporary measure, until multivariate morphisms\n                are implemented, the constructed morphism is in\n                ``Hom(codomain, domain, category)``. This is only\n                correct for unary functions.\n\n            .. TODO::\n\n               - Should codomain be ``self`` by default in the\n                 diagonal, triangular, and matrix cases?\n\n               - Support for diagonal morphisms between modules not\n                 sharing the same index set\n\n            TESTS::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, matrix=matrix(), codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(matrix=factorial, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: matrix (=factorial) should be a matrix\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=3, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: diagonal (=3) should be a function\n\n            ",
                    "args": [
                        "self",
                        "on_basis",
                        "matrix",
                        "function",
                        "diagonal",
                        "triangular",
                        "unitriangular"
                    ],
                    "argspec": [
                        [
                            "self",
                            "on_basis",
                            "matrix",
                            "function",
                            "diagonal",
                            "triangular",
                            "unitriangular"
                        ],
                        null,
                        "keywords",
                        [
                            null,
                            null,
                            null,
                            null,
                            null,
                            false
                        ]
                    ]
                },
                "monomial": {
                    "__doc__": "\n            Return the basis element indexed by ``i``.\n\n            INPUT:\n\n            - ``i`` -- an element of the index set\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])\n                sage: F.monomial('a')\n                B['a']\n\n            ``F.monomial`` is in fact (almost) a map::\n\n                sage: F.monomial\n                Term map from {'a', 'b', 'c'} to Free module generated by {'a', 'b', 'c'} over Rational Field\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "monomial_or_zero_if_none": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])\n                sage: F.monomial_or_zero_if_none('a')\n                B['a']\n                sage: F.monomial_or_zero_if_none(None)\n                0\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "submodule": {
                    "__doc__": "\n            The submodule spanned by a finite set of elements.\n\n            INPUT:\n\n            - ``gens`` -- a list or family of elements of ``self``\n\n            - ``check`` -- (default: ``True``) whether to verify that the\n               elements of ``gens`` are in ``self``\n\n            - ``already_echelonized`` -- (default: ``False``) whether\n               the elements of ``gens`` are already in (not necessarily\n               reduced) echelon form\n\n            - ``unitrangular`` -- (default: ``False``) whether\n              the lift morphism is unitrangular\n\n            If ``already_echelonized`` is ``False``, then the\n            generators are put in reduced echelon form using\n            :meth:`echelonize`, and reindexed by `0,1,...`.\n\n            .. WARNING::\n\n                At this point, this method only works for finite\n                dimensional submodules and if matrices can be\n                echelonized over the base ring.\n\n            If in addition ``unitriangular`` is ``True``, then\n            the generators are made such that the coefficients of\n            the pivots are 1, so that lifting map is unitriangular.\n\n            The basis of the submodule uses the same index set as the\n            generators, and the lifting map sends `y_i` to `gens[i]`.\n\n\n            .. SEEALSO::\n\n                 - :meth:`ModulesWithBasis.FiniteDimensional.ParentMethods.quotient_module`\n                 - :class:`sage.modules.with_basis.subquotient.SubmoduleWithBasis`\n\n            EXAMPLES:\n\n            We construct a submodule of the free `\\QQ`-module generated by\n            `x_0, x_1, x_2`. The submodule is spanned by `y_0 = x_0 - x_1` and\n            `y_1 - x_1 - x_2`, and its basis elements are indexed by `0` and `1`::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: gens = [x[0] - x[1], x[1] - x[2]]; gens\n                [x[0] - x[1], x[1] - x[2]]\n                sage: Y = X.submodule(gens, already_echelonized=True)\n                sage: Y.print_options(prefix='y'); Y\n                Free module generated by {0, 1} over Rational Field\n                sage: y = Y.basis()\n                sage: y[1]\n                y[1]\n                sage: y[1].lift()\n                x[1] - x[2]\n                sage: Y.retract(x[0]-x[2])\n                y[0] + y[1]\n                sage: Y.retract(x[0])\n                Traceback (most recent call last):\n                ...\n                ValueError: x[0] is not in the image\n\n            By using a family to specify a basis of the submodule, we obtain a\n            submodule whose index set coincides with the index set of the family::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: gens = Family({1 : x[0] - x[1], 3: x[1] - x[2]}); gens\n                Finite family {1: x[0] - x[1], 3: x[1] - x[2]}\n                sage: Y = X.submodule(gens, already_echelonized=True)\n                sage: Y.print_options(prefix='y'); Y\n                Free module generated by {1, 3} over Rational Field\n                sage: y = Y.basis()\n                sage: y[1]\n                y[1]\n                sage: y[1].lift()\n                x[0] - x[1]\n                sage: y[3].lift()\n                x[1] - x[2]\n                sage: Y.retract(x[0]-x[2])\n                y[1] + y[3]\n                sage: Y.retract(x[0])\n                Traceback (most recent call last):\n                ...\n                ValueError: x[0] is not in the image\n\n            It is not necessary that the generators of the submodule form\n            a basis (an explicit basis will be computed)::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: gens = [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]; gens\n                [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]\n                sage: Y = X.submodule(gens, already_echelonized=False)\n                sage: Y.print_options(prefix='y')\n                sage: Y\n                Free module generated by {0, 1} over Rational Field\n                sage: [b.lift() for b in Y.basis()]\n                [x[0] - x[2], x[1] - x[2]]\n\n            We now implement by hand the center of the algebra of the\n            symmetric group `S_3`::\n\n                sage: S3 = SymmetricGroup(3)\n                sage: S3A = S3.algebra(QQ)\n                sage: basis = S3A.annihilator_basis(S3A.algebra_generators(), S3A.bracket)\n                sage: basis\n                ((), (2,3) + (1,2) + (1,3), (1,2,3) + (1,3,2))\n                sage: center = S3A.submodule(basis,\n                ....:                        category=AlgebrasWithBasis(QQ).Subobjects(),\n                ....:                        already_echelonized=True)\n                sage: center\n                Free module generated by {0, 1, 2} over Rational Field\n                sage: center in Algebras\n                True\n                sage: center.print_options(prefix='c')\n                sage: c = center.basis()\n                sage: c[1].lift()\n                (2,3) + (1,2) + (1,3)\n                sage: c[0]^2\n                c[0]\n                sage: e = 1/6*(c[0]+c[1]+c[2])\n                sage: e.is_idempotent()\n                True\n\n            Of course, this center is best constructed using::\n\n                sage: center = S3A.center()\n\n            We can also automatically construct a basis such that\n            the lift morphism is (lower) unitriangular::\n\n                sage: R.<a,b> = QQ[]\n                sage: C = CombinatorialFreeModule(R, range(3), prefix='x')\n                sage: x = C.basis()\n                sage: gens = [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]\n                sage: Y = C.submodule(gens, unitriangular=True)\n                sage: Y.lift.matrix()\n                [ 1  0]\n                [ 0  1]\n                [-1 -1]\n\n            TESTS::\n\n                sage: TestSuite(Y).run()\n                sage: TestSuite(center).run()\n            ",
                    "args": [
                        "self",
                        "gens",
                        "check",
                        "already_echelonized",
                        "unitriangular",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "gens",
                            "check",
                            "already_echelonized",
                            "unitriangular",
                            "category"
                        ],
                        null,
                        null,
                        [
                            true,
                            false,
                            false,
                            null
                        ]
                    ]
                },
                "sum_of_terms": {
                    "__doc__": "\n            Construct a sum of terms of ``self``.\n\n            INPUT:\n\n            - ``terms`` -- a list (or iterable) of pairs ``(index, coeff)``\n\n            OUTPUT:\n\n            Sum of ``coeff * B[index]`` over all ``(index, coeff)`` in\n            ``terms``, where ``B`` is the basis of ``self``.\n\n            EXAMPLES::\n\n                sage: m = matrix([[0,1],[1,1]])\n                sage: J.<a,b,c> = JordanAlgebra(m)\n                sage: J.sum_of_terms([(0, 2), (2, -3)])\n                2 + (0, -3)\n            ",
                    "args": [
                        "self",
                        "terms"
                    ],
                    "argspec": [
                        [
                            "self",
                            "terms"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "tensor": {
                    "__doc__": "\n            Return the tensor product of the parents.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example(); A.rename(\"A\")\n                sage: A.tensor(A,A)\n                A # A # A\n                sage: A.rename(None)\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "parents",
                        null,
                        null
                    ]
                },
                "term": {
                    "__doc__": "\n            Construct a term in ``self``.\n\n            INPUT:\n\n            - ``index`` -- the index of a basis element\n            - ``coeff`` -- an element of the coefficient ring (default: one)\n\n            OUTPUT:\n\n            ``coeff * B[index]``, where ``B`` is the basis of ``self``.\n\n            EXAMPLES::\n\n                sage: m = matrix([[0,1],[1,1]])\n                sage: J.<a,b,c> = JordanAlgebra(m)\n                sage: J.term(1, -2)\n                0 + (-2, 0)\n\n            Design: should this do coercion on the coefficient ring?\n            ",
                    "args": [
                        "self",
                        "index",
                        "coeff"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index",
                            "coeff"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "__getitem__": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self``.\n\n            EXAMPLES::\n\n                sage: p = Partition([2,1])\n                sage: q = Partition([1,1,1])\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s(p)\n                sage: a._coefficient_fast([2,1])\n                Traceback (most recent call last):\n                ...\n                TypeError: unhashable type: 'list'\n\n            ::\n\n                sage: a._coefficient_fast(p)\n                1\n                sage: a._coefficient_fast(q)\n                0\n                sage: a[p]\n                1\n                sage: a[q]\n                0\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__len__": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: len(f)\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: len(z)\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficient": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self`` and raise an error\n            if ``m`` is not in the basis indexing set.\n\n            INPUT:\n\n            - ``m`` -- a basis index of the parent of ``self``\n\n            OUTPUT:\n\n            The ``B[m]``-coordinate of ``self`` with respect to the basis\n            ``B``. Here, ``B`` denotes the given basis of the parent of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: s = CombinatorialFreeModule(QQ, Partitions())\n                sage: z = s([4]) - 2*s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficient([4])\n                1\n                sage: z.coefficient([2,1])\n                -2\n                sage: z.coefficient(Partition([2,1]))\n                -2\n                sage: z.coefficient([1,2])\n                Traceback (most recent call last):\n                ...\n                AssertionError: [1, 2] should be an element of Partitions\n                sage: z.coefficient(Composition([2,1]))\n                Traceback (most recent call last):\n                ...\n                AssertionError: [2, 1] should be an element of Partitions\n\n            Test that ``coefficient`` also works for those parents that do\n            not yet have an element_class::\n\n                sage: G = DihedralGroup(3)\n                sage: F = CombinatorialFreeModule(QQ, G)\n                sage: hasattr(G, \"element_class\")\n                False\n                sage: g = G.an_element()\n                sage: (2*F.monomial(g)).coefficient(g)\n                2\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficients": {
                    "__doc__": "\n            Return a list of the (non-zero) coefficients appearing on\n            the basis elements in ``self`` (in an arbitrary order).\n\n            INPUT:\n\n            - ``sort`` -- (default: ``True``) to sort the coefficients\n              based upon the default ordering of the indexing set\n\n            .. SEEALSO::\n\n                :meth:`~sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis.ElementMethods.dense_coefficient_list`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.coefficients()\n                [1, -3]\n                sage: f = B['c'] - 3*B['a']\n                sage: f.coefficients()\n                [-3, 1]\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficients()\n                [1, 1, 1, 1]\n            ",
                    "args": [
                        "self",
                        "sort"
                    ],
                    "argspec": [
                        [
                            "self",
                            "sort"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "is_zero": {
                    "__doc__": "\n            Return ``True`` if and only if ``self == 0``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.is_zero()\n                False\n                sage: F.zero().is_zero()\n                True\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: s([2,1]).is_zero()\n                False\n                sage: s(0).is_zero()\n                True\n                sage: (s([2,1]) - s([2,1])).is_zero()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "leading_coefficient": {
                    "__doc__": "\n            Returns the leading coefficient of ``self``.\n\n            This is the coefficient of the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\")\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_coefficient()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_coefficient(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_coefficient()\n                -5\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_item": {
                    "__doc__": "\n            Return the pair ``(k, c)`` where\n\n            .. MATH::\n\n                c \\cdot (\\mbox{the basis element indexed by } k)\n\n            is the leading term of ``self``.\n\n            Here 'leading term' means that the corresponding basis element is\n            maximal.  Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be\n            provided.  This should return a negative value if ``x < y``, ``0``\n            if ``x == y`` and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_item()\n                (3, 4)\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_item(cmp=cmp)\n                (1, 3)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_item()\n                ([3], -5)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_monomial": {
                    "__doc__": "\n            Return the leading monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_monomial()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_monomial(cmp=cmp)\n                B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_monomial()\n                s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_support": {
                    "__doc__": "\n            Return the maximal element of the support of ``self``. Note\n            that this may not be the term which actually appears first when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_support()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_support(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_support()\n                [3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_term": {
                    "__doc__": "\n            Return the leading term of ``self``.\n\n            This is the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_term()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_term(cmp=cmp)\n                3*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_term()\n                -5*s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "length": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.length()\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.length()\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_coefficients": {
                    "__doc__": "\n            Mapping a function on coefficients.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the coefficient ring of the\n              free module\n\n            Return a new element of ``self.parent()`` obtained by applying the\n            function ``f`` to all of the coefficients of ``self``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.map_coefficients(lambda x: x+5)\n                6*B['a'] + 2*B['c']\n\n            Killed coefficients are handled properly::\n\n                sage: f.map_coefficients(lambda x: 0)\n                0\n                sage: list(f.map_coefficients(lambda x: 0))\n                []\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_coefficients(lambda x: x*2)\n                2*s[2, 1] + 4*s[3, 2]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_item": {
                    "__doc__": "\n            Mapping a function on items.\n\n            INPUT:\n\n            - ``f`` -- a function mapping pairs ``(index, coeff)`` to\n              other such pairs\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function `f` to all items ``(index, coeff)`` of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_item(lambda i, c: (-i, 2*c))\n                6*B[-1] + 4*B[0] + 4*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_item(lambda i, c: (1, 2*c))\n                14*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = lambda m,c: (m.conjugate(), 2*c)\n                sage: a = s([2,1]) + s([1,1,1])\n                sage: a.map_item(f)\n                2*s[2, 1] + 2*s[3]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function ``f`` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support(lambda i: -i)\n                3*B[-1] + 2*B[0] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support(lambda i: 1)\n                7*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_support(lambda x: x.conjugate())\n                s[2, 1] + 2*s[2, 2, 1]\n\n            TESTS::\n\n                sage: B.zero()      # This actually failed at some point!!! See #8890\n                0\n\n                sage: y = B.zero().map_support(lambda i: i/0); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support_skip_none": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Returns a new element of ``self.parent()`` obtained by\n            applying the function `f` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support_skip_none(lambda i: -i if i else None)\n                3*B[-1] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support_skip_none(lambda i: 1 if i else None)\n                5*B[1]\n\n            TESTS::\n\n                sage: y = x.map_support_skip_none(lambda i: None); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "monomial_coefficients": {
                    "__doc__": "\n            Return a dictionary whose keys are indices of basis elements\n            in the support of ``self`` and whose values are the\n            corresponding coefficients.\n\n            INPUT:\n\n            - ``copy`` -- (default: ``True``) if ``self`` is internally\n              represented by a dictionary ``d``, then make a copy of ``d``;\n              if ``False``, then this can cause undesired behavior by\n              mutating ``d``\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a']\n                1\n                sage: d['c']\n                3\n\n            TESTS:\n\n            We check that we make a copy of the coefficient dictionary::\n\n                sage: F = CombinatorialFreeModule(ZZ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a'] = 5\n                sage: f\n                B['a'] + 3*B['c']\n            ",
                    "args": [
                        "self",
                        "copy"
                    ],
                    "argspec": [
                        [
                            "self",
                            "copy"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "monomials": {
                    "__doc__": "\n            Return a list of the monomials of ``self`` (in an arbitrary\n            order).\n\n            The monomials of an element `a` are defined to be the basis\n            elements whose corresponding coefficients of `a` are\n            non-zero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.monomials()\n                [B['a'], B['c']]\n\n                sage: (F.zero()).monomials()\n                []\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support": {
                    "__doc__": "\n            Return a list of the objects indexing the basis of\n            ``self.parent()`` whose corresponding coefficients of\n            ``self`` are non-zero.\n\n            This method returns these objects in an arbitrary order.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: sorted(f.support())\n                ['a', 'c']\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: sorted(z.support())\n                [[1], [1, 1, 1], [2, 1], [4]]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support_of_term": {
                    "__doc__": "\n            Return the support of ``self``, where ``self`` is a monomial\n            (possibly with coefficient).\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3,4]); X.rename(\"X\")\n                sage: X.monomial(2).support_of_term()\n                2\n                sage: X.term(3, 2).support_of_term()\n                3\n\n            An exception is raised if ``self`` has more than one term::\n\n                sage: (X.monomial(2) + X.monomial(3)).support_of_term()\n                Traceback (most recent call last):\n                ...\n                ValueError: B[2] + B[3] is not a single term\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "tensor": {
                    "__doc__": "\n            Return the tensor product of its arguments, as an element of\n            the tensor product of the parents of those elements.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example()\n                sage: (a,b,c) = A.algebra_generators()\n                sage: a.tensor(b, c)\n                B[word: a] # B[word: b] # B[word: c]\n\n            FIXME: is this a policy that we want to enforce on all parents?\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "elements",
                        null,
                        null
                    ]
                },
                "terms": {
                    "__doc__": "\n            Return a list of the (non-zero) terms of ``self`` (in an\n            arbitrary order).\n\n            .. SEEALSO:: :meth:`monomials`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.terms()\n                [B['a'], 2*B['c']]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "trailing_coefficient": {
                    "__doc__": "\n            Return the trailing coefficient of ``self``.\n\n            This is the coefficient of the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_coefficient()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_coefficient(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_coefficient()\n                2\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_item": {
                    "__doc__": "\n            Returns the pair ``(c, k)`` where ``c*self.parent().monomial(k)``\n            is the trailing term of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_item()\n                (1, 3)\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_item(cmp=cmp)\n                (3, 1)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_item()\n                ([1], 2)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_monomial": {
                    "__doc__": "\n            Return the trailing monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_monomial()\n                B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_monomial(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_monomial()\n                s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_support": {
                    "__doc__": "\n            Return the minimal element of the support of ``self``. Note\n            that this may not be the term which actually appears last when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, `0` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.trailing_support()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_support(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_support()\n                [1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_term": {
                    "__doc__": "\n            Return the trailing term of ``self``.\n\n            This is the term whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_term()\n                3*B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_term(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_term()\n                2*s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of Hopf algebras\n\n    EXAMPLES::\n\n        sage: HopfAlgebras(QQ)\n        Category of hopf algebras over Rational Field\n        sage: HopfAlgebras(QQ).super_categories()\n        [Category of bialgebras over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(HopfAlgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "antipode": {
                    "__doc__": "\n            Return the antipode of self\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.antipode()\n                (B[(1,2,3)], B[(1,3,2)])\n                sage: b, b.antipode()\n                (B[(1,3)], B[(1,3)])\n\n            TESTS::\n\n                sage: all(x.antipode() * x == A.one() for x in A.basis())\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.bialgebras.Bialgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of Hopf algebras\n\n    EXAMPLES::\n\n        sage: HopfAlgebras(QQ)\n        Category of hopf algebras over Rational Field\n        sage: HopfAlgebras(QQ).super_categories()\n        [Category of bialgebras over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(HopfAlgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.hopf_algebras.HopfAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "antipode": {
                    "__doc__": "\n            Return the antipode of self\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.antipode()\n                (B[(1,2,3)], B[(1,3,2)])\n                sage: b, b.antipode()\n                (B[(1,3)], B[(1,3)])\n\n            TESTS::\n\n                sage: all(x.antipode() * x == A.one() for x in A.basis())\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite (multiplicative) groups.\n\n    EXAMPLES::\n\n        sage: C = FiniteGroups(); C\n        Category of finite groups\n        sage: C.super_categories()\n        [Category of finite monoids, Category of groups]\n        sage: C.example()\n        General Linear Group of degree 2 over Finite Field of size 3\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Finite",
            "Inverse",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_monoids.FiniteMonoids",
            "sage.categories.groups.Groups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite (multiplicative) groups.\n\n    EXAMPLES::\n\n        sage: C = FiniteGroups(); C\n        Category of finite groups\n        sage: C.super_categories()\n        [Category of finite monoids, Category of groups]\n        sage: C.example()\n        General Linear Group of degree 2 over Finite Field of size 3\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_groups.FiniteGroups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "cayley_graph_disabled": {
                    "__doc__": "\n\n            AUTHORS:\n\n            - Bobby Moretti (2007-08-10)\n\n            - Robert Miller (2008-05-01): editing\n            ",
                    "args": [
                        "self",
                        "connecting_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "connecting_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "conjugacy_classes": {
                    "__doc__": "\n            Return a list with all the conjugacy classes of the group.\n\n            This will eventually be a fall-back method for groups not defined\n            over GAP. Right now just raises a ``NotImplementedError``, until\n            we include a non-GAP way of listing the conjugacy classes\n            representatives.\n\n            EXAMPLES::\n\n                sage: from sage.groups.group import FiniteGroup\n                sage: G = FiniteGroup()\n                sage: G.conjugacy_classes()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: Listing the conjugacy classes for\n                group <type 'sage.groups.group.FiniteGroup'> is not implemented\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "conjugacy_classes_representatives": {
                    "__doc__": "\n            Return a list of the conjugacy classes representatives of the group.\n\n            EXAMPLES::\n\n                sage: G = SymmetricGroup(3)\n                sage: G.conjugacy_classes_representatives()\n                [(), (1,2), (1,2,3)]\n           ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of commutative additive monoids, that is abelian\n    additive semigroups with a unit\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveMonoids(); C\n        Category of commutative additive monoids\n        sage: C.super_categories()\n        [Category of additive monoids, Category of commutative additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveMonoids()).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital"
        ],
        "element_class": {
            "__doc__": "\n    The category of commutative additive monoids, that is abelian\n    additive semigroups with a unit\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveMonoids(); C\n        Category of commutative additive monoids\n        sage: C.super_categories()\n        [Category of additive monoids, Category of commutative additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveMonoids()).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_monoids.AdditiveMonoids",
            "sage.categories.commutative_additive_semigroups.CommutativeAdditiveSemigroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of commutative additive monoids, that is abelian\n    additive semigroups with a unit\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveMonoids(); C\n        Category of commutative additive monoids\n        sage: C.super_categories()\n        [Category of additive monoids, Category of commutative additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveMonoids()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.commutative_additive_monoids.CommutativeAdditiveMonoids",
        "parent_class": {
            "__doc__": "\n    The category of commutative additive monoids, that is abelian\n    additive semigroups with a unit\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveMonoids(); C\n        Category of commutative additive monoids\n        sage: C.super_categories()\n        [Category of additive monoids, Category of commutative additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveMonoids()).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of commutative additive monoids, that is abelian\n    additive semigroups with a unit\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveMonoids(); C\n        Category of commutative additive monoids\n        sage: C.super_categories()\n        [Category of additive monoids, Category of commutative additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital']\n        sage: C is AdditiveMagmas().AdditiveAssociative().AdditiveCommutative().AdditiveUnital()\n        True\n\n    .. NOTE::\n\n        This category is currently empty and only serves as a place\n        holder to make ``C.example()`` work.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveMonoids()).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.enumerated_sets.EnumeratedSets",
            "sage.categories.finite_sets.FiniteSets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_cardinality_from_iterator": {
                    "__doc__": "\n            The cardinality of ``self``.\n\n            OUTPUT: an ``Integer``\n\n            This brute force implementation of :meth:`cardinality`\n            iterates through the elements of ``self`` to count them.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example(); C\n                An example of a finite enumerated set: {1,2,3}\n                sage: C._cardinality_from_iterator()\n                3\n\n            This is the default implementation of :meth:`cardinality`\n            from the category ``FiniteEnumeratedSet()``. To test this,\n            we need a fresh example::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class FreshExample(Example): pass\n                sage: C = FreshExample(); C.rename(\"FreshExample\")\n                sage: C.cardinality\n                <bound method FreshExample_with_category._cardinality_from_iterator of FreshExample>\n\n            TESTS:\n\n            This method shall return an ``Integer``; we test this\n            here, because :meth:`_test_enumerated_set_iter_cardinality`\n            does not do it for us::\n\n                sage: type(C._cardinality_from_iterator())\n                <type 'sage.rings.integer.Integer'>\n\n            We ignore additional inputs since during doctests classes which\n            override ``cardinality()`` call up to the category rather than\n            their own ``cardinality()`` method (see :trac:`13688`)::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._cardinality_from_iterator(algorithm='testing')\n                3\n\n            Here is a more complete example::\n\n                sage: class TestParent(Parent):\n                ...     def __init__(self):\n                ...         Parent.__init__(self, category=FiniteEnumeratedSets())\n                ...     def __iter__(self):\n                ...         yield 1\n                ...         return\n                ...     def cardinality(self, dummy_arg):\n                ...         return 1 # we don't want to change the semantics of cardinality()\n                sage: P = TestParent()\n                sage: P.cardinality(-1)\n                1\n                sage: v = P.list(); v\n                [1]\n                sage: P.cardinality()\n                1\n                sage: P.cardinality('use alt algorithm') # Used to break here: see trac #13688\n                1\n                sage: P.cardinality(dummy_arg='use alg algorithm') # Used to break here: see trac #13688\n                1\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "ignored_args",
                        "ignored_kwds",
                        null
                    ]
                },
                "_cardinality_from_list": {
                    "__doc__": "\n            The cardinality of ``self``.\n\n            This implementation of :meth:`cardinality` computes the\n            cardinality from :meth:`list` (which is\n            cached). Reciprocally, calling ``self.list()`` makes this\n            method the default implementation of :meth:`cardinality`.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._cardinality_from_list()\n                3\n\n            We ignore additional inputs since during doctests classes which\n            override ``cardinality()`` call up to the category rather than\n            their own ``cardinality()`` method (see :trac:`13688`)::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._cardinality_from_list(algorithm='testing')\n                3\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "ignored_args",
                        "ignored_kwds",
                        null
                    ]
                },
                "_last_from_iterator": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "_last_from_unrank": {
                    "__doc__": "\n            The last element of ``self``.\n\n            ``self.last()`` returns the last element of ``self``\n\n            This is a generic implementation from the category\n            ``FiniteEnumeratedSet()`` which can be used when the\n            method ``unrank`` is provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._last_from_unrank()\n                3\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_list_from_iterator": {
                    "__doc__": "\n            The list of the elements of ``self``.\n\n            This implementation computes this list from the iterator\n            of ``self``. This is used by the default implementation of\n            :meth:`list`.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._list_from_iterator()\n                [1, 2, 3]\n                sage: C.list() # indirect doctest\n                [1, 2, 3]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_random_element_from_unrank": {
                    "__doc__": "\n            A random element in ``self``.\n\n            ``self.random_element()`` returns a random element in\n            ``self`` with uniform probability.\n\n            This is the default implementation from the category\n            ``EnumeratedSet()`` which uses the method ``unrank``.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.random_element()\n                1\n                sage: C._random_element_from_unrank()\n                2\n\n            TODO: implement _test_random which checks uniformness\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_test_enumerated_set_iter_cardinality": {
                    "__doc__": "\n            Checks that the methods :meth:`.cardinality` and\n            :meth:`.__iter__` are consistent. Also checks that\n            :meth:`.cardinality` returns an ``Integer``.\n\n            For efficiency reasons, those tests are not run if\n            :meth:`.cardinality` is\n            :meth:`._cardinality_from_iterator`, or if ``self`` is too\n            big.\n\n            .. seealso:: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._test_enumerated_set_iter_cardinality()\n\n            Let us now break the class::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class CCls(Example):\n                ...       def cardinality(self):\n                ...           return 4\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_iter_cardinality()\n                Traceback (most recent call last):\n                ...\n                AssertionError: 4 != 3\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_unrank_from_list": {
                    "__doc__": "\n            The ``r``-th element of ``self``\n\n            INPUT:\n\n              - ``r`` -- an integer between ``0`` and ``n-1``,\n                where ``n`` is the cardinality of ``self``.\n\n            OUTPUT: the ``r``-th element of ``self``\n\n            This implementation of :meth:`unrank` uses the method\n            :meth:`list` (which is cached). Reciprocally, calling\n            ``self.list()`` makes this method the default\n            implementation of :meth:`unrank`.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._unrank_from_list(1)\n                2\n            ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "last": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of finite enumerated sets\n\n    EXAMPLES::\n\n        sage: FiniteEnumeratedSets()\n        Category of finite enumerated sets\n        sage: FiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of finite sets]\n        sage: FiniteEnumeratedSets().all_super_categories()\n        [Category of finite enumerated sets,\n         Category of enumerated sets,\n         Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = FiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n        sage: sorted(C.Algebras(QQ).super_categories(), key=str)\n        [Category of finite dimensional modules with basis over Rational Field,\n         Category of set algebras over Rational Field]\n\n    .. TODO::\n\n        :class:`sage.combinat.debruijn_sequence.DeBruijnSequences` should\n        not inherit from this class. If that is solved, then\n        :class:`FiniteEnumeratedSets` shall be turned into a subclass of\n        :class:`~sage.categories.category_singleton.Category_singleton`.\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded algebras with a distinguished basis\n\n    EXAMPLES::\n\n        sage: C = GradedAlgebrasWithBasis(ZZ); C\n        Category of graded algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered algebras with basis over Integer Ring,\n         Category of graded algebras over Integer Ring,\n         Category of graded modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_algebras_with_basis.FilteredAlgebrasWithBasis",
            "sage.categories.graded_algebras.GradedAlgebras",
            "sage.categories.graded_modules_with_basis.GradedModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded algebras with a distinguished basis\n\n    EXAMPLES::\n\n        sage: C = GradedAlgebrasWithBasis(ZZ); C\n        Category of graded algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered algebras with basis over Integer Ring,\n         Category of graded algebras over Integer Ring,\n         Category of graded modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_algebras_with_basis.GradedAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.commutative_rings.CommutativeRings"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "name": "sage.categories.commutative_algebras.CommutativeAlgebras",
        "parent_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of sets.\n\n    The base category for collections of elements with = (equality).\n\n    This is also the category whose objects are all parents.\n\n    EXAMPLES::\n\n        sage: Sets()\n        Category of sets\n        sage: Sets().super_categories()\n        [Category of sets with partial maps]\n        sage: Sets().all_super_categories()\n        [Category of sets, Category of sets with partial maps, Category of objects]\n\n    Let us consider an example of set::\n\n        sage: P = Sets().example(\"inherits\")\n        sage: P\n        Set of prime numbers\n\n    See ``P??`` for the code.\n\n\n    P is in the category of sets::\n\n        sage: P.category()\n        Category of sets\n\n    and therefore gets its methods from the following classes::\n\n        sage: for cl in P.__class__.mro(): print(cl)\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits_with_category'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Abstract'>\n        <class 'sage.structure.unique_representation.UniqueRepresentation'>\n        <class 'sage.structure.unique_representation.CachedRepresentation'>\n        <type 'sage.misc.fast_methods.WithEqualityById'>\n        <type 'sage.structure.parent.Parent'>\n        <type 'sage.structure.category_object.CategoryObject'>\n        <type 'sage.structure.sage_object.SageObject'>\n        <class 'sage.categories.sets_cat.Sets.parent_class'>\n        <class 'sage.categories.sets_with_partial_maps.SetsWithPartialMaps.parent_class'>\n        <class 'sage.categories.objects.Objects.parent_class'>\n        <type 'object'>\n\n    We run some generic checks on P::\n\n        sage: TestSuite(P).run(verbose=True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n\n    Now, we manipulate some elements of P::\n\n        sage: P.an_element()\n        47\n        sage: x = P(3)\n        sage: x.parent()\n        Set of prime numbers\n        sage: x in P, 4 in P\n        (True, False)\n        sage: x.is_prime()\n        True\n\n    They get their methods from the following classes::\n\n        sage: for cl in x.__class__.mro(): print(cl)\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits_with_category.element_class'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits.Element'>\n        <type 'sage.rings.integer.IntegerWrapper'>\n        <type 'sage.rings.integer.Integer'>\n        <type 'sage.structure.element.EuclideanDomainElement'>\n        <type 'sage.structure.element.PrincipalIdealDomainElement'>\n        <type 'sage.structure.element.DedekindDomainElement'>\n        <type 'sage.structure.element.IntegralDomainElement'>\n        <type 'sage.structure.element.CommutativeRingElement'>\n        <type 'sage.structure.element.RingElement'>\n        <type 'sage.structure.element.ModuleElement'>\n        <class 'sage.categories.examples.sets_cat.PrimeNumbers_Abstract.Element'>\n        <type 'sage.structure.element.Element'>\n        <type 'sage.structure.sage_object.SageObject'>\n        <class 'sage.categories.sets_cat.Sets.element_class'>\n        <class 'sage.categories.sets_with_partial_maps.SetsWithPartialMaps.element_class'>\n        <class 'sage.categories.objects.Objects.element_class'>\n        <type 'object'>\n\n    FIXME: Objects.element_class is not very meaningful ...\n\n\n    TESTS::\n\n          sage: TestSuite(Sets()).run()\n\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {
                "cartesian_product": {
                    "__doc__": "\n            Return the Cartesian product of its arguments, as an element of\n            the Cartesian product of the parents of those elements.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example()\n                sage: (a,b,c) = A.algebra_generators()\n                sage: a.cartesian_product(b, c)\n                B[(0, word: a)] + B[(1, word: b)] + B[(2, word: c)]\n\n            FIXME: is this a policy that we want to enforce on all parents?\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "elements",
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "mmt": "Set",
        "morphism_class": {
            "__doc__": null,
            "methods": {
                "__invert__": {
                    "__doc__": "\n            Return the inverse morphism, or raise an error.\n\n            The error may either state that the morphism is not\n            invertible, or that Sage cannot invert it.\n\n            EXAMPLES::\n\n                sage: i = End(QQ).identity(); i\n                Identity endomorphism of Rational Field\n                sage: i.__invert__()\n                Identity endomorphism of Rational Field\n\n            This method is meant to be used with the Python inversion\n            operator `~`::\n\n                sage: ~i\n                Identity endomorphism of Rational Field\n\n            We now try to inverse a couple of morphisms defined by a matrix::\n\n                sage: H = End(QQ^2)\n                sage: phi = H(matrix([[1,1],[0,1]])); phi\n                Vector space morphism represented by the matrix:\n                [1 1]\n                [0 1]\n                Domain: Vector space of dimension 2 over Rational Field\n                Codomain: Vector space of dimension 2 over Rational Field\n                sage: ~phi\n                Vector space morphism represented by the matrix:\n                [ 1 -1]\n                [ 0  1]\n                Domain: Vector space of dimension 2 over Rational Field\n                Codomain: Vector space of dimension 2 over Rational Field\n\n                sage: phi = H(matrix([[1,1],[1,1]]))\n                sage: ~phi\n                Traceback (most recent call last):\n                ...\n                ZeroDivisionError: matrix morphism not invertible\n\n            .. NOTE::\n\n                This is an optional method. A default implementation\n                raising ``NotImplementedError`` could be provided instead.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "name": "sage.categories.sets_cat.Sets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "CartesianProduct": {
                    "__doc__": "LazyImport(module, name, as_name=None, namespace=None, at_startup=False, deprecation=None)\nFile: sage/misc/lazy_import.pyx (starting at line 132)\n\n    EXAMPLES::\n\n        sage: from sage.misc.lazy_import import LazyImport\n        sage: my_integer = LazyImport('sage.rings.all', 'Integer')\n        sage: my_integer(4)\n        4\n        sage: my_integer('101', base=2)\n        5\n        sage: my_integer(3/2)\n        Traceback (most recent call last):\n        ...\n        TypeError: no conversion of this rational to integer\n    ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        "args",
                        "kwds",
                        [
                            0
                        ]
                    ]
                },
                "__contains__": {
                    "__doc__": "\n            Test whether the set ``self`` contains the object ``x``.\n\n            All parents in the category ``Sets()`` should implement this method.\n\n            EXAMPLES::\n\n                sage: P = Sets().example(); P\n                Set of prime numbers (basic implementation)\n                sage: 12 in P\n                False\n                sage: P(5) in P\n                True\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_an_element_": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method _an_element_ at 0x7fe375e8ef50>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "self",
                    "gap_name": "Representative",
                    "mmt_name": null
                },
                "_element_constructor_from_element_class": {
                    "__doc__": "\n            The default constructor for elements of this parent ``self``.\n\n            Among other things, it is called upon ``self(data)`` when\n            the coercion model did not find a way to coerce ``data`` into\n            this parent.\n\n            This default implementation for\n            :meth:`_element_constructor_` calls the constructor of the\n            element class, passing ``self`` as first argument.\n\n            EXAMPLES::\n\n                sage: S = Sets().example(\"inherits\")\n                sage: s = S._element_constructor_from_element_class(17); s\n                17\n                sage: type(s)\n                <class 'sage.categories.examples.sets_cat.PrimeNumbers_Inherits_with_category.element_class'>\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "keywords",
                        null
                    ]
                },
                "_test_an_element": {
                    "__doc__": "\n            Run generic tests on the method :meth:`.an_element`.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_an_element()\n\n            Let us now write a broken :meth:`.an_element` method::\n\n                sage: from sage.categories.examples.sets_cat import PrimeNumbers\n                sage: class CCls(PrimeNumbers):\n                ...       def an_element(self):\n                ...           return 18\n                sage: CC = CCls()\n                sage: CC._test_an_element()\n                Traceback (most recent call last):\n                ...\n                AssertionError: self.an_element() is not in self\n\n            TESTS::\n\n                sage: FiniteEnumeratedSet([])._test_an_element()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_cardinality": {
                    "__doc__": "\n            Run generic test on the method :meth:`.cardinality`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_cardinality()\n\n            Let us now write a broken :meth:`cardinality` method::\n\n                sage: from sage.categories.examples.sets_cat import *\n                sage: class CCls(PrimeNumbers):\n                ....:     def cardinality(self):\n                ....:         return int(5)\n                sage: CC = CCls()\n                sage: CC._test_cardinality()\n                Traceback (most recent call last):\n                ...\n                AssertionError: the output of the method cardinality must either\n                be a Sage integer or infinity. Not <type 'int'>.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_elements": {
                    "__doc__": "\n            Run generic tests on element(s) of ``self``.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements(verbose = True)\n                <BLANKLINE>\n                  Running the test suite of self.an_element()\n                  running ._test_category() . . . pass\n                  running ._test_eq() . . . pass\n                  running ._test_nonzero_equal() . . . pass\n                  running ._test_not_implemented_methods() . . . pass\n                  running ._test_pickling() . . . pass\n                <BLANKLINE>\n\n            Debugging tip: in case of failure of this test, run instead::\n\n                sage: TestSuite(C.an_element()).run()\n\n            Let us now implement a parent whose elements cannot be pickled::\n\n                sage: from sage.categories.examples.sets_cat import PrimeNumbers\n                sage: class Bla(SageObject): pass\n                sage: class CCls(PrimeNumbers):\n                ...       def an_element(self):\n                ...           return Bla()\n                sage: CC = CCls()\n                sage: CC._test_elements()\n                  Failure in _test_pickling:\n                  ...\n                  PicklingError: Can't pickle <class '__main__.Bla'>: attribute lookup __main__.Bla failed\n                  ...\n                  The following tests failed: _test_pickling\n            ",
                    "args": [
                        "self",
                        "tester"
                    ],
                    "argspec": [
                        [
                            "self",
                            "tester"
                        ],
                        null,
                        "options",
                        [
                            null
                        ]
                    ]
                },
                "_test_elements_eq_reflexive": {
                    "__doc__": "\n            Run generic tests on the equality of elements.\n\n            Test that ``==`` is reflexive.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_eq_reflexive()\n\n            We try a non-reflexive equality::\n\n                sage: P = Sets().example(\"wrapper\")\n                sage: P._test_elements_eq_reflexive()\n                sage: eq = P.element_class.__eq__\n\n                sage: P.element_class.__eq__ = (lambda x, y:\n                ...        False if eq(x, P(47)) and eq(y, P(47)) else eq(x, y))\n                sage: P._test_elements_eq_reflexive()\n                Traceback (most recent call last):\n                ...\n                AssertionError: 47 != 47\n\n            We restore ``P.element_class`` in a proper state for further tests::\n\n                sage: P.element_class.__eq__ = eq\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_elements_eq_symmetric": {
                    "__doc__": "\n            Run generic tests on the equality of elements.\n\n            This tests that ``==`` is symmetric.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_eq_symmetric()\n\n            We test a non symmetric equality::\n\n                sage: P = Sets().example(\"wrapper\")\n                sage: P._test_elements_eq_symmetric()\n                sage: eq = P.element_class.__eq__\n\n                sage: def non_sym_eq(x, y):\n                ...      if not y in P:                      return False\n                ...      elif eq(x, P(47)) and eq(y, P(53)): return True\n                ...      else:                               return eq(x, y)\n                sage: P.element_class.__eq__ = non_sym_eq\n                sage: P._test_elements_eq_symmetric()\n                Traceback (most recent call last):\n                ...\n                AssertionError: non symmetric equality: 47 == 53 but 53 != 47\n\n            We restore ``P.element_class`` in a proper state for further tests::\n\n                sage: P.element_class.__eq__ = eq\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_elements_eq_transitive": {
                    "__doc__": "\n            Run generic tests on the equality of elements.\n\n            Test that ``==`` is transitive.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_eq_transitive()\n\n            We test a non transitive equality::\n\n                sage: R = Zp(3)\n                sage: Sets().ParentMethods._test_elements_eq_transitive.__func__(R,elements=[R(3,2),R(3,1),R(0)])\n                Traceback (most recent call last):\n                ...\n                AssertionError: non transitive equality:\n                3 + O(3^2) == O(3) and O(3) == 0 but 3 + O(3^2) != 0\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_elements_neq": {
                    "__doc__": "\n            Run generic tests on the equality of elements.\n\n            Test that ``==`` and ``!=`` are consistent.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_elements_neq()\n\n            We try a broken inequality::\n\n                sage: P = Sets().example(\"wrapper\")\n                sage: P._test_elements_neq()\n                sage: ne = P.element_class.__ne__\n                sage: eq = P.element_class.__eq__\n\n                sage: P.element_class.__ne__ = lambda x, y: False\n                sage: P._test_elements_neq()\n                Traceback (most recent call last):\n                ...\n                AssertionError: __eq__ and __ne__ inconsistency:\n                  47 == 53 returns False  but  47 != 53 returns False\n\n                sage: P.element_class.__ne__ = lambda x, y: not(x == y)\n\n            We restore ``P.element_class`` in a proper state for further tests::\n\n                sage: P.element_class.__ne__ = ne\n                sage: P.element_class.__eq__ = eq\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_some_elements": {
                    "__doc__": "\n            Run generic tests on the method :meth:`.some_elements`.\n\n            .. SEEALSO:: :class:`TestSuite`\n\n            EXAMPLES::\n\n                sage: C = Sets().example()\n                sage: C._test_some_elements()\n\n            Let us now write a broken :meth:`.some_elements` method::\n\n                sage: from sage.categories.examples.sets_cat import *\n                sage: class CCls(PrimeNumbers):\n                ...       def some_elements(self):\n                ...           return [self(17), 32]\n                sage: CC = CCls()\n                sage: CC._test_some_elements()\n                Traceback (most recent call last):\n                ...\n                AssertionError: the object 32 in self.some_elements() is not in self\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "algebra": {
                    "__doc__": "\n            Return the algebra of ``self`` over ``base_ring``.\n\n            INPUT:\n\n            - ``self`` -- a parent `S`\n            - ``base_ring`` -- a ring `K`\n            - ``category`` -- a super category of the category\n              of `S`, or ``None``\n\n            This returns the `K`-free module with basis indexed by\n            `S`, endowed with whatever structure can be induced from\n            that of `S`. Note that the ``category`` keyword needs to\n            be fed with the structure on `S` to be used, not the\n            structure that one wants to obtain on the result; see the\n            examples below.\n\n            EXAMPLES:\n\n            If `S` is a monoid, the result is the monoid algebra `KS`::\n\n                sage: S = Monoids().example(); S\n                An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n                sage: A = S.algebra(QQ); A\n                Free module generated by An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd') over Rational Field\n                sage: A.category()\n                Category of monoid algebras over Rational Field\n\n            If `S` is a group, the result is the group algebra `KS`::\n\n                sage: S = Groups().example(); S\n                General Linear Group of degree 4 over Rational Field\n                sage: A = S.algebra(QQ); A\n                Group algebra of General Linear Group of degree 4 over Rational Field over Rational Field\n                sage: A.category()\n                Category of group algebras over Rational Field\n\n            which is actually a Hopf algebra::\n\n                sage: A in HopfAlgebras(QQ)\n                True\n\n            By Maschke's theorem, for a finite group whose cardinality\n            does not divide the characteristic of the base field, the\n            algebra is semisimple::\n\n                sage: SymmetricGroup(5).algebra(QQ) in Algebras(QQ).Semisimple()\n                True\n                sage: CyclicPermutationGroup(10).algebra(FiniteField(5)) in Algebras.Semisimple\n                False\n                sage: CyclicPermutationGroup(10).algebra(FiniteField(7)) in Algebras.Semisimple\n                True\n\n\n            One may specify for which category one takes the algebra::\n\n                sage: A = S.algebra(QQ, category=Sets()); A\n                Free module generated by General Linear Group of degree 4 over Rational Field over Rational Field\n                sage: A.category()\n                Category of set algebras over Rational Field\n\n            One may construct as well algebras of additive magmas,\n            semigroups, monoids, or groups::\n\n                sage: S = CommutativeAdditiveMonoids().example(); S\n                An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd')\n                sage: U = S.algebra(QQ); U\n                Free module generated by An example of a commutative monoid: the free commutative monoid generated by ('a', 'b', 'c', 'd') over Rational Field\n\n            Despite saying \"free module\", this is really an algebra\n            and its elements can be multiplied::\n\n                sage: U in Algebras(QQ)\n                True\n                sage: (a,b,c,d) = S.additive_semigroup_generators()\n                sage: U(a) * U(b)\n                B[a + b]\n\n            Constructing the algebra of a set endowed with both an\n            additive and a multiplicative structure is ambiguous::\n\n                sage: Z3 = IntegerModRing(3)\n                sage: A = Z3.algebra(QQ)\n                Traceback (most recent call last):\n                ...\n                TypeError:  `S = Ring of integers modulo 3` is both an additive and a multiplicative semigroup.\n                Constructing its algebra is ambiguous.\n                Please use, e.g., S.algebra(QQ, category=Semigroups())\n\n            The ambiguity can be resolved using the ``category`` argument::\n\n                sage: A = Z3.algebra(QQ, category=Monoids()); A\n                Free module generated by Ring of integers modulo 3 over Rational Field\n                sage: A.category()\n                Category of finite dimensional monoid algebras over Rational Field\n\n                sage: A = Z3.algebra(QQ, category=CommutativeAdditiveGroups()); A\n                Free module generated by Ring of integers modulo 3 over Rational Field\n                sage: A.category()\n                Category of finite dimensional commutative additive group algebras over Rational Field\n\n            Similarly, on , we obtain for additive magmas, monoids, groups.\n\n\n            .. WARNING::\n\n                As we have seen, in most practical use cases, the\n                result is actually an algebra, hence the name of this\n                method. In the other cases this name is misleading::\n\n                    sage: A = Sets().example().algebra(QQ); A\n                    Free module generated by Set of prime numbers (basic implementation) over Rational Field\n                    sage: A.category()\n                    Category of set algebras over Rational Field\n                    sage: A in Algebras(QQ)\n                    False\n\n                Suggestions for a uniform, meaningful, and non\n                misleading name are welcome!\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "category"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "an_element": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "cardinality": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method cardinality at 0x7fe375e8eed8>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "sage",
                    "gap_name": "Size",
                    "mmt_name": null
                },
                "cartesian_product": {
                    "__doc__": "\n            Return the Cartesian product of the parents.\n\n            INPUT:\n\n            - ``parents`` -- a list (or other iterable) of parents.\n\n            - ``category`` -- (default: ``None``) the category the\n              Cartesian product belongs to. If ``None`` is passed,\n              then\n              :meth:`~sage.categories.covariant_functorial_construction.CovariantFactorialConstruction.category_from_parents`\n              is used to determine the category.\n\n            - ``extra_category`` -- (default: ``None``) a category\n              that is added to the Cartesian product in addition\n              to the categories obtained from the parents.\n\n            - other keyword arguments will passed on to the class used\n              for this Cartesian product (see also\n              :class:`~sage.sets.cartesian_product.CartesianProduct`).\n\n            OUTPUT:\n\n            The Cartesian product.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example(); A.rename(\"A\")\n                sage: A.cartesian_product(A,A)\n                A (+) A (+) A\n                sage: ZZ.cartesian_product(GF(2), FiniteEnumeratedSet([1,2,3]))\n                The Cartesian product of (Integer Ring, Finite Field of size 2, {1, 2, 3})\n\n                sage: C = ZZ.cartesian_product(A); C\n                The Cartesian product of (Integer Ring, A)\n\n            TESTS::\n\n                sage: type(C)\n                <class 'sage.sets.cartesian_product.CartesianProduct_with_category'>\n                sage: C.category()\n                Join of Category of rings and ...\n                    and Category of Cartesian products of commutative additive groups\n\n            ::\n\n                sage: cartesian_product([ZZ, ZZ], category=Sets()).category()\n                Category of sets\n                sage: cartesian_product([ZZ, ZZ]).category()\n                Join of\n                Category of Cartesian products of commutative rings and\n                Category of Cartesian products of enumerated sets\n                sage: cartesian_product([ZZ, ZZ], extra_category=Posets()).category()\n                Join of\n                Category of Cartesian products of commutative rings and\n                Category of posets and\n                Category of Cartesian products of enumerated sets\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "parents",
                        "kwargs",
                        null
                    ]
                },
                "is_finite": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method is_finite at 0x7fe375e8ede8>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "sage",
                    "gap_name": "IsFinite",
                    "mmt_name": null
                },
                "is_parent_of": {
                    "__doc__": "\n            Return whether ``self`` is the parent of ``element``.\n\n            INPUT:\n\n            - ``element`` -- any object\n\n            EXAMPLES::\n\n                sage: S = ZZ\n                sage: S.is_parent_of(1)\n                True\n                sage: S.is_parent_of(2/1)\n                False\n\n            This method differs from :meth:`__contains__` because it\n            does not attempt any coercion::\n\n                sage: 2/1 in S, S.is_parent_of(2/1)\n                (True, False)\n                sage: int(1) in S, S.is_parent_of(int(1))\n                (True, False)\n            ",
                    "args": [
                        "self",
                        "element"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "random_element": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method random_element at 0x7fe375eb2050>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "self",
                    "gap_name": "Random",
                    "mmt_name": null
                },
                "some_elements": {
                    "__doc__": "\n            Return a list (or iterable) of elements of ``self``.\n\n            This is typically used for running generic tests\n            (see :class:`TestSuite`).\n\n            This default implementation calls :meth:`.an_element`.\n\n            EXAMPLES::\n\n                sage: S = Sets().example(); S\n                Set of prime numbers (basic implementation)\n                sage: S.an_element()\n                47\n                sage: S.some_elements()\n                [47]\n                sage: S = Set([])\n                sage: S.some_elements()\n                []\n\n            This method should return an iterable, *not* an iterator.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "cartesian_product": {
                    "__doc__": "\n            Return the Cartesian product of its arguments, as an element of\n            the Cartesian product of the parents of those elements.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example()\n                sage: (a,b,c) = A.algebra_generators()\n                sage: a.cartesian_product(b, c)\n                B[(0, word: a)] + B[(1, word: b)] + B[(2, word: c)]\n\n            FIXME: is this a policy that we want to enforce on all parents?\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "elements",
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of semirings.\n\n    A semiring `(S,+,*)` is similar to a ring, but without the\n    requirement that each element must have an additive inverse. In\n    other words, it is a combination of a commutative additive monoid\n    `(S,+)` and a multiplicative monoid `(S,*)`, where `*` distributes\n    over `+`.\n\n    .. SEEALSO::\n\n        :wikipedia:`Semiring`\n\n    EXAMPLES::\n\n        sage: Semirings()\n        Category of semirings\n        sage: Semirings().super_categories()\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of monoids]\n\n        sage: sorted(Semirings().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital', 'Associative', 'Distributive', 'Unital']\n\n        sage: Semirings() is (CommutativeAdditiveMonoids() & Monoids()).Distributive()\n        True\n\n        sage: Semirings().AdditiveInverse()\n        Category of rings\n\n\n    TESTS::\n\n        sage: TestSuite(Semirings()).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of semirings.\n\n    A semiring `(S,+,*)` is similar to a ring, but without the\n    requirement that each element must have an additive inverse. In\n    other words, it is a combination of a commutative additive monoid\n    `(S,+)` and a multiplicative monoid `(S,*)`, where `*` distributes\n    over `+`.\n\n    .. SEEALSO::\n\n        :wikipedia:`Semiring`\n\n    EXAMPLES::\n\n        sage: Semirings()\n        Category of semirings\n        sage: Semirings().super_categories()\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of monoids]\n\n        sage: sorted(Semirings().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital', 'Associative', 'Distributive', 'Unital']\n\n        sage: Semirings() is (CommutativeAdditiveMonoids() & Monoids()).Distributive()\n        True\n\n        sage: Semirings().AdditiveInverse()\n        Category of rings\n\n\n    TESTS::\n\n        sage: TestSuite(Semirings()).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital.Associative",
            "sage.categories.monoids.Monoids"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of semirings.\n\n    A semiring `(S,+,*)` is similar to a ring, but without the\n    requirement that each element must have an additive inverse. In\n    other words, it is a combination of a commutative additive monoid\n    `(S,+)` and a multiplicative monoid `(S,*)`, where `*` distributes\n    over `+`.\n\n    .. SEEALSO::\n\n        :wikipedia:`Semiring`\n\n    EXAMPLES::\n\n        sage: Semirings()\n        Category of semirings\n        sage: Semirings().super_categories()\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of monoids]\n\n        sage: sorted(Semirings().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital', 'Associative', 'Distributive', 'Unital']\n\n        sage: Semirings() is (CommutativeAdditiveMonoids() & Monoids()).Distributive()\n        True\n\n        sage: Semirings().AdditiveInverse()\n        Category of rings\n\n\n    TESTS::\n\n        sage: TestSuite(Semirings()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.semirings.Semirings",
        "parent_class": {
            "__doc__": "\n    The category of semirings.\n\n    A semiring `(S,+,*)` is similar to a ring, but without the\n    requirement that each element must have an additive inverse. In\n    other words, it is a combination of a commutative additive monoid\n    `(S,+)` and a multiplicative monoid `(S,*)`, where `*` distributes\n    over `+`.\n\n    .. SEEALSO::\n\n        :wikipedia:`Semiring`\n\n    EXAMPLES::\n\n        sage: Semirings()\n        Category of semirings\n        sage: Semirings().super_categories()\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of monoids]\n\n        sage: sorted(Semirings().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital', 'Associative', 'Distributive', 'Unital']\n\n        sage: Semirings() is (CommutativeAdditiveMonoids() & Monoids()).Distributive()\n        True\n\n        sage: Semirings().AdditiveInverse()\n        Category of rings\n\n\n    TESTS::\n\n        sage: TestSuite(Semirings()).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of semirings.\n\n    A semiring `(S,+,*)` is similar to a ring, but without the\n    requirement that each element must have an additive inverse. In\n    other words, it is a combination of a commutative additive monoid\n    `(S,+)` and a multiplicative monoid `(S,*)`, where `*` distributes\n    over `+`.\n\n    .. SEEALSO::\n\n        :wikipedia:`Semiring`\n\n    EXAMPLES::\n\n        sage: Semirings()\n        Category of semirings\n        sage: Semirings().super_categories()\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of monoids]\n\n        sage: sorted(Semirings().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveUnital', 'Associative', 'Distributive', 'Unital']\n\n        sage: Semirings() is (CommutativeAdditiveMonoids() & Monoids()).Distributive()\n        True\n\n        sage: Semirings().AdditiveInverse()\n        Category of rings\n\n\n    TESTS::\n\n        sage: TestSuite(Semirings()).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of groupoids, for a set (usually a group) $G$.\n\n    FIXME:\n\n     - Groupoid or Groupoids ?\n     - definition and link with http://en.wikipedia.org/wiki/Groupoid\n     - Should Groupoid inherit from Category_over_base?\n\n    EXAMPLES::\n\n        sage: Groupoid(DihedralGroup(3))\n        Groupoid with underlying set Dihedral group of order 6 as a permutation group\n\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of groupoids, for a set (usually a group) $G$.\n\n    FIXME:\n\n     - Groupoid or Groupoids ?\n     - definition and link with http://en.wikipedia.org/wiki/Groupoid\n     - Should Groupoid inherit from Category_over_base?\n\n    EXAMPLES::\n\n        sage: Groupoid(DihedralGroup(3))\n        Groupoid with underlying set Dihedral group of order 6 as a permutation group\n\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of groupoids, for a set (usually a group) $G$.\n\n    FIXME:\n\n     - Groupoid or Groupoids ?\n     - definition and link with http://en.wikipedia.org/wiki/Groupoid\n     - Should Groupoid inherit from Category_over_base?\n\n    EXAMPLES::\n\n        sage: Groupoid(DihedralGroup(3))\n        Groupoid with underlying set Dihedral group of order 6 as a permutation group\n\n    ",
            "methods": {}
        },
        "name": "sage.categories.groupoid.Groupoid",
        "parent_class": {
            "__doc__": "\n    The category of groupoids, for a set (usually a group) $G$.\n\n    FIXME:\n\n     - Groupoid or Groupoids ?\n     - definition and link with http://en.wikipedia.org/wiki/Groupoid\n     - Should Groupoid inherit from Category_over_base?\n\n    EXAMPLES::\n\n        sage: Groupoid(DihedralGroup(3))\n        Groupoid with underlying set Dihedral group of order 6 as a permutation group\n\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.groupoid.Groupoid",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of groupoids, for a set (usually a group) $G$.\n\n    FIXME:\n\n     - Groupoid or Groupoids ?\n     - definition and link with http://en.wikipedia.org/wiki/Groupoid\n     - Should Groupoid inherit from Category_over_base?\n\n    EXAMPLES::\n\n        sage: Groupoid(DihedralGroup(3))\n        Groupoid with underlying set Dihedral group of order 6 as a permutation group\n\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of number fields.\n\n    EXAMPLES:\n\n    We create the category of number fields::\n\n        sage: C = NumberFields()\n        sage: C\n        Category of number fields\n\n    Notice that the rational numbers `\\QQ` *are* considered as\n    an object in this category::\n\n        sage: RationalField() in C\n        True\n\n    However, we can define a degree 1 extension of `\\QQ`, which is of\n    course also in this category::\n\n        sage: x = PolynomialRing(RationalField(), 'x').gen()\n        sage: K = NumberField(x - 1, 'a'); K\n        Number Field in a with defining polynomial x - 1\n        sage: K in C\n        True\n\n    Number fields all lie in this category, regardless of the name\n    of the variable::\n\n        sage: K = NumberField(x^2 + 1, 'a')\n        sage: K in C\n        True\n\n    TESTS::\n\n        sage: TestSuite(NumberFields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.fields.Fields"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of number fields.\n\n    EXAMPLES:\n\n    We create the category of number fields::\n\n        sage: C = NumberFields()\n        sage: C\n        Category of number fields\n\n    Notice that the rational numbers `\\QQ` *are* considered as\n    an object in this category::\n\n        sage: RationalField() in C\n        True\n\n    However, we can define a degree 1 extension of `\\QQ`, which is of\n    course also in this category::\n\n        sage: x = PolynomialRing(RationalField(), 'x').gen()\n        sage: K = NumberField(x - 1, 'a'); K\n        Number Field in a with defining polynomial x - 1\n        sage: K in C\n        True\n\n    Number fields all lie in this category, regardless of the name\n    of the variable::\n\n        sage: K = NumberField(x^2 + 1, 'a')\n        sage: K in C\n        True\n\n    TESTS::\n\n        sage: TestSuite(NumberFields()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.number_fields.NumberFields",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.number_fields.NumberFields",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite dimensional algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = FiniteDimensionalAlgebrasWithBasis(QQ); C\n        Category of finite dimensional algebras with basis over Rational Field\n        sage: C.super_categories()\n        [Category of algebras with basis over Rational Field,\n         Category of finite dimensional modules with basis over Rational Field]\n        sage: C.example()\n        An example of a finite dimensional algebra with basis:\n        the path algebra of the Kronecker quiver\n        (containing the arrows a:x->y and b:x->y) over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Algebras(QQ).FiniteDimensional().WithBasis()\n        True\n        sage: C is Algebras(QQ).WithBasis().FiniteDimensional()\n        True\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "FiniteDimensional",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "_matrix_": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "on_left_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "to_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite dimensional algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = FiniteDimensionalAlgebrasWithBasis(QQ); C\n        Category of finite dimensional algebras with basis over Rational Field\n        sage: C.super_categories()\n        [Category of algebras with basis over Rational Field,\n         Category of finite dimensional modules with basis over Rational Field]\n        sage: C.example()\n        An example of a finite dimensional algebra with basis:\n        the path algebra of the Kronecker quiver\n        (containing the arrows a:x->y and b:x->y) over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Algebras(QQ).FiniteDimensional().WithBasis()\n        True\n        sage: C is Algebras(QQ).WithBasis().FiniteDimensional()\n        True\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_dimensional_algebras_with_basis.FiniteDimensionalAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "cartan_invariants_matrix": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "center": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "center_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "idempotent_lift": {
                    "__doc__": "\n            Lift an idempotent of the semisimple quotient into an idempotent of ``self``.\n\n            Let `A` be this finite dimensional algebra and `\\pi` be\n            the projection `A \\rightarrow \\overline{A}` on its\n            semisimple quotient. Let `\\overline{x}` be an idempotent\n            of `\\overline A`, and `x` any lift thereof in `A`. This\n            returns an idempotent `e` of `A` such that `\\pi(e)=\\pi(x)`\n            and `e` is a polynomial in `x`.\n\n            INPUT:\n\n            - `x` -- an element of `A` that projects on an idempotent\n              `\\overline x` of the semisimple quotient of `A`.\n              Alternatively one may give as input the idempotent\n              `\\overline{x}`, in which case some lift thereof will be\n              taken for `x`.\n\n            OUTPUT: the idempotent `e` of ``self``\n\n            ALGORITHM:\n\n            Iterate the formula `1 - (1 - x^2)^2` until having an\n            idempotent.\n\n            See [CR62]_ for correctness and termination proofs.\n\n            EXAMPLES::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example()\n                sage: S = A.semisimple_quotient()\n                sage: A.idempotent_lift(S.basis()['x'])\n                x\n                sage: A.idempotent_lift(A.basis()['y'])\n                y\n\n            .. TODO::\n\n                Add some non trivial example\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_commutative": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "is_identity_decomposition_into_orthogonal_idempotents": {
                    "__doc__": "\n            Return whether ``l`` is a decomposition of the identity\n            into orthogonal idempotents.\n\n            INPUT:\n\n            - ``l`` -- a list or iterable of elements of ``self``\n\n            EXAMPLES::\n\n                sage: A = FiniteDimensionalAlgebrasWithBasis(QQ).example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n\n                sage: x,y,a,b = A.algebra_generators(); x,y,a,b\n                (x, y, a, b)\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([A.one()])\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([x,y])\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([x+a, y-a])\n                True\n\n            Here the idempotents do not sum up to `1`::\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([x])\n                False\n\n            Here `1+x` and `-x` are neither idempotent nor orthogonal::\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([1+x,-x])\n                False\n\n            With the algebra of the `0`-Hecke monoid::\n\n                sage: from sage.monoids.hecke_monoid import HeckeMonoid\n                sage: A = HeckeMonoid(SymmetricGroup(4)).algebra(QQ)\n                sage: idempotents = A.orthogonal_idempotents_central_mod_radical()\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents(idempotents)\n                True\n\n            Here are some more counterexamples:\n\n            1. Some orthogonal elements summing to `1` but not being\n            idempotent::\n\n                sage: class PQAlgebra(CombinatorialFreeModule):\n                ....:     def __init__(self, F, p):\n                ....:         # Construct the quotient algebra F[x] / p,\n                ....:         # where p is a univariate polynomial.\n                ....:         R = parent(p); x = R.gen()\n                ....:         I = R.ideal(p)\n                ....:         self._xbar = R.quotient(I).gen()\n                ....:         basis_keys = [self._xbar**i for i in range(p.degree())]\n                ....:         CombinatorialFreeModule.__init__(self, F, basis_keys,\n                ....:                 category=Algebras(F).FiniteDimensional().WithBasis())\n                ....:     def x(self):\n                ....:         return self(self._xbar)\n                ....:     def one(self):\n                ....:         return self.basis()[self.base_ring().one()]\n                ....:     def product_on_basis(self, w1, w2):\n                ....:         return self.from_vector(vector(w1*w2))\n                sage: R.<x> = PolynomialRing(QQ)\n                sage: A = PQAlgebra(QQ, x**3 - x**2 + x + 1); y = A.x()\n                sage: a, b = y, 1-y\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, b))\n                False\n\n            For comparison::\n\n                sage: A = PQAlgebra(QQ, x**2 - x); y = A.x()\n                sage: a, b = y, 1-y\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, b))\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, A.zero(), b))\n                True\n                sage: A = PQAlgebra(QQ, x**3 - x**2 + x - 1); y = A.x()\n                sage: a = (y**2 + 1) / 2\n                sage: b = 1 - a\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, b))\n                True\n\n            2. Some idempotents summing to 1 but not orthogonal::\n\n                sage: R.<x> = PolynomialRing(GF(2))\n                sage: A = PQAlgebra(GF(2), x)\n                sage: a = A.one()\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a,))\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, a, a))\n                False\n\n            3. Some orthogonal idempotents not summing to the identity::\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a,a))\n                False\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents(())\n                False\n            ",
                    "args": [
                        "self",
                        "l"
                    ],
                    "argspec": [
                        [
                            "self",
                            "l"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "isotypic_projective_modules": {
                    "__doc__": "\n            Return the isotypic projective ``side`` ``self``-modules.\n\n            Let `P_i` be representatives of the indecomposable\n            projective ``side``-modules of this finite dimensional\n            algebra `A`, and `S_i` be the associated simple modules.\n\n            The regular ``side`` representation of `A` can be\n            decomposed as a direct sum `A = \\bigoplus_i Q_i` where\n            each `Q_i` is an isotypic projective module; namely `Q_i`\n            is the direct sum of `\\dim S_i` copies of the\n            indecomposable projective module `P_i`. This decomposition\n            is not unique.\n\n            The isotypic projective modules are constructed as\n            `Q_i=e_iA`, where the `(e_i)_i` is the decomposition of\n            the identity into orthogonal idempotents obtained by\n            lifting the central orthogonal idempotents of the\n            semisimple quotient of `A`.\n\n            INPUT:\n\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            OUTPUT: a list of subspaces of ``self``.\n\n            EXAMPLES::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: Q = A.isotypic_projective_modules(side=\"left\"); Q\n                [Free module generated by {0} over Rational Field,\n                 Free module generated by {0, 1, 2} over Rational Field]\n                sage: [[x.lift() for x in Qi.basis()]\n                ....:  for Qi in Q]\n                [[x],\n                 [y, a, b]]\n\n            We check that the sum of the dimensions of the isotypic\n            projective modules is the dimension of ``self``::\n\n                sage: sum([Qi.dimension() for Qi in Q]) == A.dimension()\n                True\n\n            .. SEEALSO::\n\n                - :meth:`orthogonal_idempotents_central_mod_radical`\n                - :meth:`peirce_decomposition`\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "left"
                        ]
                    ]
                },
                "orthogonal_idempotents_central_mod_radical": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "peirce_decomposition": {
                    "__doc__": "\n            Return a Peirce decomposition of ``self``.\n\n            Let `(e_i)_i` be a collection of orthogonal idempotents of\n            `A` with sum `1`. The *Peirce decomposition* of `A` is the\n            decomposition of `A` into the direct sum of the subspaces\n            `e_i A e_j`.\n\n            With the default collection of orthogonal idempotents, one has\n\n            .. MATH::\n\n                \\dim e_i A e_j = C_{i,j} \\dim S_i \\dim S_j\n\n            where `(S_i)_i` are the simple modules of `A` and\n            `(C_{i,j})_{i, j}` is the Cartan invariants matrix.\n\n            INPUT:\n\n            - ``idempotents`` -- a list of orthogonal idempotents\n              `(e_i)_{i=0,\\ldots,n}` of the algebra that sum to `1`\n              (default: the idempotents returned by\n              :meth:`orthogonal_idempotents_central_mod_radical`)\n\n            - ``check`` -- (default: ``True``) whether to check that the\n              idempotents are indeed orthogonal and idempotent and\n              sum to `1`\n\n            OUTPUT:\n\n            A list of lists `l` such that ``l[i][j]`` is the subspace\n            `e_i A e_j`.\n\n            .. SEEALSO::\n\n                - :meth:`orthogonal_idempotents_central_mod_radical`\n                - :meth:`cartan_invariants_matrix`\n\n            EXAMPLES::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: A.orthogonal_idempotents_central_mod_radical()\n                (x, y)\n                sage: decomposition = A.peirce_decomposition(); decomposition\n                [[Free module generated by {0} over Rational Field,\n                  Free module generated by {0, 1} over Rational Field],\n                 [Free module generated by {} over Rational Field,\n                  Free module generated by {0} over Rational Field]]\n                sage: [ [[x.lift() for x in decomposition[i][j].basis()]\n                ....:    for j in range(2)]\n                ....:   for i in range(2)]\n                [[[x], [a, b]],\n                 [[], [y]]]\n\n            We recover that the group algebra of the symmetric group\n            `S_4` is a block matrix algebra::\n\n                sage: A = SymmetricGroup(4).algebra(QQ)\n                sage: decomposition = A.peirce_decomposition()   # long time\n                sage: [[decomposition[i][j].dimension()          # long time (4s)\n                ....:   for j in range(len(decomposition))]\n                ....:  for i in range(len(decomposition))]\n                [[1, 0, 0, 0, 0],\n                 [0, 9, 0, 0, 0],\n                 [0, 0, 4, 0, 0],\n                 [0, 0, 0, 9, 0],\n                 [0, 0, 0, 0, 1]]\n\n            The dimension of each block is `d^2`, where `d` is the\n            dimension of the corresponding simple module of `S_4`. The\n            latter are given by::\n\n                sage: [p.standard_tableaux().cardinality() for p in Partitions(4)]\n                [1, 3, 2, 3, 1]\n            ",
                    "args": [
                        "self",
                        "idempotents",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "idempotents",
                            "check"
                        ],
                        null,
                        null,
                        [
                            null,
                            true
                        ]
                    ]
                },
                "peirce_summand": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "principal_ideal": {
                    "__doc__": "\n            Construct the ``side`` principal ideal generated by ``a``.\n\n            EXAMPLES:\n\n            In order to highlight the difference between left and\n            right principal ideals, our first example deals with a non\n            commutative algebra::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: x, y, a, b = A.basis()\n\n            In this algebra, multiplication on the right by `x`\n            annihilates all basis elements but `x`::\n\n                sage: x*x, y*x, a*x, b*x\n                (x, 0, 0, 0)\n\n            so the left ideal generated by `x` is one-dimensional::\n\n                sage: Ax = A.principal_ideal(x, side='left'); Ax\n                Free module generated by {0} over Rational Field\n                sage: [B.lift() for B in Ax.basis()]\n                [x]\n\n            Multiplication on the left by `x` annihilates\n            only `x` and fixes the other basis elements::\n\n                sage: x*x, x*y, x*a, x*b\n                (x, 0, a, b)\n\n            so the right ideal generated by `x` is 3-dimensional::\n\n                sage: xA = A.principal_ideal(x, side='right'); xA\n                Free module generated by {0, 1, 2} over Rational Field\n                sage: [B.lift() for B in xA.basis()]\n                [x, a, b]\n\n            .. SEEALSO::\n\n                - :meth:`peirce_summand`\n            ",
                    "args": [
                        "self",
                        "a",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "a",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "left"
                        ]
                    ]
                },
                "radical": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "radical_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "semisimple_quotient": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "_matrix_": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "on_left_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "to_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of Weyl groups\n\n    See the :wikipedia:`Wikipedia page of Weyl Groups <Weyl_group>`.\n\n    EXAMPLES::\n\n        sage: WeylGroups()\n        Category of weyl groups\n        sage: WeylGroups().super_categories()\n        [Category of coxeter groups]\n\n    Here are some examples::\n\n        sage: WeylGroups().example()            # todo: not implemented\n        sage: FiniteWeylGroups().example()\n        The symmetric group on {0, ..., 3}\n        sage: AffineWeylGroups().example()      # todo: not implemented\n        sage: WeylGroup([\"B\", 3])\n        Weyl Group of type ['B', 3] (as a matrix group acting on the ambient space)\n\n    This one will eventually be also in this category::\n\n        sage: SymmetricGroup(4)\n        Symmetric group of order 4! as a permutation group\n\n    TESTS::\n\n        sage: C = WeylGroups()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "FinitelyGeneratedAsMagma",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "bruhat_lower_covers_coroots": {
                    "__doc__": "\n            Return all 2-tuples (``v``, `\\alpha`) where ``v`` is covered\n            by ``self`` and `\\alpha` is the positive coroot such that\n            ``self`` = ``v`` `s_\\alpha` where `s_\\alpha` is\n            the reflection orthogonal to `\\alpha`.\n\n            ALGORITHM:\n\n            See :meth:`.bruhat_lower_covers` and\n            :meth:`.bruhat_lower_covers_reflections` for Coxeter groups.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3], prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.bruhat_lower_covers_coroots()\n                [(s1*s2*s1, alphacheck[1] + alphacheck[2] + alphacheck[3]),\n                 (s3*s2*s1, alphacheck[2]), (s3*s1*s2, alphacheck[1])]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "bruhat_upper_covers_coroots": {
                    "__doc__": "\n            Returns all 2-tuples (``v``, `\\alpha`) where ``v`` is covers ``self`` and `\\alpha`\n            is the positive coroot such that ``self`` = ``v`` `s_\\alpha` where `s_\\alpha` is\n            the reflection orthogonal to `\\alpha`.\n\n            ALGORITHM:\n\n            See :meth:`~CoxeterGroups.ElementMethods.bruhat_upper_covers` and :meth:`.bruhat_upper_covers_reflections` for Coxeter groups.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',4], prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.bruhat_upper_covers_coroots()\n                [(s1*s2*s3*s2*s1, alphacheck[3]),\n                 (s2*s3*s1*s2*s1, alphacheck[2] + alphacheck[3]),\n                 (s3*s4*s1*s2*s1, alphacheck[4]),\n                 (s4*s3*s1*s2*s1, alphacheck[1] + alphacheck[2] + alphacheck[3] + alphacheck[4])]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "inversion_arrangement": {
                    "__doc__": "\n            Return the inversion hyperplane arrangement of ``self``.\n\n            INPUT:\n\n            - ``side`` -- ``'right'`` (default) or ``'left'``\n\n            OUTPUT:\n\n            A (central) hyperplane arrangement whose hyperplanes correspond\n            to the inversions of ``self`` given as roots.\n\n            The ``side`` parameter determines on which side\n            to compute the inversions.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3])\n                sage: w = W.from_reduced_word([1, 2, 3, 1, 2])\n                sage: A = w.inversion_arrangement(); A\n                Arrangement of 5 hyperplanes of dimension 3 and rank 3\n                sage: A.hyperplanes()\n                (Hyperplane 0*a1 + 0*a2 + a3 + 0,\n                 Hyperplane 0*a1 + a2 + 0*a3 + 0,\n                 Hyperplane 0*a1 + a2 + a3 + 0,\n                 Hyperplane a1 + a2 + 0*a3 + 0,\n                 Hyperplane a1 + a2 + a3 + 0)\n\n            The identity element gives the empty arrangement::\n\n                sage: W = WeylGroup(['A',3])\n                sage: W.one().inversion_arrangement()\n                Empty hyperplane arrangement of dimension 3\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "inversions": {
                    "__doc__": "\n            Returns the set of inversions of ``self``.\n\n            INPUT:\n\n            - ``side`` -- 'right' (default) or 'left'\n            - ``inversion_type`` -- 'reflections' (default), 'roots', or 'coroots'.\n\n            OUTPUT:\n\n            For reflections, the set of reflections r in the Weyl group such that\n            ``self`` ``r`` < ``self``. For (co)roots, the set of positive (co)roots that are sent\n            by ``self`` to negative (co)roots; their associated reflections are described above.\n\n            If ``side`` is 'left', the inverse Weyl group element is used.\n\n            EXAMPLES::\n\n                sage: W=WeylGroup(['C',2], prefix=\"s\")\n                sage: w=W.from_reduced_word([1,2])\n                sage: w.inversions()\n                [s2, s2*s1*s2]\n                sage: w.inversions(inversion_type = 'reflections')\n                [s2, s2*s1*s2]\n                sage: w.inversions(inversion_type = 'roots')\n                [alpha[2], alpha[1] + alpha[2]]\n                sage: w.inversions(inversion_type = 'coroots')\n                [alphacheck[2], alphacheck[1] + 2*alphacheck[2]]\n                sage: w.inversions(side = 'left')\n                [s1, s1*s2*s1]\n                sage: w.inversions(side = 'left', inversion_type = 'roots')\n                [alpha[1], 2*alpha[1] + alpha[2]]\n                sage: w.inversions(side = 'left', inversion_type = 'coroots')\n                [alphacheck[1], alphacheck[1] + alphacheck[2]]\n\n            ",
                    "args": [
                        "self",
                        "side",
                        "inversion_type"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "inversion_type"
                        ],
                        null,
                        null,
                        [
                            "right",
                            "reflections"
                        ]
                    ]
                },
                "is_pieri_factor": {
                    "__doc__": "\n            Returns whether ``self`` is a Pieri factor, as used for\n            computing Stanley symmetric functions.\n\n            .. SEEALSO::\n\n                * :meth:`stanley_symmetric_function`\n                * :meth:`WeylGroups.ParentMethods.pieri_factors`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',5,1])\n                sage: W.from_reduced_word([3,2,5]).is_pieri_factor()\n                True\n                sage: W.from_reduced_word([3,2,4,5]).is_pieri_factor()\n                False\n\n                sage: W = WeylGroup(['C',4,1])\n                sage: W.from_reduced_word([0,2,1]).is_pieri_factor()\n                True\n                sage: W.from_reduced_word([0,2,1,0]).is_pieri_factor()\n                False\n\n                sage: W = WeylGroup(['B',3])\n                sage: W.from_reduced_word([3,2,3]).is_pieri_factor()\n                False\n                sage: W.from_reduced_word([2,1,2]).is_pieri_factor()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "left_pieri_factorizations": {
                    "__doc__": "\n            Returns all factorizations of ``self`` as `uv`, where `u`\n            is a Pieri factor and `v` is an element of the Weyl group.\n\n            .. SEEALSO::\n\n                * :meth:`WeylGroups.ParentMethods.pieri_factors`\n                * :mod:`sage.combinat.root_system.pieri_factors`\n\n            EXAMPLES:\n\n            If we take `w = w_0` the maximal element of a strict parabolic\n            subgroup of type `A_{n_1} \\times \\cdots \\times A_{n_k}`, then the Pieri\n            factorizations are in correspondence with all Pieri factors, and\n            there are `\\prod 2^{n_i}` of them::\n\n                sage: W = WeylGroup(['A', 4, 1])\n                sage: W.from_reduced_word([]).left_pieri_factorizations().cardinality()\n                1\n                sage: W.from_reduced_word([1]).left_pieri_factorizations().cardinality()\n                2\n                sage: W.from_reduced_word([1,2,1]).left_pieri_factorizations().cardinality()\n                4\n                sage: W.from_reduced_word([1,2,3,1,2,1]).left_pieri_factorizations().cardinality()\n                8\n\n                sage: W.from_reduced_word([1,3]).left_pieri_factorizations().cardinality()\n                4\n                sage: W.from_reduced_word([1,3,4,3]).left_pieri_factorizations().cardinality()\n                8\n\n                sage: W.from_reduced_word([2,1]).left_pieri_factorizations().cardinality()\n                3\n                sage: W.from_reduced_word([1,2]).left_pieri_factorizations().cardinality()\n                2\n                sage: [W.from_reduced_word([1,2]).left_pieri_factorizations(max_length=i).cardinality() for i in [-1, 0, 1, 2]]\n                [0, 1, 2, 2]\n\n                sage: W = WeylGroup(['C',4,1])\n                sage: w = W.from_reduced_word([0,3,2,1,0])\n                sage: w.left_pieri_factorizations().cardinality()\n                7\n                sage: [(u.reduced_word(),v.reduced_word()) for (u,v) in w.left_pieri_factorizations()]\n                [([], [3, 2, 0, 1, 0]),\n                ([0], [3, 2, 1, 0]),\n                ([3], [2, 0, 1, 0]),\n                ([3, 0], [2, 1, 0]),\n                ([3, 2], [0, 1, 0]),\n                ([3, 2, 0], [1, 0]),\n                ([3, 2, 0, 1], [0])]\n\n                sage: W = WeylGroup(['B',4,1])\n                sage: W.from_reduced_word([0,2,1,0]).left_pieri_factorizations().cardinality()\n                6\n            ",
                    "args": [
                        "self",
                        "max_length"
                    ],
                    "argspec": [
                        [
                            "self",
                            "max_length"
                        ],
                        null,
                        null,
                        [
                            "+Infinity"
                        ]
                    ]
                },
                "quantum_bruhat_successors": {
                    "__doc__": "\n            Return the successors of ``self`` in the quantum Bruhat graph\n            on the parabolic quotient of the Weyl group determined by the\n            subset of Dynkin nodes ``index_set``.\n\n            INPUT:\n\n            - ``self`` -- a Weyl group element, which is assumed to\n              be of minimum length in its coset with respect to the\n              parabolic subgroup\n\n            - ``index_set`` -- (default: ``None``) indicates the set of\n              simple reflections used to generate the parabolic subgroup;\n              the default value indicates that the subgroup is the identity\n\n            - ``roots`` -- (default: ``False``) if ``True``, returns the\n              list of 2-tuples (``w``, `\\alpha`) where ``w`` is a successor\n              and `\\alpha` is the positive root associated with the\n              successor relation\n\n            - ``quantum_only`` -- (default: ``False``) if ``True``, returns\n              only the quantum successors\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3], prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2])\n                sage: w.quantum_bruhat_successors([1], roots = True)\n                [(s3, alpha[2]), (s1*s2*s3*s2, alpha[3]),\n                 (s2*s3*s1*s2, alpha[1] + alpha[2] + alpha[3])]\n                sage: w.quantum_bruhat_successors([1,3])\n                [1, s2*s3*s1*s2]\n                sage: w.quantum_bruhat_successors(roots = True)\n                [(s3*s1*s2*s1, alpha[1]),\n                 (s3*s1, alpha[2]),\n                 (s1*s2*s3*s2, alpha[3]),\n                 (s2*s3*s1*s2, alpha[1] + alpha[2] + alpha[3])]\n                sage: w.quantum_bruhat_successors()\n                [s3*s1*s2*s1, s3*s1, s1*s2*s3*s2, s2*s3*s1*s2]\n                sage: w.quantum_bruhat_successors(quantum_only = True)\n                [s3*s1]\n                sage: w = W.from_reduced_word([2,3])\n                sage: w.quantum_bruhat_successors([1,3])\n                Traceback (most recent call last):\n                ...\n                ValueError: s2*s3 is not of minimum length in its coset of the parabolic subgroup generated by the reflections (1, 3)\n            ",
                    "args": [
                        "self",
                        "index_set",
                        "roots",
                        "quantum_only"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set",
                            "roots",
                            "quantum_only"
                        ],
                        null,
                        null,
                        [
                            null,
                            false,
                            false
                        ]
                    ]
                },
                "reflection_to_coroot": {},
                "reflection_to_root": {},
                "stanley_symmetric_function": {
                    "__doc__": "\n            Return the affine Stanley symmetric function indexed by ``self``.\n\n            INPUT:\n\n            - ``self`` -- an element `w` of a Weyl group\n\n            Returns the affine Stanley symmetric function indexed by\n            `w`. Stanley symmetric functions are defined as generating\n            series of the factorizations of `w` into Pieri factors and\n            weighted by a statistic on Pieri factors.\n\n            .. SEEALSO::\n\n                * :meth:`stanley_symmetric_function_as_polynomial`\n                * :meth:`WeylGroups.ParentMethods.pieri_factors`\n                * :mod:`sage.combinat.root_system.pieri_factors`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A', 3, 1])\n                sage: W.from_reduced_word([3,1,2,0,3,1,0]).stanley_symmetric_function()\n                8*m[1, 1, 1, 1, 1, 1, 1] + 4*m[2, 1, 1, 1, 1, 1] + 2*m[2, 2, 1, 1, 1] + m[2, 2, 2, 1]\n                sage: A = AffinePermutationGroup(['A',3,1])\n                sage: A.from_reduced_word([3,1,2,0,3,1,0]).stanley_symmetric_function()\n                8*m[1, 1, 1, 1, 1, 1, 1] + 4*m[2, 1, 1, 1, 1, 1] + 2*m[2, 2, 1, 1, 1] + m[2, 2, 2, 1]\n\n                sage: W = WeylGroup(['C',3,1])\n                sage: W.from_reduced_word([0,2,1,0]).stanley_symmetric_function()\n                32*m[1, 1, 1, 1] + 16*m[2, 1, 1] + 8*m[2, 2] + 4*m[3, 1]\n\n                sage: W = WeylGroup(['B',3,1])\n                sage: W.from_reduced_word([3,2,1]).stanley_symmetric_function()\n                2*m[1, 1, 1] + m[2, 1] + 1/2*m[3]\n\n                sage: W = WeylGroup(['B',4])\n                sage: w = W.from_reduced_word([3,2,3,1])\n                sage: w.stanley_symmetric_function()  # long time (6s on sage.math, 2011)\n                48*m[1, 1, 1, 1] + 24*m[2, 1, 1] + 12*m[2, 2] + 8*m[3, 1] + 2*m[4]\n\n                sage: A = AffinePermutationGroup(['A',4,1])\n                sage: a = A([-2,0,1,4,12])\n                sage: a.stanley_symmetric_function()\n                6*m[1, 1, 1, 1, 1, 1, 1, 1] + 5*m[2, 1, 1, 1, 1, 1, 1] + 4*m[2, 2, 1, 1, 1, 1]\n                + 3*m[2, 2, 2, 1, 1] + 2*m[2, 2, 2, 2] + 4*m[3, 1, 1, 1, 1, 1] + 3*m[3, 2, 1, 1, 1]\n                + 2*m[3, 2, 2, 1] + 2*m[3, 3, 1, 1] + m[3, 3, 2] + 3*m[4, 1, 1, 1, 1] + 2*m[4, 2, 1, 1]\n                + m[4, 2, 2] + m[4, 3, 1]\n\n            One more example (:trac:`14095`)::\n\n                sage: G = SymmetricGroup(4)\n                sage: w = G.from_reduced_word([3,2,3,1])\n                sage: w.stanley_symmetric_function()\n                3*m[1, 1, 1, 1] + 2*m[2, 1, 1] + m[2, 2] + m[3, 1]\n\n            REFERENCES:\n\n            .. [BH1994] \\S. Billey, M. Haiman. *Schubert polynomials for the\n               classical groups*. J. Amer. Math. Soc., 1994.\n            .. [Lam2008] \\T. Lam. *Schubert polynomials for the affine\n               Grassmannian*. J. Amer. Math. Soc., 2008.\n            .. [LSS2009] \\T. Lam, A. Schilling, M. Shimozono. *Schubert\n               polynomials for the affine Grassmannian of the symplectic\n               group*. Mathematische Zeitschrift 264(4) (2010) 765-811\n               (:arxiv:`0710.2720`)\n            .. [Pon2010] \\S. Pon. *Types B and D affine Stanley symmetric\n               functions*, unpublished PhD Thesis, UC Davis, 2010.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "stanley_symmetric_function_as_polynomial": {}
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.coxeter_groups.CoxeterGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of Weyl groups\n\n    See the :wikipedia:`Wikipedia page of Weyl Groups <Weyl_group>`.\n\n    EXAMPLES::\n\n        sage: WeylGroups()\n        Category of weyl groups\n        sage: WeylGroups().super_categories()\n        [Category of coxeter groups]\n\n    Here are some examples::\n\n        sage: WeylGroups().example()            # todo: not implemented\n        sage: FiniteWeylGroups().example()\n        The symmetric group on {0, ..., 3}\n        sage: AffineWeylGroups().example()      # todo: not implemented\n        sage: WeylGroup([\"B\", 3])\n        Weyl Group of type ['B', 3] (as a matrix group acting on the ambient space)\n\n    This one will eventually be also in this category::\n\n        sage: SymmetricGroup(4)\n        Symmetric group of order 4! as a permutation group\n\n    TESTS::\n\n        sage: C = WeylGroups()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.weyl_groups.WeylGroups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "pieri_factors": {
                    "__doc__": "\n            Returns the set of Pieri factors in this Weyl group.\n\n            For any type, the set of Pieri factors forms a lower ideal\n            in Bruhat order, generated by all the conjugates of some\n            special element of the Weyl group. In type `A_n`, this\n            special element is `s_n\\cdots s_1`, and the conjugates are\n            obtained by rotating around this reduced word.\n\n            These are used to compute Stanley symmetric functions.\n\n            .. SEEALSO::\n\n                * :meth:`WeylGroups.ElementMethods.stanley_symmetric_function`\n                * :mod:`sage.combinat.root_system.pieri_factors`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',5,1])\n                sage: PF = W.pieri_factors()\n                sage: PF.cardinality()\n                63\n\n                sage: W = WeylGroup(['B',3])\n                sage: PF = W.pieri_factors()\n                sage: [w.reduced_word() for w in PF]\n                [[1, 2, 3, 2, 1], [1, 2, 3, 2], [2, 3, 2], [2, 3], [3, 1, 2, 1], [1, 2, 1], [2], [1, 2], [1], [], [2, 1], [3, 2, 1], [3, 1], [2, 3, 2, 1], [3], [3, 2], [1, 2, 3], [1, 2, 3, 1], [3, 1, 2], [2, 3, 1]]\n\n                sage: W = WeylGroup(['C',4,1])\n                sage: PF = W.pieri_factors()\n                sage: W.from_reduced_word([3,2,0]) in PF\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "keywords",
                        null
                    ]
                },
                "quantum_bruhat_graph": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "bruhat_lower_covers_coroots": {
                    "__doc__": "\n            Return all 2-tuples (``v``, `\\alpha`) where ``v`` is covered\n            by ``self`` and `\\alpha` is the positive coroot such that\n            ``self`` = ``v`` `s_\\alpha` where `s_\\alpha` is\n            the reflection orthogonal to `\\alpha`.\n\n            ALGORITHM:\n\n            See :meth:`.bruhat_lower_covers` and\n            :meth:`.bruhat_lower_covers_reflections` for Coxeter groups.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3], prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.bruhat_lower_covers_coroots()\n                [(s1*s2*s1, alphacheck[1] + alphacheck[2] + alphacheck[3]),\n                 (s3*s2*s1, alphacheck[2]), (s3*s1*s2, alphacheck[1])]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "bruhat_upper_covers_coroots": {
                    "__doc__": "\n            Returns all 2-tuples (``v``, `\\alpha`) where ``v`` is covers ``self`` and `\\alpha`\n            is the positive coroot such that ``self`` = ``v`` `s_\\alpha` where `s_\\alpha` is\n            the reflection orthogonal to `\\alpha`.\n\n            ALGORITHM:\n\n            See :meth:`~CoxeterGroups.ElementMethods.bruhat_upper_covers` and :meth:`.bruhat_upper_covers_reflections` for Coxeter groups.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',4], prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.bruhat_upper_covers_coroots()\n                [(s1*s2*s3*s2*s1, alphacheck[3]),\n                 (s2*s3*s1*s2*s1, alphacheck[2] + alphacheck[3]),\n                 (s3*s4*s1*s2*s1, alphacheck[4]),\n                 (s4*s3*s1*s2*s1, alphacheck[1] + alphacheck[2] + alphacheck[3] + alphacheck[4])]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "inversion_arrangement": {
                    "__doc__": "\n            Return the inversion hyperplane arrangement of ``self``.\n\n            INPUT:\n\n            - ``side`` -- ``'right'`` (default) or ``'left'``\n\n            OUTPUT:\n\n            A (central) hyperplane arrangement whose hyperplanes correspond\n            to the inversions of ``self`` given as roots.\n\n            The ``side`` parameter determines on which side\n            to compute the inversions.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3])\n                sage: w = W.from_reduced_word([1, 2, 3, 1, 2])\n                sage: A = w.inversion_arrangement(); A\n                Arrangement of 5 hyperplanes of dimension 3 and rank 3\n                sage: A.hyperplanes()\n                (Hyperplane 0*a1 + 0*a2 + a3 + 0,\n                 Hyperplane 0*a1 + a2 + 0*a3 + 0,\n                 Hyperplane 0*a1 + a2 + a3 + 0,\n                 Hyperplane a1 + a2 + 0*a3 + 0,\n                 Hyperplane a1 + a2 + a3 + 0)\n\n            The identity element gives the empty arrangement::\n\n                sage: W = WeylGroup(['A',3])\n                sage: W.one().inversion_arrangement()\n                Empty hyperplane arrangement of dimension 3\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "inversions": {
                    "__doc__": "\n            Returns the set of inversions of ``self``.\n\n            INPUT:\n\n            - ``side`` -- 'right' (default) or 'left'\n            - ``inversion_type`` -- 'reflections' (default), 'roots', or 'coroots'.\n\n            OUTPUT:\n\n            For reflections, the set of reflections r in the Weyl group such that\n            ``self`` ``r`` < ``self``. For (co)roots, the set of positive (co)roots that are sent\n            by ``self`` to negative (co)roots; their associated reflections are described above.\n\n            If ``side`` is 'left', the inverse Weyl group element is used.\n\n            EXAMPLES::\n\n                sage: W=WeylGroup(['C',2], prefix=\"s\")\n                sage: w=W.from_reduced_word([1,2])\n                sage: w.inversions()\n                [s2, s2*s1*s2]\n                sage: w.inversions(inversion_type = 'reflections')\n                [s2, s2*s1*s2]\n                sage: w.inversions(inversion_type = 'roots')\n                [alpha[2], alpha[1] + alpha[2]]\n                sage: w.inversions(inversion_type = 'coroots')\n                [alphacheck[2], alphacheck[1] + 2*alphacheck[2]]\n                sage: w.inversions(side = 'left')\n                [s1, s1*s2*s1]\n                sage: w.inversions(side = 'left', inversion_type = 'roots')\n                [alpha[1], 2*alpha[1] + alpha[2]]\n                sage: w.inversions(side = 'left', inversion_type = 'coroots')\n                [alphacheck[1], alphacheck[1] + alphacheck[2]]\n\n            ",
                    "args": [
                        "self",
                        "side",
                        "inversion_type"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "inversion_type"
                        ],
                        null,
                        null,
                        [
                            "right",
                            "reflections"
                        ]
                    ]
                },
                "is_pieri_factor": {
                    "__doc__": "\n            Returns whether ``self`` is a Pieri factor, as used for\n            computing Stanley symmetric functions.\n\n            .. SEEALSO::\n\n                * :meth:`stanley_symmetric_function`\n                * :meth:`WeylGroups.ParentMethods.pieri_factors`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',5,1])\n                sage: W.from_reduced_word([3,2,5]).is_pieri_factor()\n                True\n                sage: W.from_reduced_word([3,2,4,5]).is_pieri_factor()\n                False\n\n                sage: W = WeylGroup(['C',4,1])\n                sage: W.from_reduced_word([0,2,1]).is_pieri_factor()\n                True\n                sage: W.from_reduced_word([0,2,1,0]).is_pieri_factor()\n                False\n\n                sage: W = WeylGroup(['B',3])\n                sage: W.from_reduced_word([3,2,3]).is_pieri_factor()\n                False\n                sage: W.from_reduced_word([2,1,2]).is_pieri_factor()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "left_pieri_factorizations": {
                    "__doc__": "\n            Returns all factorizations of ``self`` as `uv`, where `u`\n            is a Pieri factor and `v` is an element of the Weyl group.\n\n            .. SEEALSO::\n\n                * :meth:`WeylGroups.ParentMethods.pieri_factors`\n                * :mod:`sage.combinat.root_system.pieri_factors`\n\n            EXAMPLES:\n\n            If we take `w = w_0` the maximal element of a strict parabolic\n            subgroup of type `A_{n_1} \\times \\cdots \\times A_{n_k}`, then the Pieri\n            factorizations are in correspondence with all Pieri factors, and\n            there are `\\prod 2^{n_i}` of them::\n\n                sage: W = WeylGroup(['A', 4, 1])\n                sage: W.from_reduced_word([]).left_pieri_factorizations().cardinality()\n                1\n                sage: W.from_reduced_word([1]).left_pieri_factorizations().cardinality()\n                2\n                sage: W.from_reduced_word([1,2,1]).left_pieri_factorizations().cardinality()\n                4\n                sage: W.from_reduced_word([1,2,3,1,2,1]).left_pieri_factorizations().cardinality()\n                8\n\n                sage: W.from_reduced_word([1,3]).left_pieri_factorizations().cardinality()\n                4\n                sage: W.from_reduced_word([1,3,4,3]).left_pieri_factorizations().cardinality()\n                8\n\n                sage: W.from_reduced_word([2,1]).left_pieri_factorizations().cardinality()\n                3\n                sage: W.from_reduced_word([1,2]).left_pieri_factorizations().cardinality()\n                2\n                sage: [W.from_reduced_word([1,2]).left_pieri_factorizations(max_length=i).cardinality() for i in [-1, 0, 1, 2]]\n                [0, 1, 2, 2]\n\n                sage: W = WeylGroup(['C',4,1])\n                sage: w = W.from_reduced_word([0,3,2,1,0])\n                sage: w.left_pieri_factorizations().cardinality()\n                7\n                sage: [(u.reduced_word(),v.reduced_word()) for (u,v) in w.left_pieri_factorizations()]\n                [([], [3, 2, 0, 1, 0]),\n                ([0], [3, 2, 1, 0]),\n                ([3], [2, 0, 1, 0]),\n                ([3, 0], [2, 1, 0]),\n                ([3, 2], [0, 1, 0]),\n                ([3, 2, 0], [1, 0]),\n                ([3, 2, 0, 1], [0])]\n\n                sage: W = WeylGroup(['B',4,1])\n                sage: W.from_reduced_word([0,2,1,0]).left_pieri_factorizations().cardinality()\n                6\n            ",
                    "args": [
                        "self",
                        "max_length"
                    ],
                    "argspec": [
                        [
                            "self",
                            "max_length"
                        ],
                        null,
                        null,
                        [
                            "+Infinity"
                        ]
                    ]
                },
                "quantum_bruhat_successors": {
                    "__doc__": "\n            Return the successors of ``self`` in the quantum Bruhat graph\n            on the parabolic quotient of the Weyl group determined by the\n            subset of Dynkin nodes ``index_set``.\n\n            INPUT:\n\n            - ``self`` -- a Weyl group element, which is assumed to\n              be of minimum length in its coset with respect to the\n              parabolic subgroup\n\n            - ``index_set`` -- (default: ``None``) indicates the set of\n              simple reflections used to generate the parabolic subgroup;\n              the default value indicates that the subgroup is the identity\n\n            - ``roots`` -- (default: ``False``) if ``True``, returns the\n              list of 2-tuples (``w``, `\\alpha`) where ``w`` is a successor\n              and `\\alpha` is the positive root associated with the\n              successor relation\n\n            - ``quantum_only`` -- (default: ``False``) if ``True``, returns\n              only the quantum successors\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3], prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2])\n                sage: w.quantum_bruhat_successors([1], roots = True)\n                [(s3, alpha[2]), (s1*s2*s3*s2, alpha[3]),\n                 (s2*s3*s1*s2, alpha[1] + alpha[2] + alpha[3])]\n                sage: w.quantum_bruhat_successors([1,3])\n                [1, s2*s3*s1*s2]\n                sage: w.quantum_bruhat_successors(roots = True)\n                [(s3*s1*s2*s1, alpha[1]),\n                 (s3*s1, alpha[2]),\n                 (s1*s2*s3*s2, alpha[3]),\n                 (s2*s3*s1*s2, alpha[1] + alpha[2] + alpha[3])]\n                sage: w.quantum_bruhat_successors()\n                [s3*s1*s2*s1, s3*s1, s1*s2*s3*s2, s2*s3*s1*s2]\n                sage: w.quantum_bruhat_successors(quantum_only = True)\n                [s3*s1]\n                sage: w = W.from_reduced_word([2,3])\n                sage: w.quantum_bruhat_successors([1,3])\n                Traceback (most recent call last):\n                ...\n                ValueError: s2*s3 is not of minimum length in its coset of the parabolic subgroup generated by the reflections (1, 3)\n            ",
                    "args": [
                        "self",
                        "index_set",
                        "roots",
                        "quantum_only"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set",
                            "roots",
                            "quantum_only"
                        ],
                        null,
                        null,
                        [
                            null,
                            false,
                            false
                        ]
                    ]
                },
                "reflection_to_coroot": {},
                "reflection_to_root": {},
                "stanley_symmetric_function": {
                    "__doc__": "\n            Return the affine Stanley symmetric function indexed by ``self``.\n\n            INPUT:\n\n            - ``self`` -- an element `w` of a Weyl group\n\n            Returns the affine Stanley symmetric function indexed by\n            `w`. Stanley symmetric functions are defined as generating\n            series of the factorizations of `w` into Pieri factors and\n            weighted by a statistic on Pieri factors.\n\n            .. SEEALSO::\n\n                * :meth:`stanley_symmetric_function_as_polynomial`\n                * :meth:`WeylGroups.ParentMethods.pieri_factors`\n                * :mod:`sage.combinat.root_system.pieri_factors`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A', 3, 1])\n                sage: W.from_reduced_word([3,1,2,0,3,1,0]).stanley_symmetric_function()\n                8*m[1, 1, 1, 1, 1, 1, 1] + 4*m[2, 1, 1, 1, 1, 1] + 2*m[2, 2, 1, 1, 1] + m[2, 2, 2, 1]\n                sage: A = AffinePermutationGroup(['A',3,1])\n                sage: A.from_reduced_word([3,1,2,0,3,1,0]).stanley_symmetric_function()\n                8*m[1, 1, 1, 1, 1, 1, 1] + 4*m[2, 1, 1, 1, 1, 1] + 2*m[2, 2, 1, 1, 1] + m[2, 2, 2, 1]\n\n                sage: W = WeylGroup(['C',3,1])\n                sage: W.from_reduced_word([0,2,1,0]).stanley_symmetric_function()\n                32*m[1, 1, 1, 1] + 16*m[2, 1, 1] + 8*m[2, 2] + 4*m[3, 1]\n\n                sage: W = WeylGroup(['B',3,1])\n                sage: W.from_reduced_word([3,2,1]).stanley_symmetric_function()\n                2*m[1, 1, 1] + m[2, 1] + 1/2*m[3]\n\n                sage: W = WeylGroup(['B',4])\n                sage: w = W.from_reduced_word([3,2,3,1])\n                sage: w.stanley_symmetric_function()  # long time (6s on sage.math, 2011)\n                48*m[1, 1, 1, 1] + 24*m[2, 1, 1] + 12*m[2, 2] + 8*m[3, 1] + 2*m[4]\n\n                sage: A = AffinePermutationGroup(['A',4,1])\n                sage: a = A([-2,0,1,4,12])\n                sage: a.stanley_symmetric_function()\n                6*m[1, 1, 1, 1, 1, 1, 1, 1] + 5*m[2, 1, 1, 1, 1, 1, 1] + 4*m[2, 2, 1, 1, 1, 1]\n                + 3*m[2, 2, 2, 1, 1] + 2*m[2, 2, 2, 2] + 4*m[3, 1, 1, 1, 1, 1] + 3*m[3, 2, 1, 1, 1]\n                + 2*m[3, 2, 2, 1] + 2*m[3, 3, 1, 1] + m[3, 3, 2] + 3*m[4, 1, 1, 1, 1] + 2*m[4, 2, 1, 1]\n                + m[4, 2, 2] + m[4, 3, 1]\n\n            One more example (:trac:`14095`)::\n\n                sage: G = SymmetricGroup(4)\n                sage: w = G.from_reduced_word([3,2,3,1])\n                sage: w.stanley_symmetric_function()\n                3*m[1, 1, 1, 1] + 2*m[2, 1, 1] + m[2, 2] + m[3, 1]\n\n            REFERENCES:\n\n            .. [BH1994] \\S. Billey, M. Haiman. *Schubert polynomials for the\n               classical groups*. J. Amer. Math. Soc., 1994.\n            .. [Lam2008] \\T. Lam. *Schubert polynomials for the affine\n               Grassmannian*. J. Amer. Math. Soc., 2008.\n            .. [LSS2009] \\T. Lam, A. Schilling, M. Shimozono. *Schubert\n               polynomials for the affine Grassmannian of the symplectic\n               group*. Mathematische Zeitschrift 264(4) (2010) 765-811\n               (:arxiv:`0710.2720`)\n            .. [Pon2010] \\S. Pon. *Types B and D affine Stanley symmetric\n               functions*, unpublished PhD Thesis, UC Davis, 2010.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "stanley_symmetric_function_as_polynomial": {}
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded modules with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "degree_negation": {
                    "__doc__": "\n            Return the image of ``self`` under the degree negation\n            automorphism of the graded module to which ``self`` belongs.\n\n            The degree negation is the module automorphism which scales\n            every homogeneous element of degree `k` by `(-1)^k` (for all\n            `k`). This assumes that the module to which ``self`` belongs\n            (that is, the module ``self.parent()``) is `\\ZZ`-graded.\n\n            EXAMPLES::\n\n                sage: E.<a,b> = ExteriorAlgebra(QQ)\n                sage: ((1 + a) * (1 + b)).degree_negation()\n                a^b - a - b + 1\n                sage: E.zero().degree_negation()\n                0\n\n                sage: P = GradedModulesWithBasis(ZZ).example(); P\n                An example of a graded module with basis: the free module on partitions over Integer Ring\n                sage: pbp = lambda x: P.basis()[Partition(list(x))]\n                sage: p = pbp([3,1]) - 2 * pbp([2]) + 4 * pbp([1])\n                sage: p.degree_negation()\n                -4*P[1] - 2*P[2] + P[3, 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis",
            "sage.categories.graded_modules.GradedModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded modules with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_modules_with_basis.GradedModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "degree_negation": {
                    "__doc__": "\n            Return the image of ``element`` under the degree negation\n            automorphism of the graded module ``self``.\n\n            The degree negation is the module automorphism which scales\n            every homogeneous element of degree `k` by `(-1)^k` (for all\n            `k`). This assumes that the module ``self`` is `\\ZZ`-graded.\n\n            INPUT:\n\n            - ``element`` -- element of the module ``self``\n\n            EXAMPLES::\n\n                sage: E.<a,b> = ExteriorAlgebra(QQ)\n                sage: E.degree_negation((1 + a) * (1 + b))\n                a^b - a - b + 1\n                sage: E.degree_negation(E.zero())\n                0\n\n                sage: P = GradedModulesWithBasis(ZZ).example(); P\n                An example of a graded module with basis: the free module on partitions over Integer Ring\n                sage: pbp = lambda x: P.basis()[Partition(list(x))]\n                sage: p = pbp([3,1]) - 2 * pbp([2]) + 4 * pbp([1])\n                sage: P.degree_negation(p)\n                -4*P[1] - 2*P[2] + P[3, 1]\n            ",
                    "args": [
                        "self",
                        "element"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "degree_negation": {
                    "__doc__": "\n            Return the image of ``self`` under the degree negation\n            automorphism of the graded module to which ``self`` belongs.\n\n            The degree negation is the module automorphism which scales\n            every homogeneous element of degree `k` by `(-1)^k` (for all\n            `k`). This assumes that the module to which ``self`` belongs\n            (that is, the module ``self.parent()``) is `\\ZZ`-graded.\n\n            EXAMPLES::\n\n                sage: E.<a,b> = ExteriorAlgebra(QQ)\n                sage: ((1 + a) * (1 + b)).degree_negation()\n                a^b - a - b + 1\n                sage: E.zero().degree_negation()\n                0\n\n                sage: P = GradedModulesWithBasis(ZZ).example(); P\n                An example of a graded module with basis: the free module on partitions over Integer Ring\n                sage: pbp = lambda x: P.basis()[Partition(list(x))]\n                sage: p = pbp([3,1]) - 2 * pbp([2]) + 4 * pbp([1])\n                sage: p.degree_negation()\n                -4*P[1] - 2*P[2] + P[3, 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of enumerated sets\n\n    An *enumerated set* is a *finite* or *countable* set or multiset `S`\n    together with a canonical enumeration of its elements;\n    conceptually, this is very similar to an immutable list. The main\n    difference lies in the names and the return type of the methods,\n    and of course the fact that the list of elements is not supposed to\n    be expanded in memory. Whenever possible one should use one of the\n    two sub-categories :class:`FiniteEnumeratedSets` or\n    :class:`InfiniteEnumeratedSets`.\n\n    The purpose of this category is threefold:\n\n     - to fix a common interface for all these sets;\n     - to provide a bunch of default implementations;\n     - to provide consistency tests.\n\n    The standard methods for an enumerated set ``S`` are:\n\n       - ``S.cardinality()``: the number of elements of the set. This\n         is the equivalent for ``len`` on a list except that the\n         return value is specified to be a Sage :class:`Integer` or\n         ``infinity``, instead of a Python ``int``.\n\n       - ``iter(S)``: an iterator for the elements of the set;\n\n       - ``S.list()``: the list of the elements of the set, when\n         possible; raises a NotImplementedError if the list is\n         predictably too large to be expanded in memory.\n\n       - ``S.unrank(n)``: the  ``n-th`` element of the set when ``n`` is a sage\n         ``Integer``. This is the equivalent for ``l[n]`` on a list.\n\n       - ``S.rank(e)``: the position of the element ``e`` in the set;\n         This is equivalent to ``l.index(e)`` for a list except that\n         the return value is specified to be a Sage :class:`Integer`,\n         instead of a Python ``int``.\n\n       - ``S.first()``: the first object of the set; it is equivalent to\n         ``S.unrank(0)``.\n\n       - ``S.next(e)``: the object of the set which follows ``e``; It is\n         equivalent to ``S.unrank(S.rank(e)+1)``.\n\n       - ``S.random_element()``: a random generator for an element of\n         the set. Unless otherwise stated, and for finite enumerated\n         sets, the probability is uniform.\n\n    For examples and tests see:\n\n       - ``FiniteEnumeratedSets().example()``\n       - ``InfiniteEnumeratedSets().example()``\n\n\n    EXAMPLES::\n\n        sage: EnumeratedSets()\n        Category of enumerated sets\n        sage: EnumeratedSets().super_categories()\n        [Category of sets]\n        sage: EnumeratedSets().all_super_categories()\n        [Category of enumerated sets, Category of sets, Category of sets with partial maps, Category of objects]\n\n    TESTS::\n\n        sage: C = EnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {
                "rank": {
                    "__doc__": "\n            Return the rank of ``self`` in its parent.\n\n            See also :meth:`EnumeratedSets.ElementMethods.rank`\n\n            EXAMPLES::\n\n                sage: F = FiniteSemigroups().example(('a','b','c'))\n                sage: L = list(F); L\n                ['a', 'b', 'c', 'ac', 'ab', 'ba', 'bc', 'cb', 'ca',\n                 'acb', 'abc', 'bca', 'cba', 'bac', 'cab']\n                sage: L[7].rank()\n                7\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": "TODO",
        "morphism_class": {
            "__doc__": "\n    The category of enumerated sets\n\n    An *enumerated set* is a *finite* or *countable* set or multiset `S`\n    together with a canonical enumeration of its elements;\n    conceptually, this is very similar to an immutable list. The main\n    difference lies in the names and the return type of the methods,\n    and of course the fact that the list of elements is not supposed to\n    be expanded in memory. Whenever possible one should use one of the\n    two sub-categories :class:`FiniteEnumeratedSets` or\n    :class:`InfiniteEnumeratedSets`.\n\n    The purpose of this category is threefold:\n\n     - to fix a common interface for all these sets;\n     - to provide a bunch of default implementations;\n     - to provide consistency tests.\n\n    The standard methods for an enumerated set ``S`` are:\n\n       - ``S.cardinality()``: the number of elements of the set. This\n         is the equivalent for ``len`` on a list except that the\n         return value is specified to be a Sage :class:`Integer` or\n         ``infinity``, instead of a Python ``int``.\n\n       - ``iter(S)``: an iterator for the elements of the set;\n\n       - ``S.list()``: the list of the elements of the set, when\n         possible; raises a NotImplementedError if the list is\n         predictably too large to be expanded in memory.\n\n       - ``S.unrank(n)``: the  ``n-th`` element of the set when ``n`` is a sage\n         ``Integer``. This is the equivalent for ``l[n]`` on a list.\n\n       - ``S.rank(e)``: the position of the element ``e`` in the set;\n         This is equivalent to ``l.index(e)`` for a list except that\n         the return value is specified to be a Sage :class:`Integer`,\n         instead of a Python ``int``.\n\n       - ``S.first()``: the first object of the set; it is equivalent to\n         ``S.unrank(0)``.\n\n       - ``S.next(e)``: the object of the set which follows ``e``; It is\n         equivalent to ``S.unrank(S.rank(e)+1)``.\n\n       - ``S.random_element()``: a random generator for an element of\n         the set. Unless otherwise stated, and for finite enumerated\n         sets, the probability is uniform.\n\n    For examples and tests see:\n\n       - ``FiniteEnumeratedSets().example()``\n       - ``InfiniteEnumeratedSets().example()``\n\n\n    EXAMPLES::\n\n        sage: EnumeratedSets()\n        Category of enumerated sets\n        sage: EnumeratedSets().super_categories()\n        [Category of sets]\n        sage: EnumeratedSets().all_super_categories()\n        [Category of enumerated sets, Category of sets, Category of sets with partial maps, Category of objects]\n\n    TESTS::\n\n        sage: C = EnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.enumerated_sets.EnumeratedSets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "__iter__": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method __iter__ at 0x7fe375eb2410>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "iter_of_self",
                    "gap_name": "Iterator",
                    "mmt_name": null
                },
                "_an_element_from_iterator": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "_first_from_iterator": {
                    "__doc__": "\n            The \"first\" element of ``self``.\n\n            ``self.first()`` returns the first element of the set\n            ``self``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__`` is\n            provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.first() # indirect doctest\n                1\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_iterator_from_list": {
                    "__doc__": "\n            An iterator for the elements of ``self``.\n\n            ``iter(self)`` returns an iterator for the elements\n            of ``self``. This is a generic implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``list`` is provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: it = C._iterator_from_list()\n                sage: [next(it), next(it), next(it)]\n                [1, 2, 3]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_iterator_from_next": {
                    "__doc__": "\n            An iterator for the elements of ``self``.\n\n            ``iter(self)`` returns an iterator for the element of\n            the set ``self``. This is a generic implementation from\n            the category ``EnumeratedSets()`` which can be used when\n            the methods ``first`` and ``next`` are provided.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: it = C._iterator_from_next()\n                sage: [next(it), next(it), next(it), next(it), next(it)]\n                [0, 1, 2, 3, 4]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_iterator_from_unrank": {
                    "__doc__": "\n            An iterator for the elements of ``self``.\n\n            ``iter(self)`` returns an iterator for the elements\n            of the set ``self``. This is a generic implementation from\n            the category ``EnumeratedSets()`` which can be used when\n            the method ``unrank`` is provided.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: it = C._iterator_from_unrank()\n                sage: [next(it), next(it), next(it), next(it), next(it)]\n                [0, 1, 2, 3, 4]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_list_default": {
                    "__doc__": "\n            Return an error since the cardinality of ``self`` is not known.\n\n            EXAMPLES::\n\n                sage: class broken(UniqueRepresentation, Parent):\n                ...    def __init__(self):\n                ...        Parent.__init__(self, category = EnumeratedSets())\n                ...\n                sage: broken().list()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: unknown cardinality\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_next_from_iterator": {
                    "__doc__": "\n            The \"next\" element after ``obj`` in ``self``.\n\n            ``self.next(e)`` returns the element of the set ``self`` which\n            follows ``e``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__``\n            is provided.\n\n            Remark: this is the default (brute force) implementation\n            of the category ``EnumeratedSets()``. Its complexity is\n            `O(r)`, where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: C._next_from_iterator(10) # indirect doctest\n                11\n\n            TODO: specify the behavior when ``obj`` is not in ``self``.\n            ",
                    "args": [
                        "self",
                        "obj"
                    ],
                    "argspec": [
                        [
                            "self",
                            "obj"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_rank_from_iterator": {
                    "__doc__": "\n            The rank of an element of ``self``\n\n            ``self.rank(x)`` returns the rank of `x`, that is its\n            position in the enumeration of ``self``. This is an\n            integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``, or None if `x` is not in `self`.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``. For infinite enumerated\n            sets, this won't terminate when `x` is not in ``self``\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: list(C)\n                [1, 2, 3]\n                sage: C.rank(3) # indirect doctest\n                2\n                sage: C.rank(5) # indirect doctest\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_some_elements_from_iterator": {
                    "__doc__": "\n            Return some elements in ``self``.\n\n            See :class:`TestSuite` for a typical use case.\n\n            This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method\n            ``__iter__`` is provided. It returns an iterator for up to\n            the first 100 elements of ``self``\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: list(C.some_elements()) # indirect doctest\n                [1, 2, 3]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_test_enumerated_set_contains": {
                    "__doc__": "\n            Checks that the methods :meth:`.__contains__` and :meth:`.__iter__` are consistent.\n\n            See also :class:`TestSuite`.\n\n            TESTS::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._test_enumerated_set_contains()\n                sage: TestSuite(C).run()\n\n            Let us now break the class::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class CCls(Example):\n                ...       def __contains__(self, obj):\n                ...           if obj == 3:\n                ...               return False\n                ...           else:\n                ...               return obj in C\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_contains()\n                Traceback (most recent call last):\n                ...\n                AssertionError: False is not true\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_enumerated_set_iter_list": {
                    "__doc__": "\n            Checks that the methods :meth:`.list` and :meth:`.__iter__` are consistent.\n\n            See also: :class:`TestSuite`.\n\n            .. NOTE::\n\n                This test does nothing if the cardinality of the set\n                is larger than the max_runs argument.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C._test_enumerated_set_iter_list()\n                sage: TestSuite(C).run()\n\n            Let us now break the class::\n\n                sage: from sage.categories.examples.finite_enumerated_sets import Example\n                sage: class CCls(Example):\n                ...       def list(self):\n                ...           return [1,2,3,4]\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_iter_list()\n                Traceback (most recent call last):\n                ...\n                AssertionError: 3 != 4\n\n            For a large enumerated set this test does nothing:\n            increase tester._max_runs if you want to actually run the\n            test::\n\n                sage: class CCls(Example):\n                ...       def list(self):\n                ...           return [1,2,3]\n                sage: CC = CCls()\n                sage: CC._test_enumerated_set_iter_list(verbose=True,max_runs=2)\n                Enumerated set too big; skipping test; increase tester._max_runs\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_unrank_from_iterator": {
                    "__doc__": "\n            The ``r``-th element of ``self``\n\n            ``self.unrank(r)`` returns the ``r``-th element of self, where\n            ``r`` is an integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.unrank(2) # indirect doctest\n                3\n                sage: C._unrank_from_iterator(5)\n                Traceback (most recent call last):\n                ...\n                ValueError: the value must be between 0 and 2 inclusive\n            ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "first": {
                    "__doc__": "\n            The \"first\" element of ``self``.\n\n            ``self.first()`` returns the first element of the set\n            ``self``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__`` is\n            provided.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.first() # indirect doctest\n                1\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_empty": {
                    "__doc__": "\n            Return whether this set is empty.\n\n            EXAMPLES::\n\n                sage: F = FiniteEnumeratedSet([1,2,3])\n                sage: F.is_empty()\n                False\n                sage: F = FiniteEnumeratedSet([])\n                sage: F.is_empty()\n                True\n\n            TESTS::\n\n                sage: F.is_empty.__module__\n                'sage.categories.enumerated_sets'\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "list": {
                    "__doc__": "\n            Return an error since the cardinality of ``self`` is not known.\n\n            EXAMPLES::\n\n                sage: class broken(UniqueRepresentation, Parent):\n                ...    def __init__(self):\n                ...        Parent.__init__(self, category = EnumeratedSets())\n                ...\n                sage: broken().list()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: unknown cardinality\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map": {
                    "__doc__": "\n            Return the image `\\{f(x) | x \\in \\text{self}\\}` of this\n            enumerated set by `f`, as an enumerated set.\n\n            `f` is supposed to be injective.\n\n            EXAMPLES::\n\n                sage: R = SymmetricGroup(3).map(attrcall('reduced_word')); R\n                Image of Symmetric group of order 3! as a permutation group by *.reduced_word()\n                sage: R.cardinality()\n                6\n                sage: R.list()\n                [[], [1], [2, 1], [1, 2], [2], [1, 2, 1]]\n                sage: [ r for r in R]\n                [[], [1], [2, 1], [1, 2], [2], [1, 2, 1]]\n\n            .. warning::\n\n                If the function is not injective, then there may be\n                repeated elements::\n\n                    sage: P = SymmetricGroup(3)\n                    sage: P.list()\n                    [(), (1,2), (1,2,3), (1,3,2), (2,3), (1,3)]\n                    sage: P.map(attrcall('length')).list()\n                    [0, 1, 2, 2, 1, 3]\n\n            .. warning::\n\n                :class:`MapCombinatorialClass` needs to be refactored to use categories::\n\n                    sage: R.category()             # todo: not implemented\n                    Category of enumerated sets\n                    sage: TestSuite(R).run(skip=['_test_an_element', '_test_category', '_test_some_elements'])\n            ",
                    "args": [
                        "self",
                        "f",
                        "name"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "name"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "next": {
                    "__doc__": "\n            The \"next\" element after ``obj`` in ``self``.\n\n            ``self.next(e)`` returns the element of the set ``self`` which\n            follows ``e``. This is a generic implementation from the category\n            ``EnumeratedSets()`` which can be used when the method ``__iter__``\n            is provided.\n\n            Remark: this is the default (brute force) implementation\n            of the category ``EnumeratedSets()``. Its complexity is\n            `O(r)`, where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = InfiniteEnumeratedSets().example()\n                sage: C._next_from_iterator(10) # indirect doctest\n                11\n\n            TODO: specify the behavior when ``obj`` is not in ``self``.\n            ",
                    "args": [
                        "self",
                        "obj"
                    ],
                    "argspec": [
                        [
                            "self",
                            "obj"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "rank": {
                    "__doc__": "\n            The rank of an element of ``self``\n\n            ``self.rank(x)`` returns the rank of `x`, that is its\n            position in the enumeration of ``self``. This is an\n            integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``, or None if `x` is not in `self`.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``. For infinite enumerated\n            sets, this won't terminate when `x` is not in ``self``\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: list(C)\n                [1, 2, 3]\n                sage: C.rank(3) # indirect doctest\n                2\n                sage: C.rank(5) # indirect doctest\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "unrank": {
                    "__doc__": "\n            The ``r``-th element of ``self``\n\n            ``self.unrank(r)`` returns the ``r``-th element of self, where\n            ``r`` is an integer between ``0`` and ``n-1`` where ``n`` is the\n            cardinality of ``self``.\n\n            This is the default (brute force) implementation from the\n            category ``EnumeratedSets()`` which can be used when the\n            method ``__iter__`` is provided. Its complexity is `O(r)`,\n            where `r` is the rank of ``obj``.\n\n            EXAMPLES::\n\n                sage: C = FiniteEnumeratedSets().example()\n                sage: C.unrank(2) # indirect doctest\n                3\n                sage: C._unrank_from_iterator(5)\n                Traceback (most recent call last):\n                ...\n                ValueError: the value must be between 0 and 2 inclusive\n            ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "rank": {
                    "__doc__": "\n            Return the rank of ``self`` in its parent.\n\n            See also :meth:`EnumeratedSets.ElementMethods.rank`\n\n            EXAMPLES::\n\n                sage: F = FiniteSemigroups().example(('a','b','c'))\n                sage: L = list(F); L\n                ['a', 'b', 'c', 'ac', 'ab', 'ba', 'bc', 'cb', 'ca',\n                 'acb', 'abc', 'bca', 'cba', 'bac', 'cab']\n                sage: L[7].rank()\n                7\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded Hopf algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = GradedHopfAlgebrasWithBasis(ZZ); C\n        Category of graded hopf algebras with basis over Integer Ring\n        sage: C.super_categories()\n        [Category of hopf algebras with basis over Integer Ring,\n         Category of graded algebras with basis over Integer Ring]\n\n        sage: C is HopfAlgebras(ZZ).WithBasis().Graded()\n        True\n        sage: C is HopfAlgebras(ZZ).Graded().WithBasis()\n        False\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis",
            "sage.categories.graded_algebras_with_basis.GradedAlgebrasWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded Hopf algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = GradedHopfAlgebrasWithBasis(ZZ); C\n        Category of graded hopf algebras with basis over Integer Ring\n        sage: C.super_categories()\n        [Category of hopf algebras with basis over Integer Ring,\n         Category of graded algebras with basis over Integer Ring]\n\n        sage: C is HopfAlgebras(ZZ).WithBasis().Graded()\n        True\n        sage: C is HopfAlgebras(ZZ).Graded().WithBasis()\n        False\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (commutative) fields, i.e. commutative rings where\n    all non-zero elements have multiplicative inverses\n\n    EXAMPLES::\n\n        sage: K = Fields()\n        sage: K\n        Category of fields\n        sage: Fields().super_categories()\n        [Category of euclidean domains, Category of division rings]\n\n        sage: K(IntegerRing())\n        Rational Field\n        sage: K(PolynomialRing(GF(3), 'x'))\n        Fraction Field of Univariate Polynomial Ring in x over\n        Finite Field of size 3\n        sage: K(RealField())\n        Real Field with 53 bits of precision\n\n    TESTS::\n\n        sage: TestSuite(Fields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "lcm": {
                    "__doc__": "NamedBinopMethod(func, name=None, obj=None)\nFile: sage/structure/element.pyx (starting at line 3287)\n\n    A decorator to be used on binary operation methods that should operate\n    on elements of the same parent. If the parents of the arguments differ,\n    coercion is performed, then the method is re-looked up by name on the\n    first argument.\n\n    In short, using the ``NamedBinopMethod`` (alias ``coerce_binop``) decorator\n    on a method gives it the exact same semantics of the basic arithmetic\n    operations like ``_add_``, ``_sub_``, etc. in that both operands are\n    guaranteed to have exactly the same parent.\n    ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "xgcd": {
                    "__doc__": "NamedBinopMethod(func, name=None, obj=None)\nFile: sage/structure/element.pyx (starting at line 3287)\n\n    A decorator to be used on binary operation methods that should operate\n    on elements of the same parent. If the parents of the arguments differ,\n    coercion is performed, then the method is re-looked up by name on the\n    first argument.\n\n    In short, using the ``NamedBinopMethod`` (alias ``coerce_binop``) decorator\n    on a method gives it the exact same semantics of the basic arithmetic\n    operations like ``_add_``, ``_sub_``, etc. in that both operands are\n    guaranteed to have exactly the same parent.\n    ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.division_rings.DivisionRings"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of (commutative) fields, i.e. commutative rings where\n    all non-zero elements have multiplicative inverses\n\n    EXAMPLES::\n\n        sage: K = Fields()\n        sage: K\n        Category of fields\n        sage: Fields().super_categories()\n        [Category of euclidean domains, Category of division rings]\n\n        sage: K(IntegerRing())\n        Rational Field\n        sage: K(PolynomialRing(GF(3), 'x'))\n        Fraction Field of Univariate Polynomial Ring in x over\n        Finite Field of size 3\n        sage: K(RealField())\n        Real Field with 53 bits of precision\n\n    TESTS::\n\n        sage: TestSuite(Fields()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.fields.Fields",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "__pow__": {
                    "__doc__": "\n            Returns the vector space of dimension `n` over ``self``.\n\n            EXAMPLES::\n\n                sage: QQ^4\n                Vector space of dimension 4 over Rational Field\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_squarefree_decomposition_univariate_polynomial": {
                    "__doc__": "\n            Return the square-free decomposition of ``f`` over this field.\n\n            This is a helper method for\n            :meth:`sage.rings.polynomial.squarefree_decomposition`.\n\n            INPUT:\n\n            - ``f`` -- a univariate non-zero polynomial over this field\n\n            ALGORITHM: For rings of characteristic zero, we use the algorithm\n            descriped in [Yun]_. Other fields may provide their own\n            implementation by overriding this method.\n\n            EXAMPLES::\n\n                sage: x = polygen(QQ)\n                sage: p = 37 * (x-1)^3 * (x-2)^3 * (x-1/3)^7 * (x-3/7)\n                sage: p.squarefree_decomposition()\n                (37*x - 111/7) * (x^2 - 3*x + 2)^3 * (x - 1/3)^7\n                sage: p = 37 * (x-2/3)^2\n                sage: p.squarefree_decomposition()\n                (37) * (x - 2/3)^2\n                sage: x = polygen(GF(3))\n                sage: x.squarefree_decomposition()\n                x\n                sage: f = QQbar['x'](1)\n                sage: f.squarefree_decomposition()\n                1\n\n            REFERENCES:\n\n            .. [Yun] Yun, David YY. On square-free decomposition algorithms.\n               In Proceedings of the third ACM symposium on Symbolic and algebraic\n               computation, pp. 26-35. ACM, 1976.\n\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_test_characteristic_fields": {
                    "__doc__": "\n            Run generic tests on the method :meth:`.characteristic`.\n\n            EXAMPLES::\n\n                sage: QQ._test_characteristic_fields()\n\n            .. NOTE::\n\n                We cannot call this method ``_test_characteristic`` since that\n                would overwrite the method in the super category, and for\n                cython classes just calling\n                ``super(sage.categories.fields.Fields().parent_class,\n                self)._test_characteristic`` doesn't have the desired effect.\n\n            .. SEEALSO::\n\n                :meth:`sage.categories.rings.Rings.ParentMethods._test_characteristic`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_xgcd_univariate_polynomial": {
                    "__doc__": "\n            Return an extended gcd of ``left`` and ``right``.\n\n            INPUT:\n\n            - ``left``, ``right`` -- two polynomials over this field\n\n            OUTPUT:\n\n            Polynomials ``g``, ``u``, and ``v`` such that ``g`` is a\n            greatest common divisor of ``left and ``right``, and such\n            that ``g = u*left + v*right`` holds.\n\n            .. NOTE::\n\n                This is a helper method for\n                :meth:`sage.rings.polynomial.polynomial_element.Polynomial.xgcd`.\n\n            EXAMPLES::\n\n                sage: P.<x> = QQ[]\n                sage: F = (x^2 + 2)*x^3; G = (x^2+2)*(x-3)\n                sage: g, u, v = QQ._xgcd_univariate_polynomial(F,G)\n                sage: g, u, v\n                (x^2 + 2, 1/27, -1/27*x^2 - 1/9*x - 1/3)\n                sage: u*F + v*G\n                x^2 + 2\n\n            ::\n\n                sage: g, u, v = QQ._xgcd_univariate_polynomial(x,P(0)); g, u, v\n                (x, 1, 0)\n                sage: g == u*x + v*P(0)\n                True\n                sage: g, u, v = QQ._xgcd_univariate_polynomial(P(0),x); g, u, v\n                (x, 0, 1)\n                sage: g == u*P(0) + v*x\n                True\n\n            TESTS:\n\n            We check that the behavior of xgcd with zero elements is\n            compatible with gcd (:trac:`17671`)::\n\n                sage: R.<x> = QQbar[]\n                sage: zero = R.zero()\n                sage: zero.xgcd(2*x)\n                (x, 0, 1/2)\n                sage: (2*x).xgcd(zero)\n                (x, 1/2, 0)\n                sage: zero.xgcd(zero)\n                (0, 0, 0)\n            ",
                    "args": [
                        "self",
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "fraction_field": {
                    "__doc__": "\n            Returns the *fraction field* of ``self``, which is ``self``.\n\n            EXAMPLES::\n\n                sage: QQ.fraction_field() is QQ\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_field": {
                    "__doc__": "\n            Returns True as ``self`` is a field.\n\n            EXAMPLES::\n\n                sage: QQ.is_field()\n                True\n                sage: Parent(QQ,category=Fields()).is_field()\n                True\n            ",
                    "args": [
                        "self",
                        "proof"
                    ],
                    "argspec": [
                        [
                            "self",
                            "proof"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "is_integrally_closed": {
                    "__doc__": "\n            Return ``True``, as per :meth:`IntegralDomain.is_integrally_closed`:\n            for every field `F`, `F` is its own field of fractions,\n            hence every element of `F` is integral over `F`.\n\n            EXAMPLES::\n\n                sage: QQ.is_integrally_closed()\n                True\n                sage: QQbar.is_integrally_closed()\n                True\n                sage: Z5 = GF(5); Z5\n                Finite Field of size 5\n                sage: Z5.is_integrally_closed()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_perfect": {
                    "__doc__": "\n            Return whether this field is perfect, i.e., its characteristic is\n            `p=0` or every element has a `p`-th root.\n\n            EXAMPLES::\n\n                sage: QQ.is_perfect()\n                True\n                sage: GF(2).is_perfect()\n                True\n                sage: FunctionField(GF(2), 'x').is_perfect()\n                False\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.euclidean_domains.EuclideanDomains"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "lcm": {
                    "__doc__": "NamedBinopMethod(func, name=None, obj=None)\nFile: sage/structure/element.pyx (starting at line 3287)\n\n    A decorator to be used on binary operation methods that should operate\n    on elements of the same parent. If the parents of the arguments differ,\n    coercion is performed, then the method is re-looked up by name on the\n    first argument.\n\n    In short, using the ``NamedBinopMethod`` (alias ``coerce_binop``) decorator\n    on a method gives it the exact same semantics of the basic arithmetic\n    operations like ``_add_``, ``_sub_``, etc. in that both operands are\n    guaranteed to have exactly the same parent.\n    ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "xgcd": {
                    "__doc__": "NamedBinopMethod(func, name=None, obj=None)\nFile: sage/structure/element.pyx (starting at line 3287)\n\n    A decorator to be used on binary operation methods that should operate\n    on elements of the same parent. If the parents of the arguments differ,\n    coercion is performed, then the method is re-looked up by name on the\n    first argument.\n\n    In short, using the ``NamedBinopMethod`` (alias ``coerce_binop``) decorator\n    on a method gives it the exact same semantics of the basic arithmetic\n    operations like ``_add_``, ``_sub_``, etc. in that both operands are\n    guaranteed to have exactly the same parent.\n    ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of commutative rings\n\n    commutative rings with unity, i.e. rings with commutative * and\n    a multiplicative identity\n\n    EXAMPLES::\n\n         sage: C = CommutativeRings(); C\n         Category of commutative rings\n         sage: C.super_categories()\n         [Category of rings, Category of commutative monoids]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n\n        sage: QQ['x,y,z'] in CommutativeRings()\n        True\n        sage: GroupAlgebra(DihedralGroup(3), QQ) in CommutativeRings()\n        False\n        sage: MatrixSpace(QQ,2,2) in CommutativeRings()\n        False\n\n    GroupAlgebra should be fixed::\n\n        sage: GroupAlgebra(CyclicPermutationGroup(3), QQ) in CommutativeRings() # todo: not implemented\n        True\n\n    ",
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.rings.Rings",
            "sage.categories.monoids.Monoids.Commutative"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of commutative rings\n\n    commutative rings with unity, i.e. rings with commutative * and\n    a multiplicative identity\n\n    EXAMPLES::\n\n         sage: C = CommutativeRings(); C\n         Category of commutative rings\n         sage: C.super_categories()\n         [Category of rings, Category of commutative monoids]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n\n        sage: QQ['x,y,z'] in CommutativeRings()\n        True\n        sage: GroupAlgebra(DihedralGroup(3), QQ) in CommutativeRings()\n        False\n        sage: MatrixSpace(QQ,2,2) in CommutativeRings()\n        False\n\n    GroupAlgebra should be fixed::\n\n        sage: GroupAlgebra(CyclicPermutationGroup(3), QQ) in CommutativeRings() # todo: not implemented\n        True\n\n    ",
            "methods": {}
        },
        "name": "sage.categories.commutative_rings.CommutativeRings",
        "parent_class": {
            "__doc__": "\n    The category of commutative rings\n\n    commutative rings with unity, i.e. rings with commutative * and\n    a multiplicative identity\n\n    EXAMPLES::\n\n         sage: C = CommutativeRings(); C\n         Category of commutative rings\n         sage: C.super_categories()\n         [Category of rings, Category of commutative monoids]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n\n        sage: QQ['x,y,z'] in CommutativeRings()\n        True\n        sage: GroupAlgebra(DihedralGroup(3), QQ) in CommutativeRings()\n        False\n        sage: MatrixSpace(QQ,2,2) in CommutativeRings()\n        False\n\n    GroupAlgebra should be fixed::\n\n        sage: GroupAlgebra(CyclicPermutationGroup(3), QQ) in CommutativeRings() # todo: not implemented\n        True\n\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (multiplicative) monoids.\n\n    A *monoid* is a unital :class:`semigroup <Semigroups>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative and admits a unit (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: Monoids()\n        Category of monoids\n        sage: Monoids().super_categories()\n        [Category of semigroups, Category of unital magmas]\n        sage: Monoids().all_super_categories()\n        [Category of monoids,\n         Category of semigroups,\n         Category of unital magmas, Category of magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: Monoids().axioms()\n        frozenset({'Associative', 'Unital'})\n        sage: Semigroups().Unital()\n        Category of monoids\n\n        sage: Monoids().example()\n        An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: C = Monoids()\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "_pow_naive": {
                    "__doc__": "\n            Return ``self`` to the `n^{th}` power (naive implementation).\n\n            INPUT:\n\n            - ``n`` -- a nonnegative integer\n\n            This naive implementation does not use binary\n            exponentiation; there are cases where this is actually\n            faster due to size explosion.\n\n            EXAMPLES::\n\n                sage: S = Monoids().example()\n                sage: x = S(\"aa\")\n                sage: [x._pow_naive(i) for i in range(6)]\n                ['', 'aa', 'aaaa', 'aaaaaa', 'aaaaaaaa', 'aaaaaaaaaa']\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_one": {
                    "__doc__": "\n            Return whether ``self`` is the one of the monoid.\n\n            The default implementation is to compare with ``self.one()``.\n\n            TESTS::\n\n                sage: S = Monoids().example()\n                sage: S.one().is_one()\n                True\n                sage: S(\"aa\").is_one()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "powers": {
                    "__doc__": "\n            Return the list `[x^0, x^1, \\ldots, x^{n-1}]`.\n\n            EXAMPLES::\n\n                sage: A = Matrix([[1, 1], [-1, 0]])\n                sage: A.powers(6)\n                [\n                [1 0]  [ 1  1]  [ 0  1]  [-1  0]  [-1 -1]  [ 0 -1]\n                [0 1], [-1  0], [-1 -1], [ 0 -1], [ 1  0], [ 1  1]\n                ]\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.semigroups.Semigroups",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of (multiplicative) monoids.\n\n    A *monoid* is a unital :class:`semigroup <Semigroups>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative and admits a unit (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: Monoids()\n        Category of monoids\n        sage: Monoids().super_categories()\n        [Category of semigroups, Category of unital magmas]\n        sage: Monoids().all_super_categories()\n        [Category of monoids,\n         Category of semigroups,\n         Category of unital magmas, Category of magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: Monoids().axioms()\n        frozenset({'Associative', 'Unital'})\n        sage: Semigroups().Unital()\n        Category of monoids\n\n        sage: Monoids().example()\n        An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: C = Monoids()\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "name": "sage.categories.monoids.Monoids",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_prod": {
                    "__doc__": "\n            Run basic tests for the product method :meth:`prod` of ``self``.\n\n            See the documentation for :class:`TestSuite` for information on\n            further options.\n\n            INPUT:\n\n            - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n            EXAMPLES:\n\n            By default, this method tests only the elements returned by\n            ``self.some_elements()``::\n\n                sage: S = Monoids().example()\n                sage: S._test_prod()\n\n            However, the elements tested can be customized with the\n            ``elements`` keyword argument::\n\n                sage: S._test_prod(elements = (S('a'), S('b')))\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "monoid_generators": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method monoid_generators at 0x7fe375ebb1b8>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "list_of_self",
                    "gap_name": "GeneratorsOfMonoid",
                    "mmt_name": null
                },
                "one_element": {
                    "__doc__": "\n            Backward compatibility alias for :meth:`one`.\n\n            TESTS::\n\n                sage: S = Monoids().example()\n                sage: S.one_element()\n                doctest:...: DeprecationWarning: .one_element() is deprecated. Please use .one() instead.\n                See http://trac.sagemath.org/17694 for details.\n                ''\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "submonoid": {
                    "__doc__": "\n            Return the multiplicative submonoid generated by ``generators``.\n\n            INPUT:\n\n            - ``generators`` -- a finite family of elements of\n              ``self``, or a list, iterable, ... that can be converted\n              into one (see :class:`Family`).\n\n            - ``category`` -- a category\n\n            This is a shorthand for\n            :meth:`Semigroups.ParentMethods.subsemigroup` that\n            specifies that this is a submonoid, and in particular that\n            the unit is ``self.one()``.\n\n            EXAMPLES::\n\n                sage: R = IntegerModRing(15)\n                sage: M = R.submonoid([R(3),R(5)]); M\n                A submonoid of (Ring of integers modulo 15) with 2 generators\n                sage: M.list()\n                [1, 3, 5, 9, 0, 10, 12, 6]\n\n            Not the presence of the unit, unlike in::\n\n                sage: S = R.subsemigroup([R(3),R(5)]); S\n                A subsemigroup of (Ring of integers modulo 15) with 2 generators\n                sage: S.list()\n                [3, 5, 9, 0, 10, 12, 6]\n\n            This method is really a shorthand for subsemigroup::\n\n                sage: M2 = R.subsemigroup([R(3),R(5)], one=R.one())\n                sage: M2 is M\n                True\n\n\n            ",
                    "args": [
                        "self",
                        "generators",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "generators",
                            "category"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "_pow_naive": {
                    "__doc__": "\n            Return ``self`` to the `n^{th}` power (naive implementation).\n\n            INPUT:\n\n            - ``n`` -- a nonnegative integer\n\n            This naive implementation does not use binary\n            exponentiation; there are cases where this is actually\n            faster due to size explosion.\n\n            EXAMPLES::\n\n                sage: S = Monoids().example()\n                sage: x = S(\"aa\")\n                sage: [x._pow_naive(i) for i in range(6)]\n                ['', 'aa', 'aaaa', 'aaaaaa', 'aaaaaaaa', 'aaaaaaaaaa']\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_one": {
                    "__doc__": "\n            Return whether ``self`` is the one of the monoid.\n\n            The default implementation is to compare with ``self.one()``.\n\n            TESTS::\n\n                sage: S = Monoids().example()\n                sage: S.one().is_one()\n                True\n                sage: S(\"aa\").is_one()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "powers": {
                    "__doc__": "\n            Return the list `[x^0, x^1, \\ldots, x^{n-1}]`.\n\n            EXAMPLES::\n\n                sage: A = Matrix([[1, 1], [-1, 0]])\n                sage: A.powers(6)\n                [\n                [1 0]  [ 1  1]  [ 0  1]  [-1  0]  [-1 -1]  [ 0 -1]\n                [0 1], [-1  0], [-1 -1], [ 0 -1], [ 1  0], [ 1  1]\n                ]\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of classical crystals, that is crystals of finite Cartan type.\n\n    EXAMPLES::\n\n        sage: C = ClassicalCrystals()\n        sage: C\n        Category of classical crystals\n        sage: C.super_categories()\n        [Category of regular crystals,\n         Category of finite crystals,\n         Category of highest weight crystals]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = ClassicalCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "lusztig_involution": {
                    "__doc__": "\n            Return the Lusztig involution on the classical highest weight\n            crystal ``self``.\n\n            The Lusztig involution on a finite-dimensional highest weight\n            crystal `B(\\lambda)` of highest weight `\\lambda` maps the\n            highest weight vector to the lowest weight vector and the\n            Kashiwara operator `f_i` to `e_{i^*}`, where `i^*` is defined as\n            `\\alpha_{i^*} = -w_0(\\alpha_i)`. Here `w_0` is the longest element\n            of the Weyl group acting on the `i`-th simple root `\\alpha_i`.\n\n            EXAMPLES::\n\n                sage: B = crystals.Tableaux(['A',3],shape=[2,1])\n                sage: b = B(rows=[[1,2],[4]])\n                sage: b.lusztig_involution()\n                [[1, 4], [3]]\n                sage: b.to_tableau().schuetzenberger_involution(n=4)\n                [[1, 4], [3]]\n\n                sage: all(b.lusztig_involution().to_tableau() == b.to_tableau().schuetzenberger_involution(n=4) for b in B)\n                True\n\n                sage: B = crystals.Tableaux(['D',4],shape=[1])\n                sage: [[b,b.lusztig_involution()] for b in B]\n                [[[[1]], [[-1]]], [[[2]], [[-2]]], [[[3]], [[-3]]], [[[4]], [[-4]]], [[[-4]],\n                [[4]]], [[[-3]], [[3]]], [[[-2]], [[2]]], [[[-1]], [[1]]]]\n\n                sage: B = crystals.Tableaux(['D',3],shape=[1])\n                sage: [[b,b.lusztig_involution()] for b in B]\n                [[[[1]], [[-1]]], [[[2]], [[-2]]], [[[3]], [[3]]], [[[-3]], [[-3]]],\n                [[[-2]], [[2]]], [[[-1]], [[1]]]]\n\n                sage: C = CartanType(['E',6])\n                sage: La = C.root_system().weight_lattice().fundamental_weights()\n                sage: T = crystals.HighestWeight(La[1])\n                sage: t = T[3]; t\n                [(-4, 2, 5)]\n                sage: t.lusztig_involution()\n                [(-2, -3, 4)]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.regular_crystals.RegularCrystals",
            "sage.categories.finite_crystals.FiniteCrystals",
            "sage.categories.highest_weight_crystals.HighestWeightCrystals"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of classical crystals, that is crystals of finite Cartan type.\n\n    EXAMPLES::\n\n        sage: C = ClassicalCrystals()\n        sage: C\n        Category of classical crystals\n        sage: C.super_categories()\n        [Category of regular crystals,\n         Category of finite crystals,\n         Category of highest weight crystals]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = ClassicalCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
            "methods": {}
        },
        "name": "sage.categories.classical_crystals.ClassicalCrystals",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_fast_iter": {
                    "__doc__": "\n            Tests whether the elements returned by :meth:`.__iter__`\n            and ``Crystal.list(self)`` are the same (the two\n            algorithms are different).\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A', 5])\n                sage: C._test_fast_iter()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "character": {
                    "__doc__": "\n            Returns the character of this crystal.\n\n            INPUT:\n\n            - ``R`` -- a :class:`WeylCharacterRing`\n              (default: the default :class:`WeylCharacterRing` for this Cartan type)\n\n            Returns the character of ``self`` as an element of ``R``.\n\n            EXAMPLES::\n\n                sage: C = crystals.Tableaux(\"A2\", shape=[2,1])\n                sage: chi = C.character(); chi\n                A2(2,1,0)\n\n                sage: T = crystals.TensorProduct(C,C)\n                sage: chiT = T.character(); chiT\n                A2(2,2,2) + 2*A2(3,2,1) + A2(3,3,0) + A2(4,1,1) + A2(4,2,0)\n                sage: chiT == chi^2\n                True\n\n            One may specify an alternate :class:`WeylCharacterRing`::\n\n                sage: R = WeylCharacterRing(\"A2\", style=\"coroots\")\n                sage: chiT = T.character(R); chiT\n                A2(0,0) + 2*A2(1,1) + A2(0,3) + A2(3,0) + A2(2,2)\n                sage: chiT in R\n                True\n\n            It should have the same Cartan type and use the same\n            realization of the weight lattice as ``self``::\n\n                sage: R = WeylCharacterRing(\"A3\", style=\"coroots\")\n                sage: T.character(R)\n                Traceback (most recent call last):\n                ...\n                ValueError: Weyl character ring does not have the right Cartan type\n\n            ",
                    "args": [
                        "self",
                        "R"
                    ],
                    "argspec": [
                        [
                            "self",
                            "R"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "demazure_character": {
                    "__doc__": "\n            Returns the Demazure character associated to ``w``.\n\n            INPUT:\n\n            - ``w`` -- an element of the ambient weight lattice\n              realization of the crystal, or a reduced word, or an element\n              in the associated Weyl group\n\n            OPTIONAL:\n\n            - ``f`` -- a function from the crystal to a module\n\n            This is currently only supported for crystals whose underlying\n            weight space is the ambient space.\n\n            The Demazure character is obtained by applying the Demazure operator\n            `D_w` (see :meth:`sage.categories.regular_crystals.RegularCrystals.ParentMethods.demazure_operator`)\n            to the highest weight element of the classical crystal. The simple\n            Demazure operators `D_i` (see\n            :meth:`sage.categories.regular_crystals.RegularCrystals.ElementMethods.demazure_operator_simple`)\n            do not braid on the level of crystals, but on the level of characters they do.\n            That is why it makes sense to input ``w`` either as a weight, a reduced word,\n            or as an element of the underlying Weyl group.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape = [2,1])\n                sage: e = T.weight_lattice_realization().basis()\n                sage: weight = e[0] + 2*e[2]\n                sage: weight.reduced_word()\n                [2, 1]\n                sage: T.demazure_character(weight)\n                x1^2*x2 + x1*x2^2 + x1^2*x3 + x1*x2*x3 + x1*x3^2\n\n                sage: T = crystals.Tableaux(['A',3],shape=[2,1])\n                sage: T.demazure_character([1,2,3])\n                x1^2*x2 + x1*x2^2 + x1^2*x3 + x1*x2*x3 + x2^2*x3\n                sage: W = WeylGroup(['A',3])\n                sage: w = W.from_reduced_word([1,2,3])\n                sage: T.demazure_character(w)\n                x1^2*x2 + x1*x2^2 + x1^2*x3 + x1*x2*x3 + x2^2*x3\n\n                sage: T = crystals.Tableaux(['B',2], shape = [2])\n                sage: e = T.weight_lattice_realization().basis()\n                sage: weight = -2*e[1]\n                sage: T.demazure_character(weight)\n                x1^2 + x1*x2 + x2^2 + x1 + x2 + x1/x2 + 1/x2 + 1/x2^2 + 1\n\n                sage: T = crystals.Tableaux(\"B2\",shape=[1/2,1/2])\n                sage: b2=WeylCharacterRing(\"B2\",base_ring=QQ).ambient()\n                sage: T.demazure_character([1,2],f=lambda x:b2(x.weight()))\n                b2(-1/2,1/2) + b2(1/2,-1/2) + b2(1/2,1/2)\n\n            REFERENCES:\n\n            .. [D1974] \\M. Demazure, Desingularisation des varietes de Schubert,\n               Ann. E. N. S., Vol. 6, (1974), p. 163-172\n\n            .. [M2009] Sarah Mason, An Explicit Construction of Type A Demazure Atoms,\n               Journal of Algebraic Combinatorics, Vol. 29, (2009), No. 3, p.295-313.\n               :arXiv:`0707.4267`\n            ",
                    "args": [
                        "self",
                        "w",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "w",
                            "f"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "opposition_automorphism": {
                    "__doc__": "\n            Deprecated in :trac:`15560`. Use the corresponding method in\n            Cartan type.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',5],shape=[1])\n                sage: T.opposition_automorphism()\n                doctest:...: DeprecationWarning: opposition_automorphism is deprecated.\n                Use opposition_automorphism from the Cartan type instead.\n                See http://trac.sagemath.org/15560 for details.\n                Finite family {1: 5, 2: 4, 3: 3, 4: 2, 5: 1}\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.crystals.Crystals",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "lusztig_involution": {
                    "__doc__": "\n            Return the Lusztig involution on the classical highest weight\n            crystal ``self``.\n\n            The Lusztig involution on a finite-dimensional highest weight\n            crystal `B(\\lambda)` of highest weight `\\lambda` maps the\n            highest weight vector to the lowest weight vector and the\n            Kashiwara operator `f_i` to `e_{i^*}`, where `i^*` is defined as\n            `\\alpha_{i^*} = -w_0(\\alpha_i)`. Here `w_0` is the longest element\n            of the Weyl group acting on the `i`-th simple root `\\alpha_i`.\n\n            EXAMPLES::\n\n                sage: B = crystals.Tableaux(['A',3],shape=[2,1])\n                sage: b = B(rows=[[1,2],[4]])\n                sage: b.lusztig_involution()\n                [[1, 4], [3]]\n                sage: b.to_tableau().schuetzenberger_involution(n=4)\n                [[1, 4], [3]]\n\n                sage: all(b.lusztig_involution().to_tableau() == b.to_tableau().schuetzenberger_involution(n=4) for b in B)\n                True\n\n                sage: B = crystals.Tableaux(['D',4],shape=[1])\n                sage: [[b,b.lusztig_involution()] for b in B]\n                [[[[1]], [[-1]]], [[[2]], [[-2]]], [[[3]], [[-3]]], [[[4]], [[-4]]], [[[-4]],\n                [[4]]], [[[-3]], [[3]]], [[[-2]], [[2]]], [[[-1]], [[1]]]]\n\n                sage: B = crystals.Tableaux(['D',3],shape=[1])\n                sage: [[b,b.lusztig_involution()] for b in B]\n                [[[[1]], [[-1]]], [[[2]], [[-2]]], [[[3]], [[3]]], [[[-3]], [[-3]]],\n                [[[-2]], [[2]]], [[[-1]], [[1]]]]\n\n                sage: C = CartanType(['E',6])\n                sage: La = C.root_system().weight_lattice().fundamental_weights()\n                sage: T = crystals.HighestWeight(La[1])\n                sage: t = T[3]; t\n                [(-4, 2, 5)]\n                sage: t.lusztig_involution()\n                [(-2, -3, 4)]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": "TODO",
        "morphism_class": {
            "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_sets.FiniteSets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "list": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method list at 0x7fe375eb21b8>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "list_of_self",
                    "gap_name": "List",
                    "mmt_name": null
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of finite sets.\n\n    EXAMPLES::\n\n        sage: C = FiniteSets(); C\n        Category of finite sets\n        sage: C.super_categories()\n        [Category of sets]\n        sage: C.all_super_categories()\n        [Category of finite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n        sage: C.example()\n        NotImplemented\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Sets().Finite()\n        True\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of right modules\n    right modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with right multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: RightModules(QQ)\n        Category of right modules over Rational Field\n        sage: RightModules(QQ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(RightModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of right modules\n    right modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with right multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: RightModules(QQ)\n        Category of right modules over Rational Field\n        sage: RightModules(QQ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(RightModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.right_modules.RightModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.objects.Objects"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
        "parent_class": {
            "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category whose objects are sets and whose morphisms are\n    maps that are allowed to raise a ValueError on some inputs.\n\n    This category is equivalent to the category of pointed sets,\n    via the equivalence sending an object X to X union {error},\n    a morphism f to the morphism of pointed sets that sends x\n    to f(x) if f does not raise an error on x, or to error if it\n    does.\n\n    EXAMPLES::\n\n        sage: SetsWithPartialMaps()\n        Category of sets with partial maps\n\n        sage: SetsWithPartialMaps().super_categories()\n        [Category of objects]\n\n    TESTS::\n\n        sage: TestSuite(SetsWithPartialMaps()).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite dimensional modules with a distinguished basis\n\n    EXAMPLES::\n\n      sage: C = FiniteDimensionalModulesWithBasis(ZZ); C\n      Category of finite dimensional modules with basis over Integer Ring\n      sage: sorted(C.super_categories(), key=str)\n      [Category of finite dimensional modules over Integer Ring,\n       Category of modules with basis over Integer Ring]\n      sage: C is Modules(ZZ).WithBasis().FiniteDimensional()\n      True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "FiniteDimensional"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "dense_coefficient_list": {
                    "__doc__": "\n            Return a list of *all* coefficients of ``self``.\n\n            By default, this list is ordered in the same way as the\n            indexing set of the basis of the parent of ``self``.\n\n            INPUT:\n\n            - ``order`` -- (optional) an ordering of the basis indexing set\n\n            EXAMPLES::\n\n                sage: v = vector([0, -1, -3])\n                sage: v.dense_coefficient_list()\n                [0, -1, -3]\n                sage: v.dense_coefficient_list([2,1,0])\n                [-3, -1, 0]\n                sage: sorted(v.coefficients())\n                [-3, -1]\n            ",
                    "args": [
                        "self",
                        "order"
                    ],
                    "argspec": [
                        [
                            "self",
                            "order"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "gap": "IsFiniteDimensional",
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.modules.Modules.FiniteDimensional"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {
                "image": {
                    "__doc__": "\n            Return the image of ``self`` as a submodule of the codomain.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: f.image()\n                Free module generated by {0, 1, 2} over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "image_basis": {
                    "__doc__": "\n            Return a basis for the image of ``self`` in echelon form.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: f.image_basis()\n                ([1, 2, 3], [2, 3, 1], [3, 1, 2])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "kernel": {
                    "__doc__": "\n            Return the kernel of ``self`` as a submodule of the domain.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: K = f.kernel()\n                sage: K\n                Free module generated by {0, 1, 2} over Rational Field\n                sage: K.ambient()\n                Symmetric group algebra of order 3 over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "kernel_basis": {
                    "__doc__": "\n            Return a basis of the kernel of ``self`` in echelon form.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: f.kernel_basis()\n                ([1, 2, 3] - [3, 2, 1], [1, 3, 2] - [3, 2, 1], [2, 1, 3] - [3, 2, 1])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "matrix": {
                    "__doc__": "\n            Return the matrix of this morphism in the distinguished\n            bases of the domain and codomain.\n\n            INPUT:\n\n            - ``base_ring`` -- a ring (default: ``None``, meaning the\n              base ring of the codomain)\n\n            - ``side`` -- \"left\" or \"right\" (default: \"left\")\n\n            If ``side`` is \"left\", this morphism is considered as\n            acting on the left; i.e. each column of the matrix\n            represents the image of an element of the basis of the\n            domain.\n\n            The order of the rows and columns matches with the order\n            in which the bases are enumerated.\n\n            .. SEEALSO:: :func:`Modules.WithBasis.ParentMethods.module_morphism`\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2]); x = X.basis()\n                sage: Y = CombinatorialFreeModule(ZZ, [3,4]); y = Y.basis()\n                sage: phi = X.module_morphism(on_basis = {1: y[3] + 3*y[4], 2: 2*y[3] + 5*y[4]}.__getitem__,\n                ...                           codomain = Y)\n                sage: phi.matrix()\n                [1 2]\n                [3 5]\n                sage: phi.matrix(side=\"right\")\n                [1 3]\n                [2 5]\n\n                sage: phi.matrix().parent()\n                Full MatrixSpace of 2 by 2 dense matrices over Integer Ring\n                sage: phi.matrix(QQ).parent()\n                Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n\n            The resulting matrix is immutable::\n\n                sage: phi.matrix().is_mutable()\n                False\n\n            The zero morphism has a zero matrix::\n\n                sage: Hom(X,Y).zero().matrix()\n                [0 0]\n                [0 0]\n\n            .. TODO::\n\n                Add support for morphisms where the codomain has a\n                different base ring than the domain::\n\n                    sage: Y = CombinatorialFreeModule(QQ, [3,4]); y = Y.basis()\n                    sage: phi = X.module_morphism(on_basis = {1: y[3] + 3*y[4], 2: 2*y[3] + 5/2*y[4]}.__getitem__,\n                    ...                           codomain = Y)\n                    sage: phi.matrix().parent()          # todo: not implemented\n                    Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n\n                This currently does not work because, in this case,\n                the morphism is just in the category of commutative\n                additive groups (i.e. the intersection of the\n                categories of modules over `\\ZZ` and over `\\QQ`)::\n\n                    sage: phi.parent().homset_category()\n                    Category of commutative additive semigroups\n                    sage: phi.parent().homset_category() # todo: not implemented\n                    Category of finite dimensional modules with basis over Integer Ring\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "left"
                        ]
                    ]
                }
            }
        },
        "name": "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "annihilator": {
                    "__doc__": "\n            Return the annihilator of a finite set.\n\n            INPUT:\n\n            - ``S`` -- a finite set\n\n            - ``action`` -- a function (default: :obj:`operator.mul`)\n\n            - ``side`` -- 'left' or 'right' (default: 'right')\n\n            - ``category`` -- a category\n\n            Assumptions:\n\n            - ``action`` takes elements of ``self`` as first argument\n              and elements of ``S`` as second argument;\n\n            - The codomain is any vector space, and ``action`` is\n              linear on its first argument; typically it is bilinear;\n\n            - If ``side`` is 'left', this is reversed.\n\n            OUTPUT:\n\n            The subspace of the elements `x` of ``self`` such that\n            ``action(x,s) = 0`` for all `s\\in S`. If ``side`` is\n            'left' replace the above equation by ``action(s,x) = 0``.\n\n            If ``self`` is a ring, ``action`` an action of ``self`` on\n            a module `M` and `S` is a subset of `M`, we recover the\n            :Wikipedia:`Annihilator_%28ring_theory%29`. Similarly this\n            can be used to compute torsion or orthogonals.\n\n            .. SEEALSO:: :meth:`annihilator_basis` for lots of examples.\n\n            EXAMPLES::\n\n                sage: F = FiniteDimensionalAlgebrasWithBasis(QQ).example(); F\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: x,y,a,b = F.basis()\n                sage: A = F.annihilator([a + 3*b + 2*y]); A\n                Free module generated by {0} over Rational Field\n                sage: [b.lift() for b in A.basis()]\n                [-1/2*a - 3/2*b + x]\n\n            The category can be used to specify other properties of\n            this subspace, like that this is a subalgebra::\n\n                sage: center = F.annihilator(F.basis(), F.bracket,\n                ....:                        category=Algebras(QQ).Subobjects())\n                sage: (e,) = center.basis()\n                sage: e.lift()\n                x + y\n                sage: e * e == e\n                True\n\n            Taking annihilator is order reversing for inclusion::\n\n                sage: A   = F.annihilator([]);    A  .rename(\"A\")\n                sage: Ax  = F.annihilator([x]);   Ax .rename(\"Ax\")\n                sage: Ay  = F.annihilator([y]);   Ay .rename(\"Ay\")\n                sage: Axy = F.annihilator([x,y]); Axy.rename(\"Axy\")\n                sage: P = Poset(([A, Ax, Ay, Axy], attrcall(\"is_submodule\")))\n                sage: sorted(P.cover_relations(), key=str)\n                [[Ax, A], [Axy, Ax], [Axy, Ay], [Ay, A]]\n            ",
                    "args": [
                        "self",
                        "S",
                        "action",
                        "side",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S",
                            "action",
                            "side",
                            "category"
                        ],
                        null,
                        null,
                        [
                            "<built-in function mul>",
                            "right",
                            null
                        ]
                    ]
                },
                "annihilator_basis": {
                    "__doc__": "\n            Return a basis of the annihilator of a finite set of elements.\n\n            INPUT:\n\n            - ``S`` -- a finite set of objects\n\n            - ``action`` -- a function (default: :obj:`operator.mul`)\n\n            - ``side`` -- 'left' or 'right' (default: 'right'):\n              on which side of ``self`` the elements of `S` acts.\n\n            See :meth:`annihilator` for the assumptions and definition\n            of the annihilator.\n\n            EXAMPLES:\n\n            By default, the action is the standard `*` operation. So\n            our first example is about an algebra::\n\n                sage: F = FiniteDimensionalAlgebrasWithBasis(QQ).example(); F\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: x,y,a,b = F.basis()\n\n            In this algebra, multiplication on the right by `x`\n            annihilates all basis elements but `x`::\n\n                sage: x*x, y*x, a*x, b*x\n                (x, 0, 0, 0)\n\n            So the annihilator is the subspace spanned by `y`, `a`, and `b`::\n\n                sage: F.annihilator_basis([x])\n                (y, a, b)\n\n            The same holds for `a` and `b`::\n\n                sage: x*a, y*a, a*a, b*a\n                (a, 0, 0, 0)\n                sage: F.annihilator_basis([a])\n                (y, a, b)\n\n            On the other hand, `y` annihilates only `x`::\n\n                sage: F.annihilator_basis([y])\n                (x,)\n\n            Here is a non trivial annihilator::\n\n                sage: F.annihilator_basis([a + 3*b + 2*y])\n                (-1/2*a - 3/2*b + x,)\n\n            Let's check it::\n\n                sage: (-1/2*a - 3/2*b + x) * (a + 3*b + 2*y)\n                0\n\n            Doing the same calculations on the left exchanges the\n            roles of `x` and `y`::\n\n                sage: F.annihilator_basis([y], side=\"left\")\n                (x, a, b)\n                sage: F.annihilator_basis([a], side=\"left\")\n                (x, a, b)\n                sage: F.annihilator_basis([b], side=\"left\")\n                (x, a, b)\n                sage: F.annihilator_basis([x], side=\"left\")\n                (y,)\n                sage: F.annihilator_basis([a+3*b+2*x], side=\"left\")\n                (-1/2*a - 3/2*b + y,)\n\n            By specifying an inner product, this method can be used to\n            compute the orthogonal of a subspace::\n\n                sage: x,y,a,b = F.basis()\n                sage: def scalar(u,v): return vector([sum(u[i]*v[i] for i in F.basis().keys())])\n                sage: F.annihilator_basis([x+y, a+b], scalar)\n                (x - y, a - b)\n\n            By specifying the standard Lie bracket as action, one can\n            compute the commutator of a subspace of `F`::\n\n                sage: F.annihilator_basis([a+b], action=F.bracket)\n                (x + y, a, b)\n\n            In particular one can compute a basis of the center of the\n            algebra. In our example, it is reduced to the identity::\n\n                sage: F.annihilator_basis(F.algebra_generators(), action=F.bracket)\n                (x + y,)\n\n            But see also\n            :meth:`FiniteDimensionalAlgebrasWithBasis.ParentMethods.center_basis`.\n            ",
                    "args": [
                        "self",
                        "S",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "<built-in function mul>",
                            "right"
                        ]
                    ]
                },
                "dimension": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method dimension at 0x7fe375ebb758>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "sage",
                    "gap_name": "Dimension",
                    "mmt_name": null
                },
                "quotient_module": {
                    "__doc__": "\n            Construct the quotient module ``self``/``submodule``.\n\n            INPUT:\n\n            - ``submodule`` -- a submodule with basis of ``self``, or\n              something that can be turned into one via\n              ``self.submodule(submodule)``.\n\n            - ``check``, ``already_echelonized`` -- passed down to\n              :meth:`ModulesWithBasis.ParentMethods.submodule`.\n\n            .. WARNING::\n\n                At this point, this only supports quotients by free\n                submodules admitting a basis in unitriangular echelon\n                form. In this case, the quotient is also a free\n                module, with a basis consisting of the retract of a\n                subset of the basis of ``self``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: Y = X.quotient_module([x[0]-x[1], x[1]-x[2]], already_echelonized=True)\n                sage: Y.print_options(prefix='y'); Y\n                Free module generated by {2} over Rational Field\n                sage: y = Y.basis()\n                sage: y[2]\n                y[2]\n                sage: y[2].lift()\n                x[2]\n                sage: Y.retract(x[0]+2*x[1])\n                3*y[2]\n\n                sage: R.<a,b> = QQ[]\n                sage: C = CombinatorialFreeModule(R, range(3), prefix='x')\n                sage: x = C.basis()\n                sage: gens = [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]\n                sage: Y = X.quotient_module(gens)\n\n            .. SEEALSO::\n\n                 - :meth:`Modules.WithBasis.ParentMethods.submodule`\n                 - :meth:`Rings.ParentMethods.quotient`\n                 - :class:`sage.modules.with_basis.subquotient.QuotientModuleWithBasis`\n            ",
                    "args": [
                        "self",
                        "submodule",
                        "check",
                        "already_echelonized",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "submodule",
                            "check",
                            "already_echelonized",
                            "category"
                        ],
                        null,
                        null,
                        [
                            true,
                            false,
                            null
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "dense_coefficient_list": {
                    "__doc__": "\n            Return a list of *all* coefficients of ``self``.\n\n            By default, this list is ordered in the same way as the\n            indexing set of the basis of the parent of ``self``.\n\n            INPUT:\n\n            - ``order`` -- (optional) an ordering of the basis indexing set\n\n            EXAMPLES::\n\n                sage: v = vector([0, -1, -3])\n                sage: v.dense_coefficient_list()\n                [0, -1, -3]\n                sage: v.dense_coefficient_list([2,1,0])\n                [-3, -1, 0]\n                sage: sorted(v.coefficients())\n                [-3, -1]\n            ",
                    "args": [
                        "self",
                        "order"
                    ],
                    "argspec": [
                        [
                            "self",
                            "order"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of two-sided ideals in a fixed ring.\n\n    EXAMPLES::\n\n        sage: Ideals(Integers(200))\n        Category of ring ideals in Ring of integers modulo 200\n        sage: C = Ideals(IntegerRing()); C\n        Category of ring ideals in Integer Ring\n        sage: I = C([8,12,18])\n        sage: I\n        Principal ideal (2) of Integer Ring\n\n    See also: :class:`CommutativeRingIdeals`.\n\n    TODO:\n     - If useful, implement RingLeftIdeals and RingRightIdeals\n       of which RingIdeals would be a subcategory\n\n     - Make RingIdeals(R), return CommutativeRingIdeals(R) when R is\n       commutative\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of two-sided ideals in a fixed ring.\n\n    EXAMPLES::\n\n        sage: Ideals(Integers(200))\n        Category of ring ideals in Ring of integers modulo 200\n        sage: C = Ideals(IntegerRing()); C\n        Category of ring ideals in Integer Ring\n        sage: I = C([8,12,18])\n        sage: I\n        Principal ideal (2) of Integer Ring\n\n    See also: :class:`CommutativeRingIdeals`.\n\n    TODO:\n     - If useful, implement RingLeftIdeals and RingRightIdeals\n       of which RingIdeals would be a subcategory\n\n     - Make RingIdeals(R), return CommutativeRingIdeals(R) when R is\n       commutative\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of two-sided ideals in a fixed ring.\n\n    EXAMPLES::\n\n        sage: Ideals(Integers(200))\n        Category of ring ideals in Ring of integers modulo 200\n        sage: C = Ideals(IntegerRing()); C\n        Category of ring ideals in Integer Ring\n        sage: I = C([8,12,18])\n        sage: I\n        Principal ideal (2) of Integer Ring\n\n    See also: :class:`CommutativeRingIdeals`.\n\n    TODO:\n     - If useful, implement RingLeftIdeals and RingRightIdeals\n       of which RingIdeals would be a subcategory\n\n     - Make RingIdeals(R), return CommutativeRingIdeals(R) when R is\n       commutative\n    ",
            "methods": {}
        },
        "name": "sage.categories.ring_ideals.RingIdeals",
        "parent_class": {
            "__doc__": "\n    The category of two-sided ideals in a fixed ring.\n\n    EXAMPLES::\n\n        sage: Ideals(Integers(200))\n        Category of ring ideals in Ring of integers modulo 200\n        sage: C = Ideals(IntegerRing()); C\n        Category of ring ideals in Integer Ring\n        sage: I = C([8,12,18])\n        sage: I\n        Principal ideal (2) of Integer Ring\n\n    See also: :class:`CommutativeRingIdeals`.\n\n    TODO:\n     - If useful, implement RingLeftIdeals and RingRightIdeals\n       of which RingIdeals would be a subcategory\n\n     - Make RingIdeals(R), return CommutativeRingIdeals(R) when R is\n       commutative\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.ring_ideals.RingIdeals",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of two-sided ideals in a fixed ring.\n\n    EXAMPLES::\n\n        sage: Ideals(Integers(200))\n        Category of ring ideals in Ring of integers modulo 200\n        sage: C = Ideals(IntegerRing()); C\n        Category of ring ideals in Integer Ring\n        sage: I = C([8,12,18])\n        sage: I\n        Principal ideal (2) of Integer Ring\n\n    See also: :class:`CommutativeRingIdeals`.\n\n    TODO:\n     - If useful, implement RingLeftIdeals and RingRightIdeals\n       of which RingIdeals would be a subcategory\n\n     - Make RingIdeals(R), return CommutativeRingIdeals(R) when R is\n       commutative\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (multiplicative) groups, i.e. monoids with\n    inverses.\n\n    EXAMPLES::\n\n        sage: Groups()\n        Category of groups\n        sage: Groups().super_categories()\n        [Category of monoids, Category of inverse unital magmas]\n\n    TESTS::\n\n        sage: TestSuite(Groups()).run()\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "conjugacy_class": {
                    "__doc__": "\n            Return the conjugacy class of ``self``.\n\n            EXAMPLES::\n\n                sage: D = DihedralGroup(5)\n                sage: g = D((1,3,5,2,4))\n                sage: g.conjugacy_class()\n                Conjugacy class of (1,3,5,2,4) in Dihedral group of order 10 as a permutation group\n\n                sage: H = MatrixGroup([matrix(GF(5),2,[1,2, -1, 1]), matrix(GF(5),2, [1,1, 0,1])])\n                sage: h = H(matrix(GF(5),2,[1,2, -1, 1]))\n                sage: h.conjugacy_class()\n                Conjugacy class of [1 2]\n                [4 1] in Matrix group over Finite Field of size 5 with 2 generators (\n                [1 2]  [1 1]\n                [4 1], [0 1]\n                )\n\n                sage: G = SL(2, GF(2))\n                sage: g = G.gens()[0]\n                sage: g.conjugacy_class()\n                Conjugacy class of [1 1]\n                [0 1] in Special Linear Group of degree 2 over Finite Field of size 2\n\n                sage: G = SL(2, QQ)\n                sage: g = G([[1,1],[0,1]])\n                sage: g.conjugacy_class()\n                Conjugacy class of [1 1]\n                [0 1] in Special Linear Group of degree 2 over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.magmas.Magmas.Unital.Inverse"
        ],
        "mmt": "Group",
        "morphism_class": {
            "__doc__": "\n    The category of (multiplicative) groups, i.e. monoids with\n    inverses.\n\n    EXAMPLES::\n\n        sage: Groups()\n        Category of groups\n        sage: Groups().super_categories()\n        [Category of monoids, Category of inverse unital magmas]\n\n    TESTS::\n\n        sage: TestSuite(Groups()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.groups.Groups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_inverse": {
                    "__doc__": "\n            Run generic tests on the method :meth:`.__invert__`.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: G = SymmetricGroup(3)\n                sage: G._test_inverse()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "cayley_table": {
                    "__doc__": "\n            Returns the \"multiplication\" table of this multiplicative group,\n            which is also known as the \"Cayley table\".\n\n            .. note:: The order of the elements in the row and column\n              headings is equal to the order given by the table's\n              :meth:`~sage.matrix.operation_table.OperationTable.column_keys`\n              method.  The association between the actual elements and the\n              names/symbols used in the table can also be retrieved as\n              a dictionary with the\n              :meth:`~sage.matrix.operation_table.OperationTable.translation`\n              method.\n\n            For groups, this routine should behave identically to the\n            :meth:`~sage.categories.magmas.Magmas.ParentMethods.multiplication_table`\n            method for magmas, which applies in greater generality.\n\n            INPUT:\n\n            - ``names`` - the type of names used, values are:\n\n              * ``'letters'`` - lowercase ASCII letters are used\n                for a base 26 representation of the elements'\n                positions in the list given by :meth:`list`,\n                padded to a common width with leading 'a's.\n              * ``'digits'`` - base 10 representation of the\n                elements' positions in the list given by\n                :meth:`~sage.matrix.operation_table.OperationTable.column_keys`,\n                padded to a common width with leading zeros.\n              * ``'elements'`` - the string representations\n                of the elements themselves.\n              * a list - a list of strings, where the length\n                of the list equals the number of elements.\n\n            - ``elements`` - default = ``None``.  A list of\n              elements of the group, in forms that can be\n              coerced into the structure, eg. their string\n              representations. This may be used to impose an\n              alternate ordering on the elements, perhaps when\n              this is used in the context of a particular structure.\n              The default is to use whatever ordering is provided by the\n              the group, which is reported by the\n              :meth:`~sage.matrix.operation_table.OperationTable.column_keys`\n              method.  Or the ``elements`` can be a subset\n              which is closed under the operation. In particular,\n              this can be used when the base set is infinite.\n\n            OUTPUT:\n            An object representing the multiplication table.  This is\n            an :class:`~sage.matrix.operation_table.OperationTable` object\n            and even more documentation can be found there.\n\n\n            EXAMPLES:\n\n            Permutation groups, matrix groups and abelian groups\n            can all compute their multiplication tables.  ::\n\n                sage: G = DiCyclicGroup(3)\n                sage: T = G.cayley_table()\n                sage: T.column_keys()\n                ((), (1,3,2,4)(5,7), ..., (1,2)(3,4)(5,7,6))\n                sage: T\n                *  a b c d e f g h i j k l\n                 +------------------------\n                a| a b c d e f g h i j k l\n                b| b e f j i h d k a l c g\n                c| c g d e h b k l j f i a\n                d| d k e h l g i a f b j c\n                e| e i h l a k j c b g f d\n                f| f d j i k e c g l h a b\n                g| g h b f j l e i c a d k\n                h| h j l a c i f d g k b e\n                i| i a k g b c l f e d h j\n                j| j c i k g d a b h e l f\n                k| k l g b f a h j d c e i\n                l| l f a c d j b e k i g h\n\n            ::\n\n                sage: M=SL(2,2)\n                sage: M.cayley_table()\n                *  a b c d e f\n                 +------------\n                a| a b c d e f\n                b| b a d c f e\n                c| c f e b a d\n                d| d e f a b c\n                e| e d a f c b\n                f| f c b e d a\n                <BLANKLINE>\n\n            ::\n\n                sage: A=AbelianGroup([2,3])\n                sage: A.cayley_table()\n                *  a b c d e f\n                 +------------\n                a| a b c d e f\n                b| b c a e f d\n                c| c a b f d e\n                d| d e f a b c\n                e| e f d b c a\n                f| f d e c a b\n\n            Lowercase ASCII letters are the default symbols used\n            for the table, but you can also specify the use of\n            decimal digit strings, or provide your own strings\n            (in the proper order if they have meaning).\n            Also, if the elements themselves are not too complex,\n            you can choose to just use the string representations\n            of the elements themselves.  ::\n\n                sage: C=CyclicPermutationGroup(11)\n                sage: C.cayley_table(names='digits')\n                 *  00 01 02 03 04 05 06 07 08 09 10\n                  +---------------------------------\n                00| 00 01 02 03 04 05 06 07 08 09 10\n                01| 01 02 03 04 05 06 07 08 09 10 00\n                02| 02 03 04 05 06 07 08 09 10 00 01\n                03| 03 04 05 06 07 08 09 10 00 01 02\n                04| 04 05 06 07 08 09 10 00 01 02 03\n                05| 05 06 07 08 09 10 00 01 02 03 04\n                06| 06 07 08 09 10 00 01 02 03 04 05\n                07| 07 08 09 10 00 01 02 03 04 05 06\n                08| 08 09 10 00 01 02 03 04 05 06 07\n                09| 09 10 00 01 02 03 04 05 06 07 08\n                10| 10 00 01 02 03 04 05 06 07 08 09\n\n            ::\n\n                sage: G=QuaternionGroup()\n                sage: names=['1', 'I', 'J', '-1', '-K', 'K', '-I', '-J']\n                sage: G.cayley_table(names=names)\n                 *   1  I  J -1 -K  K -I -J\n                  +------------------------\n                 1|  1  I  J -1 -K  K -I -J\n                 I|  I -1  K -I  J -J  1 -K\n                 J|  J -K -1 -J -I  I  K  1\n                -1| -1 -I -J  1  K -K  I  J\n                -K| -K -J  I  K -1  1  J -I\n                 K|  K  J -I -K  1 -1 -J  I\n                -I| -I  1 -K  I -J  J -1  K\n                -J| -J  K  1  J  I -I -K -1\n\n            ::\n\n                sage: A=AbelianGroup([2,2])\n                sage: A.cayley_table(names='elements')\n                    *      1    f1    f0 f0*f1\n                     +------------------------\n                    1|     1    f1    f0 f0*f1\n                   f1|    f1     1 f0*f1    f0\n                   f0|    f0 f0*f1     1    f1\n                f0*f1| f0*f1    f0    f1     1\n\n            The :meth:`~sage.matrix.operation_table.OperationTable.change_names`\n            routine behaves similarly, but changes an existing table \"in-place.\"\n            ::\n\n                sage: G=AlternatingGroup(3)\n                sage: T=G.cayley_table()\n                sage: T.change_names('digits')\n                sage: T\n                *  0 1 2\n                 +------\n                0| 0 1 2\n                1| 1 2 0\n                2| 2 0 1\n\n            For an infinite group, you can still work with finite sets of\n            elements, provided the set is closed under multiplication.\n            Elements will be coerced into the group as part of setting\n            up the table.  ::\n\n                sage: G=SL(2,ZZ)\n                sage: G\n                Special Linear Group of degree 2 over Integer Ring\n                sage: identity = matrix(ZZ, [[1,0], [0,1]])\n                sage: G.cayley_table(elements=[identity, -identity])\n                *  a b\n                 +----\n                a| a b\n                b| b a\n\n            The\n            :class:`~sage.matrix.operation_table.OperationTable`\n            class provides even greater flexibility, including changing\n            the operation.  Here is one such example, illustrating the\n            computation of commutators.  ``commutator`` is defined as\n            a function of two variables, before being used to build\n            the table. From this, the commutator subgroup seems obvious,\n            and creating a Cayley table with just these three elements\n            confirms that they form a closed subset in the group.\n            ::\n\n                sage: from sage.matrix.operation_table import OperationTable\n                sage: G=DiCyclicGroup(3)\n                sage: commutator = lambda x, y: x*y*x^-1*y^-1\n                sage: T=OperationTable(G, commutator)\n                sage: T\n                .  a b c d e f g h i j k l\n                 +------------------------\n                a| a a a a a a a a a a a a\n                b| a a h d a d h h a h d d\n                c| a d a a a d d a d d d a\n                d| a h a a a h h a h h h a\n                e| a a a a a a a a a a a a\n                f| a h h d a a d h h d a d\n                g| a d h d a h a h d a h d\n                h| a d a a a d d a d d d a\n                i| a a h d a d h h a h d d\n                j| a d h d a h a h d a h d\n                k| a h h d a a d h h d a d\n                l| a h a a a h h a h h h a\n                sage: trans = T.translation()\n                sage: comm = [trans['a'], trans['d'],trans['h']]\n                sage: comm\n                [(), (5,7,6), (5,6,7)]\n                sage: P=G.cayley_table(elements=comm)\n                sage: P\n                *  a b c\n                 +------\n                a| a b c\n                b| b c a\n                c| c a b\n\n            TODO:\n\n            Arrange an ordering of elements into cosets of a normal\n            subgroup close to size `\\sqrt{n}`.  Then the quotient\n            group structure is often apparent in the table.  See\n            comments on Trac #7555.\n\n            AUTHOR:\n\n            - Rob Beezer (2010-03-15)\n\n            ",
                    "args": [
                        "self",
                        "names",
                        "elements"
                    ],
                    "argspec": [
                        [
                            "self",
                            "names",
                            "elements"
                        ],
                        null,
                        null,
                        [
                            "letters",
                            null
                        ]
                    ]
                },
                "conjugacy_class": {
                    "__doc__": "\n            Return the conjugacy class of the element ``g``.\n\n            This is a fall-back method for groups not defined over GAP.\n\n            EXAMPLES::\n\n                sage: A = AbelianGroup([2,2])\n                sage: c = A.conjugacy_class(A.an_element())\n                sage: type(c)\n                <class 'sage.groups.conjugacy_classes.ConjugacyClass_with_category'>\n            ",
                    "args": [
                        "self",
                        "g"
                    ],
                    "argspec": [
                        [
                            "self",
                            "g"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "group_generators": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method group_generators at 0x7fe375ebb2a8>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "list_of_self",
                    "gap_name": "GeneratorsOfGroup",
                    "mmt_name": null
                },
                "holomorph": {
                    "__doc__": "\n            The holomorph of a group\n\n            The holomorph of a group `G` is the semidirect product\n            `G \\rtimes_{id} Aut(G)`, where `id` is the identity function\n            on `Aut(G)`, the automorphism group of `G`.\n\n            See :wikipedia:`Holomorph (mathematics)`\n\n            EXAMPLES::\n\n                sage: G = Groups().example()\n                sage: G.holomorph()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: holomorph of General Linear Group of degree 4 over Rational Field not yet implemented\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_abelian": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method is_abelian at 0x7fe452debc80>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "sage",
                    "gap_name": "IsAbelian",
                    "mmt_name": null
                },
                "semidirect_product": {
                    "__doc__": "\n            The semi-direct product of two groups\n\n            EXAMPLES::\n\n                sage: G = Groups().example()\n                sage: G.semidirect_product(G,Morphism(G,G))\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: semidirect product of General Linear Group of degree 4 over Rational Field and General Linear Group of degree 4 over Rational Field not yet implemented\n            ",
                    "args": [
                        "self",
                        "N",
                        "mapping",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "N",
                            "mapping",
                            "check"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "conjugacy_class": {
                    "__doc__": "\n            Return the conjugacy class of ``self``.\n\n            EXAMPLES::\n\n                sage: D = DihedralGroup(5)\n                sage: g = D((1,3,5,2,4))\n                sage: g.conjugacy_class()\n                Conjugacy class of (1,3,5,2,4) in Dihedral group of order 10 as a permutation group\n\n                sage: H = MatrixGroup([matrix(GF(5),2,[1,2, -1, 1]), matrix(GF(5),2, [1,1, 0,1])])\n                sage: h = H(matrix(GF(5),2,[1,2, -1, 1]))\n                sage: h.conjugacy_class()\n                Conjugacy class of [1 2]\n                [4 1] in Matrix group over Finite Field of size 5 with 2 generators (\n                [1 2]  [1 1]\n                [4 1], [0 1]\n                )\n\n                sage: G = SL(2, GF(2))\n                sage: g = G.gens()[0]\n                sage: g.conjugacy_class()\n                Conjugacy class of [1 1]\n                [0 1] in Special Linear Group of degree 2 over Finite Field of size 2\n\n                sage: G = SL(2, QQ)\n                sage: g = G([[1,1],[0,1]])\n                sage: g.conjugacy_class()\n                Conjugacy class of [1 1]\n                [0 1] in Special Linear Group of degree 2 over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all elements of a given parent.\n\n    EXAMPLES::\n\n        sage: a = IntegerRing()(5)\n        sage: C = a.category(); C\n        Category of elements of Integer Ring\n        sage: a in C\n        True\n        sage: 2/3 in C\n        False\n        sage: loads(C.dumps()) == C\n        True\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of all elements of a given parent.\n\n    EXAMPLES::\n\n        sage: a = IntegerRing()(5)\n        sage: C = a.category(); C\n        Category of elements of Integer Ring\n        sage: a in C\n        True\n        sage: 2/3 in C\n        False\n        sage: loads(C.dumps()) == C\n        True\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.objects.Objects"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of all elements of a given parent.\n\n    EXAMPLES::\n\n        sage: a = IntegerRing()(5)\n        sage: C = a.category(); C\n        Category of elements of Integer Ring\n        sage: a in C\n        True\n        sage: 2/3 in C\n        False\n        sage: loads(C.dumps()) == C\n        True\n    ",
            "methods": {}
        },
        "name": "sage.categories.category_types.Elements",
        "parent_class": {
            "__doc__": "\n    The category of all elements of a given parent.\n\n    EXAMPLES::\n\n        sage: a = IntegerRing()(5)\n        sage: C = a.category(); C\n        Category of elements of Integer Ring\n        sage: a in C\n        True\n        sage: 2/3 in C\n        False\n        sage: loads(C.dumps()) == C\n        True\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.category_types.Elements"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of all elements of a given parent.\n\n    EXAMPLES::\n\n        sage: a = IntegerRing()(5)\n        sage: C = a.category(); C\n        Category of elements of Integer Ring\n        sage: a in C\n        True\n        sage: 2/3 in C\n        False\n        sage: loads(C.dumps()) == C\n        True\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of $G$-sets, for a group $G$.\n\n    EXAMPLES::\n\n        sage: S = SymmetricGroup(3)\n        sage: GSets(S)\n        Category of G-sets for Symmetric group of order 3! as a permutation group\n\n    TODO: should this derive from Category_over_base?\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of $G$-sets, for a group $G$.\n\n    EXAMPLES::\n\n        sage: S = SymmetricGroup(3)\n        sage: GSets(S)\n        Category of G-sets for Symmetric group of order 3! as a permutation group\n\n    TODO: should this derive from Category_over_base?\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of $G$-sets, for a group $G$.\n\n    EXAMPLES::\n\n        sage: S = SymmetricGroup(3)\n        sage: GSets(S)\n        Category of G-sets for Symmetric group of order 3! as a permutation group\n\n    TODO: should this derive from Category_over_base?\n    ",
            "methods": {}
        },
        "name": "sage.categories.g_sets.GSets",
        "parent_class": {
            "__doc__": "\n    The category of $G$-sets, for a group $G$.\n\n    EXAMPLES::\n\n        sage: S = SymmetricGroup(3)\n        sage: GSets(S)\n        Category of G-sets for Symmetric group of order 3! as a permutation group\n\n    TODO: should this derive from Category_over_base?\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.g_sets.GSets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of $G$-sets, for a group $G$.\n\n    EXAMPLES::\n\n        sage: S = SymmetricGroup(3)\n        sage: GSets(S)\n        Category of G-sets for Symmetric group of order 3! as a permutation group\n\n    TODO: should this derive from Category_over_base?\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of abelian groups, i.e. additive abelian monoids\n    where each element has an inverse.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveGroups(); C\n        Category of commutative additive groups\n        sage: C.super_categories()\n        [Category of additive groups, Category of commutative additive monoids]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n        sage: C is CommutativeAdditiveMonoids().AdditiveInverse()\n        True\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: C is AdditiveGroups().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty. It's left there for backward\n        compatibility and because it is likely to grow in the future.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveGroups()).run()\n        sage: sorted(CommutativeAdditiveGroups().CartesianProducts().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n\n    The empty covariant functorial construction category classes\n    ``CartesianProducts`` and ``Algebras`` are left here for the sake\n    of nicer output since this is a commonly used category::\n\n        sage: CommutativeAdditiveGroups().CartesianProducts()\n        Category of Cartesian products of commutative additive groups\n        sage: CommutativeAdditiveGroups().Algebras(QQ)\n        Category of commutative additive group algebras over Rational Field\n\n    Also, it's likely that some code will end up there at some point.\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of abelian groups, i.e. additive abelian monoids\n    where each element has an inverse.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveGroups(); C\n        Category of commutative additive groups\n        sage: C.super_categories()\n        [Category of additive groups, Category of commutative additive monoids]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n        sage: C is CommutativeAdditiveMonoids().AdditiveInverse()\n        True\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: C is AdditiveGroups().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty. It's left there for backward\n        compatibility and because it is likely to grow in the future.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveGroups()).run()\n        sage: sorted(CommutativeAdditiveGroups().CartesianProducts().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n\n    The empty covariant functorial construction category classes\n    ``CartesianProducts`` and ``Algebras`` are left here for the sake\n    of nicer output since this is a commonly used category::\n\n        sage: CommutativeAdditiveGroups().CartesianProducts()\n        Category of Cartesian products of commutative additive groups\n        sage: CommutativeAdditiveGroups().Algebras(QQ)\n        Category of commutative additive group algebras over Rational Field\n\n    Also, it's likely that some code will end up there at some point.\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_groups.AdditiveGroups",
            "sage.categories.commutative_additive_monoids.CommutativeAdditiveMonoids"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of abelian groups, i.e. additive abelian monoids\n    where each element has an inverse.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveGroups(); C\n        Category of commutative additive groups\n        sage: C.super_categories()\n        [Category of additive groups, Category of commutative additive monoids]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n        sage: C is CommutativeAdditiveMonoids().AdditiveInverse()\n        True\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: C is AdditiveGroups().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty. It's left there for backward\n        compatibility and because it is likely to grow in the future.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveGroups()).run()\n        sage: sorted(CommutativeAdditiveGroups().CartesianProducts().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n\n    The empty covariant functorial construction category classes\n    ``CartesianProducts`` and ``Algebras`` are left here for the sake\n    of nicer output since this is a commonly used category::\n\n        sage: CommutativeAdditiveGroups().CartesianProducts()\n        Category of Cartesian products of commutative additive groups\n        sage: CommutativeAdditiveGroups().Algebras(QQ)\n        Category of commutative additive group algebras over Rational Field\n\n    Also, it's likely that some code will end up there at some point.\n    ",
            "methods": {}
        },
        "name": "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups",
        "parent_class": {
            "__doc__": "\n    The category of abelian groups, i.e. additive abelian monoids\n    where each element has an inverse.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveGroups(); C\n        Category of commutative additive groups\n        sage: C.super_categories()\n        [Category of additive groups, Category of commutative additive monoids]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n        sage: C is CommutativeAdditiveMonoids().AdditiveInverse()\n        True\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: C is AdditiveGroups().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty. It's left there for backward\n        compatibility and because it is likely to grow in the future.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveGroups()).run()\n        sage: sorted(CommutativeAdditiveGroups().CartesianProducts().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n\n    The empty covariant functorial construction category classes\n    ``CartesianProducts`` and ``Algebras`` are left here for the sake\n    of nicer output since this is a commonly used category::\n\n        sage: CommutativeAdditiveGroups().CartesianProducts()\n        Category of Cartesian products of commutative additive groups\n        sage: CommutativeAdditiveGroups().Algebras(QQ)\n        Category of commutative additive group algebras over Rational Field\n\n    Also, it's likely that some code will end up there at some point.\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of abelian groups, i.e. additive abelian monoids\n    where each element has an inverse.\n\n    EXAMPLES::\n\n        sage: C = CommutativeAdditiveGroups(); C\n        Category of commutative additive groups\n        sage: C.super_categories()\n        [Category of additive groups, Category of commutative additive monoids]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n        sage: C is CommutativeAdditiveMonoids().AdditiveInverse()\n        True\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: C is AdditiveGroups().AdditiveCommutative()\n        True\n\n    .. NOTE::\n\n        This category is currently empty. It's left there for backward\n        compatibility and because it is likely to grow in the future.\n\n    TESTS::\n\n        sage: TestSuite(CommutativeAdditiveGroups()).run()\n        sage: sorted(CommutativeAdditiveGroups().CartesianProducts().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital']\n\n    The empty covariant functorial construction category classes\n    ``CartesianProducts`` and ``Algebras`` are left here for the sake\n    of nicer output since this is a commonly used category::\n\n        sage: CommutativeAdditiveGroups().CartesianProducts()\n        Category of Cartesian products of commutative additive groups\n        sage: CommutativeAdditiveGroups().Algebras(QQ)\n        Category of commutative additive group algebras over Rational Field\n\n    Also, it's likely that some code will end up there at some point.\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (constructive) principal ideal domains\n\n    By constructive, we mean that a single generator can be\n    constructively found for any ideal given by a finite set of\n    generators. Note that this constructive definition only implies\n    that finitely generated ideals are principal. It is not clear what\n    we would mean by an infinitely generated ideal.\n\n    EXAMPLES::\n\n      sage: PrincipalIdealDomains()\n      Category of principal ideal domains\n      sage: PrincipalIdealDomains().super_categories()\n      [Category of unique factorization domains]\n\n    See also: http://en.wikipedia.org/wiki/Principal_ideal_domain\n\n    TESTS::\n\n        sage: TestSuite(PrincipalIdealDomains()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.unique_factorization_domains.UniqueFactorizationDomains"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of (constructive) principal ideal domains\n\n    By constructive, we mean that a single generator can be\n    constructively found for any ideal given by a finite set of\n    generators. Note that this constructive definition only implies\n    that finitely generated ideals are principal. It is not clear what\n    we would mean by an infinitely generated ideal.\n\n    EXAMPLES::\n\n      sage: PrincipalIdealDomains()\n      Category of principal ideal domains\n      sage: PrincipalIdealDomains().super_categories()\n      [Category of unique factorization domains]\n\n    See also: http://en.wikipedia.org/wiki/Principal_ideal_domain\n\n    TESTS::\n\n        sage: TestSuite(PrincipalIdealDomains()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.principal_ideal_domains.PrincipalIdealDomains",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_gcd_vs_xgcd": {
                    "__doc__": "\n            Check that gcd and xgcd are compatible if implemented.\n\n            This test will prevent things like :trac:`17671` to happen again.\n\n            TESTS::\n\n                sage: ZZ._test_gcd_vs_xgcd()\n                sage: QQ._test_gcd_vs_xgcd()\n                sage: QQ['x']._test_gcd_vs_xgcd()\n                sage: QQbar['x']._test_gcd_vs_xgcd()\n                sage: RR._test_gcd_vs_xgcd()\n                sage: RR['x']._test_gcd_vs_xgcd()\n\n            A slightly more involved example of polynomial ring with a non UFD\n            base ring::\n\n                sage: K = QuadraticField(5)\n                sage: O = K.maximal_order()\n                sage: O in UniqueFactorizationDomains()\n                False\n                sage: R = PolynomialRing(O, 'x')\n                sage: F = R.fraction_field()\n                sage: F in PrincipalIdealDomains()\n                True\n                sage: F._test_gcd_vs_xgcd()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of unique factorization domains\n    constructive unique factorization domains, i.e. where one can constructively\n    factor members into a product of a finite number of irreducible elements\n\n    EXAMPLES::\n\n        sage: UniqueFactorizationDomains()\n        Category of unique factorization domains\n        sage: UniqueFactorizationDomains().super_categories()\n        [Category of gcd domains]\n\n    TESTS::\n\n        sage: TestSuite(UniqueFactorizationDomains()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.gcd_domains.GcdDomains"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of unique factorization domains\n    constructive unique factorization domains, i.e. where one can constructively\n    factor members into a product of a finite number of irreducible elements\n\n    EXAMPLES::\n\n        sage: UniqueFactorizationDomains()\n        Category of unique factorization domains\n        sage: UniqueFactorizationDomains().super_categories()\n        [Category of gcd domains]\n\n    TESTS::\n\n        sage: TestSuite(UniqueFactorizationDomains()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.unique_factorization_domains.UniqueFactorizationDomains",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_gcd_univariate_polynomial": {
                    "__doc__": "\n            Return the greatest common divisor of ``f`` and ``g``.\n\n            INPUT:\n\n            - ``f``, ``g`` -- two polynomials defined over this UFD.\n\n            .. NOTE::\n\n                This is a helper method for\n                :meth:`sage.rings.polynomial.polynomial_element.Polynomial.gcd`.\n\n            ALGORITHM:\n\n            Algorithm 3.3.1 in [GTM138]_, based on pseudo-division.\n\n            EXAMPLES::\n\n                sage: R.<x> = PolynomialRing(ZZ, sparse=True)\n                sage: S.<T> = R[]\n                sage: p = (-3*x^2 - x)*T^3 - 3*x*T^2 + (x^2 - x)*T + 2*x^2 + 3*x - 2\n                sage: q = (-x^2 - 4*x - 5)*T^2 + (6*x^2 + x + 1)*T + 2*x^2 - x\n                sage: quo,rem=p.pseudo_quo_rem(q); quo,rem\n                ((3*x^4 + 13*x^3 + 19*x^2 + 5*x)*T + 18*x^4 + 12*x^3 + 16*x^2 + 16*x,\n                 (-113*x^6 - 106*x^5 - 133*x^4 - 101*x^3 - 42*x^2 - 41*x)*T - 34*x^6 + 13*x^5 + 54*x^4 + 126*x^3 + 134*x^2 - 5*x - 50)\n                sage: (-x^2 - 4*x - 5)^(3-2+1) * p == quo*q + rem\n                True\n\n            REFERENCES:\n\n            .. [GTM138] Henri Cohen. A Course in Computational Number Theory.\n               Graduate Texts in Mathematics, vol. 138. Springer, 1993.\n            ",
                    "args": [
                        "self",
                        "f",
                        "g"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "g"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_unique_factorization_domain": {
                    "__doc__": "\n            Return True, since this in an object of the category of unique factorization domains.\n\n            EXAMPLES::\n\n                sage: Parent(QQ,category=UniqueFactorizationDomains()).is_unique_factorization_domain()\n                True\n\n            ",
                    "args": [
                        "self",
                        "proof"
                    ],
                    "argspec": [
                        [
                            "self",
                            "proof"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of discrete valuation rings\n\n    EXAMPLES::\n\n        sage: GF(7)[['x']] in DiscreteValuationRings()\n        True\n        sage: TestSuite(DiscreteValuationRings()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "lcm": {
                    "__doc__": "\n            Return the least common multiple of self and other,\n            normalized so that it is a power of the distinguished\n            uniformizer.\n            ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "valuation": {
                    "__doc__": "\n            Return the valuation of this element.\n\n            EXAMPLES::\n\n                sage: x = Zp(5)(50)\n                sage: x.valuation()\n                2\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.euclidean_domains.EuclideanDomains"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of discrete valuation rings\n\n    EXAMPLES::\n\n        sage: GF(7)[['x']] in DiscreteValuationRings()\n        True\n        sage: TestSuite(DiscreteValuationRings()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.discrete_valuation.DiscreteValuationRings",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "residue_field": {
                    "__doc__": "\n            Return the residue field of this ring.\n\n            EXAMPLES::\n\n                sage: Zp(5).residue_field()\n                Finite Field of size 5\n\n                sage: K.<u> = QQ[[]]\n                sage: K.residue_field()\n                Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "uniformizer": {
                    "__doc__": "\n            Return a uniformizer of this ring.\n\n            EXAMPLES::\n\n                sage: Zp(5).uniformizer()\n                5 + O(5^21)\n\n                sage: K.<u> = QQ[[]]\n                sage: K.uniformizer()\n                u\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.discrete_valuation.DiscreteValuationRings",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "lcm": {
                    "__doc__": "\n            Return the least common multiple of self and other,\n            normalized so that it is a power of the distinguished\n            uniformizer.\n            ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "valuation": {
                    "__doc__": "\n            Return the valuation of this element.\n\n            EXAMPLES::\n\n                sage: x = Zp(5)(50)\n                sage: x.valuation()\n                2\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of rngs.\n\n    An *rng* `(S, +, *)` is similar to a ring but not necessarilly\n    unital. In other words, it is a combination of a commutative\n    additive group `(S, +)` and a multiplicative semigroup `(S, *)`,\n    where `*` distributes over `+`.\n\n    EXAMPLES::\n\n        sage: C = Rngs(); C\n        Category of rngs\n        sage: sorted(C.super_categories(), key=str)\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of commutative additive groups]\n\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse',\n         'AdditiveUnital', 'Associative', 'Distributive']\n\n        sage: C is (CommutativeAdditiveGroups() & Semigroups()).Distributive()\n        True\n        sage: C.Unital()\n        Category of rings\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of rngs.\n\n    An *rng* `(S, +, *)` is similar to a ring but not necessarilly\n    unital. In other words, it is a combination of a commutative\n    additive group `(S, +)` and a multiplicative semigroup `(S, *)`,\n    where `*` distributes over `+`.\n\n    EXAMPLES::\n\n        sage: C = Rngs(); C\n        Category of rngs\n        sage: sorted(C.super_categories(), key=str)\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of commutative additive groups]\n\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse',\n         'AdditiveUnital', 'Associative', 'Distributive']\n\n        sage: C is (CommutativeAdditiveGroups() & Semigroups()).Distributive()\n        True\n        sage: C.Unital()\n        Category of rings\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital.Associative",
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of rngs.\n\n    An *rng* `(S, +, *)` is similar to a ring but not necessarilly\n    unital. In other words, it is a combination of a commutative\n    additive group `(S, +)` and a multiplicative semigroup `(S, *)`,\n    where `*` distributes over `+`.\n\n    EXAMPLES::\n\n        sage: C = Rngs(); C\n        Category of rngs\n        sage: sorted(C.super_categories(), key=str)\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of commutative additive groups]\n\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse',\n         'AdditiveUnital', 'Associative', 'Distributive']\n\n        sage: C is (CommutativeAdditiveGroups() & Semigroups()).Distributive()\n        True\n        sage: C.Unital()\n        Category of rings\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.rngs.Rngs",
        "parent_class": {
            "__doc__": "\n    The category of rngs.\n\n    An *rng* `(S, +, *)` is similar to a ring but not necessarilly\n    unital. In other words, it is a combination of a commutative\n    additive group `(S, +)` and a multiplicative semigroup `(S, *)`,\n    where `*` distributes over `+`.\n\n    EXAMPLES::\n\n        sage: C = Rngs(); C\n        Category of rngs\n        sage: sorted(C.super_categories(), key=str)\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of commutative additive groups]\n\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse',\n         'AdditiveUnital', 'Associative', 'Distributive']\n\n        sage: C is (CommutativeAdditiveGroups() & Semigroups()).Distributive()\n        True\n        sage: C.Unital()\n        Category of rings\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of rngs.\n\n    An *rng* `(S, +, *)` is similar to a ring but not necessarilly\n    unital. In other words, it is a combination of a commutative\n    additive group `(S, +)` and a multiplicative semigroup `(S, *)`,\n    where `*` distributes over `+`.\n\n    EXAMPLES::\n\n        sage: C = Rngs(); C\n        Category of rngs\n        sage: sorted(C.super_categories(), key=str)\n        [Category of associative additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of commutative additive groups]\n\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse',\n         'AdditiveUnital', 'Associative', 'Distributive']\n\n        sage: C is (CommutativeAdditiveGroups() & Semigroups()).Distributive()\n        True\n        sage: C.Unital()\n        Category of rings\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite crystals.\n\n    EXAMPLES::\n\n        sage: C = FiniteCrystals()\n        sage: C\n        Category of finite crystals\n        sage: C.super_categories()\n        [Category of crystals, Category of finite enumerated sets]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = FiniteCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": "\n    The category of finite crystals.\n\n    EXAMPLES::\n\n        sage: C = FiniteCrystals()\n        sage: C\n        Category of finite crystals\n        sage: C.super_categories()\n        [Category of crystals, Category of finite enumerated sets]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = FiniteCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.crystals.Crystals",
            "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite crystals.\n\n    EXAMPLES::\n\n        sage: C = FiniteCrystals()\n        sage: C\n        Category of finite crystals\n        sage: C.super_categories()\n        [Category of crystals, Category of finite enumerated sets]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = FiniteCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_crystals.FiniteCrystals",
        "parent_class": {
            "__doc__": "\n    The category of finite crystals.\n\n    EXAMPLES::\n\n        sage: C = FiniteCrystals()\n        sage: C\n        Category of finite crystals\n        sage: C.super_categories()\n        [Category of crystals, Category of finite enumerated sets]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = FiniteCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.crystals.Crystals",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of finite crystals.\n\n    EXAMPLES::\n\n        sage: C = FiniteCrystals()\n        sage: C\n        Category of finite crystals\n        sage: C.super_categories()\n        [Category of crystals, Category of finite enumerated sets]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = FiniteCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of gcd domains\n    domains where gcd can be computed but where there is no guarantee of\n    factorisation into irreducibles\n\n    EXAMPLES::\n\n        sage: GcdDomains()\n        Category of gcd domains\n        sage: GcdDomains().super_categories()\n        [Category of integral domains]\n\n    TESTS::\n\n        sage: TestSuite(GcdDomains()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.integral_domains.IntegralDomains"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of gcd domains\n    domains where gcd can be computed but where there is no guarantee of\n    factorisation into irreducibles\n\n    EXAMPLES::\n\n        sage: GcdDomains()\n        Category of gcd domains\n        sage: GcdDomains().super_categories()\n        [Category of integral domains]\n\n    TESTS::\n\n        sage: TestSuite(GcdDomains()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.gcd_domains.GcdDomains",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all objects\n    the basic category\n\n    EXAMPLES::\n\n        sage: Objects()\n        Category of objects\n        sage: Objects().super_categories()\n        []\n\n    TESTS::\n\n        sage: TestSuite(Objects()).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of all objects\n    the basic category\n\n    EXAMPLES::\n\n        sage: Objects()\n        Category of objects\n        sage: Objects().super_categories()\n        []\n\n    TESTS::\n\n        sage: TestSuite(Objects()).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of all objects\n    the basic category\n\n    EXAMPLES::\n\n        sage: Objects()\n        Category of objects\n        sage: Objects().super_categories()\n        []\n\n    TESTS::\n\n        sage: TestSuite(Objects()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.objects.Objects",
        "parent_class": {
            "__doc__": "\n        Methods for all category objects\n        ",
            "methods": {}
        },
        "structure": [],
        "subcategory_class": {
            "__doc__": "\n    The category of all objects\n    the basic category\n\n    EXAMPLES::\n\n        sage: Objects()\n        Category of objects\n        sage: Objects().super_categories()\n        []\n\n    TESTS::\n\n        sage: TestSuite(Objects()).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite lattices, i.e. finite partially ordered\n    sets which are also lattices.\n\n    EXAMPLES::\n\n        sage: FiniteLatticePosets()\n        Category of finite lattice posets\n        sage: FiniteLatticePosets().super_categories()\n        [Category of lattice posets, Category of finite posets]\n        sage: FiniteLatticePosets().example()\n        NotImplemented\n\n    .. SEEALSO::\n\n        :class:`FinitePosets`, :class:`LatticePosets`, :class:`LatticePoset`\n\n    TESTS::\n\n        sage: C = FiniteLatticePosets()\n        sage: C is FiniteLatticePosets().Finite()\n        True\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": "\n    The category of finite lattices, i.e. finite partially ordered\n    sets which are also lattices.\n\n    EXAMPLES::\n\n        sage: FiniteLatticePosets()\n        Category of finite lattice posets\n        sage: FiniteLatticePosets().super_categories()\n        [Category of lattice posets, Category of finite posets]\n        sage: FiniteLatticePosets().example()\n        NotImplemented\n\n    .. SEEALSO::\n\n        :class:`FinitePosets`, :class:`LatticePosets`, :class:`LatticePoset`\n\n    TESTS::\n\n        sage: C = FiniteLatticePosets()\n        sage: C is FiniteLatticePosets().Finite()\n        True\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.lattice_posets.LatticePosets",
            "sage.categories.finite_posets.FinitePosets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite lattices, i.e. finite partially ordered\n    sets which are also lattices.\n\n    EXAMPLES::\n\n        sage: FiniteLatticePosets()\n        Category of finite lattice posets\n        sage: FiniteLatticePosets().super_categories()\n        [Category of lattice posets, Category of finite posets]\n        sage: FiniteLatticePosets().example()\n        NotImplemented\n\n    .. SEEALSO::\n\n        :class:`FinitePosets`, :class:`LatticePosets`, :class:`LatticePoset`\n\n    TESTS::\n\n        sage: C = FiniteLatticePosets()\n        sage: C is FiniteLatticePosets().Finite()\n        True\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_lattice_posets.FiniteLatticePosets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "is_lattice_morphism": {
                    "__doc__": "\n            Return whether ``f`` is a morphism of posets from ``self``\n            to ``codomain``.\n\n            A map `f : P \\to Q` is a poset morphism if\n\n            .. MATH::\n\n                x \\leq y \\Rightarrow f(x) \\leq f(y)\n\n            for all `x,y \\in P`.\n\n            INPUT:\n\n            - ``f`` -- a function from ``self`` to ``codomain``\n            - ``codomain`` -- a lattice\n\n            EXAMPLES:\n\n            We build the boolean lattice of `\\{2,2,3\\}` and the\n            lattice of divisors of `60`, and check that the map\n            `b \\mapsto 5 \\prod_{x\\in b} x` is a morphism of lattices::\n\n                sage: D = LatticePoset((divisors(60), attrcall(\"divides\")))\n                sage: B = LatticePoset((Subsets([2,2,3]), attrcall(\"issubset\")))\n                sage: def f(b): return D(5*prod(b))\n                sage: B.is_lattice_morphism(f, D)\n                True\n\n            We construct the boolean lattice `B_2`::\n\n                sage: B = Posets.BooleanLattice(2)\n                sage: B.cover_relations()\n                [[0, 1], [0, 2], [1, 3], [2, 3]]\n\n            And the same lattice with new top and bottom elements\n            numbered respectively `-1` and `3`::\n\n                sage: L = LatticePoset(DiGraph({-1:[0], 0:[1,2], 1:[3], 2:[3],3:[4]}))\n                sage: L.cover_relations()\n                [[-1, 0], [0, 1], [0, 2], [1, 3], [2, 3], [3, 4]]\n\n                sage: f = { B(0): L(0), B(1): L(1), B(2): L(2), B(3): L(3) }.__getitem__\n                sage: B.is_lattice_morphism(f, L)\n                True\n\n                sage: f = { B(0): L(-1),B(1): L(1), B(2): L(2), B(3): L(3) }.__getitem__\n                sage: B.is_lattice_morphism(f, L)\n                False\n\n                sage: f = { B(0): L(0), B(1): L(1), B(2): L(2), B(3): L(4) }.__getitem__\n                sage: B.is_lattice_morphism(f, L)\n                False\n\n            .. SEEALSO::\n\n                :meth:`~sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_morphism`\n            ",
                    "args": [
                        "self",
                        "f",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "codomain"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "join_irreducibles": {
                    "__doc__": "\n            Return the join-irreducible elements of this finite lattice.\n\n            A *join-irreducible element* of ``self`` is an element\n            `x` that is not minimal and that can not be written as\n            the join of two elements different from `x`.\n\n            EXAMPLES::\n\n                sage: L = LatticePoset({0:[1,2],1:[3],2:[3,4],3:[5],4:[5]})\n                sage: L.join_irreducibles()\n                [1, 2, 4]\n\n            .. SEEALSO::\n\n                :meth:`meet_irreducibles`,\n                :meth:`~sage.combinat.posets.lattices.FiniteLatticePoset.double_irreducibles`,\n                :meth:`meet_irreducibles_poset`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "join_irreducibles_poset": {
                    "__doc__": "\n            Return the poset of join-irreducible elements of this finite lattice.\n\n            A *join-irreducible element* of ``self`` is an element `x`\n            that is not minimal and can not be written as the join of two\n            elements different from `x`.\n\n            EXAMPLES::\n\n                sage: L = LatticePoset({0:[1,2,3],1:[4],2:[4],3:[4]})\n                sage: L.join_irreducibles_poset()\n                Finite poset containing 3 elements\n\n            .. SEEALSO:: :meth:`join_irreducibles`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "meet_irreducibles": {
                    "__doc__": "\n            Return the meet-irreducible elements of this finite lattice.\n\n            A *meet-irreducible element* of ``self`` is an element\n            `x` that is not maximal and that can not be written as\n            the meet of two elements different from `x`.\n\n            EXAMPLES::\n\n                sage: L = LatticePoset({0:[1,2],1:[3],2:[3,4],3:[5],4:[5]})\n                sage: L.meet_irreducibles()\n                [1, 3, 4]\n\n            .. SEEALSO::\n\n                :meth:`join_irreducibles`,\n                :meth:`~sage.combinat.posets.lattices.FiniteLatticePoset.double_irreducibles`,\n                :meth:`meet_irreducibles_poset`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "meet_irreducibles_poset": {
                    "__doc__": "\n            Return the poset of join-irreducible elements of this finite lattice.\n\n            A *meet-irreducible element* of ``self`` is an element `x`\n            that is not maximal and can not be written as the meet of two\n            elements different from `x`.\n\n            EXAMPLES::\n\n                sage: L = LatticePoset({0:[1,2,3],1:[4],2:[4],3:[4]})\n                sage: L.join_irreducibles_poset()\n                Finite poset containing 3 elements\n\n            .. SEEALSO:: :meth:`meet_irreducibles`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.lattice_posets.LatticePosets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.posets.Posets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of finite lattices, i.e. finite partially ordered\n    sets which are also lattices.\n\n    EXAMPLES::\n\n        sage: FiniteLatticePosets()\n        Category of finite lattice posets\n        sage: FiniteLatticePosets().super_categories()\n        [Category of lattice posets, Category of finite posets]\n        sage: FiniteLatticePosets().example()\n        NotImplemented\n\n    .. SEEALSO::\n\n        :class:`FinitePosets`, :class:`LatticePosets`, :class:`LatticePoset`\n\n    TESTS::\n\n        sage: C = FiniteLatticePosets()\n        sage: C is FiniteLatticePosets().Finite()\n        True\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of ideals in a fixed commutative ring.\n\n    EXAMPLES::\n\n        sage: C = CommutativeRingIdeals(IntegerRing())\n        sage: C\n        Category of commutative ring ideals in Integer Ring\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of ideals in a fixed commutative ring.\n\n    EXAMPLES::\n\n        sage: C = CommutativeRingIdeals(IntegerRing())\n        sage: C\n        Category of commutative ring ideals in Integer Ring\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.ring_ideals.RingIdeals"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of ideals in a fixed commutative ring.\n\n    EXAMPLES::\n\n        sage: C = CommutativeRingIdeals(IntegerRing())\n        sage: C\n        Category of commutative ring ideals in Integer Ring\n    ",
            "methods": {}
        },
        "name": "sage.categories.commutative_ring_ideals.CommutativeRingIdeals",
        "parent_class": {
            "__doc__": "\n    The category of ideals in a fixed commutative ring.\n\n    EXAMPLES::\n\n        sage: C = CommutativeRingIdeals(IntegerRing())\n        sage: C\n        Category of commutative ring ideals in Integer Ring\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.ring_ideals.RingIdeals",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.commutative_ring_ideals.CommutativeRingIdeals",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of ideals in a fixed commutative ring.\n\n    EXAMPLES::\n\n        sage: C = CommutativeRingIdeals(IntegerRing())\n        sage: C\n        Category of commutative ring ideals in Integer Ring\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (abstract) vector spaces over a given field\n\n    ??? with an embedding in an ambient vector space ???\n\n    EXAMPLES::\n\n        sage: VectorSpaces(QQ)\n        Category of vector spaces over Rational Field\n        sage: VectorSpaces(QQ).super_categories()\n        [Category of modules over Rational Field]\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of (abstract) vector spaces over a given field\n\n    ??? with an embedding in an ambient vector space ???\n\n    EXAMPLES::\n\n        sage: VectorSpaces(QQ)\n        Category of vector spaces over Rational Field\n        sage: VectorSpaces(QQ).super_categories()\n        [Category of modules over Rational Field]\n    ",
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of Hopf algebras with a distinguished basis\n\n    EXAMPLES::\n\n        sage: C = HopfAlgebrasWithBasis(QQ)\n        sage: C\n        Category of hopf algebras with basis over Rational Field\n        sage: C.super_categories()\n        [Category of hopf algebras over Rational Field,\n         Category of bialgebras with basis over Rational Field]\n\n    We now show how to use a simple Hopf algebra, namely the group algebra of the dihedral group\n    (see also AlgebrasWithBasis)::\n\n        sage: A = C.example(); A\n        An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n        sage: A.__custom_name = \"A\"\n        sage: A.category()\n        Category of finite dimensional hopf algebras with basis over Rational Field\n\n        sage: A.one_basis()\n        ()\n        sage: A.one()\n        B[()]\n\n        sage: A.base_ring()\n        Rational Field\n        sage: A.basis().keys()\n        Dihedral group of order 6 as a permutation group\n\n        sage: [a,b] = A.algebra_generators()\n        sage: a, b\n        (B[(1,2,3)], B[(1,3)])\n        sage: a^3, b^2\n        (B[()], B[()])\n        sage: a*b\n        B[(1,2)]\n\n        sage: A.product           # todo: not quite ...\n        <bound method MyGroupAlgebra_with_category._product_from_product_on_basis_multiply of A>\n        sage: A.product(b,b)\n        B[()]\n\n        sage: A.zero().coproduct()\n        0\n        sage: A.zero().coproduct().parent()\n        A # A\n        sage: a.coproduct()\n        B[(1,2,3)] # B[(1,2,3)]\n\n        sage: TestSuite(A).run(verbose=True)\n        running ._test_additive_associativity() . . . pass\n        running ._test_an_element() . . . pass\n        running ._test_antipode() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_characteristic() . . . pass\n        running ._test_distributivity() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_nonzero_equal() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_zero() . . . pass\n        sage: A.__class__\n        <class 'sage.categories.examples.hopf_algebras_with_basis.MyGroupAlgebra_with_category'>\n        sage: A.element_class\n        <class 'sage.combinat.free_module.MyGroupAlgebra_with_category.element_class'>\n\n    Let us look at the code for implementing A::\n\n        sage: A??                       # todo: not implemented\n\n    TESTS::\n\n        sage: TestSuite(A).run()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.bialgebras_with_basis.BialgebrasWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of Hopf algebras with a distinguished basis\n\n    EXAMPLES::\n\n        sage: C = HopfAlgebrasWithBasis(QQ)\n        sage: C\n        Category of hopf algebras with basis over Rational Field\n        sage: C.super_categories()\n        [Category of hopf algebras over Rational Field,\n         Category of bialgebras with basis over Rational Field]\n\n    We now show how to use a simple Hopf algebra, namely the group algebra of the dihedral group\n    (see also AlgebrasWithBasis)::\n\n        sage: A = C.example(); A\n        An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n        sage: A.__custom_name = \"A\"\n        sage: A.category()\n        Category of finite dimensional hopf algebras with basis over Rational Field\n\n        sage: A.one_basis()\n        ()\n        sage: A.one()\n        B[()]\n\n        sage: A.base_ring()\n        Rational Field\n        sage: A.basis().keys()\n        Dihedral group of order 6 as a permutation group\n\n        sage: [a,b] = A.algebra_generators()\n        sage: a, b\n        (B[(1,2,3)], B[(1,3)])\n        sage: a^3, b^2\n        (B[()], B[()])\n        sage: a*b\n        B[(1,2)]\n\n        sage: A.product           # todo: not quite ...\n        <bound method MyGroupAlgebra_with_category._product_from_product_on_basis_multiply of A>\n        sage: A.product(b,b)\n        B[()]\n\n        sage: A.zero().coproduct()\n        0\n        sage: A.zero().coproduct().parent()\n        A # A\n        sage: a.coproduct()\n        B[(1,2,3)] # B[(1,2,3)]\n\n        sage: TestSuite(A).run(verbose=True)\n        running ._test_additive_associativity() . . . pass\n        running ._test_an_element() . . . pass\n        running ._test_antipode() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_characteristic() . . . pass\n        running ._test_distributivity() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_nonzero_equal() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_zero() . . . pass\n        sage: A.__class__\n        <class 'sage.categories.examples.hopf_algebras_with_basis.MyGroupAlgebra_with_category'>\n        sage: A.element_class\n        <class 'sage.combinat.free_module.MyGroupAlgebra_with_category.element_class'>\n\n    Let us look at the code for implementing A::\n\n        sage: A??                       # todo: not implemented\n\n    TESTS::\n\n        sage: TestSuite(A).run()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_antipode": {
                    "__doc__": "\n            Test the antipode.\n\n            An *antipode* `S` of a Hopf algebra is a linear endomorphism of the\n            Hopf algebra that satisfies the following conditions (see\n            :wikipedia:`HopfAlgebra`).\n\n            - If `\\mu` and `\\Delta` denote the product and coproduct of the\n              Hopf algebra, respectively, then `S` satisfies\n\n              .. MATH::\n\n                  \\mu \\circ (S \\tensor 1) \\circ \\Delta = unit \\circ counit\n                  \\mu \\circ (1 \\tensor S) \\circ \\Delta = unit \\circ counit\n\n            - `S` is an *anti*-homomorphism\n\n            These properties are tested on :meth:`some_elements`.\n\n            TESTS::\n\n                sage: R = NonCommutativeSymmetricFunctions(QQ).ribbon()\n                sage: R._test_antipode()\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: s._test_antipode()\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "antipode_on_basis": {
                    "__doc__": "\n            The antipode of the Hopf algebra on the basis (optional)\n\n            INPUT:\n\n             - ``x`` -- an index of an element of the basis of ``self``\n\n            Returns the antipode of the basis element indexed by ``x``.\n\n            If this method is implemented, then :meth:`antipode` is defined\n            from this by linearity.\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example()\n                sage: W = A.basis().keys(); W\n                Dihedral group of order 6 as a permutation group\n                sage: w = W.an_element(); w\n                (1,2,3)\n                sage: A.antipode_on_basis(w)\n                B[(1,3,2)]\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of coalgebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: CoalgebrasWithBasis(ZZ)\n        Category of coalgebras with basis over Integer Ring\n        sage: sorted(CoalgebrasWithBasis(ZZ).super_categories(), key=str)\n        [Category of coalgebras over Integer Ring,\n         Category of modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(CoalgebrasWithBasis(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "coproduct_iterated": {
                    "__doc__": "\n            Apply ``n`` coproducts to ``self``.\n\n            .. TODO::\n\n                Remove dependency on ``modules_with_basis`` methods.\n\n            EXAMPLES::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(2)\n                Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[2, 2] # Psi[] + 2*Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[2] # Psi[2] # Psi[] + Psi[2, 2] # Psi[] # Psi[]\n\n            TESTS::\n\n                sage: p = SymmetricFunctions(QQ).p()\n                sage: p[5,2,2].coproduct_iterated()\n                p[] # p[5, 2, 2] + 2*p[2] # p[5, 2] + p[2, 2] # p[5]\n                 + p[5] # p[2, 2] + 2*p[5, 2] # p[2] + p[5, 2, 2] # p[]\n                sage: p([]).coproduct_iterated(3)\n                p[] # p[] # p[] # p[]\n\n            ::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(3)\n                Psi[] # Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[] # Psi[2, 2] # Psi[] + 2*Psi[] # Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[] # Psi[2] # Psi[2] # Psi[] + Psi[] # Psi[2, 2] # Psi[] # Psi[]\n                 + 2*Psi[2] # Psi[] # Psi[] # Psi[2] + 2*Psi[2] # Psi[] # Psi[2] # Psi[]\n                 + 2*Psi[2] # Psi[2] # Psi[] # Psi[] + Psi[2, 2] # Psi[] # Psi[] # Psi[]\n\n            ::\n\n                sage: m = SymmetricFunctionsNonCommutingVariables(QQ).m()\n                sage: m[[1,3],[2]].coproduct_iterated(2)\n                m{} # m{} # m{{1, 3}, {2}} + m{} # m{{1}} # m{{1, 2}}\n                 + m{} # m{{1, 2}} # m{{1}} + m{} # m{{1, 3}, {2}} # m{}\n                 + m{{1}} # m{} # m{{1, 2}} + m{{1}} # m{{1, 2}} # m{}\n                 + m{{1, 2}} # m{} # m{{1}} + m{{1, 2}} # m{{1}} # m{}\n                 + m{{1, 3}, {2}} # m{} # m{}\n                sage: m[[]].coproduct_iterated(3), m[[1,3],[2]].coproduct_iterated(0)\n                (m{} # m{} # m{} # m{}, m{{1, 3}, {2}})\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        [
                            1
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of coalgebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: CoalgebrasWithBasis(ZZ)\n        Category of coalgebras with basis over Integer Ring\n        sage: sorted(CoalgebrasWithBasis(ZZ).super_categories(), key=str)\n        [Category of coalgebras over Integer Ring,\n         Category of modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(CoalgebrasWithBasis(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "coproduct_on_basis": {
                    "__doc__": "\n            The coproduct of the algebra on the basis (optional).\n\n            INPUT:\n\n            - ``i`` -- the indices of an element of the basis of ``self``\n\n            Returns the coproduct of the corresponding basis elements\n            If implemented, the coproduct of the algebra is defined\n            from it by linearity.\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: (a, b) = A._group.gens()\n                sage: A.coproduct_on_basis(a)\n                B[(1,2,3)] # B[(1,2,3)]\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit_on_basis": {
                    "__doc__": "\n            The counit of the algebra on the basis (optional).\n\n            INPUT:\n\n            - ``i`` -- the indices of an element of the basis of ``self``\n\n            Returns the counit of the corresponding basis elements\n            If implemented, the counit of the algebra is defined\n            from it by linearity.\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: (a, b) = A._group.gens()\n                sage: A.counit_on_basis(a)\n                1\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "coproduct_iterated": {
                    "__doc__": "\n            Apply ``n`` coproducts to ``self``.\n\n            .. TODO::\n\n                Remove dependency on ``modules_with_basis`` methods.\n\n            EXAMPLES::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(2)\n                Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[2, 2] # Psi[] + 2*Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[2] # Psi[2] # Psi[] + Psi[2, 2] # Psi[] # Psi[]\n\n            TESTS::\n\n                sage: p = SymmetricFunctions(QQ).p()\n                sage: p[5,2,2].coproduct_iterated()\n                p[] # p[5, 2, 2] + 2*p[2] # p[5, 2] + p[2, 2] # p[5]\n                 + p[5] # p[2, 2] + 2*p[5, 2] # p[2] + p[5, 2, 2] # p[]\n                sage: p([]).coproduct_iterated(3)\n                p[] # p[] # p[] # p[]\n\n            ::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(3)\n                Psi[] # Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[] # Psi[2, 2] # Psi[] + 2*Psi[] # Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[] # Psi[2] # Psi[2] # Psi[] + Psi[] # Psi[2, 2] # Psi[] # Psi[]\n                 + 2*Psi[2] # Psi[] # Psi[] # Psi[2] + 2*Psi[2] # Psi[] # Psi[2] # Psi[]\n                 + 2*Psi[2] # Psi[2] # Psi[] # Psi[] + Psi[2, 2] # Psi[] # Psi[] # Psi[]\n\n            ::\n\n                sage: m = SymmetricFunctionsNonCommutingVariables(QQ).m()\n                sage: m[[1,3],[2]].coproduct_iterated(2)\n                m{} # m{} # m{{1, 3}, {2}} + m{} # m{{1}} # m{{1, 2}}\n                 + m{} # m{{1, 2}} # m{{1}} + m{} # m{{1, 3}, {2}} # m{}\n                 + m{{1}} # m{} # m{{1, 2}} + m{{1}} # m{{1, 2}} # m{}\n                 + m{{1, 2}} # m{} # m{{1}} + m{{1, 2}} # m{{1}} # m{}\n                 + m{{1, 3}, {2}} # m{} # m{}\n                sage: m[[]].coproduct_iterated(3), m[[1,3],[2]].coproduct_iterated(0)\n                (m{} # m{} # m{} # m{}, m{{1, 3}, {2}})\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        [
                            1
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of division rings\n\n    A division ring (or skew field) is a not necessarily commutative\n    ring where all non-zero elements have multiplicative inverses\n\n    EXAMPLES::\n\n      sage: DivisionRings()\n      Category of division rings\n      sage: DivisionRings().super_categories()\n      [Category of domains]\n\n    TESTS::\n\n        sage: TestSuite(DivisionRings()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.domains.Domains"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of division rings\n\n    A division ring (or skew field) is a not necessarily commutative\n    ring where all non-zero elements have multiplicative inverses\n\n    EXAMPLES::\n\n      sage: DivisionRings()\n      Category of division rings\n      sage: DivisionRings().super_categories()\n      [Category of domains]\n\n    TESTS::\n\n        sage: TestSuite(DivisionRings()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.division_rings.DivisionRings",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of crystals.\n\n    See :mod:`sage.combinat.crystals.crystals` for an introduction to crystals.\n\n    EXAMPLES::\n\n        sage: C = Crystals()\n        sage: C\n        Category of crystals\n        sage: C.super_categories()\n        [Category of... enumerated sets]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    Parents in this category should implement the following methods:\n\n    - either an attribute ``_cartan_type`` or a method ``cartan_type``\n\n    - ``module_generators``: a list (or container) of distinct elements\n      which generate the crystal using `f_i`\n\n    Furthermore, their elements ``x`` should implement the following\n    methods:\n\n    - ``x.e(i)`` (returning `e_i(x)`)\n\n    - ``x.f(i)`` (returning `f_i(x)`)\n\n    - ``x.epsilon(i)`` (returning `\\varepsilon_i(x)`)\n\n    - ``x.phi(i)`` (returning `\\varphi_i(x)`)\n\n    EXAMPLES::\n\n        sage: from sage.misc.abstract_method import abstract_methods_of_class\n        sage: abstract_methods_of_class(Crystals().element_class)\n        {'optional': [], 'required': ['e', 'epsilon', 'f', 'phi', 'weight']}\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = Crystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {
                "Epsilon": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(0).Epsilon()\n                (0, 0, 0, 0, 0, 0)\n                sage: C(1).Epsilon()\n                (0, 0, 0, 0, 0, 0)\n                sage: C(2).Epsilon()\n                (1, 0, 0, 0, 0, 0)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "Phi": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(0).Phi()\n                (0, 0, 0, 0, 0, 0)\n                sage: C(1).Phi()\n                (1, 0, 0, 0, 0, 0)\n                sage: C(2).Phi()\n                (1, 1, 0, 0, 0, 0)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "all_paths_to_highest_weight": {
                    "__doc__": "\n            Iterate over all paths to the highest weight from ``self``\n            with respect to `index_set`.\n\n            INPUT:\n\n            - ``index_set`` -- (optional) a subset of the index set of ``self``\n\n            EXAMPLES::\n\n                sage: B = crystals.infinity.Tableaux(\"A2\")\n                sage: b0 = B.highest_weight_vector()\n                sage: b = b0.f_string([1, 2, 1, 2])\n                sage: L = b.all_paths_to_highest_weight()\n                sage: list(L)\n                [[2, 1, 2, 1], [2, 2, 1, 1]]\n\n                sage: Y = crystals.infinity.GeneralizedYoungWalls(3)\n                sage: y0 = Y.highest_weight_vector()\n                sage: y = y0.f_string([0, 1, 2, 3, 2, 1, 0])\n                sage: list(y.all_paths_to_highest_weight())\n                [[0, 1, 2, 3, 2, 1, 0],\n                 [0, 1, 3, 2, 2, 1, 0],\n                 [0, 3, 1, 2, 2, 1, 0],\n                 [0, 3, 2, 1, 1, 0, 2],\n                 [0, 3, 2, 1, 1, 2, 0]]\n\n                sage: B = crystals.Tableaux(\"A3\", shape=[4,2,1])\n                sage: b0 = B.highest_weight_vector()\n                sage: b = b0.f_string([1, 1, 2, 3])\n                sage: list(b.all_paths_to_highest_weight())\n                [[1, 3, 2, 1], [3, 1, 2, 1], [3, 2, 1, 1]]\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "cartan_type": {
                    "__doc__": "\n            Returns the Cartan type associated to ``self``\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A', 5])\n                sage: C(1).cartan_type()\n                ['A', 5]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "e": {
                    "__doc__": "\n            Return `e_i` of ``self`` if it exists or ``None`` otherwise.\n\n            This method should be implemented by the element class of\n            the crystal.\n\n            EXAMPLES::\n\n                sage: C = Crystals().example(5)\n                sage: x = C[2]; x\n                3\n                sage: x.e(1), x.e(2), x.e(3)\n                (None, 2, None)\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "e_string": {
                    "__doc__": "\n            Applies `e_{i_r} \\cdots e_{i_1}` to self for ``list`` as\n            `[i_1, ..., i_r]`\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',3])\n                sage: b = C(3)\n                sage: b.e_string([2,1])\n                1\n                sage: b.e_string([1,2])\n            ",
                    "args": [
                        "self",
                        "list"
                    ],
                    "argspec": [
                        [
                            "self",
                            "list"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "epsilon": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).epsilon(1)\n                0\n                sage: C(2).epsilon(1)\n                1\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "f": {
                    "__doc__": "\n            Return `f_i` of ``self`` if it exists or ``None`` otherwise.\n\n            This method should be implemented by the element class of\n            the crystal.\n\n            EXAMPLES::\n\n                sage: C = Crystals().example(5)\n                sage: x = C[1]; x\n                2\n                sage: x.f(1), x.f(2), x.f(3)\n                (None, 3, None)\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "f_string": {
                    "__doc__": "\n            Applies `f_{i_r} \\cdots f_{i_1}` to self for ``list`` as\n            `[i_1, ..., i_r]`\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',3])\n                sage: b = C(1)\n                sage: b.f_string([1,2])\n                3\n                sage: b.f_string([2,1])\n            ",
                    "args": [
                        "self",
                        "list"
                    ],
                    "argspec": [
                        [
                            "self",
                            "list"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "index_set": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "is_highest_weight": {
                    "__doc__": "\n            Returns ``True`` if ``self`` is a highest weight.\n            Specifying the option ``index_set`` to be a subset `I` of the\n            index set of the underlying crystal, finds all highest\n            weight vectors for arrows in `I`.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).is_highest_weight()\n                True\n                sage: C(2).is_highest_weight()\n                False\n                sage: C(2).is_highest_weight(index_set = [2,3,4,5])\n                True\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "is_lowest_weight": {
                    "__doc__": "\n            Returns ``True`` if ``self`` is a lowest weight.\n            Specifying the option ``index_set`` to be a subset `I` of the\n            index set of the underlying crystal, finds all lowest\n            weight vectors for arrows in `I`.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).is_lowest_weight()\n                False\n                sage: C(6).is_lowest_weight()\n                True\n                sage: C(4).is_lowest_weight(index_set = [1,3])\n                True\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "phi": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).phi(1)\n                1\n                sage: C(2).phi(1)\n                0\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "phi_minus_epsilon": {
                    "__doc__": "\n            Return `\\varphi_i - \\varepsilon_i` of ``self``.\n\n            There are sometimes better implementations using the\n            weight for this. It is used for reflections along a string.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).phi_minus_epsilon(1)\n                1\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "s": {
                    "__doc__": "\n            Return the reflection of ``self`` along its `i`-string.\n\n            EXAMPLES::\n\n                sage: C = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: b = C(rows=[[1,1],[3]])\n                sage: b.s(1)\n                [[2, 2], [3]]\n                sage: b = C(rows=[[1,2],[3]])\n                sage: b.s(2)\n                [[1, 2], [3]]\n                sage: T = crystals.Tableaux(['A',2],shape=[4])\n                sage: t = T(rows=[[1,2,2,2]])\n                sage: t.s(1)\n                [[1, 1, 1, 2]]\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "subcrystal": {
                    "__doc__": "\n            Construct the subcrystal generated by ``self`` using `e_i` and/or\n            `f_i` for all `i` in ``index_set``.\n\n            INPUT:\n\n            - ``index_set`` -- (default: ``None``) the index set; if ``None``\n              then use the index set of the crystal\n\n            - ``max_depth`` -- (default: infinity) the maximum depth to build\n\n            - ``direction`` -- (default: ``'both'``) the direction to build\n              the subcrystal; it can be one of the following:\n\n              - ``'both'`` - using both `e_i` and `f_i`\n              - ``'upper'`` - using `e_i`\n              - ``'lower'`` - using `f_i`\n\n            - ``contained`` -- (optional) a set (or function) defining the\n              containment in the subcrystal\n\n            - ``cartan_type`` -- (optional) specify the Cartan type of the\n              subcrystal\n\n            - ``category`` -- (optional) specify the category of the subcrystal\n\n            .. SEEALSO::\n\n                - :meth:`Crystals.ParentMethods.subcrystal()`\n\n            EXAMPLES::\n\n                sage: C = crystals.KirillovReshetikhin(['A',3,1], 1, 2)\n                sage: elt = C(1,4)\n                sage: list(elt.subcrystal(index_set=[1,3]))\n                [[[1, 4]], [[2, 4]], [[1, 3]], [[2, 3]]]\n                sage: list(elt.subcrystal(index_set=[1,3], max_depth=1))\n                [[[1, 4]], [[2, 4]], [[1, 3]]]\n                sage: list(elt.subcrystal(index_set=[1,3], direction='upper'))\n                [[[1, 4]], [[1, 3]]]\n                sage: list(elt.subcrystal(index_set=[1,3], direction='lower'))\n                [[[1, 4]], [[2, 4]]]\n            ",
                    "args": [
                        "self",
                        "index_set",
                        "max_depth",
                        "direction",
                        "contained",
                        "cartan_type",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set",
                            "max_depth",
                            "direction",
                            "contained",
                            "cartan_type",
                            "category"
                        ],
                        null,
                        null,
                        [
                            null,
                            Infinity,
                            "both",
                            null,
                            null,
                            null
                        ]
                    ]
                },
                "to_highest_weight": {
                    "__doc__": "\n            Return the highest weight element `u` and a list `[i_1,...,i_k]`\n            such that `self = f_{i_1} ... f_{i_k} u`, where `i_1,...,i_k` are\n            elements in `index_set`. By default the index set is assumed to be\n            the full index set of self.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',3], shape = [1])\n                sage: t = T(rows = [[3]])\n                sage: t.to_highest_weight()\n                [[[1]], [2, 1]]\n                sage: T = crystals.Tableaux(['A',3], shape = [2,1])\n                sage: t = T(rows = [[1,2],[4]])\n                sage: t.to_highest_weight()\n                [[[1, 1], [2]], [1, 3, 2]]\n                sage: t.to_highest_weight(index_set = [3])\n                [[[1, 2], [3]], [3]]\n                sage: K = crystals.KirillovReshetikhin(['A',3,1],2,1)\n                sage: t = K(rows=[[2],[3]]); t.to_highest_weight(index_set=[1])\n                [[[1], [3]], [1]]\n                sage: t.to_highest_weight()\n                Traceback (most recent call last):\n                ...\n                ValueError: This is not a highest weight crystals!\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "to_lowest_weight": {
                    "__doc__": "\n            Return the lowest weight element `u` and a list `[i_1,...,i_k]`\n            such that `self = e_{i_1} ... e_{i_k} u`, where `i_1,...,i_k` are\n            elements in `index_set`. By default the index set is assumed to be\n            the full index set of self.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',3], shape = [1])\n                sage: t = T(rows = [[3]])\n                sage: t.to_lowest_weight()\n                [[[4]], [3]]\n                sage: T = crystals.Tableaux(['A',3], shape = [2,1])\n                sage: t = T(rows = [[1,2],[4]])\n                sage: t.to_lowest_weight()\n                [[[3, 4], [4]], [1, 2, 2, 3]]\n                sage: t.to_lowest_weight(index_set = [3])\n                [[[1, 2], [4]], []]\n                sage: K = crystals.KirillovReshetikhin(['A',3,1],2,1)\n                sage: t = K.module_generator(); t\n                [[1], [2]]\n                sage: t.to_lowest_weight(index_set=[1,2,3])\n                [[[3], [4]], [2, 1, 3, 2]]\n                sage: t.to_lowest_weight()\n                Traceback (most recent call last):\n                ...\n                ValueError: This is not a highest weight crystals!\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "weight": {
                    "__doc__": "\n            Return the weight of this crystal element.\n\n            This method should be implemented by the element class of\n            the crystal.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).weight()\n                (1, 0, 0, 0, 0, 0)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.enumerated_sets.EnumeratedSets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {
                "is_embedding": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "is_isomorphism": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "is_strict": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "name": "sage.categories.crystals.Crystals",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "Lambda": {
                    "__doc__": "\n            Returns the fundamental weights in the weight lattice\n            realization for the root system associated with the crystal\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A', 5])\n                sage: C.Lambda()\n                Finite family {1: (1, 0, 0, 0, 0, 0), 2: (1, 1, 0, 0, 0, 0), 3: (1, 1, 1, 0, 0, 0), 4: (1, 1, 1, 1, 0, 0), 5: (1, 1, 1, 1, 1, 0)}\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_Hom_": {
                    "__doc__": "\n            Return the homset from ``self`` to ``Y`` in the\n            category ``category``.\n\n            INPUT:\n\n            - ``Y`` -- a crystal\n            - ``category`` -- a subcategory of :class:`Crystals`() or ``None``\n\n            The sole purpose of this method is to construct the homset\n            as a :class:`~sage.categories.crystals.CrystalHomset`. If\n            ``category`` is specified and is not a subcategory of\n            :class:`Crystals`, a ``TypeError`` is raised instead.\n\n            This method is not meant to be called directly. Please use\n            :func:`sage.categories.homset.Hom` instead.\n\n            EXAMPLES::\n\n                sage: B = crystals.elementary.B(['A',2], 1)\n                sage: H = B._Hom_(B); H\n                Set of Crystal Morphisms from The 1-elementary crystal of type ['A', 2]\n                 to The 1-elementary crystal of type ['A', 2]\n            ",
                    "args": [
                        "self",
                        "Y",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "Y",
                            "category"
                        ],
                        null,
                        "options",
                        [
                            null
                        ]
                    ]
                },
                "__add__": {
                    "__doc__": "\n            Return the direct sum of ``self`` with ``X``.\n\n            EXAMPLES::\n\n                sage: B = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: C = crystals.Letters(['A',2])\n                sage: B.direct_sum(C)\n                Direct sum of the crystals Family\n                (The crystal of tableaux of type ['A', 2] and shape(s) [[2, 1]],\n                 The crystal of letters for type ['A', 2])\n\n            As a shorthand, we can use ``+``::\n\n                sage: B + C\n                Direct sum of the crystals Family\n                (The crystal of tableaux of type ['A', 2] and shape(s) [[2, 1]],\n                 The crystal of letters for type ['A', 2])\n            ",
                    "args": [
                        "self",
                        "X"
                    ],
                    "argspec": [
                        [
                            "self",
                            "X"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_latex_": {
                    "__doc__": "\n            Returns the crystal graph as a latex string. This can be exported\n            to a file with self.latex_file('filename').\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2],shape=[1])\n                sage: T._latex_()  # optional - dot2tex graphviz\n                '...tikzpicture...'\n                sage: view(T, tightpage = True) # optional - dot2tex graphviz, not tested (opens external window)\n\n            One can for example also color the edges using the following options::\n\n                sage: T = crystals.Tableaux(['A',2],shape=[1])\n                sage: T._latex_(color_by_label = {0:\"black\", 1:\"red\", 2:\"blue\"})   #optional - dot2tex graphviz\n                '...tikzpicture...'\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "cartan_type": {
                    "__doc__": "\n            Returns the Cartan type of the crystal\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',2])\n                sage: C.cartan_type()\n                ['A', 2]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "connected_components": {
                    "__doc__": "\n            Return the connected components of ``self`` as subcrystals.\n\n            EXAMPLES::\n\n                sage: B = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: C = crystals.Letters(['A',2])\n                sage: T = crystals.TensorProduct(B,C)\n                sage: T.connected_components()\n                [Subcrystal of Full tensor product of the crystals\n                 [The crystal of tableaux of type ['A', 2] and shape(s) [[2, 1]],\n                  The crystal of letters for type ['A', 2]],\n                 Subcrystal of Full tensor product of the crystals\n                 [The crystal of tableaux of type ['A', 2] and shape(s) [[2, 1]],\n                  The crystal of letters for type ['A', 2]],\n                 Subcrystal of Full tensor product of the crystals\n                 [The crystal of tableaux of type ['A', 2] and shape(s) [[2, 1]],\n                  The crystal of letters for type ['A', 2]]]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "connected_components_generators": {
                    "__doc__": "\n            Return a tuple of generators for each of the connected components\n            of ``self``.\n\n            EXAMPLES::\n\n                sage: B = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: C = crystals.Letters(['A',2])\n                sage: T = crystals.TensorProduct(B,C)\n                sage: T.connected_components_generators()\n                ([[[1, 1], [2]], 1], [[[1, 2], [2]], 1], [[[1, 2], [3]], 1])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "crystal_morphism": {
                    "__doc__": "\n            Construct a crystal morphism from ``self`` to another crystal\n            ``codomain``.\n\n            INPUT:\n\n            - ``on_gens`` -- a function or list that determines the image\n              of the generators (if given a list, then this uses the order\n              of the generators of the domain) of ``self`` under the\n              crystal morphism\n            - ``codomain`` -- (default: ``self``) the codomain of the morphism\n            - ``cartan_type`` -- (optional) the Cartan type of the morphism;\n              the default is the Cartan type of ``self``\n            - ``index_set`` -- (optional) the index set of the morphism;\n              the default is the index set of the Cartan type\n            - ``generators`` -- (optional) the generators to define the\n              morphism; the default is the generators of ``self``\n            - ``automorphism`` -- (optional) the automorphism to perform the\n              twisting\n            - ``virtualization`` -- (optional) a dictionary whose keys are\n              in the index set of the domain and whose values are lists of\n              entries in the index set of the codomain; the default is the\n              identity dictionary\n            - ``scaling_factors`` -- (optional) a dictionary whose keys are\n              in the index set of the domain and whose values are scaling\n              factors for the weight, `\\varepsilon` and `\\varphi`; the\n              default are all scaling factors to be one\n            - ``category`` -- (optional) the category for the crystal morphism;\n              the default is the category of :class:`Crystals`.\n            - ``check`` -- (default: ``True``) check if the crystal morphism\n              is valid\n\n            .. SEEALSO::\n\n                For more examples, see\n                :class:`sage.categories.crystals.CrystalHomset`.\n\n            EXAMPLES:\n\n            We construct the natural embedding of a crystal using tableaux\n            into the tensor product of single boxes via the reading word::\n\n                sage: B = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: F = crystals.Tableaux(['A',2], shape=[1])\n                sage: T = crystals.TensorProduct(F, F, F)\n                sage: mg = T.highest_weight_vectors()[2]; mg\n                [[[1]], [[2]], [[1]]]\n                sage: psi = B.crystal_morphism([mg], codomain=T); psi\n                ['A', 2] Crystal morphism:\n                  From: The crystal of tableaux of type ['A', 2] and shape(s) [[2, 1]]\n                  To:   Full tensor product of the crystals\n                         [The crystal of tableaux of type ['A', 2] and shape(s) [[1]],\n                          The crystal of tableaux of type ['A', 2] and shape(s) [[1]],\n                          The crystal of tableaux of type ['A', 2] and shape(s) [[1]]]\n                  Defn: [2, 1, 1] |--> [[[1]], [[2]], [[1]]]\n                sage: b = B.module_generators[0]\n                sage: b.pp()\n                  1  1\n                  2\n                sage: psi(b)\n                [[[1]], [[2]], [[1]]]\n                sage: psi(b.f(2))\n                [[[1]], [[3]], [[1]]]\n                sage: psi(b.f_string([2,1,1]))\n                [[[2]], [[3]], [[2]]]\n                sage: lw = b.to_lowest_weight()[0]\n                sage: lw.pp()\n                  2  3\n                  3\n                sage: psi(lw)\n                [[[3]], [[3]], [[2]]]\n                sage: psi(lw) == mg.to_lowest_weight()[0]\n                True\n\n            We now take the other isomorphic highest weight component\n            in the tensor product::\n\n                sage: mg = T.highest_weight_vectors()[1]; mg\n                [[[2]], [[1]], [[1]]]\n                sage: psi = B.crystal_morphism([mg], codomain=T)\n                sage: psi(lw)\n                [[[3]], [[2]], [[3]]]\n\n            We construct a crystal morphism of classical crystals using a\n            Kirillov-Reshetikhin crystal::\n\n                sage: B = crystals.Tableaux(['D', 4], shape=[1,1])\n                sage: K = crystals.KirillovReshetikhin(['D',4,1], 2,2)\n                sage: K.module_generators\n                [[], [[1], [2]], [[1, 1], [2, 2]]]\n                sage: v = K.module_generators[1]\n                sage: psi = B.crystal_morphism([v], codomain=K, category=FiniteCrystals())\n                sage: psi\n                ['D', 4] -> ['D', 4, 1] Virtual Crystal morphism:\n                  From: The crystal of tableaux of type ['D', 4] and shape(s) [[1, 1]]\n                  To:   Kirillov-Reshetikhin crystal of type ['D', 4, 1] with (r,s)=(2,2)\n                  Defn: [2, 1] |--> [[1], [2]]\n                sage: b = B.module_generators[0]\n                sage: psi(b)\n                [[1], [2]]\n                sage: psi(b.to_lowest_weight()[0])\n                [[-2], [-1]]\n\n            We can define crystal morphisms using a different set of\n            generators. For example, we construct an example using the\n            lowest weight vector::\n\n                sage: B = crystals.Tableaux(['A',2], shape=[1])\n                sage: La = RootSystem(['A',2]).weight_lattice().fundamental_weights()\n                sage: T = crystals.elementary.T(['A',2], La[2])\n                sage: Bp = T.tensor(B)\n                sage: C = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: x = C.module_generators[0].f_string([1,2])\n                sage: psi = Bp.crystal_morphism([x], generators=Bp.lowest_weight_vectors())\n                sage: psi(Bp.highest_weight_vector())\n                [[1, 1], [2]]\n\n            We can also use a dictionary to specify the generators and\n            their images::\n\n                sage: psi = Bp.crystal_morphism({Bp.lowest_weight_vectors()[0]: x})\n                sage: psi(Bp.highest_weight_vector())\n                [[1, 1], [2]]\n\n            We construct a twisted crystal morphism induced from the diagram\n            automorphism of type `A_3^{(1)}`::\n\n                sage: La = RootSystem(['A',3,1]).weight_lattice(extended=True).fundamental_weights()\n                sage: B0 = crystals.GeneralizedYoungWalls(3, La[0])\n                sage: B1 = crystals.GeneralizedYoungWalls(3, La[1])\n                sage: phi = B0.crystal_morphism(B1.module_generators, automorphism={0:1, 1:2, 2:3, 3:0})\n                sage: phi\n                ['A', 3, 1] Twisted Crystal morphism:\n                  From: Highest weight crystal of generalized Young walls of Cartan type ['A', 3, 1] and highest weight Lambda[0]\n                  To:   Highest weight crystal of generalized Young walls of Cartan type ['A', 3, 1] and highest weight Lambda[1]\n                  Defn: [] |--> []\n                sage: x = B0.module_generators[0].f_string([0,1,2,3]); x\n                [[0, 3], [1], [2]]\n                sage: phi(x)\n                [[], [1, 0], [2], [3]]\n\n            We construct a virtual crystal morphism from type `G_2` into\n            type `D_4`::\n\n                sage: D = crystals.Tableaux(['D',4], shape=[1,1])\n                sage: G = crystals.Tableaux(['G',2], shape=[1])\n                sage: psi = G.crystal_morphism(D.module_generators,\n                ....:                          virtualization={1:[2],2:[1,3,4]},\n                ....:                          scaling_factors={1:1, 2:1})\n                sage: for x in G:\n                ....:     ascii_art(x, psi(x), sep='  |-->  ')\n                ....:     print(\"\")\n                             1\n                  1  |-->    2\n                <BLANKLINE>\n                             1\n                  2  |-->    3\n                <BLANKLINE>\n                             2\n                  3  |-->   -3\n                <BLANKLINE>\n                             3\n                  0  |-->   -3\n                <BLANKLINE>\n                             3\n                 -3  |-->   -2\n                <BLANKLINE>\n                            -3\n                 -2  |-->   -1\n                <BLANKLINE>\n                            -2\n                 -1  |-->   -1\n            ",
                    "args": [
                        "self",
                        "on_gens",
                        "codomain",
                        "cartan_type",
                        "index_set",
                        "generators",
                        "automorphism",
                        "virtualization",
                        "scaling_factors",
                        "category",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "on_gens",
                            "codomain",
                            "cartan_type",
                            "index_set",
                            "generators",
                            "automorphism",
                            "virtualization",
                            "scaling_factors",
                            "category",
                            "check"
                        ],
                        null,
                        null,
                        [
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            true
                        ]
                    ]
                },
                "digraph": {
                    "__doc__": "\n            Returns the DiGraph associated to ``self``.\n\n            INPUT:\n\n            - ``subset`` -- (optional) a subset of vertices for\n              which the digraph should be constructed\n\n            - ``index_set`` -- (optional) the index set to draw arrows\n\n            EXAMPLES::\n\n                sage: C = Crystals().example(5)\n                sage: C.digraph()\n                Digraph on 6 vertices\n\n            The edges of the crystal graph are by default colored using\n            blue for edge 1, red for edge 2, and green for edge 3::\n\n                sage: C = Crystals().example(3)\n                sage: G = C.digraph()\n                sage: view(G, tightpage=True)  # optional - dot2tex graphviz, not tested (opens external window)\n\n            One may also overwrite the colors::\n\n                sage: C = Crystals().example(3)\n                sage: G = C.digraph()\n                sage: G.set_latex_options(color_by_label = {1:\"red\", 2:\"purple\", 3:\"blue\"})\n                sage: view(G, tightpage=True)  # optional - dot2tex graphviz, not tested (opens external window)\n\n            Or one may add colors to yet unspecified edges::\n\n                sage: C = Crystals().example(4)\n                sage: G = C.digraph()\n                sage: C.cartan_type()._index_set_coloring[4]=\"purple\"\n                sage: view(G, tightpage=True)  # optional - dot2tex graphviz, not tested (opens external window)\n\n            Here is an example of how to take the top part up to a\n            given depth of an infinite dimensional crystal::\n\n                sage: C = CartanType(['C',2,1])\n                sage: La = C.root_system().weight_lattice().fundamental_weights()\n                sage: T = crystals.HighestWeight(La[0])\n                sage: S = T.subcrystal(max_depth=3)\n                sage: G = T.digraph(subset=S); G\n                Digraph on 5 vertices\n                sage: sorted(G.vertices(), key=str)\n                [(-Lambda[0] + 2*Lambda[1] - delta,),\n                 (1/2*Lambda[0] + Lambda[1] - Lambda[2] - 1/2*delta, -1/2*Lambda[0] + Lambda[1] - 1/2*delta),\n                 (1/2*Lambda[0] - Lambda[1] + Lambda[2] - 1/2*delta, -1/2*Lambda[0] + Lambda[1] - 1/2*delta),\n                 (Lambda[0] - 2*Lambda[1] + 2*Lambda[2] - delta,),\n                 (Lambda[0],)]\n\n            Here is a way to construct a picture of a Demazure crystal using\n            the ``subset`` option::\n\n                sage: B = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t = B.highest_weight_vector()\n                sage: D = B.demazure_subcrystal(t, [2,1])\n                sage: list(D)\n                [[[1, 1], [2]], [[1, 1], [3]], [[1, 2], [2]],\n                 [[1, 3], [2]], [[1, 3], [3]]]\n                sage: view(D, tightpage=True)  # optional - dot2tex graphviz, not tested (opens external window)\n\n            We can also choose to display particular arrows using the\n            ``index_set`` option::\n\n                sage: C = crystals.KirillovReshetikhin(['D',4,1], 2, 1)\n                sage: G = C.digraph(index_set=[1,3])\n                sage: len(G.edges())\n                20\n                sage: view(G, tightpage=True)  # optional - dot2tex graphviz, not tested (opens external window)\n\n            .. TODO:: Add more tests.\n            ",
                    "args": [
                        "self",
                        "subset",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "subset",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null,
                            null
                        ]
                    ]
                },
                "direct_sum": {
                    "__doc__": "\n            Return the direct sum of ``self`` with ``X``.\n\n            EXAMPLES::\n\n                sage: B = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: C = crystals.Letters(['A',2])\n                sage: B.direct_sum(C)\n                Direct sum of the crystals Family\n                (The crystal of tableaux of type ['A', 2] and shape(s) [[2, 1]],\n                 The crystal of letters for type ['A', 2])\n\n            As a shorthand, we can use ``+``::\n\n                sage: B + C\n                Direct sum of the crystals Family\n                (The crystal of tableaux of type ['A', 2] and shape(s) [[2, 1]],\n                 The crystal of letters for type ['A', 2])\n            ",
                    "args": [
                        "self",
                        "X"
                    ],
                    "argspec": [
                        [
                            "self",
                            "X"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "dot_tex": {
                    "__doc__": "\n            Return a dot_tex string representation of ``self``.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',2])\n                sage: C.dot_tex()\n                'digraph G { \\n  node [ shape=plaintext ];\\n  N_0 [ label = \" \", texlbl = \"$1$\" ];\\n  N_1 [ label = \" \", texlbl = \"$2$\" ];\\n  N_2 [ label = \" \", texlbl = \"$3$\" ];\\n  N_0 -> N_1 [ label = \" \", texlbl = \"1\" ];\\n  N_1 -> N_2 [ label = \" \", texlbl = \"2\" ];\\n}'\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "index_set": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "is_connected": {
                    "__doc__": "\n            Return ``True`` if ``self`` is a connected crystal.\n\n            EXAMPLES::\n\n                sage: B = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: C = crystals.Letters(['A',2])\n                sage: T = crystals.TensorProduct(B,C)\n                sage: B.is_connected()\n                True\n                sage: T.is_connected()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "latex": {
                    "__doc__": "\n            Returns the crystal graph as a latex string. This can be exported\n            to a file with self.latex_file('filename').\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2],shape=[1])\n                sage: T._latex_()  # optional - dot2tex graphviz\n                '...tikzpicture...'\n                sage: view(T, tightpage = True) # optional - dot2tex graphviz, not tested (opens external window)\n\n            One can for example also color the edges using the following options::\n\n                sage: T = crystals.Tableaux(['A',2],shape=[1])\n                sage: T._latex_(color_by_label = {0:\"black\", 1:\"red\", 2:\"blue\"})   #optional - dot2tex graphviz\n                '...tikzpicture...'\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "latex_file": {
                    "__doc__": "\n            Exports a file, suitable for pdflatex, to 'filename'. This requires\n            a proper installation of ``dot2tex`` in sage-python. For more\n            information see the documentation for ``self.latex()``.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A', 5])\n                sage: C.latex_file('/tmp/test.tex')  # optional - dot2tex graphviz\n            ",
                    "args": [
                        "self",
                        "filename"
                    ],
                    "argspec": [
                        [
                            "self",
                            "filename"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "metapost": {
                    "__doc__": "\n            Use C.metapost(\"filename.mp\",[options]), where options can be:\n\n            thicklines = True (for thicker edges) labels = False (to suppress\n            labeling of the vertices) scaling_factor=value, where value is a\n            floating point number, 1.0 by default. Increasing or decreasing the\n            scaling factor changes the size of the image. tallness=1.0.\n            Increasing makes the image taller without increasing the width.\n\n            Root operators e(1) or f(1) move along red lines, e(2) or f(2)\n            along green. The highest weight is in the lower left. Vertices with\n            the same weight are kept close together. The concise labels on the\n            nodes are strings introduced by Berenstein and Zelevinsky and\n            Littelmann; see Littelmann's paper Cones, Crystals, Patterns,\n            sections 5 and 6.\n\n            For Cartan types B2 or C2, the pattern has the form\n\n            a2 a3 a4 a1\n\n            where c\\*a2 = a3 = 2\\*a4 =0 and a1=0, with c=2 for B2, c=1 for C2.\n            Applying e(2) a1 times, e(1) a2 times, e(2) a3 times, e(1) a4 times\n            returns to the highest weight. (Observe that Littelmann writes the\n            roots in opposite of the usual order, so our e(1) is his e(2) for\n            these Cartan types.) For type A2, the pattern has the form\n\n            a3 a2 a1\n\n            where applying e(1) a1 times, e(2) a2 times then e(3) a1 times\n            returns to the highest weight. These data determine the vertex and\n            may be translated into a Gelfand-Tsetlin pattern or tableau.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A', 2])\n                sage: C.metapost(tmp_filename())\n\n            ::\n\n                sage: C = crystals.Letters(['A', 5])\n                sage: C.metapost(tmp_filename())\n                Traceback (most recent call last):\n                ...\n                NotImplementedError\n            ",
                    "args": [
                        "self",
                        "filename",
                        "thicklines",
                        "labels",
                        "scaling_factor",
                        "tallness"
                    ],
                    "argspec": [
                        [
                            "self",
                            "filename",
                            "thicklines",
                            "labels",
                            "scaling_factor",
                            "tallness"
                        ],
                        null,
                        null,
                        [
                            false,
                            true,
                            1.0,
                            1.0
                        ]
                    ]
                },
                "number_of_connected_components": {
                    "__doc__": "\n            Return the number of connected components of ``self``.\n\n            EXAMPLES::\n\n                sage: B = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: C = crystals.Letters(['A',2])\n                sage: T = crystals.TensorProduct(B,C)\n                sage: T.number_of_connected_components()\n                3\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "plot": {
                    "__doc__": "\n            Return the plot of ``self`` as a directed graph.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A', 5])\n                sage: print(C.plot())\n                Graphics object consisting of 17 graphics primitives\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "plot3d": {
                    "__doc__": "\n            Return the 3-dimensional plot of ``self`` as a directed graph.\n\n            EXAMPLES::\n\n                sage: C = crystals.KirillovReshetikhin(['A',3,1],2,1)\n                sage: print(C.plot3d())\n                Graphics3d Object\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "subcrystal": {
                    "__doc__": "\n            Construct the subcrystal from ``generators`` using `e_i` and/or\n            `f_i` for all `i` in ``index_set``.\n\n            INPUT:\n\n            - ``index_set`` -- (default: ``None``) the index set; if ``None``\n              then use the index set of the crystal\n\n            - ``generators`` -- (default: ``None``) the list of generators; if\n              ``None`` then use the module generators of the crystal\n\n            - ``max_depth`` -- (default: infinity) the maximum depth to build\n\n            - ``direction`` -- (default: ``'both'``) the direction to build\n              the subcrystal; it can be one of the following:\n\n              - ``'both'`` - using both `e_i` and `f_i`\n              - ``'upper'`` - using `e_i`\n              - ``'lower'`` - using `f_i`\n\n            - ``contained`` -- (optional) a set or function defining the\n              containment in the subcrystal\n\n            - ``virtualization``, ``scaling_factors`` -- (optional)\n              dictionaries whose key `i` corresponds to the sets `\\sigma_i`\n              and `\\gamma_i` respectively used to define virtual crystals; see\n              :class:`~sage.combinat.crystals.virtual_crystal.VirtualCrystal`\n\n            - ``cartan_type`` -- (optional) specify the Cartan type of the\n              subcrystal\n\n            - ``category`` -- (optional) specify the category of the subcrystal\n\n            EXAMPLES::\n\n                sage: C = crystals.KirillovReshetikhin(['A',3,1], 1, 2)\n                sage: S = list(C.subcrystal(index_set=[1,2])); S\n                [[[1, 1]], [[1, 2]], [[1, 3]], [[2, 2]], [[2, 3]], [[3, 3]]]\n                sage: C.cardinality()\n                10\n                sage: len(S)\n                6\n                sage: list(C.subcrystal(index_set=[1,3], generators=[C(1,4)]))\n                [[[1, 4]], [[2, 4]], [[1, 3]], [[2, 3]]]\n                sage: list(C.subcrystal(index_set=[1,3], generators=[C(1,4)], max_depth=1))\n                [[[1, 4]], [[2, 4]], [[1, 3]]]\n                sage: list(C.subcrystal(index_set=[1,3], generators=[C(1,4)], direction='upper'))\n                [[[1, 4]], [[1, 3]]]\n                sage: list(C.subcrystal(index_set=[1,3], generators=[C(1,4)], direction='lower'))\n                [[[1, 4]], [[2, 4]]]\n\n                sage: G = C.subcrystal(index_set=[1,2,3]).digraph()\n                sage: GA = crystals.Tableaux('A3', shape=[2]).digraph()\n                sage: G.is_isomorphic(GA, edge_labels=True)\n                True\n\n            We construct the subcrystal which contains the necessary data\n            to construct the corresponding dual equivalence graph::\n\n                sage: C = crystals.Tableaux(['A',5], shape=[3,3])\n                sage: is_wt0 = lambda x: all(x.epsilon(i) == x.phi(i) for i in x.parent().index_set())\n                sage: def check(x):\n                ....:     if is_wt0(x):\n                ....:         return True\n                ....:     for i in x.parent().index_set()[:-1]:\n                ....:         L = [x.e(i), x.e_string([i,i+1]), x.f(i), x.f_string([i,i+1])]\n                ....:         if any(y is not None and is_wt0(y) for y in L):\n                ....:             return True\n                ....:     return False\n                sage: wt0 = [x for x in C if is_wt0(x)]\n                sage: S = C.subcrystal(contained=check, generators=wt0)\n                sage: S.module_generators[0]\n                [[1, 3, 5], [2, 4, 6]]\n                sage: S.module_generators[0].e(2).e(3).f(2).f(3)\n                [[1, 2, 5], [3, 4, 6]]\n\n            An example of a type `B_2` virtual crystal inside of a\n            type `A_3` ambient crystal::\n\n                sage: A = crystals.Tableaux(['A',3], shape=[2,1,1])\n                sage: S = A.subcrystal(virtualization={1:[1,3], 2:[2]},\n                ....:                  scaling_factors={1:1,2:1}, cartan_type=['B',2])\n                sage: B = crystals.Tableaux(['B',2], shape=[1])\n                sage: S.digraph().is_isomorphic(B.digraph(), edge_labels=True)\n                True\n            ",
                    "args": [
                        "self",
                        "index_set",
                        "generators",
                        "max_depth",
                        "direction",
                        "contained",
                        "virtualization",
                        "scaling_factors",
                        "cartan_type",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set",
                            "generators",
                            "max_depth",
                            "direction",
                            "contained",
                            "virtualization",
                            "scaling_factors",
                            "cartan_type",
                            "category"
                        ],
                        null,
                        null,
                        [
                            null,
                            null,
                            Infinity,
                            "both",
                            null,
                            null,
                            null,
                            null,
                            null
                        ]
                    ]
                },
                "tensor": {
                    "__doc__": "\n            Return the tensor product of ``self`` with the crystals ``B``.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A', 3])\n                sage: B = crystals.infinity.Tableaux(['A', 3])\n                sage: T = C.tensor(C, B); T\n                Full tensor product of the crystals\n                 [The crystal of letters for type ['A', 3],\n                  The crystal of letters for type ['A', 3],\n                  The infinity crystal of tableaux of type ['A', 3]]\n                sage: tensor([C, C, B]) is T\n                True\n\n                sage: C = crystals.Letters(['A',2])\n                sage: T = C.tensor(C, C, generators=[[C(2),C(1),C(1)],[C(1),C(2),C(1)]]); T\n                The tensor product of the crystals\n                 [The crystal of letters for type ['A', 2],\n                  The crystal of letters for type ['A', 2],\n                  The crystal of letters for type ['A', 2]]\n                sage: T.module_generators\n                [[2, 1, 1], [1, 2, 1]]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "crystals",
                        "options",
                        null
                    ]
                },
                "weight_lattice_realization": {
                    "__doc__": "\n            Returns the weight lattice realization used to express weights.\n\n            This default implementation uses the ambient space of the\n            root system for (non relabelled) finite types and the\n            weight lattice otherwise. This is a legacy from when\n            ambient spaces were partially implemented, and may be\n            changed in the future.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A', 5])\n                sage: C.weight_lattice_realization()\n                Ambient space of the Root system of type ['A', 5]\n                sage: K = crystals.KirillovReshetikhin(['A',2,1], 1, 1)\n                sage: K.weight_lattice_realization()\n                Weight lattice of the Root system of type ['A', 2, 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.crystals.Crystals",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "Epsilon": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(0).Epsilon()\n                (0, 0, 0, 0, 0, 0)\n                sage: C(1).Epsilon()\n                (0, 0, 0, 0, 0, 0)\n                sage: C(2).Epsilon()\n                (1, 0, 0, 0, 0, 0)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "Phi": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(0).Phi()\n                (0, 0, 0, 0, 0, 0)\n                sage: C(1).Phi()\n                (1, 0, 0, 0, 0, 0)\n                sage: C(2).Phi()\n                (1, 1, 0, 0, 0, 0)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "all_paths_to_highest_weight": {
                    "__doc__": "\n            Iterate over all paths to the highest weight from ``self``\n            with respect to `index_set`.\n\n            INPUT:\n\n            - ``index_set`` -- (optional) a subset of the index set of ``self``\n\n            EXAMPLES::\n\n                sage: B = crystals.infinity.Tableaux(\"A2\")\n                sage: b0 = B.highest_weight_vector()\n                sage: b = b0.f_string([1, 2, 1, 2])\n                sage: L = b.all_paths_to_highest_weight()\n                sage: list(L)\n                [[2, 1, 2, 1], [2, 2, 1, 1]]\n\n                sage: Y = crystals.infinity.GeneralizedYoungWalls(3)\n                sage: y0 = Y.highest_weight_vector()\n                sage: y = y0.f_string([0, 1, 2, 3, 2, 1, 0])\n                sage: list(y.all_paths_to_highest_weight())\n                [[0, 1, 2, 3, 2, 1, 0],\n                 [0, 1, 3, 2, 2, 1, 0],\n                 [0, 3, 1, 2, 2, 1, 0],\n                 [0, 3, 2, 1, 1, 0, 2],\n                 [0, 3, 2, 1, 1, 2, 0]]\n\n                sage: B = crystals.Tableaux(\"A3\", shape=[4,2,1])\n                sage: b0 = B.highest_weight_vector()\n                sage: b = b0.f_string([1, 1, 2, 3])\n                sage: list(b.all_paths_to_highest_weight())\n                [[1, 3, 2, 1], [3, 1, 2, 1], [3, 2, 1, 1]]\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "cartan_type": {
                    "__doc__": "\n            Returns the Cartan type associated to ``self``\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A', 5])\n                sage: C(1).cartan_type()\n                ['A', 5]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "e": {
                    "__doc__": "\n            Return `e_i` of ``self`` if it exists or ``None`` otherwise.\n\n            This method should be implemented by the element class of\n            the crystal.\n\n            EXAMPLES::\n\n                sage: C = Crystals().example(5)\n                sage: x = C[2]; x\n                3\n                sage: x.e(1), x.e(2), x.e(3)\n                (None, 2, None)\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "e_string": {
                    "__doc__": "\n            Applies `e_{i_r} \\cdots e_{i_1}` to self for ``list`` as\n            `[i_1, ..., i_r]`\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',3])\n                sage: b = C(3)\n                sage: b.e_string([2,1])\n                1\n                sage: b.e_string([1,2])\n            ",
                    "args": [
                        "self",
                        "list"
                    ],
                    "argspec": [
                        [
                            "self",
                            "list"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "epsilon": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).epsilon(1)\n                0\n                sage: C(2).epsilon(1)\n                1\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "f": {
                    "__doc__": "\n            Return `f_i` of ``self`` if it exists or ``None`` otherwise.\n\n            This method should be implemented by the element class of\n            the crystal.\n\n            EXAMPLES::\n\n                sage: C = Crystals().example(5)\n                sage: x = C[1]; x\n                2\n                sage: x.f(1), x.f(2), x.f(3)\n                (None, 3, None)\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "f_string": {
                    "__doc__": "\n            Applies `f_{i_r} \\cdots f_{i_1}` to self for ``list`` as\n            `[i_1, ..., i_r]`\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',3])\n                sage: b = C(1)\n                sage: b.f_string([1,2])\n                3\n                sage: b.f_string([2,1])\n            ",
                    "args": [
                        "self",
                        "list"
                    ],
                    "argspec": [
                        [
                            "self",
                            "list"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "index_set": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "is_highest_weight": {
                    "__doc__": "\n            Returns ``True`` if ``self`` is a highest weight.\n            Specifying the option ``index_set`` to be a subset `I` of the\n            index set of the underlying crystal, finds all highest\n            weight vectors for arrows in `I`.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).is_highest_weight()\n                True\n                sage: C(2).is_highest_weight()\n                False\n                sage: C(2).is_highest_weight(index_set = [2,3,4,5])\n                True\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "is_lowest_weight": {
                    "__doc__": "\n            Returns ``True`` if ``self`` is a lowest weight.\n            Specifying the option ``index_set`` to be a subset `I` of the\n            index set of the underlying crystal, finds all lowest\n            weight vectors for arrows in `I`.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).is_lowest_weight()\n                False\n                sage: C(6).is_lowest_weight()\n                True\n                sage: C(4).is_lowest_weight(index_set = [1,3])\n                True\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "phi": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).phi(1)\n                1\n                sage: C(2).phi(1)\n                0\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "phi_minus_epsilon": {
                    "__doc__": "\n            Return `\\varphi_i - \\varepsilon_i` of ``self``.\n\n            There are sometimes better implementations using the\n            weight for this. It is used for reflections along a string.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).phi_minus_epsilon(1)\n                1\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "s": {
                    "__doc__": "\n            Return the reflection of ``self`` along its `i`-string.\n\n            EXAMPLES::\n\n                sage: C = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: b = C(rows=[[1,1],[3]])\n                sage: b.s(1)\n                [[2, 2], [3]]\n                sage: b = C(rows=[[1,2],[3]])\n                sage: b.s(2)\n                [[1, 2], [3]]\n                sage: T = crystals.Tableaux(['A',2],shape=[4])\n                sage: t = T(rows=[[1,2,2,2]])\n                sage: t.s(1)\n                [[1, 1, 1, 2]]\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "subcrystal": {
                    "__doc__": "\n            Construct the subcrystal generated by ``self`` using `e_i` and/or\n            `f_i` for all `i` in ``index_set``.\n\n            INPUT:\n\n            - ``index_set`` -- (default: ``None``) the index set; if ``None``\n              then use the index set of the crystal\n\n            - ``max_depth`` -- (default: infinity) the maximum depth to build\n\n            - ``direction`` -- (default: ``'both'``) the direction to build\n              the subcrystal; it can be one of the following:\n\n              - ``'both'`` - using both `e_i` and `f_i`\n              - ``'upper'`` - using `e_i`\n              - ``'lower'`` - using `f_i`\n\n            - ``contained`` -- (optional) a set (or function) defining the\n              containment in the subcrystal\n\n            - ``cartan_type`` -- (optional) specify the Cartan type of the\n              subcrystal\n\n            - ``category`` -- (optional) specify the category of the subcrystal\n\n            .. SEEALSO::\n\n                - :meth:`Crystals.ParentMethods.subcrystal()`\n\n            EXAMPLES::\n\n                sage: C = crystals.KirillovReshetikhin(['A',3,1], 1, 2)\n                sage: elt = C(1,4)\n                sage: list(elt.subcrystal(index_set=[1,3]))\n                [[[1, 4]], [[2, 4]], [[1, 3]], [[2, 3]]]\n                sage: list(elt.subcrystal(index_set=[1,3], max_depth=1))\n                [[[1, 4]], [[2, 4]], [[1, 3]]]\n                sage: list(elt.subcrystal(index_set=[1,3], direction='upper'))\n                [[[1, 4]], [[1, 3]]]\n                sage: list(elt.subcrystal(index_set=[1,3], direction='lower'))\n                [[[1, 4]], [[2, 4]]]\n            ",
                    "args": [
                        "self",
                        "index_set",
                        "max_depth",
                        "direction",
                        "contained",
                        "cartan_type",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set",
                            "max_depth",
                            "direction",
                            "contained",
                            "cartan_type",
                            "category"
                        ],
                        null,
                        null,
                        [
                            null,
                            Infinity,
                            "both",
                            null,
                            null,
                            null
                        ]
                    ]
                },
                "to_highest_weight": {
                    "__doc__": "\n            Return the highest weight element `u` and a list `[i_1,...,i_k]`\n            such that `self = f_{i_1} ... f_{i_k} u`, where `i_1,...,i_k` are\n            elements in `index_set`. By default the index set is assumed to be\n            the full index set of self.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',3], shape = [1])\n                sage: t = T(rows = [[3]])\n                sage: t.to_highest_weight()\n                [[[1]], [2, 1]]\n                sage: T = crystals.Tableaux(['A',3], shape = [2,1])\n                sage: t = T(rows = [[1,2],[4]])\n                sage: t.to_highest_weight()\n                [[[1, 1], [2]], [1, 3, 2]]\n                sage: t.to_highest_weight(index_set = [3])\n                [[[1, 2], [3]], [3]]\n                sage: K = crystals.KirillovReshetikhin(['A',3,1],2,1)\n                sage: t = K(rows=[[2],[3]]); t.to_highest_weight(index_set=[1])\n                [[[1], [3]], [1]]\n                sage: t.to_highest_weight()\n                Traceback (most recent call last):\n                ...\n                ValueError: This is not a highest weight crystals!\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "to_lowest_weight": {
                    "__doc__": "\n            Return the lowest weight element `u` and a list `[i_1,...,i_k]`\n            such that `self = e_{i_1} ... e_{i_k} u`, where `i_1,...,i_k` are\n            elements in `index_set`. By default the index set is assumed to be\n            the full index set of self.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',3], shape = [1])\n                sage: t = T(rows = [[3]])\n                sage: t.to_lowest_weight()\n                [[[4]], [3]]\n                sage: T = crystals.Tableaux(['A',3], shape = [2,1])\n                sage: t = T(rows = [[1,2],[4]])\n                sage: t.to_lowest_weight()\n                [[[3, 4], [4]], [1, 2, 2, 3]]\n                sage: t.to_lowest_weight(index_set = [3])\n                [[[1, 2], [4]], []]\n                sage: K = crystals.KirillovReshetikhin(['A',3,1],2,1)\n                sage: t = K.module_generator(); t\n                [[1], [2]]\n                sage: t.to_lowest_weight(index_set=[1,2,3])\n                [[[3], [4]], [2, 1, 3, 2]]\n                sage: t.to_lowest_weight()\n                Traceback (most recent call last):\n                ...\n                ValueError: This is not a highest weight crystals!\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "weight": {
                    "__doc__": "\n            Return the weight of this crystal element.\n\n            This method should be implemented by the element class of\n            the crystal.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C(1).weight()\n                (1, 0, 0, 0, 0, 0)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of bialgebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = BialgebrasWithBasis(QQ); C\n        Category of bialgebras with basis over Rational Field\n\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras with basis over Rational Field,\n         Category of bialgebras over Rational Field,\n         Category of coalgebras with basis over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(BialgebrasWithBasis(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "adams_operator": {
                    "__doc__": "\n            Compute the `n`-th convolution power of the identity morphism\n            `\\mathrm{Id}` on ``self``.\n\n            INPUT:\n\n            - ``n`` -- a nonnegative integer\n\n            OUTPUT:\n\n            - the image of ``self`` under the convolution power `\\mathrm{Id}^{*n}`\n\n            .. NOTE::\n\n                In the literature, this is also called a Hopf power or\n                Sweedler power, cf. [AL2015]_.\n\n            .. SEEALSO::\n\n                :meth:`sage.categories.bialgebras.ElementMethods.convolution_product`\n\n            REFERENCES:\n\n            .. [AL2015] *The characteristic polynomial of the Adams operators\n               on graded connected Hopf algebras*.\n               Marcelo Aguiar and Aaron Lauve.\n               Algebra Number Theory, v.9, 2015, n.3, 2015.\n\n            .. TODO::\n\n                Remove dependency on ``modules_with_basis`` methods.\n\n            EXAMPLES::\n\n                sage: h = SymmetricFunctions(QQ).h()\n                sage: h[5].adams_operator(2)\n                2*h[3, 2] + 2*h[4, 1] + 2*h[5]\n                sage: h[5].plethysm(2*h[1])\n                2*h[3, 2] + 2*h[4, 1] + 2*h[5]\n                sage: h([]).adams_operator(0)\n                h[]\n                sage: h([]).adams_operator(1)\n                h[]\n                sage: h[3,2].adams_operator(0)\n                0\n                sage: h[3,2].adams_operator(1)\n                h[3, 2]\n\n            ::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S[4].adams_operator(5)\n                5*S[1, 1, 1, 1] + 10*S[1, 1, 2] + 10*S[1, 2, 1] + 10*S[1, 3] + 10*S[2, 1, 1] + 10*S[2, 2] + 10*S[3, 1] + 5*S[4]\n\n\n            ::\n\n                sage: m = SymmetricFunctionsNonCommutingVariables(QQ).m()\n                sage: m[[1,3],[2]].adams_operator(-2)\n                3*m{{1}, {2, 3}} + 3*m{{1, 2}, {3}} + 6*m{{1, 2, 3}} - 2*m{{1, 3}, {2}}\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "convolution_product": {
                    "__doc__": "\n            Return the image of ``self`` under the convolution product (map) of\n            the maps.\n\n            Let `A` and `B` be bialgebras over a commutative ring `R`.\n            Given maps `f_i : A \\to B` for `1 \\leq i < n`, define the\n            convolution product\n\n            .. MATH::\n\n                (f_1 * f_2 * \\cdots * f_n) := \\mu^{(n-1)} \\circ (f_1 \\otimes\n                f_2 \\otimes \\cdots \\otimes f_n) \\circ \\Delta^{(n-1)},\n\n            where `\\Delta^{(k)} := \\bigl(\\Delta \\otimes\n            \\mathrm{Id}^{\\otimes(k-1)}\\bigr) \\circ \\Delta^{(k-1)}`,\n            with `\\Delta^{(1)} = \\Delta` (the ordinary coproduct in `A`) and\n            `\\Delta^{(0)} = \\mathrm{Id}`; and with `\\mu^{(k)} := \\mu \\circ\n            \\bigl(\\mu^{(k-1)} \\otimes \\mathrm{Id})` and `\\mu^{(1)} = \\mu`\n            (the ordinary product in `B`). See [Sw1969]_.\n\n            (In the literature, one finds, e.g., `\\Delta^{(2)}` for what we\n            denote above as `\\Delta^{(1)}`. See [KMN2012]_.)\n\n            INPUT:\n\n            - ``maps`` -- any number `n \\geq 0` of linear maps `f_1, f_2,\n              \\ldots, f_n` on ``self.parent()``; or a single ``list`` or\n              ``tuple`` of such maps\n\n            OUTPUT:\n\n            - the convolution product of ``maps`` applied to ``self``\n\n            REFERENCES:\n\n            .. [KMN2012] On the trace of the antipode and higher indicators.\n               Yevgenia Kashina and Susan Montgomery and Richard Ng.\n               Israel J. Math., v.188, 2012.\n\n            .. [Sw1969] Hopf algebras.\n               Moss Sweedler.\n               W.A. Benjamin, Math Lec Note Ser., 1969.\n\n            AUTHORS:\n\n            - Amy Pang - 12 June 2015 - Sage Days 65\n\n            .. TODO::\n\n                Remove dependency on ``modules_with_basis`` methods.\n\n            EXAMPLES:\n\n            We compute convolution products of the identity and antipode maps\n            on Schur functions::\n\n                sage: Id = lambda x: x\n                sage: Antipode = lambda x: x.antipode()\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: s[3].convolution_product(Id, Id)\n                2*s[2, 1] + 4*s[3]\n                sage: s[3,2].convolution_product(Id) == s[3,2]\n                True\n\n            The method accepts multiple arguments, or a single argument\n            consisting of a list of maps::\n\n                sage: s[3,2].convolution_product(Id, Id)\n                2*s[2, 1, 1, 1] + 6*s[2, 2, 1] + 6*s[3, 1, 1] + 12*s[3, 2] + 6*s[4, 1] + 2*s[5]\n                sage: s[3,2].convolution_product([Id, Id])\n                2*s[2, 1, 1, 1] + 6*s[2, 2, 1] + 6*s[3, 1, 1] + 12*s[3, 2] + 6*s[4, 1] + 2*s[5]\n\n            We test the defining property of the antipode morphism; namely,\n            that the antipode is the inverse of the identity map in the\n            convolution algebra whose identity element is the composition of\n            the counit and unit::\n\n                sage: s[3,2].convolution_product() == s[3,2].convolution_product(Antipode, Id) == s[3,2].convolution_product(Id, Antipode)\n                True\n\n            ::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,1].convolution_product(Id, Id, Id)\n                3*Psi[1, 2] + 6*Psi[2, 1]\n                sage: (Psi[5,1] - Psi[1,5]).convolution_product(Id, Id, Id)\n                -3*Psi[1, 5] + 3*Psi[5, 1]\n\n            ::\n\n                sage: G = SymmetricGroup(3)\n                sage: QG = GroupAlgebra(G,QQ)\n                sage: x = QG.sum_of_terms([(p,p.length()) for p in Permutations(3)]); x\n                [1, 3, 2] + [2, 1, 3] + 2*[2, 3, 1] + 2*[3, 1, 2] + 3*[3, 2, 1]\n                sage: x.convolution_product(Id, Id)\n                5*[1, 2, 3] + 2*[2, 3, 1] + 2*[3, 1, 2]\n                sage: x.convolution_product(Id, Id, Id)\n                4*[1, 2, 3] + [1, 3, 2] + [2, 1, 3] + 3*[3, 2, 1]\n                sage: x.convolution_product([Id]*6)\n                9*[1, 2, 3]\n\n            TESTS::\n\n                sage: Id = lambda x: x\n                sage: Antipode = lambda x: x.antipode()\n\n            ::\n\n                sage: h = SymmetricFunctions(QQ).h()\n                sage: h[5].convolution_product([Id, Id])\n                2*h[3, 2] + 2*h[4, 1] + 2*h[5]\n                sage: h.one().convolution_product([Id, Antipode])\n                h[]\n                sage: h[3,2].convolution_product([Id, Antipode])\n                0\n                sage: h.one().convolution_product([Id, Antipode]) == h.one().convolution_product()\n                True\n\n            ::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S[4].convolution_product([Id]*5)\n                5*S[1, 1, 1, 1] + 10*S[1, 1, 2] + 10*S[1, 2, 1] + 10*S[1, 3]\n                 + 10*S[2, 1, 1] + 10*S[2, 2] + 10*S[3, 1] + 5*S[4]\n\n            ::\n\n                sage: m = SymmetricFunctionsNonCommutingVariables(QQ).m()\n                sage: m[[1,3],[2]].convolution_product([Antipode, Antipode])\n                3*m{{1}, {2, 3}} + 3*m{{1, 2}, {3}} + 6*m{{1, 2, 3}} - 2*m{{1, 3}, {2}}\n                sage: m[[]].convolution_product([])\n                m{}\n                sage: m[[1,3],[2]].convolution_product([])\n                0\n\n            ::\n\n                sage: QS = SymmetricGroupAlgebra(QQ, 5)\n                sage: x = QS.sum_of_terms(zip(Permutations(5)[3:6],[1,2,3])); x\n                [1, 2, 4, 5, 3] + 2*[1, 2, 5, 3, 4] + 3*[1, 2, 5, 4, 3]\n                sage: x.convolution_product([Antipode, Id])\n                6*[1, 2, 3, 4, 5]\n                sage: x.convolution_product(Id, Antipode, Antipode, Antipode)\n                3*[1, 2, 3, 4, 5] + [1, 2, 4, 5, 3] + 2*[1, 2, 5, 3, 4]\n\n            ::\n\n                sage: G = SymmetricGroup(3)\n                sage: QG = GroupAlgebra(G,QQ)\n                sage: x = QG.sum_of_terms([(p,p.length()) for p in Permutations(3)]); x\n                [1, 3, 2] + [2, 1, 3] + 2*[2, 3, 1] + 2*[3, 1, 2] + 3*[3, 2, 1]\n                sage: x.convolution_product(Antipode, Id)\n                9*[1, 2, 3]\n                sage: x.convolution_product([Id, Antipode, Antipode, Antipode])\n                5*[1, 2, 3] + 2*[2, 3, 1] + 2*[3, 1, 2]\n\n            ::\n\n                sage: s[3,2].counit().parent() == s[3,2].convolution_product().parent()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "maps",
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.bialgebras.Bialgebras",
            "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of bialgebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = BialgebrasWithBasis(QQ); C\n        Category of bialgebras with basis over Rational Field\n\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras with basis over Rational Field,\n         Category of bialgebras over Rational Field,\n         Category of coalgebras with basis over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(BialgebrasWithBasis(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.bialgebras_with_basis.BialgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "convolution_product": {
                    "__doc__": "\n            Return the convolution product (a map) of the given maps.\n\n            Let `A` and `B` be bialgebras over a commutative ring `R`.\n            Given maps `f_i : A \\to B` for `1 \\leq i < n`, define the\n            convolution product\n\n            .. MATH::\n\n                (f_1 * f_2 * \\cdots * f_n) := \\mu^{(n-1)} \\circ (f_1 \\otimes\n                f_2 \\otimes \\cdots \\otimes f_n) \\circ \\Delta^{(n-1)},\n\n            where `\\Delta^{(k)} := \\bigl(\\Delta \\otimes\n            \\mathrm{Id}^{\\otimes(k-1)}\\bigr) \\circ \\Delta^{(k-1)}`,\n            with `\\Delta^{(1)} = \\Delta` (the ordinary coproduct in `A`) and\n            `\\Delta^{(0)} = \\mathrm{Id}`; and with `\\mu^{(k)} := \\mu \\circ\n            \\bigl(\\mu^{(k-1)} \\otimes \\mathrm{Id})` and `\\mu^{(1)} = \\mu`\n            (the ordinary product in `B`). See [Sw1969]_.\n\n            (In the literature, one finds, e.g., `\\Delta^{(2)}` for what we\n            denote above as `\\Delta^{(1)}`. See [KMN2012]_.)\n\n            INPUT:\n\n            - ``maps`` -- any number `n \\geq 0` of linear maps `f_1, f_2,\n              \\ldots, f_n` on ``self``; or a single ``list`` or ``tuple``\n              of such maps\n\n            OUTPUT:\n\n            - the new map `f_1 * f_2 * \\cdots * f_2` representing their\n              convolution product\n\n            .. SEEALSO::\n\n                :meth:`sage.categories.bialgebras.ElementMethods.convolution_product`\n\n            AUTHORS:\n\n            - Aaron Lauve - 12 June 2015 - Sage Days 65\n\n            .. TODO::\n\n                Remove dependency on ``modules_with_basis`` methods.\n\n            EXAMPLES:\n\n            We construct some maps: the identity, the antipode and\n            projection onto the homogeneous componente of degree 2::\n\n                sage: Id = lambda x: x\n                sage: Antipode = lambda x: x.antipode()\n                sage: Proj2 = lambda x: x.parent().sum_of_terms([(m, c) for (m, c) in x if m.size() == 2])\n\n            Compute the convolution product of the identity with itself and\n            with the projection ``Proj2`` on the Hopf algebra of\n            non-commutative symmetric functions::\n\n                sage: R = NonCommutativeSymmetricFunctions(QQ).ribbon()\n                sage: T = R.convolution_product([Id, Id])\n                sage: [T(R(comp)) for comp in Compositions(3)]\n                [4*R[1, 1, 1] + R[1, 2] + R[2, 1],\n                 2*R[1, 1, 1] + 4*R[1, 2] + 2*R[2, 1] + 2*R[3],\n                 2*R[1, 1, 1] + 2*R[1, 2] + 4*R[2, 1] + 2*R[3],\n                 R[1, 2] + R[2, 1] + 4*R[3]]\n                sage: T = R.convolution_product(Proj2, Id)\n                sage: [T(R([i])) for i in range(1, 5)]\n                [0, R[2], R[2, 1] + R[3], R[2, 2] + R[4]]\n\n            Compute the convolution product of no maps on the Hopf algebra of\n            symmetric functions in non-commuting variables. This is the\n            composition of the counit with the unit::\n\n                sage: m = SymmetricFunctionsNonCommutingVariables(QQ).m()\n                sage: T = m.convolution_product()\n                sage: [T(m(lam)) for lam in SetPartitions(0).list() + SetPartitions(2).list()]\n                [m{}, 0, 0]\n\n            Compute the convolution product of the projection ``Proj2`` with\n            the identity on the Hopf algebra of symmetric functions in\n            non-commuting variables::\n\n                sage: T = m.convolution_product(Proj2, Id)\n                sage: [T(m(lam)) for lam in SetPartitions(3)]\n                [0,\n                 m{{1, 2}, {3}} + m{{1, 2, 3}},\n                 m{{1, 2}, {3}} + m{{1, 2, 3}},\n                 m{{1, 2}, {3}} + m{{1, 2, 3}},\n                 3*m{{1}, {2}, {3}} + 3*m{{1}, {2, 3}} + 3*m{{1, 3}, {2}}]\n\n            Compute the convolution product of the antipode with itself and the\n            identity map on group algebra of the symmetric group::\n\n                sage: G = SymmetricGroup(3)\n                sage: QG = GroupAlgebra(G, QQ)\n                sage: x = QG.sum_of_terms([(p,p.number_of_peaks() + p.number_of_inversions()) for p in Permutations(3)]); x\n                2*[1, 3, 2] + [2, 1, 3] + 3*[2, 3, 1] + 2*[3, 1, 2] + 3*[3, 2, 1]\n                sage: T = QG.convolution_product(Antipode, Antipode, Id)\n                sage: T(x)\n                2*[1, 3, 2] + [2, 1, 3] + 2*[2, 3, 1] + 3*[3, 1, 2] + 3*[3, 2, 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "maps",
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "adams_operator": {
                    "__doc__": "\n            Compute the `n`-th convolution power of the identity morphism\n            `\\mathrm{Id}` on ``self``.\n\n            INPUT:\n\n            - ``n`` -- a nonnegative integer\n\n            OUTPUT:\n\n            - the image of ``self`` under the convolution power `\\mathrm{Id}^{*n}`\n\n            .. NOTE::\n\n                In the literature, this is also called a Hopf power or\n                Sweedler power, cf. [AL2015]_.\n\n            .. SEEALSO::\n\n                :meth:`sage.categories.bialgebras.ElementMethods.convolution_product`\n\n            REFERENCES:\n\n            .. [AL2015] *The characteristic polynomial of the Adams operators\n               on graded connected Hopf algebras*.\n               Marcelo Aguiar and Aaron Lauve.\n               Algebra Number Theory, v.9, 2015, n.3, 2015.\n\n            .. TODO::\n\n                Remove dependency on ``modules_with_basis`` methods.\n\n            EXAMPLES::\n\n                sage: h = SymmetricFunctions(QQ).h()\n                sage: h[5].adams_operator(2)\n                2*h[3, 2] + 2*h[4, 1] + 2*h[5]\n                sage: h[5].plethysm(2*h[1])\n                2*h[3, 2] + 2*h[4, 1] + 2*h[5]\n                sage: h([]).adams_operator(0)\n                h[]\n                sage: h([]).adams_operator(1)\n                h[]\n                sage: h[3,2].adams_operator(0)\n                0\n                sage: h[3,2].adams_operator(1)\n                h[3, 2]\n\n            ::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S[4].adams_operator(5)\n                5*S[1, 1, 1, 1] + 10*S[1, 1, 2] + 10*S[1, 2, 1] + 10*S[1, 3] + 10*S[2, 1, 1] + 10*S[2, 2] + 10*S[3, 1] + 5*S[4]\n\n\n            ::\n\n                sage: m = SymmetricFunctionsNonCommutingVariables(QQ).m()\n                sage: m[[1,3],[2]].adams_operator(-2)\n                3*m{{1}, {2, 3}} + 3*m{{1, 2}, {3}} + 6*m{{1, 2, 3}} - 2*m{{1, 3}, {2}}\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "convolution_product": {
                    "__doc__": "\n            Return the image of ``self`` under the convolution product (map) of\n            the maps.\n\n            Let `A` and `B` be bialgebras over a commutative ring `R`.\n            Given maps `f_i : A \\to B` for `1 \\leq i < n`, define the\n            convolution product\n\n            .. MATH::\n\n                (f_1 * f_2 * \\cdots * f_n) := \\mu^{(n-1)} \\circ (f_1 \\otimes\n                f_2 \\otimes \\cdots \\otimes f_n) \\circ \\Delta^{(n-1)},\n\n            where `\\Delta^{(k)} := \\bigl(\\Delta \\otimes\n            \\mathrm{Id}^{\\otimes(k-1)}\\bigr) \\circ \\Delta^{(k-1)}`,\n            with `\\Delta^{(1)} = \\Delta` (the ordinary coproduct in `A`) and\n            `\\Delta^{(0)} = \\mathrm{Id}`; and with `\\mu^{(k)} := \\mu \\circ\n            \\bigl(\\mu^{(k-1)} \\otimes \\mathrm{Id})` and `\\mu^{(1)} = \\mu`\n            (the ordinary product in `B`). See [Sw1969]_.\n\n            (In the literature, one finds, e.g., `\\Delta^{(2)}` for what we\n            denote above as `\\Delta^{(1)}`. See [KMN2012]_.)\n\n            INPUT:\n\n            - ``maps`` -- any number `n \\geq 0` of linear maps `f_1, f_2,\n              \\ldots, f_n` on ``self.parent()``; or a single ``list`` or\n              ``tuple`` of such maps\n\n            OUTPUT:\n\n            - the convolution product of ``maps`` applied to ``self``\n\n            REFERENCES:\n\n            .. [KMN2012] On the trace of the antipode and higher indicators.\n               Yevgenia Kashina and Susan Montgomery and Richard Ng.\n               Israel J. Math., v.188, 2012.\n\n            .. [Sw1969] Hopf algebras.\n               Moss Sweedler.\n               W.A. Benjamin, Math Lec Note Ser., 1969.\n\n            AUTHORS:\n\n            - Amy Pang - 12 June 2015 - Sage Days 65\n\n            .. TODO::\n\n                Remove dependency on ``modules_with_basis`` methods.\n\n            EXAMPLES:\n\n            We compute convolution products of the identity and antipode maps\n            on Schur functions::\n\n                sage: Id = lambda x: x\n                sage: Antipode = lambda x: x.antipode()\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: s[3].convolution_product(Id, Id)\n                2*s[2, 1] + 4*s[3]\n                sage: s[3,2].convolution_product(Id) == s[3,2]\n                True\n\n            The method accepts multiple arguments, or a single argument\n            consisting of a list of maps::\n\n                sage: s[3,2].convolution_product(Id, Id)\n                2*s[2, 1, 1, 1] + 6*s[2, 2, 1] + 6*s[3, 1, 1] + 12*s[3, 2] + 6*s[4, 1] + 2*s[5]\n                sage: s[3,2].convolution_product([Id, Id])\n                2*s[2, 1, 1, 1] + 6*s[2, 2, 1] + 6*s[3, 1, 1] + 12*s[3, 2] + 6*s[4, 1] + 2*s[5]\n\n            We test the defining property of the antipode morphism; namely,\n            that the antipode is the inverse of the identity map in the\n            convolution algebra whose identity element is the composition of\n            the counit and unit::\n\n                sage: s[3,2].convolution_product() == s[3,2].convolution_product(Antipode, Id) == s[3,2].convolution_product(Id, Antipode)\n                True\n\n            ::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,1].convolution_product(Id, Id, Id)\n                3*Psi[1, 2] + 6*Psi[2, 1]\n                sage: (Psi[5,1] - Psi[1,5]).convolution_product(Id, Id, Id)\n                -3*Psi[1, 5] + 3*Psi[5, 1]\n\n            ::\n\n                sage: G = SymmetricGroup(3)\n                sage: QG = GroupAlgebra(G,QQ)\n                sage: x = QG.sum_of_terms([(p,p.length()) for p in Permutations(3)]); x\n                [1, 3, 2] + [2, 1, 3] + 2*[2, 3, 1] + 2*[3, 1, 2] + 3*[3, 2, 1]\n                sage: x.convolution_product(Id, Id)\n                5*[1, 2, 3] + 2*[2, 3, 1] + 2*[3, 1, 2]\n                sage: x.convolution_product(Id, Id, Id)\n                4*[1, 2, 3] + [1, 3, 2] + [2, 1, 3] + 3*[3, 2, 1]\n                sage: x.convolution_product([Id]*6)\n                9*[1, 2, 3]\n\n            TESTS::\n\n                sage: Id = lambda x: x\n                sage: Antipode = lambda x: x.antipode()\n\n            ::\n\n                sage: h = SymmetricFunctions(QQ).h()\n                sage: h[5].convolution_product([Id, Id])\n                2*h[3, 2] + 2*h[4, 1] + 2*h[5]\n                sage: h.one().convolution_product([Id, Antipode])\n                h[]\n                sage: h[3,2].convolution_product([Id, Antipode])\n                0\n                sage: h.one().convolution_product([Id, Antipode]) == h.one().convolution_product()\n                True\n\n            ::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S[4].convolution_product([Id]*5)\n                5*S[1, 1, 1, 1] + 10*S[1, 1, 2] + 10*S[1, 2, 1] + 10*S[1, 3]\n                 + 10*S[2, 1, 1] + 10*S[2, 2] + 10*S[3, 1] + 5*S[4]\n\n            ::\n\n                sage: m = SymmetricFunctionsNonCommutingVariables(QQ).m()\n                sage: m[[1,3],[2]].convolution_product([Antipode, Antipode])\n                3*m{{1}, {2, 3}} + 3*m{{1, 2}, {3}} + 6*m{{1, 2, 3}} - 2*m{{1, 3}, {2}}\n                sage: m[[]].convolution_product([])\n                m{}\n                sage: m[[1,3],[2]].convolution_product([])\n                0\n\n            ::\n\n                sage: QS = SymmetricGroupAlgebra(QQ, 5)\n                sage: x = QS.sum_of_terms(zip(Permutations(5)[3:6],[1,2,3])); x\n                [1, 2, 4, 5, 3] + 2*[1, 2, 5, 3, 4] + 3*[1, 2, 5, 4, 3]\n                sage: x.convolution_product([Antipode, Id])\n                6*[1, 2, 3, 4, 5]\n                sage: x.convolution_product(Id, Antipode, Antipode, Antipode)\n                3*[1, 2, 3, 4, 5] + [1, 2, 4, 5, 3] + 2*[1, 2, 5, 3, 4]\n\n            ::\n\n                sage: G = SymmetricGroup(3)\n                sage: QG = GroupAlgebra(G,QQ)\n                sage: x = QG.sum_of_terms([(p,p.length()) for p in Permutations(3)]); x\n                [1, 3, 2] + [2, 1, 3] + 2*[2, 3, 1] + 2*[3, 1, 2] + 3*[3, 2, 1]\n                sage: x.convolution_product(Antipode, Id)\n                9*[1, 2, 3]\n                sage: x.convolution_product([Id, Antipode, Antipode, Antipode])\n                5*[1, 2, 3] + 2*[2, 3, 1] + 2*[3, 1, 2]\n\n            ::\n\n                sage: s[3,2].counit().parent() == s[3,2].convolution_product().parent()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "maps",
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of domains\n\n    A domain (or non-commutative integral domain), is a ring, not\n    necessarily commutative, with no nonzero zero divisors.\n\n    EXAMPLES::\n\n        sage: C = Domains(); C\n        Category of domains\n        sage: C.super_categories()\n        [Category of rings]\n        sage: C is Rings().NoZeroDivisors()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.rings.Rings"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of domains\n\n    A domain (or non-commutative integral domain), is a ring, not\n    necessarily commutative, with no nonzero zero divisors.\n\n    EXAMPLES::\n\n        sage: C = Domains(); C\n        Category of domains\n        sage: C.super_categories()\n        [Category of rings]\n        sage: C is Rings().NoZeroDivisors()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.domains.Domains",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_zero_divisors": {
                    "__doc__": "\n            Check to see that there are no zero divisors.\n\n            .. NOTE::\n\n                In rings whose elements can not be represented exactly, there\n                may be zero divisors in practice, even though these rings do\n                not have them in theory. For such inexact rings, these tests\n                are not performed:\n\n                sage: R = ZpFM(5); R\n                5-adic Ring of fixed modulus 5^20\n                sage: R.is_exact()\n                False\n                sage: a = R(5^19)\n                sage: a.is_zero()\n                False\n                sage: (a*a).is_zero()\n                True\n                sage: R._test_zero_divisors()\n\n            EXAMPLES::\n\n                sage: ZZ._test_zero_divisors()\n                sage: ZpFM(5)._test_zero_divisors()\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite permutation groups, i.e. groups concretely\n    represented as groups of permutations acting on a finite set.\n\n    It is currently assumed that any finite permutation group comes\n    endowed with a distinguished finite set of generators (method\n    ``group_generators``); this is the case for all the existing\n    implementations in Sage.\n\n    EXAMPLES::\n\n        sage: C = PermutationGroups().Finite(); C\n        Category of finite permutation groups\n        sage: C.super_categories()\n        [Category of permutation groups,\n         Category of finite groups,\n         Category of finite finitely generated semigroups]\n\n        sage: C.example()\n        Dihedral group of order 6 as a permutation group\n\n    TESTS::\n\n        sage: C is FinitePermutationGroups()\n        True\n        sage: TestSuite(C).run()\n\n        sage: G = FinitePermutationGroups().example()\n        sage: TestSuite(G).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_inverse() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n    ",
        "axioms": [
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Unital",
            "Finite",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.permutation_groups.PermutationGroups",
            "sage.categories.finite_groups.FiniteGroups",
            "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite permutation groups, i.e. groups concretely\n    represented as groups of permutations acting on a finite set.\n\n    It is currently assumed that any finite permutation group comes\n    endowed with a distinguished finite set of generators (method\n    ``group_generators``); this is the case for all the existing\n    implementations in Sage.\n\n    EXAMPLES::\n\n        sage: C = PermutationGroups().Finite(); C\n        Category of finite permutation groups\n        sage: C.super_categories()\n        [Category of permutation groups,\n         Category of finite groups,\n         Category of finite finitely generated semigroups]\n\n        sage: C.example()\n        Dihedral group of order 6 as a permutation group\n\n    TESTS::\n\n        sage: C is FinitePermutationGroups()\n        True\n        sage: TestSuite(C).run()\n\n        sage: G = FinitePermutationGroups().example()\n        sage: TestSuite(G).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_inverse() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_permutation_groups.FinitePermutationGroups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "cycle_index": {
                    "__doc__": "\n            INPUT:\n\n             - ``self`` - a permutation group `G`\n             - ``parent`` -- a free module with basis indexed by partitions,\n               or behave as such, with a ``term`` and ``sum`` method\n               (default: the symmetric functions over the rational field in the p basis)\n\n            Returns the *cycle index* of `G`, which is a gadget counting\n            the elements of `G` by cycle type, averaged over the group:\n\n            .. math::\n\n                P = \\frac{1}{|G|} \\sum_{g\\in G} p_{ \\operatorname{cycle\\ type}(g) }\n\n            EXAMPLES:\n\n            Among the permutations of the symmetric group `S_4`, there is\n            the identity, 6 cycles of length 2, 3 products of two cycles\n            of length 2, 8 cycles of length 3, and 6 cycles of length 4::\n\n                sage: S4 = SymmetricGroup(4)\n                sage: P = S4.cycle_index()\n                sage: 24 * P\n                p[1, 1, 1, 1] + 6*p[2, 1, 1] + 3*p[2, 2] + 8*p[3, 1] + 6*p[4]\n\n            If `l = (l_1,\\dots,l_k)` is a partition, ``|G| P[l]`` is the number\n            of elements of `G` with cycles of length `(p_1,\\dots,p_k)`::\n\n                sage: 24 * P[ Partition([3,1]) ]\n                8\n\n            The cycle index plays an important role in the enumeration of\n            objects modulo the action of a group (Polya enumeration), via\n            the use of symmetric functions and plethysms. It is therefore\n            encoded as a symmetric function, expressed in the powersum\n            basis::\n\n                sage: P.parent()\n                Symmetric Functions over Rational Field in the powersum basis\n\n            This symmetric function can have some nice properties; for\n            example, for the symmetric group `S_n`, we get the complete\n            symmetric function `h_n`::\n\n                sage: S = SymmetricFunctions(QQ); h = S.h()\n                sage: h( P )\n                h[4]\n\n            TODO: add some simple examples of Polya enumeration, once it\n            will be easy to expand symmetric functions on any alphabet.\n\n            Here are the cycle indices of some permutation groups::\n\n                sage: 6 * CyclicPermutationGroup(6).cycle_index()\n                p[1, 1, 1, 1, 1, 1] + p[2, 2, 2] + 2*p[3, 3] + 2*p[6]\n\n                sage: 60 * AlternatingGroup(5).cycle_index()\n                p[1, 1, 1, 1, 1] + 15*p[2, 2, 1] + 20*p[3, 1, 1] + 24*p[5]\n\n                sage: for G in TransitiveGroups(5):               # optional - database_gap # long time\n                ...       G.cardinality() * G.cycle_index()\n                p[1, 1, 1, 1, 1] + 4*p[5]\n                p[1, 1, 1, 1, 1] + 5*p[2, 2, 1] + 4*p[5]\n                p[1, 1, 1, 1, 1] + 5*p[2, 2, 1] + 10*p[4, 1] + 4*p[5]\n                p[1, 1, 1, 1, 1] + 15*p[2, 2, 1] + 20*p[3, 1, 1] + 24*p[5]\n                p[1, 1, 1, 1, 1] + 10*p[2, 1, 1, 1] + 15*p[2, 2, 1] + 20*p[3, 1, 1] + 20*p[3, 2] + 30*p[4, 1] + 24*p[5]\n\n            One may specify another parent for the result::\n\n                sage: F = CombinatorialFreeModule(QQ, Partitions())\n                sage: P = CyclicPermutationGroup(6).cycle_index(parent = F)\n                sage: 6 * P\n                B[[1, 1, 1, 1, 1, 1]] + B[[2, 2, 2]] + 2*B[[3, 3]] + 2*B[[6]]\n                sage: P.parent() is F\n                True\n\n            This parent should have a ``term`` and ``sum`` method::\n\n                sage: CyclicPermutationGroup(6).cycle_index(parent = QQ)\n                Traceback (most recent call last):\n                  ...\n                AssertionError: `parent` should be (or behave as) a free module with basis indexed by partitions\n\n            REFERENCES:\n\n             .. [Ker1991] \\A. Kerber. Algebraic combinatorics via finite group actions, 2.2 p. 70.\n               BI-Wissenschaftsverlag, Mannheim, 1991.\n\n            AUTHORS:\n\n             - Nicolas Borie and Nicolas M. Thiery\n\n            TESTS::\n\n                sage: P = PermutationGroup([]); P\n                Permutation Group with generators [()]\n                sage: P.cycle_index()\n                p[1]\n                sage: P = PermutationGroup([[(1)]]); P\n                Permutation Group with generators [()]\n                sage: P.cycle_index()\n                p[1]\n            ",
                    "args": [
                        "self",
                        "parent"
                    ],
                    "argspec": [
                        [
                            "self",
                            "parent"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.permutation_groups.PermutationGroups",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of highest weight crystals.\n\n    A crystal is highest weight if it is acyclic; in particular, every\n    connected component has a unique highest weight element, and that\n    element generate the component.\n\n    EXAMPLES::\n\n        sage: C = HighestWeightCrystals()\n        sage: C\n        Category of highest weight crystals\n        sage: C.super_categories()\n        [Category of crystals]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = HighestWeightCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.crystals.Crystals"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of highest weight crystals.\n\n    A crystal is highest weight if it is acyclic; in particular, every\n    connected component has a unique highest weight element, and that\n    element generate the component.\n\n    EXAMPLES::\n\n        sage: C = HighestWeightCrystals()\n        sage: C\n        Category of highest weight crystals\n        sage: C.super_categories()\n        [Category of crystals]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = HighestWeightCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
            "methods": {}
        },
        "name": "sage.categories.highest_weight_crystals.HighestWeightCrystals",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "highest_weight_vector": {
                    "__doc__": "\n            Returns the highest weight vector if there is a single one;\n            otherwise, raises an error.\n\n            Caveat: this assumes that :meth:`.highest_weight_vectors`\n            returns a list or tuple.\n\n            EXAMPLES::\n\n                sage: C = crystals.Letters(['A',5])\n                sage: C.highest_weight_vector()\n                1\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "highest_weight_vectors": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "lowest_weight_vectors": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "q_dimension": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.crystals.Crystals",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of Coxeter groups.\n\n    A *Coxeter group* is a group `W` with a distinguished (finite)\n    family of involutions `(s_i)_{i\\in I}`, called the *simple\n    reflections*, subject to relations of the form `(s_is_j)^{m_{i,j}} = 1`.\n\n    `I` is the *index set* of `W` and `|I|` is the *rank* of `W`.\n\n    See :Wikipedia:`Coxeter_group` for details.\n\n    EXAMPLES::\n\n        sage: C = CoxeterGroups(); C\n        Category of coxeter groups\n        sage: C.super_categories()\n        [Category of generalized coxeter groups]\n\n        sage: W = C.example(); W\n        The symmetric group on {0, ..., 3}\n\n        sage: W.simple_reflections()\n        Finite family {0: (1, 0, 2, 3), 1: (0, 2, 1, 3), 2: (0, 1, 3, 2)}\n\n    Here are some further examples::\n\n        sage: FiniteCoxeterGroups().example()\n        The 5-th dihedral group of order 10\n        sage: FiniteWeylGroups().example()\n        The symmetric group on {0, ..., 3}\n        sage: WeylGroup([\"B\", 3])\n        Weyl Group of type ['B', 3] (as a matrix group acting on the ambient space)\n\n    Those will eventually be also in this category::\n\n        sage: SymmetricGroup(4)\n        Symmetric group of order 4! as a permutation group\n        sage: DihedralGroup(5)\n        Dihedral group of order 10 as a permutation group\n\n    .. TODO:: add a demo of usual computations on Coxeter groups.\n\n    .. SEEALSO::\n\n        - :mod:`sage.combinat.root_system`\n        - :class:`WeylGroups`\n        - :class:`GeneralizedCoxeterGroups`\n\n    .. WARNING::\n\n        It is assumed that morphisms in this category preserve the\n        distinguished choice of simple reflections. In particular,\n        subobjects in this category are parabolic subgroups. In this\n        sense, this category might be better named ``Coxeter\n        Systems``. In the long run we might want to have two distinct\n        categories, one for Coxeter groups (with morphisms being just\n        group morphisms) and one for Coxeter systems::\n\n            sage: CoxeterGroups().is_full_subcategory(Groups())\n            False\n            sage: from sage.categories.generalized_coxeter_groups import GeneralizedCoxeterGroups\n            sage: CoxeterGroups().is_full_subcategory(GeneralizedCoxeterGroups())\n            True\n\n    TESTS::\n\n        sage: W = CoxeterGroups().example()\n        sage: TestSuite(W).run()\n    ",
        "axioms": [
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "absolute_covers": {
                    "__doc__": "\n            Return the list of covers of ``self`` in absolute order.\n\n            .. SEEALSO::\n\n                :meth:`absolute_length`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup([\"A\", 3])\n                sage: s = W.simple_reflections()\n                sage: w0 = s[1]\n                sage: w1 = s[1]*s[2]*s[3]\n                sage: w0.absolute_covers()\n                [\n                [0 0 1 0]  [0 1 0 0]  [0 0 0 1]  [0 1 0 0]  [0 1 0 0]\n                [1 0 0 0]  [1 0 0 0]  [1 0 0 0]  [0 0 1 0]  [0 0 0 1]\n                [0 1 0 0]  [0 0 0 1]  [0 0 1 0]  [1 0 0 0]  [0 0 1 0]\n                [0 0 0 1], [0 0 1 0], [0 1 0 0], [0 0 0 1], [1 0 0 0]\n                ]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "absolute_le": {
                    "__doc__": "\n            Return whether ``self`` is smaller than ``other`` in the absolute\n            order.\n\n            A general reflection is an element of the form `w s_i w^{-1}`,\n            where `s_i` is a simple reflection. The absolute order is defined\n            analogously to the weak order but using general reflections rather\n            than just simple reflections.\n\n            This partial order can be used to define noncrossing partitions\n            associated with this Coxeter group.\n\n            .. SEEALSO::\n\n                :meth:`absolute_length`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup([\"A\", 3])\n                sage: s = W.simple_reflections()\n                sage: w0 = s[1]\n                sage: w1 = s[1]*s[2]*s[3]\n                sage: w0.absolute_le(w1)\n                True\n                sage: w1.absolute_le(w0)\n                False\n                sage: w1.absolute_le(w1)\n                True\n            ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "absolute_length": {
                    "__doc__": "\n            Return the absolute length of ``self``.\n\n            The absolute length is the length of the shortest expression\n            of the element as a product of reflections.\n\n            For permutations in the symmetric groups, the absolute\n            length is the size minus the number of its disjoint\n            cycles.\n\n            .. SEEALSO::\n\n                :meth:`absolute_le`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup([\"A\", 3])\n                sage: s = W.simple_reflections()\n                sage: (s[1]*s[2]*s[3]).absolute_length()\n                3\n\n                sage: W = SymmetricGroup(4)\n                sage: s = W.simple_reflections()\n                sage: (s[3]*s[2]*s[1]).absolute_length()\n                3\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "apply_demazure_product": {
                    "__doc__": "\n            Returns the Demazure or 0-Hecke product of ``self`` with another Coxeter group element.\n\n            See :meth:`CoxeterGroups.ParentMethods.simple_projections`.\n\n            INPUT:\n\n            - ``element`` -- either an element of the same Coxeter\n                group as ``self`` or a tuple or a list (such as a\n                reduced word) of elements from the index set of the\n                Coxeter group.\n\n            - ``side`` -- 'left' or 'right' (default: 'right'); the\n                side of ``self`` on which the element should be\n                applied. If ``side`` is 'left' then the operation is\n                applied on the left.\n\n            - ``length_increasing`` -- a boolean (default True)\n                whether to act length increasingly or decreasingly\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['C',4],prefix=\"s\")\n                sage: v = W.from_reduced_word([1,2,3,4,3,1])\n                sage: v.apply_demazure_product([1,3,4,3,3])\n                s4*s1*s2*s3*s4*s3*s1\n                sage: v.apply_demazure_product([1,3,4,3],side='left')\n                s3*s4*s1*s2*s3*s4*s2*s3*s1\n                sage: v.apply_demazure_product((1,3,4,3),side='left')\n                s3*s4*s1*s2*s3*s4*s2*s3*s1\n                sage: v.apply_demazure_product(v)\n                s2*s3*s4*s1*s2*s3*s4*s2*s3*s2*s1\n\n            ",
                    "args": [
                        "self",
                        "element",
                        "side",
                        "length_increasing"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element",
                            "side",
                            "length_increasing"
                        ],
                        null,
                        null,
                        [
                            "right",
                            true
                        ]
                    ]
                },
                "apply_simple_projection": {
                    "__doc__": "\n            INPUT:\n\n            - ``i`` - an element of the index set of the Coxeter group\n            - ``side`` - 'left' or 'right' (default: 'right')\n            - ``length_increasing`` - a boolean (default: True) specifying\n              the direction of the projection\n\n            Returns the result of the application of the simple\n            projection `\\pi_i` (resp. `\\overline\\pi_i`) on ``self``.\n\n            See :meth:`CoxeterGroups.ParentMethods.simple_projections`\n            for the definition of the simple projections.\n\n            EXAMPLE::\n\n                sage: W=CoxeterGroups().example()\n                sage: w=W.an_element()\n                sage: w\n                (1, 2, 3, 0)\n                sage: w.apply_simple_projection(2)\n                (1, 2, 3, 0)\n                sage: w.apply_simple_projection(2, length_increasing=False)\n                (1, 2, 0, 3)\n                sage: W = WeylGroup(['C',4],prefix=\"s\")\n                sage: v = W.from_reduced_word([1,2,3,4,3,1])\n                sage: v\n                s1*s2*s3*s4*s3*s1\n                sage: v.apply_simple_projection(2)\n                s1*s2*s3*s4*s3*s1*s2\n                sage: v.apply_simple_projection(2, side='left')\n                s1*s2*s3*s4*s3*s1\n                sage: v.apply_simple_projection(1, length_increasing = False)\n                s1*s2*s3*s4*s3\n\n            ",
                    "args": [
                        "self",
                        "i",
                        "side",
                        "length_increasing"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "side",
                            "length_increasing"
                        ],
                        null,
                        null,
                        [
                            "right",
                            true
                        ]
                    ]
                },
                "binary_factorizations": {
                    "__doc__": "\n            Returns the set of all the factorizations `self = u v` such\n            that `l(self) = l(u) + l(v)`.\n\n            Iterating through this set is Constant Amortized Time\n            (counting arithmetic operations in the Coxeter group as\n            constant time) complexity, and memory linear in the length\n            of `self`.\n\n            One can pass as optional argument a predicate p such that\n            `p(u)` implies `p(u')` for any `u` left factor of `self`\n            and `u'` left factor of `u`. Then this returns only the\n            factorizations `self = uv` such `p(u)` holds.\n\n            EXAMPLES:\n\n            We construct the set of all factorizations of the maximal\n            element of the group::\n\n                sage: W = WeylGroup(['A',3])\n                sage: s = W.simple_reflections()\n                sage: w0 = W.from_reduced_word([1,2,3,1,2,1])\n                sage: w0.binary_factorizations().cardinality()\n                24\n\n            The same number of factorizations, by bounded length::\n\n                sage: [w0.binary_factorizations(lambda u: u.length() <= l).cardinality() for l in [-1,0,1,2,3,4,5,6]]\n                [0, 1, 4, 9, 15, 20, 23, 24]\n\n            The number of factorizations of the elements just below\n            the maximal element::\n\n                sage: [(s[i]*w0).binary_factorizations().cardinality() for i in [1,2,3]]\n                [12, 12, 12]\n                sage: w0.binary_factorizations(lambda u: False).cardinality()\n                0\n\n            TESTS::\n\n                sage: w0.binary_factorizations().category()\n                Category of finite enumerated sets\n            ",
                    "args": [
                        "self",
                        "predicate"
                    ],
                    "argspec": [
                        [
                            "self",
                            "predicate"
                        ],
                        null,
                        null,
                        [
                            "The constant function (...) -> True"
                        ]
                    ]
                },
                "bruhat_le": {},
                "bruhat_lower_covers": {},
                "bruhat_lower_covers_reflections": {},
                "bruhat_upper_covers": {},
                "bruhat_upper_covers_reflections": {},
                "canonical_matrix": {
                    "__doc__": "\n            Return the matrix of ``self`` in the canonical faithful\n            representation.\n\n            This is an `n`-dimension real faithful essential representation,\n            where `n` is the number of generators of the Coxeter group.\n            Note that this is not always the most natural matrix\n            representation, for instance in type `A_n`.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup([\"A\", 3])\n                sage: s = W.simple_reflections()\n                sage: (s[1]*s[2]*s[3]).canonical_matrix()\n                [ 0  0 -1]\n                [ 1  0 -1]\n                [ 0  1 -1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coset_representative": {
                    "__doc__": "\n            INPUT:\n\n            - ``index_set`` - a subset (or iterable) of the nodes of the Dynkin diagram\n            - ``side`` - 'left' or 'right'\n\n            Returns the unique shortest element of the Coxeter group\n            $W$ which is in the same left (resp. right) coset as\n            ``self``, with respect to the parabolic subgroup $W_I$.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example(5)\n                sage: s = W.simple_reflections()\n                sage: w = s[2]*s[1]*s[3]\n                sage: w.coset_representative([]).reduced_word()\n                [2, 3, 1]\n                sage: w.coset_representative([1]).reduced_word()\n                [2, 3]\n                sage: w.coset_representative([1,2]).reduced_word()\n                [2, 3]\n                sage: w.coset_representative([1,3]                 ).reduced_word()\n                [2]\n                sage: w.coset_representative([2,3]                 ).reduced_word()\n                [2, 1]\n                sage: w.coset_representative([1,2,3]               ).reduced_word()\n                []\n                sage: w.coset_representative([],      side = 'left').reduced_word()\n                [2, 3, 1]\n                sage: w.coset_representative([1],     side = 'left').reduced_word()\n                [2, 3, 1]\n                sage: w.coset_representative([1,2],   side = 'left').reduced_word()\n                [3]\n                sage: w.coset_representative([1,3],   side = 'left').reduced_word()\n                [2, 3, 1]\n                sage: w.coset_representative([2,3],   side = 'left').reduced_word()\n                [1]\n                sage: w.coset_representative([1,2,3], side = 'left').reduced_word()\n                []\n\n            ",
                    "args": [
                        "self",
                        "index_set",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "cover_reflections": {
                    "__doc__": "\n            Returns the set of reflections ``t`` such that ``self`` ``t`` covers ``self``.\n\n            If ``side`` is 'left', ``t`` ``self`` covers ``self``.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',4], prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.cover_reflections()\n                [s3, s2*s3*s2, s4, s1*s2*s3*s4*s3*s2*s1]\n                sage: w.cover_reflections(side = 'left')\n                [s4, s2, s1*s2*s1, s3*s4*s3]\n\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "coxeter_sorting_word": {
                    "__doc__": "\n            Return the ``c``-sorting word of ``self``.\n\n            For a Coxeter element `c` and an element `w`, the `c`-sorting\n            word of `w` is the lexicographic minimal reduced expression of\n            `w` in the infinite word `c^\\infty`.\n\n            INPUT:\n\n            - ``c``-- a Coxeter element.\n\n            OUTPUT:\n\n            the ``c``-sorting word of ``self`` as a list of integers.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: c = W.from_reduced_word([0,2,1])\n                sage: w = W.from_reduced_word([1,2,1,0,1])\n                sage: w.coxeter_sorting_word(c)\n                [2, 1, 2, 0, 1]\n            ",
                    "args": [
                        "self",
                        "c"
                    ],
                    "argspec": [
                        [
                            "self",
                            "c"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "deodhar_factor_element": {
                    "__doc__": "\n            Returns Deodhar's Bruhat order factoring element.\n\n            INPUT:\n\n            - ``w`` is an element of the same Coxeter group ``W`` as ``self``\n            - ``index_set`` is a subset of Dynkin nodes defining a parabolic subgroup ``W'`` of ``W``\n\n            It is assumed that ``v = self`` and ``w`` are minimum length coset representatives\n            for ``W/W'`` such that ``v`` $\\le$ ``w`` in Bruhat order.\n\n            OUTPUT:\n\n            Deodhar's element ``f(v,w)`` is the unique element of ``W'`` such that,\n            for all ``v'`` and ``w'`` in ``W'``, ``vv'`` $\\le$ ``ww'`` in ``W`` if and only if\n            ``v'`` $\\le$ ``f(v,w) * w'`` in ``W'`` where ``*`` is the Demazure product.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',5],prefix=\"s\")\n                sage: v = W.from_reduced_word([5])\n                sage: w = W.from_reduced_word([4,5,2,3,1,2])\n                sage: v.deodhar_factor_element(w,[1,3,4])\n                s3*s1\n                sage: W=WeylGroup(['C',2])\n                sage: w=W.from_reduced_word([2,1])\n                sage: w.deodhar_factor_element(W.from_reduced_word([2]),[1])\n                Traceback (most recent call last):\n                ...\n                ValueError: [2, 1] is not of minimum length in its coset for the parabolic subgroup with index set [1]\n\n            REFERENCES:\n\n                .. [Deodhar] \\V. Deodhar,  A splitting criterion for the Bruhat orderings on Coxeter groups. Comm. Algebra, 15:1889-1894, 1987.\n\n            ",
                    "args": [
                        "self",
                        "w",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "w",
                            "index_set"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "deodhar_lift_down": {
                    "__doc__": "\n            Letting ``v = self``, given a Bruhat relation ``v W'`` $\\ge$ ``w W'`` among cosets\n            with respect to the subgroup ``W'`` given by the Dynkin node subset ``index_set``,\n            returns the Bruhat-maximum lift ``x`` of ``wW'`` such that ``v`` $\\ge$ ``x``.\n\n            INPUT:\n\n            - ``w`` is an element of the same Coxeter group ``W`` as ``self``.\n            - ``index_set`` is a subset of Dynkin nodes defining a parabolic subgroup ``W'``.\n\n            OUTPUT:\n\n            The unique Bruhat-maximum element ``x`` in ``W`` such that ``x W' = w W'``\n            and ``v $\\ge$ ``x``.\n\n            .. SEEALSO:: :meth:`sage.categories.coxeter_groups.CoxeterGroups.ElementMethods.deodhar_lift_up`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3],prefix=\"s\")\n                sage: v = W.from_reduced_word([1,2,3,2])\n                sage: w = W.from_reduced_word([3,2])\n                sage: v.deodhar_lift_down(w, [3])\n                s2*s3*s2\n\n            ",
                    "args": [
                        "self",
                        "w",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "w",
                            "index_set"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "deodhar_lift_up": {
                    "__doc__": "\n            Letting ``v = self``, given a Bruhat relation ``v W'`` $\\le$ ``w W'`` among cosets\n            with respect to the subgroup ``W'`` given by the Dynkin node subset ``index_set``,\n            returns the Bruhat-minimum lift ``x`` of ``wW'`` such that ``v`` $\\le$ ``x``.\n\n            INPUT:\n\n            - ``w`` is an element of the same Coxeter group ``W`` as ``self``.\n            - ``index_set`` is a subset of Dynkin nodes defining a parabolic subgroup ``W'``.\n\n            OUTPUT:\n\n            The unique Bruhat-minimum element ``x`` in ``W`` such that ``x W' = w W'``\n            and ``v`` $\\le$ ``x``.\n\n            .. SEEALSO:: :meth:`sage.categories.coxeter_groups.CoxeterGroups.ElementMethods.deodhar_lift_down`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3],prefix=\"s\")\n                sage: v = W.from_reduced_word([1,2,3])\n                sage: w = W.from_reduced_word([1,3,2])\n                sage: v.deodhar_lift_up(w, [3])\n                s1*s2*s3*s2\n\n            ",
                    "args": [
                        "self",
                        "w",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "w",
                            "index_set"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "descents": {
                    "__doc__": "\n            INPUT:\n\n            - ``index_set`` - a subset (as a list or iterable) of the nodes of the Dynkin diagram;\n              (default: all of them)\n            - ``side`` - 'left' or 'right' (default: 'right')\n            - ``positive`` - a boolean (default: ``False``)\n\n            Returns the descents of self, as a list of elements of the\n            index_set.\n\n            The ``index_set`` option can be used to restrict to the\n            parabolic subgroup indexed by ``index_set``.\n\n            If positive is ``True``, then returns the non-descents\n            instead\n\n            TODO: find a better name for ``positive``: complement? non_descent?\n\n            Caveat: the return type may change to some other iterable\n            (tuple, ...) in the future. Please use keyword arguments\n            also, as the order of the arguments may change as well.\n\n            EXAMPLES::\n\n                sage: W=CoxeterGroups().example()\n                sage: s=W.simple_reflections()\n                sage: w=s[0]*s[1]\n                sage: w.descents()\n                [1]\n                sage: w=s[0]*s[2]\n                sage: w.descents()\n                [0, 2]\n\n                TODO: side, index_set, positive\n            ",
                    "args": [
                        "self",
                        "side",
                        "index_set",
                        "positive"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "index_set",
                            "positive"
                        ],
                        null,
                        null,
                        [
                            "right",
                            null,
                            false
                        ]
                    ]
                },
                "first_descent": {
                    "__doc__": "\n            Returns the first left (resp. right) descent of self, as\n            ane element of ``index_set``, or ``None`` if there is none.\n\n            See :meth:`.descents` for a description of the options.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: s = W.simple_reflections()\n                sage: w = s[2]*s[0]\n                sage: w.first_descent()\n                0\n                sage: w = s[0]*s[2]\n                sage: w.first_descent()\n                0\n                sage: w = s[0]*s[1]\n                sage: w.first_descent()\n                1\n            ",
                    "args": [
                        "self",
                        "side",
                        "index_set",
                        "positive"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "index_set",
                            "positive"
                        ],
                        null,
                        null,
                        [
                            "right",
                            null,
                            false
                        ]
                    ]
                },
                "has_descent": {
                    "__doc__": "\n            Returns whether i is a (left/right) descent of self.\n\n            See :meth:`.descents` for a description of the options.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: s = W.simple_reflections()\n                sage: w = s[0] * s[1] * s[2]\n                sage: w.has_descent(2)\n                True\n                sage: [ w.has_descent(i)                  for i in [0,1,2] ]\n                [False, False, True]\n                sage: [ w.has_descent(i, side = 'left')   for i in [0,1,2] ]\n                [True, False, False]\n                sage: [ w.has_descent(i, positive = True) for i in [0,1,2] ]\n                [True, True, False]\n\n            This default implementation delegates the work to\n            :meth:`.has_left_descent` and :meth:`.has_right_descent`.\n            ",
                    "args": [
                        "self",
                        "i",
                        "side",
                        "positive"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "side",
                            "positive"
                        ],
                        null,
                        null,
                        [
                            "right",
                            false
                        ]
                    ]
                },
                "has_full_support": {
                    "__doc__": "\n            Return whether ``self`` has full support.\n\n            An element is said to have full support if its support contains\n            all simple reflections.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: w = W.from_reduced_word([1,2,1])\n                sage: w.has_full_support()\n                False\n                sage: w = W.from_reduced_word([1,2,1,0,1])\n                sage: w.has_full_support()\n                True\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "has_left_descent": {
                    "__doc__": "\n            Returns whether `i` is a left descent of self.\n\n            This default implementation uses that a left descent of\n            `w` is a right descent of `w^{-1}`.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example(); W\n                The symmetric group on {0, ..., 3}\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.has_left_descent(0)\n                True\n                sage: w.has_left_descent(1)\n                False\n                sage: w.has_left_descent(2)\n                False\n\n            TESTS::\n\n                sage: w.has_left_descent.__module__\n                'sage.categories.coxeter_groups'\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "has_right_descent": {
                    "__doc__": "\n            Returns whether ``i`` is a right descent of self.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example(); W\n                The symmetric group on {0, ..., 3}\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.has_right_descent(0)\n                False\n                sage: w.has_right_descent(1)\n                False\n                sage: w.has_right_descent(2)\n                True\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "inversions_as_reflections": {},
                "is_coxeter_sortable": {
                    "__doc__": "\n            Return whether ``self`` is ``c``-sortable.\n\n            Given a Coxeter element `c`, an element `w` is `c`-sortable if\n            its `c`-sorting word decomposes into a sequence of weakly\n            decreasing subwords of `c`.\n\n            INPUT:\n\n            - ``c`` -- a Coxeter element.\n            - ``sorting_word`` -- sorting word (default: None) used to\n              not recompute the ``c``-sorting word if already computed.\n\n            OUTPUT:\n\n            is ``self`` ``c``-sortable\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: c = W.from_reduced_word([0,2,1])\n                sage: w = W.from_reduced_word([1,2,1,0,1])\n                sage: w.coxeter_sorting_word(c)\n                [2, 1, 2, 0, 1]\n                sage: w.is_coxeter_sortable(c)\n                False\n                sage: w = W.from_reduced_word([0,2,1,0,2])\n                sage: w.coxeter_sorting_word(c)\n                [2, 0, 1, 2, 0]\n                sage: w.is_coxeter_sortable(c)\n                True\n                sage: W = CoxeterGroup(['A',3])\n                sage: c = W.from_reduced_word([1,2,3])\n                sage: len([w for w in W if w.is_coxeter_sortable(c)]) # number of c-sortable elements in A_3 (Catalan number)\n                14\n            ",
                    "args": [
                        "self",
                        "c",
                        "sorting_word"
                    ],
                    "argspec": [
                        [
                            "self",
                            "c",
                            "sorting_word"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "is_grassmannian": {
                    "__doc__": "\n            INPUT:\n\n            - ``side`` - \"left\" or \"right\" (default: \"right\")\n\n            Tests whether ``self`` is Grassmannian, i.e. it has at\n            most one descent on the right (resp. on the left).\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example(); W\n                The symmetric group on {0, ..., 3}\n                sage: s = W.simple_reflections()\n                sage: W.one().is_grassmannian()\n                True\n                sage: s[1].is_grassmannian()\n                True\n                sage: (s[1]*s[2]).is_grassmannian()\n                True\n                sage: (s[0]*s[1]).is_grassmannian()\n                True\n                sage: (s[1]*s[2]*s[1]).is_grassmannian()\n                False\n\n                sage: (s[0]*s[2]*s[1]).is_grassmannian(side = \"left\")\n                False\n                sage: (s[0]*s[2]*s[1]).is_grassmannian(side = \"right\")\n                True\n                sage: (s[0]*s[2]*s[1]).is_grassmannian()\n                True\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "left_inversions_as_reflections": {
                    "__doc__": "\n            Returns the set of reflections ``r`` such that ``r``  ``self`` < ``self``.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3], prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.left_inversions_as_reflections()\n                [s1, s3, s1*s2*s3*s2*s1, s2*s3*s2]\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "length": {
                    "__doc__": "\n            Return the length of ``self``.\n\n            This is the minimal length of\n            a product of simple reflections giving ``self``.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: s1 = W.simple_reflection(1)\n                sage: s2 = W.simple_reflection(2)\n                sage: s1.length()\n                1\n                sage: (s1*s2).length()\n                2\n                sage: W = CoxeterGroups().example()\n                sage: s = W.simple_reflections()\n                sage: w = s[0]*s[1]*s[0]\n                sage: w.length()\n                3\n                sage: W = CoxeterGroups().example()\n                sage: sum((x^w.length()) for w in W) - expand(prod(sum(x^i for i in range(j+1)) for j in range(4))) # This is scandalously slow!!!\n                0\n\n            .. SEEALSO::\n\n                :meth:`.reduced_word`\n\n            .. TODO::\n\n                Should use reduced_word_iterator (or reverse_iterator)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "lower_cover_reflections": {
                    "__doc__": "\n            Returns the reflections ``t`` such that ``self`` covers ``self`` ``t``.\n\n            If ``side`` is 'left', ``self`` covers ``t`` ``self``.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3],prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.lower_cover_reflections()\n                [s1*s2*s3*s2*s1, s2, s1]\n                sage: w.lower_cover_reflections(side = 'left')\n                [s2*s3*s2, s3, s1]\n\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "lower_covers": {
                    "__doc__": "\n            Returns all elements that ``self`` covers in weak order.\n\n            INPUT:\n\n            - side - 'left' or 'right' (default: 'right')\n            - index_set - a list of indices or None\n\n            OUTPUT: a list\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3])\n                sage: w = W.from_reduced_word([3,2,1])\n                sage: [x.reduced_word() for x in w.lower_covers()]\n                [[3, 2]]\n\n            To obtain covers for left weak order, set the option side to 'left'::\n\n                sage: [x.reduced_word() for x in w.lower_covers(side='left')]\n                [[2, 1]]\n                sage: w = W.from_reduced_word([3,2,3,1])\n                sage: [x.reduced_word() for x in w.lower_covers()]\n                [[2, 3, 2], [3, 2, 1]]\n\n            Covers w.r.t. a parabolic subgroup are obtained with the option ``index_set``::\n\n                sage: [x.reduced_word() for x in w.lower_covers(index_set = [1,2])]\n                [[2, 3, 2]]\n                sage: [x.reduced_word() for x in w.lower_covers(side='left')]\n                [[3, 2, 1], [2, 3, 1]]\n            ",
                    "args": [
                        "self",
                        "side",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            "right",
                            null
                        ]
                    ]
                },
                "min_demazure_product_greater": {
                    "__doc__": "\n            Finds the unique Bruhat-minimum element ``u`` such that ``v`` $\\le$ ``w`` * ``u`` where ``v`` is ``self``, ``w`` is ``element`` and ``*`` is the Demazure product.\n\n            INPUT:\n\n            - ``element`` is either an element of the same Coxeter group as ``self`` or a list (such as a reduced word) of elements from the index set of the Coxeter group.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',4],prefix=\"s\")\n                sage: v = W.from_reduced_word([2,3,4,1,2])\n                sage: u = W.from_reduced_word([2,3,2,1])\n                sage: v.min_demazure_product_greater(u)\n                s4*s2\n                sage: v.min_demazure_product_greater([2,3,2,1])\n                s4*s2\n                sage: v.min_demazure_product_greater((2,3,2,1))\n                s4*s2\n\n            ",
                    "args": [
                        "self",
                        "element"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reduced_word": {
                    "__doc__": "\n            Return a reduced word for ``self``.\n\n            This is a word `[i_1,i_2,\\ldots,i_k]` of minimal length\n            such that\n            `s_{i_1} s_{i_2} \\cdots s_{i_k} = \\operatorname{self}`,\n            where the `s_i` are the simple reflections.\n\n            EXAMPLES::\n\n                sage: W=CoxeterGroups().example()\n                sage: s=W.simple_reflections()\n                sage: w=s[0]*s[1]*s[2]\n                sage: w.reduced_word()\n                [0, 1, 2]\n                sage: w=s[0]*s[2]\n                sage: w.reduced_word()\n                [2, 0]\n\n            .. SEEALSO::\n\n                - :meth:`.reduced_words`, :meth:`.reduced_word_reverse_iterator`,\n                - :meth:`length`, :meth:`reduced_word_graph`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reduced_word_graph": {
                    "__doc__": "\n            Return the reduced word graph of ``self``.\n\n            The reduced word graph of an element `w` in a Coxeter group\n            is the graph whose vertices are the reduced words for `w`\n            (see :meth:`reduced_word` for a definition of this term),\n            and which has an `m`-colored edge between two reduced words\n            `x` and `y` whenever `x` and `y` differ by exactly one\n            length-`m` braid move (with `m \\geq 2`).\n\n            This graph is always connected (a theorem due to Tits) and\n            has no multiple edges.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3], prefix='s')\n                sage: w0 = W.long_element()\n                sage: G = w0.reduced_word_graph()\n                sage: G.num_verts()\n                16\n                sage: len(w0.reduced_words())\n                16\n                sage: G.num_edges()\n                18\n                sage: len([e for e in G.edges() if e[2] == 2])\n                10\n                sage: len([e for e in G.edges() if e[2] == 3])\n                8\n\n            TESTS::\n\n                sage: p = Permutation([3,2,4,1])\n                sage: pp = WeylGroup(['A',3]).from_reduced_word(p.reduced_word())\n                sage: pp.reduced_word_graph()\n                Graph on 3 vertices\n\n                sage: w1 = W.one()\n                sage: G = w1.reduced_word_graph()\n                sage: G.num_verts()\n                1\n                sage: G.num_edges()\n                0\n\n            .. SEEALSO::\n\n                :meth:`.reduced_words`, :meth:`.reduced_word_reverse_iterator`,\n                :meth:`length`, :meth:`reduced_word`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reduced_word_reverse_iterator": {
                    "__doc__": "\n            Return a reverse iterator on a reduced word for ``self``.\n\n            EXAMPLES::\n\n                sage: W=CoxeterGroups().example()\n                sage: s = W.simple_reflections()\n                sage: sigma = s[0]*s[1]*s[2]\n                sage: rI=sigma.reduced_word_reverse_iterator()\n                sage: [i for i in rI]\n                [2, 1, 0]\n                sage: s[0]*s[1]*s[2]==sigma\n                True\n                sage: sigma.length()\n                3\n\n            .. SEEALSO::\n\n                :meth:`.reduced_word`\n\n            Default implementation: recursively remove the first right\n            descent until the identity is reached (see :meth:`.first_descent` and\n            :meth:`~sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods.apply_simple_reflection`).\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reduced_words": {
                    "__doc__": "\n            Return all reduced words for ``self``.\n\n            See :meth:`reduced_word` for the definition of a reduced\n            word.\n\n            EXAMPLES::\n\n                sage: W=CoxeterGroups().example()\n                sage: s=W.simple_reflections()\n                sage: w=s[0]*s[2]\n                sage: w.reduced_words()\n                [[2, 0], [0, 2]]\n                sage: W=WeylGroup(['E',6])\n                sage: w=W.from_reduced_word([2,3,4,2])\n                sage: w.reduced_words()\n                [[3, 2, 4, 2], [2, 3, 4, 2], [3, 4, 2, 4]]\n\n            TODO: the result should be full featured finite enumerated\n            set (e.g. counting can be done much faster than iterating).\n\n            .. SEEALSO::\n\n                :meth:`.reduced_word`, :meth:`.reduced_word_reverse_iterator`,\n                :meth:`length`, :meth:`reduced_word_graph`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support": {
                    "__doc__": "\n            Return the support of ``self``, that is the simple reflections that\n            appear in the reduced expressions of ``self``.\n\n            OUTPUT:\n\n            The support of ``self`` as a set of integers\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: w = W.from_reduced_word([1,2,1])\n                sage: w.support()\n                {1, 2}\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "upper_covers": {
                    "__doc__": "\n            Returns all elements that cover ``self`` in weak order.\n\n            INPUT:\n\n            - side - 'left' or 'right' (default: 'right')\n            - index_set - a list of indices or None\n\n            OUTPUT: a list\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3])\n                sage: w = W.from_reduced_word([2,3])\n                sage: [x.reduced_word() for x in w.upper_covers()]\n                [[2, 3, 1], [2, 3, 2]]\n\n            To obtain covers for left weak order, set the option ``side`` to 'left'::\n\n                sage: [x.reduced_word() for x in w.upper_covers(side = 'left')]\n                [[1, 2, 3], [2, 3, 2]]\n\n            Covers w.r.t. a parabolic subgroup are obtained with the option ``index_set``::\n\n                sage: [x.reduced_word() for x in w.upper_covers(index_set = [1])]\n                [[2, 3, 1]]\n                sage: [x.reduced_word() for x in w.upper_covers(side = 'left', index_set = [1])]\n                [[1, 2, 3]]\n            ",
                    "args": [
                        "self",
                        "side",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            "right",
                            null
                        ]
                    ]
                },
                "weak_covers": {
                    "__doc__": "\n            Returns all elements that ``self`` covers in weak order.\n\n            INPUT:\n\n            - side - 'left' or 'right'  (default: 'right')\n            - positive - a boolean (default: False)\n            - index_set - a list of indices or None\n\n            OUTPUT: a list\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3])\n                sage: w = W.from_reduced_word([3,2,1])\n                sage: [x.reduced_word() for x in w.weak_covers()]\n                [[3, 2]]\n\n            To obtain instead elements that cover self, set ``positive = True``::\n\n                sage: [x.reduced_word() for x in w.weak_covers(positive = True)]\n                [[3, 1, 2, 1], [2, 3, 2, 1]]\n\n            To obtain covers for left weak order, set the option side to 'left'::\n\n                sage: [x.reduced_word() for x in w.weak_covers(side='left')]\n                [[2, 1]]\n                sage: w = W.from_reduced_word([3,2,3,1])\n                sage: [x.reduced_word() for x in w.weak_covers()]\n                [[2, 3, 2], [3, 2, 1]]\n                sage: [x.reduced_word() for x in w.weak_covers(side='left')]\n                [[3, 2, 1], [2, 3, 1]]\n\n            Covers w.r.t. a parabolic subgroup are obtained with the option ``index_set``::\n\n                sage: [x.reduced_word() for x in w.weak_covers(index_set = [1,2])]\n                [[2, 3, 2]]\n            ",
                    "args": [
                        "self",
                        "side",
                        "index_set",
                        "positive"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "index_set",
                            "positive"
                        ],
                        null,
                        null,
                        [
                            "right",
                            null,
                            false
                        ]
                    ]
                },
                "weak_le": {
                    "__doc__": "\n            comparison in weak order\n\n            INPUT:\n\n            - other - an element of the same Coxeter group\n            - side - 'left' or 'right'  (default: 'right')\n\n            OUTPUT: a boolean\n\n            Returns whether ``self`` <= ``other`` in left\n            (resp. right) weak order, that is if 'v' can be obtained\n            from 'v' by length increasing multiplication by simple\n            reflections on the left (resp. right).\n\n            EXAMPLES::\n\n                sage: W = WeylGroup([\"A\",3])\n                sage: u = W.from_reduced_word([1,2])\n                sage: v = W.from_reduced_word([1,2,3,2])\n                sage: u.weak_le(u)\n                True\n                sage: u.weak_le(v)\n                True\n                sage: v.weak_le(u)\n                False\n                sage: v.weak_le(v)\n                True\n\n            Comparison for left weak order is achieved with the option ``side``::\n\n                sage: u.weak_le(v, side = 'left')\n                False\n\n            The implementation uses the equivalent condition that any\n            reduced word for `u` is a right (resp. left) prefix of\n            some reduced word for `v`.\n\n            Complexity: `O(l * c)`, where `l` is the minimum of the\n            lengths of `u` and of `v`, and `c` is the cost of the low\n            level methods :meth:`first_descent`, :meth:`has_descent`,\n            :meth:`~sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods.apply_simple_reflection`),\n            etc. Those are typically `O(n)`, where `n` is the rank of the\n            Coxeter group.\n\n            We now run consistency tests with permutations::\n\n                sage: W = WeylGroup([\"A\",3])\n                sage: P4 = Permutations(4)\n                sage: def P4toW(w): return W.from_reduced_word(w.reduced_word())\n                sage: for u in P4:  # long time (5s on sage.math, 2011)\n                ....:     for v in P4:\n                ....:         assert u.permutohedron_lequal(v) == P4toW(u).weak_le(P4toW(v))\n                ....:         assert u.permutohedron_lequal(v, side='left') == P4toW(u).weak_le(P4toW(v), side='left')\n            ",
                    "args": [
                        "self",
                        "other",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.generalized_coxeter_groups.GeneralizedCoxeterGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of Coxeter groups.\n\n    A *Coxeter group* is a group `W` with a distinguished (finite)\n    family of involutions `(s_i)_{i\\in I}`, called the *simple\n    reflections*, subject to relations of the form `(s_is_j)^{m_{i,j}} = 1`.\n\n    `I` is the *index set* of `W` and `|I|` is the *rank* of `W`.\n\n    See :Wikipedia:`Coxeter_group` for details.\n\n    EXAMPLES::\n\n        sage: C = CoxeterGroups(); C\n        Category of coxeter groups\n        sage: C.super_categories()\n        [Category of generalized coxeter groups]\n\n        sage: W = C.example(); W\n        The symmetric group on {0, ..., 3}\n\n        sage: W.simple_reflections()\n        Finite family {0: (1, 0, 2, 3), 1: (0, 2, 1, 3), 2: (0, 1, 3, 2)}\n\n    Here are some further examples::\n\n        sage: FiniteCoxeterGroups().example()\n        The 5-th dihedral group of order 10\n        sage: FiniteWeylGroups().example()\n        The symmetric group on {0, ..., 3}\n        sage: WeylGroup([\"B\", 3])\n        Weyl Group of type ['B', 3] (as a matrix group acting on the ambient space)\n\n    Those will eventually be also in this category::\n\n        sage: SymmetricGroup(4)\n        Symmetric group of order 4! as a permutation group\n        sage: DihedralGroup(5)\n        Dihedral group of order 10 as a permutation group\n\n    .. TODO:: add a demo of usual computations on Coxeter groups.\n\n    .. SEEALSO::\n\n        - :mod:`sage.combinat.root_system`\n        - :class:`WeylGroups`\n        - :class:`GeneralizedCoxeterGroups`\n\n    .. WARNING::\n\n        It is assumed that morphisms in this category preserve the\n        distinguished choice of simple reflections. In particular,\n        subobjects in this category are parabolic subgroups. In this\n        sense, this category might be better named ``Coxeter\n        Systems``. In the long run we might want to have two distinct\n        categories, one for Coxeter groups (with morphisms being just\n        group morphisms) and one for Coxeter systems::\n\n            sage: CoxeterGroups().is_full_subcategory(Groups())\n            False\n            sage: from sage.categories.generalized_coxeter_groups import GeneralizedCoxeterGroups\n            sage: CoxeterGroups().is_full_subcategory(GeneralizedCoxeterGroups())\n            True\n\n    TESTS::\n\n        sage: W = CoxeterGroups().example()\n        sage: TestSuite(W).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.coxeter_groups.CoxeterGroups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_descents": {
                    "__doc__": "\n            Run sanity checks on the method\n            :meth:`CoxeterGroups.ElementMethods.descents` of the\n            elements of ``self``.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: W._test_descents()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_has_descent": {
                    "__doc__": "\n            Runs sanity checks on the method\n            :meth:`CoxeterGroups.ElementMethods.has_descent` of the\n            elements of self.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: W._test_has_descent()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_reduced_word": {
                    "__doc__": "\n            Runs sanity checks on :meth:'CoxeterGroups.ElementMethods.reduced_word' and\n            :meth:`~sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups.ParentMethods.from_reduced_word`\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: W._test_reduced_word()\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_simple_projections": {
                    "__doc__": "\n            Runs sanity checks on :meth:`.simple_projections`\n            and :meth:`CoxeterGroups.ElementMethods.apply_simple_projection`\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: W._test_simple_projections()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "bruhat_interval": {
                    "__doc__": "\n            Returns the list of t such that x <= t <= y.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(\"A3\", prefix=\"s\")\n                sage: [s1,s2,s3]=W.simple_reflections()\n                sage: W.bruhat_interval(s2,s1*s3*s2*s1*s3)\n                [s1*s2*s3*s2*s1, s2*s3*s2*s1, s3*s1*s2*s1, s1*s2*s3*s1, s1*s2*s3*s2, s3*s2*s1, s2*s3*s1, s2*s3*s2, s1*s2*s1, s3*s1*s2, s1*s2*s3, s2*s1, s3*s2, s2*s3, s1*s2, s2]\n                sage: W = WeylGroup(['A',2,1], prefix=\"s\")\n                sage: [s0,s1,s2]=W.simple_reflections()\n                sage: W.bruhat_interval(1,s0*s1*s2)\n                [s0*s1*s2, s1*s2, s0*s2, s0*s1, s2, s1, s0, 1]\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "canonical_representation": {
                    "__doc__": "\n            Return the canonical faithful representation of ``self``.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(\"A3\")\n                sage: W.canonical_representation()\n                Finite Coxeter group over Universal Cyclotomic Field with Coxeter matrix:\n                [1 3 2]\n                [3 1 3]\n                [2 3 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coxeter_element": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "demazure_product": {
                    "__doc__": "\n            Returns the Demazure product of the list ``Q`` in ``self``.\n\n            INPUT:\n\n            - ``Q`` is a list of elements from the index set of ``self``.\n\n            This returns the Coxeter group element that represents the composition of 0-Hecke or Demazure operators.\n            See :meth:`CoxeterGroups.ParentMethods.simple_projections`.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',2])\n                sage: w = W.demazure_product([2,2,1])\n                sage: w.reduced_word()\n                [2, 1]\n\n                sage: w = W.demazure_product([2,1,2,1,2])\n                sage: w.reduced_word()\n                [1, 2, 1]\n\n                sage: W = WeylGroup(['B',2])\n                sage: w = W.demazure_product([2,1,2,1,2])\n                sage: w.reduced_word()\n                [2, 1, 2, 1]\n\n            ",
                    "args": [
                        "self",
                        "Q"
                    ],
                    "argspec": [
                        [
                            "self",
                            "Q"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "elements_of_length": {
                    "__doc__": "\n            Return all elements of length `n`.\n\n            EXAMPLES::\n\n                sage: A = AffinePermutationGroup(['A',2,1])\n                sage: [len(list(A.elements_of_length(i))) for i in [0..5]]\n                [1, 3, 6, 9, 12, 15]\n\n                sage: W = CoxeterGroup(['H',3])\n                sage: [len(list(W.elements_of_length(i))) for i in range(4)]\n                [1, 3, 5, 7]\n\n                sage: W = CoxeterGroup(['A',2])\n                sage: [len(list(W.elements_of_length(i))) for i in range(6)]\n                [1, 2, 2, 1, 0, 0]\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "grassmannian_elements": {
                    "__doc__": "\n            Return the left or right grassmanian elements of ``self``\n            as an enumerated set.\n\n            INPUT:\n\n            - ``side`` -- (default: ``\"right\"``) ``\"left\"`` or ``\"right\"``\n\n            EXAMPLES::\n\n                sage: S = CoxeterGroups().example()\n                sage: G = S.grassmannian_elements()\n                sage: G.cardinality()\n                12\n                sage: G.list()\n                [(0, 1, 2, 3), (1, 0, 2, 3), (0, 2, 1, 3), (0, 1, 3, 2),\n                 (2, 0, 1, 3), (1, 2, 0, 3), (0, 3, 1, 2), (0, 2, 3, 1),\n                 (3, 0, 1, 2), (1, 3, 0, 2), (1, 2, 3, 0), (2, 3, 0, 1)]\n                sage: sorted(tuple(w.descents()) for w in G)\n                [(), (0,), (0,), (0,), (1,), (1,), (1,), (1,), (1,), (2,), (2,), (2,)]\n                sage: G = S.grassmannian_elements(side = \"left\")\n                sage: G.cardinality()\n                12\n                sage: sorted(tuple(w.descents(side = \"left\")) for w in G)\n                [(), (0,), (0,), (0,), (1,), (1,), (1,), (1,), (1,), (2,), (2,), (2,)]\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "random_element_of_length": {
                    "__doc__": "\n            Return a random element of length ``n`` in ``self``.\n\n            Starts at the identity, then chooses an upper cover at random.\n\n            Not very uniform: actually constructs a uniformly random\n            reduced word of length `n`. Thus we most likely get\n            elements with lots of reduced words!\n\n            EXAMPLES::\n\n                sage: A = AffinePermutationGroup(['A', 7, 1])\n                sage: p = A.random_element_of_length(10)\n                sage: p in A\n                True\n                sage: p.length() == 10\n                True\n\n                sage: W = CoxeterGroup(['A', 4])\n                sage: p = W.random_element_of_length(5)\n                sage: p in W\n                True\n                sage: p.length() == 5\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "simple_projection": {
                    "__doc__": "\n            INPUT:\n\n            - ``i`` - an element of the index set of ``self``\n\n            Returns the simple projection `\\pi_i` (or `\\overline\\pi_i` if `length_increasing` is False).\n\n            See :meth:`.simple_projections` for the options and for\n            the definition of the simple projections.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: W\n                The symmetric group on {0, ..., 3}\n                sage: s = W.simple_reflections()\n                sage: sigma=W.an_element()\n                sage: sigma\n                (1, 2, 3, 0)\n                sage: u0=W.simple_projection(0)\n                sage: d0=W.simple_projection(0,length_increasing=False)\n                sage: sigma.length()\n                3\n                sage: pi=sigma*s[0]\n                sage: pi.length()\n                4\n                sage: u0(sigma)\n                (2, 1, 3, 0)\n                sage: pi\n                (2, 1, 3, 0)\n                sage: u0(pi)\n                (2, 1, 3, 0)\n                sage: d0(sigma)\n                (1, 2, 3, 0)\n                sage: d0(pi)\n                (1, 2, 3, 0)\n\n            ",
                    "args": [
                        "self",
                        "i",
                        "side",
                        "length_increasing"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "side",
                            "length_increasing"
                        ],
                        null,
                        null,
                        [
                            "right",
                            true
                        ]
                    ]
                },
                "simple_projections": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "standard_coxeter_elements": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "weak_order_ideal": {
                    "__doc__": "\n            Returns a weak order ideal defined by a predicate\n\n            INPUT:\n\n            - ``predicate``: a predicate on the elements of ``self`` defining an\n              weak order ideal in ``self``\n            - ``side``: \"left\" or \"right\" (default: \"right\")\n\n            OUTPUT: an enumerated set\n\n            EXAMPLES::\n\n                sage: D6 = FiniteCoxeterGroups().example(5)\n                sage: I = D6.weak_order_ideal(predicate = lambda w: w.length() <= 3)\n                sage: I.cardinality()\n                7\n                sage: list(I)\n                [(), (1,), (2,), (1, 2), (2, 1), (1, 2, 1), (2, 1, 2)]\n\n            We now consider an infinite Coxeter group::\n\n                sage: W = WeylGroup([\"A\",1,1])\n                sage: I = W.weak_order_ideal(predicate = lambda w: w.length() <= 2)\n                sage: list(iter(I))\n                [\n                [1 0]  [-1  2]  [ 1  0]  [ 3 -2]  [-1  2]\n                [0 1], [ 0  1], [ 2 -1], [ 2 -1], [-2  3]\n                ]\n\n            Even when the result is finite, some features of\n            :class:`FiniteEnumeratedSets` are not available::\n\n                sage: I.cardinality() # todo: not implemented\n                5\n                sage: list(I)         # todo: not implemented\n\n            unless this finiteness is explicitly specified::\n\n                sage: I = W.weak_order_ideal(predicate = lambda w: w.length() <= 2,\n                ...                          category = FiniteEnumeratedSets())\n                sage: I.cardinality()\n                5\n                sage: list(I)\n                [\n                [1 0]  [-1  2]  [ 1  0]  [ 3 -2]  [-1  2]\n                [0 1], [ 0  1], [ 2 -1], [ 2 -1], [-2  3]\n                ]\n\n            .. rubric:: Background\n\n            The weak order is returned as a :class:`SearchForest`.\n            This is achieved by assigning to each element `u1` of the\n            ideal a single ancestor `u=u1 s_i`, where `i` is the\n            smallest descent of `u`.\n\n            This allows for iterating through the elements in\n            roughly Constant Amortized Time and constant memory\n            (taking the operations and size of the generated objects\n            as constants).\n\n            TESTS:\n\n            We iterate over each level (i.e., breadth-first-search in the\n            search forest), see :trac:`19926`::\n\n                sage: W = CoxeterGroup(['A',2])\n                sage: [x.length() for x in W]\n                [0, 1, 1, 2, 2, 3]\n            ",
                    "args": [
                        "self",
                        "predicate",
                        "side",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "predicate",
                            "side",
                            "category"
                        ],
                        null,
                        null,
                        [
                            "right",
                            null
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "absolute_covers": {
                    "__doc__": "\n            Return the list of covers of ``self`` in absolute order.\n\n            .. SEEALSO::\n\n                :meth:`absolute_length`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup([\"A\", 3])\n                sage: s = W.simple_reflections()\n                sage: w0 = s[1]\n                sage: w1 = s[1]*s[2]*s[3]\n                sage: w0.absolute_covers()\n                [\n                [0 0 1 0]  [0 1 0 0]  [0 0 0 1]  [0 1 0 0]  [0 1 0 0]\n                [1 0 0 0]  [1 0 0 0]  [1 0 0 0]  [0 0 1 0]  [0 0 0 1]\n                [0 1 0 0]  [0 0 0 1]  [0 0 1 0]  [1 0 0 0]  [0 0 1 0]\n                [0 0 0 1], [0 0 1 0], [0 1 0 0], [0 0 0 1], [1 0 0 0]\n                ]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "absolute_le": {
                    "__doc__": "\n            Return whether ``self`` is smaller than ``other`` in the absolute\n            order.\n\n            A general reflection is an element of the form `w s_i w^{-1}`,\n            where `s_i` is a simple reflection. The absolute order is defined\n            analogously to the weak order but using general reflections rather\n            than just simple reflections.\n\n            This partial order can be used to define noncrossing partitions\n            associated with this Coxeter group.\n\n            .. SEEALSO::\n\n                :meth:`absolute_length`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup([\"A\", 3])\n                sage: s = W.simple_reflections()\n                sage: w0 = s[1]\n                sage: w1 = s[1]*s[2]*s[3]\n                sage: w0.absolute_le(w1)\n                True\n                sage: w1.absolute_le(w0)\n                False\n                sage: w1.absolute_le(w1)\n                True\n            ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "absolute_length": {
                    "__doc__": "\n            Return the absolute length of ``self``.\n\n            The absolute length is the length of the shortest expression\n            of the element as a product of reflections.\n\n            For permutations in the symmetric groups, the absolute\n            length is the size minus the number of its disjoint\n            cycles.\n\n            .. SEEALSO::\n\n                :meth:`absolute_le`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup([\"A\", 3])\n                sage: s = W.simple_reflections()\n                sage: (s[1]*s[2]*s[3]).absolute_length()\n                3\n\n                sage: W = SymmetricGroup(4)\n                sage: s = W.simple_reflections()\n                sage: (s[3]*s[2]*s[1]).absolute_length()\n                3\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "apply_demazure_product": {
                    "__doc__": "\n            Returns the Demazure or 0-Hecke product of ``self`` with another Coxeter group element.\n\n            See :meth:`CoxeterGroups.ParentMethods.simple_projections`.\n\n            INPUT:\n\n            - ``element`` -- either an element of the same Coxeter\n                group as ``self`` or a tuple or a list (such as a\n                reduced word) of elements from the index set of the\n                Coxeter group.\n\n            - ``side`` -- 'left' or 'right' (default: 'right'); the\n                side of ``self`` on which the element should be\n                applied. If ``side`` is 'left' then the operation is\n                applied on the left.\n\n            - ``length_increasing`` -- a boolean (default True)\n                whether to act length increasingly or decreasingly\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['C',4],prefix=\"s\")\n                sage: v = W.from_reduced_word([1,2,3,4,3,1])\n                sage: v.apply_demazure_product([1,3,4,3,3])\n                s4*s1*s2*s3*s4*s3*s1\n                sage: v.apply_demazure_product([1,3,4,3],side='left')\n                s3*s4*s1*s2*s3*s4*s2*s3*s1\n                sage: v.apply_demazure_product((1,3,4,3),side='left')\n                s3*s4*s1*s2*s3*s4*s2*s3*s1\n                sage: v.apply_demazure_product(v)\n                s2*s3*s4*s1*s2*s3*s4*s2*s3*s2*s1\n\n            ",
                    "args": [
                        "self",
                        "element",
                        "side",
                        "length_increasing"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element",
                            "side",
                            "length_increasing"
                        ],
                        null,
                        null,
                        [
                            "right",
                            true
                        ]
                    ]
                },
                "apply_simple_projection": {
                    "__doc__": "\n            INPUT:\n\n            - ``i`` - an element of the index set of the Coxeter group\n            - ``side`` - 'left' or 'right' (default: 'right')\n            - ``length_increasing`` - a boolean (default: True) specifying\n              the direction of the projection\n\n            Returns the result of the application of the simple\n            projection `\\pi_i` (resp. `\\overline\\pi_i`) on ``self``.\n\n            See :meth:`CoxeterGroups.ParentMethods.simple_projections`\n            for the definition of the simple projections.\n\n            EXAMPLE::\n\n                sage: W=CoxeterGroups().example()\n                sage: w=W.an_element()\n                sage: w\n                (1, 2, 3, 0)\n                sage: w.apply_simple_projection(2)\n                (1, 2, 3, 0)\n                sage: w.apply_simple_projection(2, length_increasing=False)\n                (1, 2, 0, 3)\n                sage: W = WeylGroup(['C',4],prefix=\"s\")\n                sage: v = W.from_reduced_word([1,2,3,4,3,1])\n                sage: v\n                s1*s2*s3*s4*s3*s1\n                sage: v.apply_simple_projection(2)\n                s1*s2*s3*s4*s3*s1*s2\n                sage: v.apply_simple_projection(2, side='left')\n                s1*s2*s3*s4*s3*s1\n                sage: v.apply_simple_projection(1, length_increasing = False)\n                s1*s2*s3*s4*s3\n\n            ",
                    "args": [
                        "self",
                        "i",
                        "side",
                        "length_increasing"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "side",
                            "length_increasing"
                        ],
                        null,
                        null,
                        [
                            "right",
                            true
                        ]
                    ]
                },
                "binary_factorizations": {
                    "__doc__": "\n            Returns the set of all the factorizations `self = u v` such\n            that `l(self) = l(u) + l(v)`.\n\n            Iterating through this set is Constant Amortized Time\n            (counting arithmetic operations in the Coxeter group as\n            constant time) complexity, and memory linear in the length\n            of `self`.\n\n            One can pass as optional argument a predicate p such that\n            `p(u)` implies `p(u')` for any `u` left factor of `self`\n            and `u'` left factor of `u`. Then this returns only the\n            factorizations `self = uv` such `p(u)` holds.\n\n            EXAMPLES:\n\n            We construct the set of all factorizations of the maximal\n            element of the group::\n\n                sage: W = WeylGroup(['A',3])\n                sage: s = W.simple_reflections()\n                sage: w0 = W.from_reduced_word([1,2,3,1,2,1])\n                sage: w0.binary_factorizations().cardinality()\n                24\n\n            The same number of factorizations, by bounded length::\n\n                sage: [w0.binary_factorizations(lambda u: u.length() <= l).cardinality() for l in [-1,0,1,2,3,4,5,6]]\n                [0, 1, 4, 9, 15, 20, 23, 24]\n\n            The number of factorizations of the elements just below\n            the maximal element::\n\n                sage: [(s[i]*w0).binary_factorizations().cardinality() for i in [1,2,3]]\n                [12, 12, 12]\n                sage: w0.binary_factorizations(lambda u: False).cardinality()\n                0\n\n            TESTS::\n\n                sage: w0.binary_factorizations().category()\n                Category of finite enumerated sets\n            ",
                    "args": [
                        "self",
                        "predicate"
                    ],
                    "argspec": [
                        [
                            "self",
                            "predicate"
                        ],
                        null,
                        null,
                        [
                            "The constant function (...) -> True"
                        ]
                    ]
                },
                "bruhat_le": {},
                "bruhat_lower_covers": {},
                "bruhat_lower_covers_reflections": {},
                "bruhat_upper_covers": {},
                "bruhat_upper_covers_reflections": {},
                "canonical_matrix": {
                    "__doc__": "\n            Return the matrix of ``self`` in the canonical faithful\n            representation.\n\n            This is an `n`-dimension real faithful essential representation,\n            where `n` is the number of generators of the Coxeter group.\n            Note that this is not always the most natural matrix\n            representation, for instance in type `A_n`.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup([\"A\", 3])\n                sage: s = W.simple_reflections()\n                sage: (s[1]*s[2]*s[3]).canonical_matrix()\n                [ 0  0 -1]\n                [ 1  0 -1]\n                [ 0  1 -1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coset_representative": {
                    "__doc__": "\n            INPUT:\n\n            - ``index_set`` - a subset (or iterable) of the nodes of the Dynkin diagram\n            - ``side`` - 'left' or 'right'\n\n            Returns the unique shortest element of the Coxeter group\n            $W$ which is in the same left (resp. right) coset as\n            ``self``, with respect to the parabolic subgroup $W_I$.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example(5)\n                sage: s = W.simple_reflections()\n                sage: w = s[2]*s[1]*s[3]\n                sage: w.coset_representative([]).reduced_word()\n                [2, 3, 1]\n                sage: w.coset_representative([1]).reduced_word()\n                [2, 3]\n                sage: w.coset_representative([1,2]).reduced_word()\n                [2, 3]\n                sage: w.coset_representative([1,3]                 ).reduced_word()\n                [2]\n                sage: w.coset_representative([2,3]                 ).reduced_word()\n                [2, 1]\n                sage: w.coset_representative([1,2,3]               ).reduced_word()\n                []\n                sage: w.coset_representative([],      side = 'left').reduced_word()\n                [2, 3, 1]\n                sage: w.coset_representative([1],     side = 'left').reduced_word()\n                [2, 3, 1]\n                sage: w.coset_representative([1,2],   side = 'left').reduced_word()\n                [3]\n                sage: w.coset_representative([1,3],   side = 'left').reduced_word()\n                [2, 3, 1]\n                sage: w.coset_representative([2,3],   side = 'left').reduced_word()\n                [1]\n                sage: w.coset_representative([1,2,3], side = 'left').reduced_word()\n                []\n\n            ",
                    "args": [
                        "self",
                        "index_set",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "cover_reflections": {
                    "__doc__": "\n            Returns the set of reflections ``t`` such that ``self`` ``t`` covers ``self``.\n\n            If ``side`` is 'left', ``t`` ``self`` covers ``self``.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',4], prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.cover_reflections()\n                [s3, s2*s3*s2, s4, s1*s2*s3*s4*s3*s2*s1]\n                sage: w.cover_reflections(side = 'left')\n                [s4, s2, s1*s2*s1, s3*s4*s3]\n\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "coxeter_sorting_word": {
                    "__doc__": "\n            Return the ``c``-sorting word of ``self``.\n\n            For a Coxeter element `c` and an element `w`, the `c`-sorting\n            word of `w` is the lexicographic minimal reduced expression of\n            `w` in the infinite word `c^\\infty`.\n\n            INPUT:\n\n            - ``c``-- a Coxeter element.\n\n            OUTPUT:\n\n            the ``c``-sorting word of ``self`` as a list of integers.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: c = W.from_reduced_word([0,2,1])\n                sage: w = W.from_reduced_word([1,2,1,0,1])\n                sage: w.coxeter_sorting_word(c)\n                [2, 1, 2, 0, 1]\n            ",
                    "args": [
                        "self",
                        "c"
                    ],
                    "argspec": [
                        [
                            "self",
                            "c"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "deodhar_factor_element": {
                    "__doc__": "\n            Returns Deodhar's Bruhat order factoring element.\n\n            INPUT:\n\n            - ``w`` is an element of the same Coxeter group ``W`` as ``self``\n            - ``index_set`` is a subset of Dynkin nodes defining a parabolic subgroup ``W'`` of ``W``\n\n            It is assumed that ``v = self`` and ``w`` are minimum length coset representatives\n            for ``W/W'`` such that ``v`` $\\le$ ``w`` in Bruhat order.\n\n            OUTPUT:\n\n            Deodhar's element ``f(v,w)`` is the unique element of ``W'`` such that,\n            for all ``v'`` and ``w'`` in ``W'``, ``vv'`` $\\le$ ``ww'`` in ``W`` if and only if\n            ``v'`` $\\le$ ``f(v,w) * w'`` in ``W'`` where ``*`` is the Demazure product.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',5],prefix=\"s\")\n                sage: v = W.from_reduced_word([5])\n                sage: w = W.from_reduced_word([4,5,2,3,1,2])\n                sage: v.deodhar_factor_element(w,[1,3,4])\n                s3*s1\n                sage: W=WeylGroup(['C',2])\n                sage: w=W.from_reduced_word([2,1])\n                sage: w.deodhar_factor_element(W.from_reduced_word([2]),[1])\n                Traceback (most recent call last):\n                ...\n                ValueError: [2, 1] is not of minimum length in its coset for the parabolic subgroup with index set [1]\n\n            REFERENCES:\n\n                .. [Deodhar] \\V. Deodhar,  A splitting criterion for the Bruhat orderings on Coxeter groups. Comm. Algebra, 15:1889-1894, 1987.\n\n            ",
                    "args": [
                        "self",
                        "w",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "w",
                            "index_set"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "deodhar_lift_down": {
                    "__doc__": "\n            Letting ``v = self``, given a Bruhat relation ``v W'`` $\\ge$ ``w W'`` among cosets\n            with respect to the subgroup ``W'`` given by the Dynkin node subset ``index_set``,\n            returns the Bruhat-maximum lift ``x`` of ``wW'`` such that ``v`` $\\ge$ ``x``.\n\n            INPUT:\n\n            - ``w`` is an element of the same Coxeter group ``W`` as ``self``.\n            - ``index_set`` is a subset of Dynkin nodes defining a parabolic subgroup ``W'``.\n\n            OUTPUT:\n\n            The unique Bruhat-maximum element ``x`` in ``W`` such that ``x W' = w W'``\n            and ``v $\\ge$ ``x``.\n\n            .. SEEALSO:: :meth:`sage.categories.coxeter_groups.CoxeterGroups.ElementMethods.deodhar_lift_up`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3],prefix=\"s\")\n                sage: v = W.from_reduced_word([1,2,3,2])\n                sage: w = W.from_reduced_word([3,2])\n                sage: v.deodhar_lift_down(w, [3])\n                s2*s3*s2\n\n            ",
                    "args": [
                        "self",
                        "w",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "w",
                            "index_set"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "deodhar_lift_up": {
                    "__doc__": "\n            Letting ``v = self``, given a Bruhat relation ``v W'`` $\\le$ ``w W'`` among cosets\n            with respect to the subgroup ``W'`` given by the Dynkin node subset ``index_set``,\n            returns the Bruhat-minimum lift ``x`` of ``wW'`` such that ``v`` $\\le$ ``x``.\n\n            INPUT:\n\n            - ``w`` is an element of the same Coxeter group ``W`` as ``self``.\n            - ``index_set`` is a subset of Dynkin nodes defining a parabolic subgroup ``W'``.\n\n            OUTPUT:\n\n            The unique Bruhat-minimum element ``x`` in ``W`` such that ``x W' = w W'``\n            and ``v`` $\\le$ ``x``.\n\n            .. SEEALSO:: :meth:`sage.categories.coxeter_groups.CoxeterGroups.ElementMethods.deodhar_lift_down`\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3],prefix=\"s\")\n                sage: v = W.from_reduced_word([1,2,3])\n                sage: w = W.from_reduced_word([1,3,2])\n                sage: v.deodhar_lift_up(w, [3])\n                s1*s2*s3*s2\n\n            ",
                    "args": [
                        "self",
                        "w",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "w",
                            "index_set"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "descents": {
                    "__doc__": "\n            INPUT:\n\n            - ``index_set`` - a subset (as a list or iterable) of the nodes of the Dynkin diagram;\n              (default: all of them)\n            - ``side`` - 'left' or 'right' (default: 'right')\n            - ``positive`` - a boolean (default: ``False``)\n\n            Returns the descents of self, as a list of elements of the\n            index_set.\n\n            The ``index_set`` option can be used to restrict to the\n            parabolic subgroup indexed by ``index_set``.\n\n            If positive is ``True``, then returns the non-descents\n            instead\n\n            TODO: find a better name for ``positive``: complement? non_descent?\n\n            Caveat: the return type may change to some other iterable\n            (tuple, ...) in the future. Please use keyword arguments\n            also, as the order of the arguments may change as well.\n\n            EXAMPLES::\n\n                sage: W=CoxeterGroups().example()\n                sage: s=W.simple_reflections()\n                sage: w=s[0]*s[1]\n                sage: w.descents()\n                [1]\n                sage: w=s[0]*s[2]\n                sage: w.descents()\n                [0, 2]\n\n                TODO: side, index_set, positive\n            ",
                    "args": [
                        "self",
                        "side",
                        "index_set",
                        "positive"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "index_set",
                            "positive"
                        ],
                        null,
                        null,
                        [
                            "right",
                            null,
                            false
                        ]
                    ]
                },
                "first_descent": {
                    "__doc__": "\n            Returns the first left (resp. right) descent of self, as\n            ane element of ``index_set``, or ``None`` if there is none.\n\n            See :meth:`.descents` for a description of the options.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: s = W.simple_reflections()\n                sage: w = s[2]*s[0]\n                sage: w.first_descent()\n                0\n                sage: w = s[0]*s[2]\n                sage: w.first_descent()\n                0\n                sage: w = s[0]*s[1]\n                sage: w.first_descent()\n                1\n            ",
                    "args": [
                        "self",
                        "side",
                        "index_set",
                        "positive"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "index_set",
                            "positive"
                        ],
                        null,
                        null,
                        [
                            "right",
                            null,
                            false
                        ]
                    ]
                },
                "has_descent": {
                    "__doc__": "\n            Returns whether i is a (left/right) descent of self.\n\n            See :meth:`.descents` for a description of the options.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: s = W.simple_reflections()\n                sage: w = s[0] * s[1] * s[2]\n                sage: w.has_descent(2)\n                True\n                sage: [ w.has_descent(i)                  for i in [0,1,2] ]\n                [False, False, True]\n                sage: [ w.has_descent(i, side = 'left')   for i in [0,1,2] ]\n                [True, False, False]\n                sage: [ w.has_descent(i, positive = True) for i in [0,1,2] ]\n                [True, True, False]\n\n            This default implementation delegates the work to\n            :meth:`.has_left_descent` and :meth:`.has_right_descent`.\n            ",
                    "args": [
                        "self",
                        "i",
                        "side",
                        "positive"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "side",
                            "positive"
                        ],
                        null,
                        null,
                        [
                            "right",
                            false
                        ]
                    ]
                },
                "has_full_support": {
                    "__doc__": "\n            Return whether ``self`` has full support.\n\n            An element is said to have full support if its support contains\n            all simple reflections.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: w = W.from_reduced_word([1,2,1])\n                sage: w.has_full_support()\n                False\n                sage: w = W.from_reduced_word([1,2,1,0,1])\n                sage: w.has_full_support()\n                True\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "has_left_descent": {
                    "__doc__": "\n            Returns whether `i` is a left descent of self.\n\n            This default implementation uses that a left descent of\n            `w` is a right descent of `w^{-1}`.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example(); W\n                The symmetric group on {0, ..., 3}\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.has_left_descent(0)\n                True\n                sage: w.has_left_descent(1)\n                False\n                sage: w.has_left_descent(2)\n                False\n\n            TESTS::\n\n                sage: w.has_left_descent.__module__\n                'sage.categories.coxeter_groups'\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "has_right_descent": {
                    "__doc__": "\n            Returns whether ``i`` is a right descent of self.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example(); W\n                The symmetric group on {0, ..., 3}\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.has_right_descent(0)\n                False\n                sage: w.has_right_descent(1)\n                False\n                sage: w.has_right_descent(2)\n                True\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "inversions_as_reflections": {},
                "is_coxeter_sortable": {
                    "__doc__": "\n            Return whether ``self`` is ``c``-sortable.\n\n            Given a Coxeter element `c`, an element `w` is `c`-sortable if\n            its `c`-sorting word decomposes into a sequence of weakly\n            decreasing subwords of `c`.\n\n            INPUT:\n\n            - ``c`` -- a Coxeter element.\n            - ``sorting_word`` -- sorting word (default: None) used to\n              not recompute the ``c``-sorting word if already computed.\n\n            OUTPUT:\n\n            is ``self`` ``c``-sortable\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: c = W.from_reduced_word([0,2,1])\n                sage: w = W.from_reduced_word([1,2,1,0,1])\n                sage: w.coxeter_sorting_word(c)\n                [2, 1, 2, 0, 1]\n                sage: w.is_coxeter_sortable(c)\n                False\n                sage: w = W.from_reduced_word([0,2,1,0,2])\n                sage: w.coxeter_sorting_word(c)\n                [2, 0, 1, 2, 0]\n                sage: w.is_coxeter_sortable(c)\n                True\n                sage: W = CoxeterGroup(['A',3])\n                sage: c = W.from_reduced_word([1,2,3])\n                sage: len([w for w in W if w.is_coxeter_sortable(c)]) # number of c-sortable elements in A_3 (Catalan number)\n                14\n            ",
                    "args": [
                        "self",
                        "c",
                        "sorting_word"
                    ],
                    "argspec": [
                        [
                            "self",
                            "c",
                            "sorting_word"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "is_grassmannian": {
                    "__doc__": "\n            INPUT:\n\n            - ``side`` - \"left\" or \"right\" (default: \"right\")\n\n            Tests whether ``self`` is Grassmannian, i.e. it has at\n            most one descent on the right (resp. on the left).\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example(); W\n                The symmetric group on {0, ..., 3}\n                sage: s = W.simple_reflections()\n                sage: W.one().is_grassmannian()\n                True\n                sage: s[1].is_grassmannian()\n                True\n                sage: (s[1]*s[2]).is_grassmannian()\n                True\n                sage: (s[0]*s[1]).is_grassmannian()\n                True\n                sage: (s[1]*s[2]*s[1]).is_grassmannian()\n                False\n\n                sage: (s[0]*s[2]*s[1]).is_grassmannian(side = \"left\")\n                False\n                sage: (s[0]*s[2]*s[1]).is_grassmannian(side = \"right\")\n                True\n                sage: (s[0]*s[2]*s[1]).is_grassmannian()\n                True\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "left_inversions_as_reflections": {
                    "__doc__": "\n            Returns the set of reflections ``r`` such that ``r``  ``self`` < ``self``.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3], prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.left_inversions_as_reflections()\n                [s1, s3, s1*s2*s3*s2*s1, s2*s3*s2]\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "length": {
                    "__doc__": "\n            Return the length of ``self``.\n\n            This is the minimal length of\n            a product of simple reflections giving ``self``.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: s1 = W.simple_reflection(1)\n                sage: s2 = W.simple_reflection(2)\n                sage: s1.length()\n                1\n                sage: (s1*s2).length()\n                2\n                sage: W = CoxeterGroups().example()\n                sage: s = W.simple_reflections()\n                sage: w = s[0]*s[1]*s[0]\n                sage: w.length()\n                3\n                sage: W = CoxeterGroups().example()\n                sage: sum((x^w.length()) for w in W) - expand(prod(sum(x^i for i in range(j+1)) for j in range(4))) # This is scandalously slow!!!\n                0\n\n            .. SEEALSO::\n\n                :meth:`.reduced_word`\n\n            .. TODO::\n\n                Should use reduced_word_iterator (or reverse_iterator)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "lower_cover_reflections": {
                    "__doc__": "\n            Returns the reflections ``t`` such that ``self`` covers ``self`` ``t``.\n\n            If ``side`` is 'left', ``self`` covers ``t`` ``self``.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3],prefix=\"s\")\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.lower_cover_reflections()\n                [s1*s2*s3*s2*s1, s2, s1]\n                sage: w.lower_cover_reflections(side = 'left')\n                [s2*s3*s2, s3, s1]\n\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "lower_covers": {
                    "__doc__": "\n            Returns all elements that ``self`` covers in weak order.\n\n            INPUT:\n\n            - side - 'left' or 'right' (default: 'right')\n            - index_set - a list of indices or None\n\n            OUTPUT: a list\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3])\n                sage: w = W.from_reduced_word([3,2,1])\n                sage: [x.reduced_word() for x in w.lower_covers()]\n                [[3, 2]]\n\n            To obtain covers for left weak order, set the option side to 'left'::\n\n                sage: [x.reduced_word() for x in w.lower_covers(side='left')]\n                [[2, 1]]\n                sage: w = W.from_reduced_word([3,2,3,1])\n                sage: [x.reduced_word() for x in w.lower_covers()]\n                [[2, 3, 2], [3, 2, 1]]\n\n            Covers w.r.t. a parabolic subgroup are obtained with the option ``index_set``::\n\n                sage: [x.reduced_word() for x in w.lower_covers(index_set = [1,2])]\n                [[2, 3, 2]]\n                sage: [x.reduced_word() for x in w.lower_covers(side='left')]\n                [[3, 2, 1], [2, 3, 1]]\n            ",
                    "args": [
                        "self",
                        "side",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            "right",
                            null
                        ]
                    ]
                },
                "min_demazure_product_greater": {
                    "__doc__": "\n            Finds the unique Bruhat-minimum element ``u`` such that ``v`` $\\le$ ``w`` * ``u`` where ``v`` is ``self``, ``w`` is ``element`` and ``*`` is the Demazure product.\n\n            INPUT:\n\n            - ``element`` is either an element of the same Coxeter group as ``self`` or a list (such as a reduced word) of elements from the index set of the Coxeter group.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',4],prefix=\"s\")\n                sage: v = W.from_reduced_word([2,3,4,1,2])\n                sage: u = W.from_reduced_word([2,3,2,1])\n                sage: v.min_demazure_product_greater(u)\n                s4*s2\n                sage: v.min_demazure_product_greater([2,3,2,1])\n                s4*s2\n                sage: v.min_demazure_product_greater((2,3,2,1))\n                s4*s2\n\n            ",
                    "args": [
                        "self",
                        "element"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reduced_word": {
                    "__doc__": "\n            Return a reduced word for ``self``.\n\n            This is a word `[i_1,i_2,\\ldots,i_k]` of minimal length\n            such that\n            `s_{i_1} s_{i_2} \\cdots s_{i_k} = \\operatorname{self}`,\n            where the `s_i` are the simple reflections.\n\n            EXAMPLES::\n\n                sage: W=CoxeterGroups().example()\n                sage: s=W.simple_reflections()\n                sage: w=s[0]*s[1]*s[2]\n                sage: w.reduced_word()\n                [0, 1, 2]\n                sage: w=s[0]*s[2]\n                sage: w.reduced_word()\n                [2, 0]\n\n            .. SEEALSO::\n\n                - :meth:`.reduced_words`, :meth:`.reduced_word_reverse_iterator`,\n                - :meth:`length`, :meth:`reduced_word_graph`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reduced_word_graph": {
                    "__doc__": "\n            Return the reduced word graph of ``self``.\n\n            The reduced word graph of an element `w` in a Coxeter group\n            is the graph whose vertices are the reduced words for `w`\n            (see :meth:`reduced_word` for a definition of this term),\n            and which has an `m`-colored edge between two reduced words\n            `x` and `y` whenever `x` and `y` differ by exactly one\n            length-`m` braid move (with `m \\geq 2`).\n\n            This graph is always connected (a theorem due to Tits) and\n            has no multiple edges.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3], prefix='s')\n                sage: w0 = W.long_element()\n                sage: G = w0.reduced_word_graph()\n                sage: G.num_verts()\n                16\n                sage: len(w0.reduced_words())\n                16\n                sage: G.num_edges()\n                18\n                sage: len([e for e in G.edges() if e[2] == 2])\n                10\n                sage: len([e for e in G.edges() if e[2] == 3])\n                8\n\n            TESTS::\n\n                sage: p = Permutation([3,2,4,1])\n                sage: pp = WeylGroup(['A',3]).from_reduced_word(p.reduced_word())\n                sage: pp.reduced_word_graph()\n                Graph on 3 vertices\n\n                sage: w1 = W.one()\n                sage: G = w1.reduced_word_graph()\n                sage: G.num_verts()\n                1\n                sage: G.num_edges()\n                0\n\n            .. SEEALSO::\n\n                :meth:`.reduced_words`, :meth:`.reduced_word_reverse_iterator`,\n                :meth:`length`, :meth:`reduced_word`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reduced_word_reverse_iterator": {
                    "__doc__": "\n            Return a reverse iterator on a reduced word for ``self``.\n\n            EXAMPLES::\n\n                sage: W=CoxeterGroups().example()\n                sage: s = W.simple_reflections()\n                sage: sigma = s[0]*s[1]*s[2]\n                sage: rI=sigma.reduced_word_reverse_iterator()\n                sage: [i for i in rI]\n                [2, 1, 0]\n                sage: s[0]*s[1]*s[2]==sigma\n                True\n                sage: sigma.length()\n                3\n\n            .. SEEALSO::\n\n                :meth:`.reduced_word`\n\n            Default implementation: recursively remove the first right\n            descent until the identity is reached (see :meth:`.first_descent` and\n            :meth:`~sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods.apply_simple_reflection`).\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reduced_words": {
                    "__doc__": "\n            Return all reduced words for ``self``.\n\n            See :meth:`reduced_word` for the definition of a reduced\n            word.\n\n            EXAMPLES::\n\n                sage: W=CoxeterGroups().example()\n                sage: s=W.simple_reflections()\n                sage: w=s[0]*s[2]\n                sage: w.reduced_words()\n                [[2, 0], [0, 2]]\n                sage: W=WeylGroup(['E',6])\n                sage: w=W.from_reduced_word([2,3,4,2])\n                sage: w.reduced_words()\n                [[3, 2, 4, 2], [2, 3, 4, 2], [3, 4, 2, 4]]\n\n            TODO: the result should be full featured finite enumerated\n            set (e.g. counting can be done much faster than iterating).\n\n            .. SEEALSO::\n\n                :meth:`.reduced_word`, :meth:`.reduced_word_reverse_iterator`,\n                :meth:`length`, :meth:`reduced_word_graph`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support": {
                    "__doc__": "\n            Return the support of ``self``, that is the simple reflections that\n            appear in the reduced expressions of ``self``.\n\n            OUTPUT:\n\n            The support of ``self`` as a set of integers\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: w = W.from_reduced_word([1,2,1])\n                sage: w.support()\n                {1, 2}\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "upper_covers": {
                    "__doc__": "\n            Returns all elements that cover ``self`` in weak order.\n\n            INPUT:\n\n            - side - 'left' or 'right' (default: 'right')\n            - index_set - a list of indices or None\n\n            OUTPUT: a list\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3])\n                sage: w = W.from_reduced_word([2,3])\n                sage: [x.reduced_word() for x in w.upper_covers()]\n                [[2, 3, 1], [2, 3, 2]]\n\n            To obtain covers for left weak order, set the option ``side`` to 'left'::\n\n                sage: [x.reduced_word() for x in w.upper_covers(side = 'left')]\n                [[1, 2, 3], [2, 3, 2]]\n\n            Covers w.r.t. a parabolic subgroup are obtained with the option ``index_set``::\n\n                sage: [x.reduced_word() for x in w.upper_covers(index_set = [1])]\n                [[2, 3, 1]]\n                sage: [x.reduced_word() for x in w.upper_covers(side = 'left', index_set = [1])]\n                [[1, 2, 3]]\n            ",
                    "args": [
                        "self",
                        "side",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            "right",
                            null
                        ]
                    ]
                },
                "weak_covers": {
                    "__doc__": "\n            Returns all elements that ``self`` covers in weak order.\n\n            INPUT:\n\n            - side - 'left' or 'right'  (default: 'right')\n            - positive - a boolean (default: False)\n            - index_set - a list of indices or None\n\n            OUTPUT: a list\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3])\n                sage: w = W.from_reduced_word([3,2,1])\n                sage: [x.reduced_word() for x in w.weak_covers()]\n                [[3, 2]]\n\n            To obtain instead elements that cover self, set ``positive = True``::\n\n                sage: [x.reduced_word() for x in w.weak_covers(positive = True)]\n                [[3, 1, 2, 1], [2, 3, 2, 1]]\n\n            To obtain covers for left weak order, set the option side to 'left'::\n\n                sage: [x.reduced_word() for x in w.weak_covers(side='left')]\n                [[2, 1]]\n                sage: w = W.from_reduced_word([3,2,3,1])\n                sage: [x.reduced_word() for x in w.weak_covers()]\n                [[2, 3, 2], [3, 2, 1]]\n                sage: [x.reduced_word() for x in w.weak_covers(side='left')]\n                [[3, 2, 1], [2, 3, 1]]\n\n            Covers w.r.t. a parabolic subgroup are obtained with the option ``index_set``::\n\n                sage: [x.reduced_word() for x in w.weak_covers(index_set = [1,2])]\n                [[2, 3, 2]]\n            ",
                    "args": [
                        "self",
                        "side",
                        "index_set",
                        "positive"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "index_set",
                            "positive"
                        ],
                        null,
                        null,
                        [
                            "right",
                            null,
                            false
                        ]
                    ]
                },
                "weak_le": {
                    "__doc__": "\n            comparison in weak order\n\n            INPUT:\n\n            - other - an element of the same Coxeter group\n            - side - 'left' or 'right'  (default: 'right')\n\n            OUTPUT: a boolean\n\n            Returns whether ``self`` <= ``other`` in left\n            (resp. right) weak order, that is if 'v' can be obtained\n            from 'v' by length increasing multiplication by simple\n            reflections on the left (resp. right).\n\n            EXAMPLES::\n\n                sage: W = WeylGroup([\"A\",3])\n                sage: u = W.from_reduced_word([1,2])\n                sage: v = W.from_reduced_word([1,2,3,2])\n                sage: u.weak_le(u)\n                True\n                sage: u.weak_le(v)\n                True\n                sage: v.weak_le(u)\n                False\n                sage: v.weak_le(v)\n                True\n\n            Comparison for left weak order is achieved with the option ``side``::\n\n                sage: u.weak_le(v, side = 'left')\n                False\n\n            The implementation uses the equivalent condition that any\n            reduced word for `u` is a right (resp. left) prefix of\n            some reduced word for `v`.\n\n            Complexity: `O(l * c)`, where `l` is the minimum of the\n            lengths of `u` and of `v`, and `c` is the cost of the low\n            level methods :meth:`first_descent`, :meth:`has_descent`,\n            :meth:`~sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods.apply_simple_reflection`),\n            etc. Those are typically `O(n)`, where `n` is the rank of the\n            Coxeter group.\n\n            We now run consistency tests with permutations::\n\n                sage: W = WeylGroup([\"A\",3])\n                sage: P4 = Permutations(4)\n                sage: def P4toW(w): return W.from_reduced_word(w.reduced_word())\n                sage: for u in P4:  # long time (5s on sage.math, 2011)\n                ....:     for v in P4:\n                ....:         assert u.permutohedron_lequal(v) == P4toW(u).weak_le(P4toW(v))\n                ....:         assert u.permutohedron_lequal(v, side='left') == P4toW(u).weak_le(P4toW(v), side='left')\n            ",
                    "args": [
                        "self",
                        "other",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded algebras\n\n    EXAMPLES::\n\n        sage: GradedAlgebras(ZZ)\n        Category of graded algebras over Integer Ring\n        sage: GradedAlgebras(ZZ).super_categories()\n        [Category of filtered algebras over Integer Ring,\n         Category of graded modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(GradedAlgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_algebras.FilteredAlgebras",
            "sage.categories.graded_modules.GradedModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded algebras\n\n    EXAMPLES::\n\n        sage: GradedAlgebras(ZZ)\n        Category of graded algebras over Integer Ring\n        sage: GradedAlgebras(ZZ).super_categories()\n        [Category of filtered algebras over Integer Ring,\n         Category of graded modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(GradedAlgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_algebras.GradedAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of complete discrete valuation rings\n\n    EXAMPLES::\n\n        sage: Zp(7) in CompleteDiscreteValuationRings()\n        True\n        sage: QQ in CompleteDiscreteValuationRings()\n        False\n        sage: QQ[['u']] in CompleteDiscreteValuationRings()\n        True\n        sage: Qp(7) in CompleteDiscreteValuationRings()\n        False\n        sage: TestSuite(CompleteDiscreteValuationRings()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "precision_absolute": {
                    "__doc__": "\n            Return the absolute precision of this element.\n\n            EXAMPLES::\n\n                sage: R = Zp(7)\n                sage: x = R(7); x\n                7 + O(7^21)\n                sage: x.precision_absolute()\n                21\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "precision_relative": {
                    "__doc__": "\n            Return the relative precision of this element.\n\n            EXAMPLES::\n\n                sage: R = Zp(7)\n                sage: x = R(7); x\n                7 + O(7^21)\n                sage: x.precision_relative()\n                20\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.discrete_valuation.DiscreteValuationRings"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of complete discrete valuation rings\n\n    EXAMPLES::\n\n        sage: Zp(7) in CompleteDiscreteValuationRings()\n        True\n        sage: QQ in CompleteDiscreteValuationRings()\n        False\n        sage: QQ[['u']] in CompleteDiscreteValuationRings()\n        True\n        sage: Qp(7) in CompleteDiscreteValuationRings()\n        False\n        sage: TestSuite(CompleteDiscreteValuationRings()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.complete_discrete_valuation.CompleteDiscreteValuationRings",
        "parent_class": {
            "__doc__": "\n    The category of complete discrete valuation rings\n\n    EXAMPLES::\n\n        sage: Zp(7) in CompleteDiscreteValuationRings()\n        True\n        sage: QQ in CompleteDiscreteValuationRings()\n        False\n        sage: QQ[['u']] in CompleteDiscreteValuationRings()\n        True\n        sage: Qp(7) in CompleteDiscreteValuationRings()\n        False\n        sage: TestSuite(CompleteDiscreteValuationRings()).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.complete_discrete_valuation.CompleteDiscreteValuationRings",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.discrete_valuation.DiscreteValuationRings",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.euclidean_domains.EuclideanDomains"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "precision_absolute": {
                    "__doc__": "\n            Return the absolute precision of this element.\n\n            EXAMPLES::\n\n                sage: R = Zp(7)\n                sage: x = R(7); x\n                7 + O(7^21)\n                sage: x.precision_absolute()\n                21\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "precision_relative": {
                    "__doc__": "\n            Return the relative precision of this element.\n\n            EXAMPLES::\n\n                sage: R = Zp(7)\n                sage: x = R(7); x\n                7 + O(7^21)\n                sage: x.precision_relative()\n                20\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of constructive euclidean domains, i.e., one can divide\n    producing a quotient and a remainder where the remainder is either zero or\n    its :meth:`ElementMethods.euclidean_degree` is smaller than the divisor.\n\n    EXAMPLES::\n\n      sage: EuclideanDomains()\n      Category of euclidean domains\n      sage: EuclideanDomains().super_categories()\n      [Category of principal ideal domains]\n\n    TESTS::\n\n        sage: TestSuite(EuclideanDomains()).run()\n\n    ",
        "axioms": [
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "euclidean_degree": {
                    "__doc__": "\n            Return the degree of this element as an element of a euclidean\n            domain, i.e., for elements `a`, `b` the euclidean degree `f`\n            satisfies the usual properties:\n\n            1. if `b` is not zero, then there are elements `q` and `r` such\n               that `a = bq + r` with `r = 0` or `f(r) < f(b)`\n            2. if `a,b` are not zero, then `f(a) \\leq f(ab)`\n\n            .. NOTE::\n\n                The name ``euclidean_degree`` was chosen because the euclidean\n                function has different names in different contexts, e.g.,\n                absolute value for integers, degree for polynomials.\n\n            OUTPUT:\n\n            For non-zero elements, a natural number. For the zero element, this\n            might raise an exception or produce some other output, depending on\n            the implementation.\n\n            EXAMPLES::\n\n                sage: R.<x> = QQ[]\n                sage: x.euclidean_degree()\n                1\n                sage: ZZ.one().euclidean_degree()\n                1\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "gcd": {
                    "__doc__": "NamedBinopMethod(func, name=None, obj=None)\nFile: sage/structure/element.pyx (starting at line 3287)\n\n    A decorator to be used on binary operation methods that should operate\n    on elements of the same parent. If the parents of the arguments differ,\n    coercion is performed, then the method is re-looked up by name on the\n    first argument.\n\n    In short, using the ``NamedBinopMethod`` (alias ``coerce_binop``) decorator\n    on a method gives it the exact same semantics of the basic arithmetic\n    operations like ``_add_``, ``_sub_``, etc. in that both operands are\n    guaranteed to have exactly the same parent.\n    ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "quo_rem": {
                    "__doc__": "\n            Return the quotient and remainder of the division of this element\n            by the non-zero element ``other``.\n\n            INPUT:\n\n            - ``other`` -- an element in the same euclidean domain\n\n            OUTPUT\n\n            EXAMPLES::\n\n                sage: R.<x> = QQ[]\n                sage: x.quo_rem(x)\n                (1, 0)\n            ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.principal_ideal_domains.PrincipalIdealDomains"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of constructive euclidean domains, i.e., one can divide\n    producing a quotient and a remainder where the remainder is either zero or\n    its :meth:`ElementMethods.euclidean_degree` is smaller than the divisor.\n\n    EXAMPLES::\n\n      sage: EuclideanDomains()\n      Category of euclidean domains\n      sage: EuclideanDomains().super_categories()\n      [Category of principal ideal domains]\n\n    TESTS::\n\n        sage: TestSuite(EuclideanDomains()).run()\n\n    ",
            "methods": {}
        },
        "name": "sage.categories.euclidean_domains.EuclideanDomains",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_euclidean_degree": {
                    "__doc__": "\n            Test that the assumptions on a euclidean degree are met.\n\n            EXAMPLES::\n\n                sage: R.<x> = QQ[]\n                sage: R._test_euclidean_degree()\n\n            .. SEEALSO::\n\n                :meth:`_test_quo_rem`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_quo_rem": {
                    "__doc__": "\n            Test that the assumptions on a quotient with remainder of an\n            euclidean domain are met.\n\n            EXAMPLES::\n\n                sage: R.<x> = QQ[]\n                sage: R._test_quo_rem()\n\n            .. SEEALSO::\n\n                :meth:`_test_euclidean_degree`\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "gcd_free_basis": {
                    "__doc__": "\n            Compute a set of coprime elements that can be used to express the\n            elements of ``elts``.\n\n            INPUT:\n\n            - ``elts`` - A sequence of elements of ``self``.\n\n            OUTPUT:\n\n            A GCD-free basis (also called a coprime base) of ``elts``; that is,\n            a set of pairwise relatively prime elements of ``self`` such that\n            any element of ``elts`` can be written as a product of elements of\n            the set.\n\n            ALGORITHM:\n\n            Naive implementation of the algorithm described in Section 4.8 of\n            Bach & Shallit [BachShallit1996]_.\n\n            .. [BachShallit1996] Eric Bach, Jeffrey Shallit.\n                *Algorithmic Number Theory, Vol. 1: Efficient Algorithms*.\n                MIT Press, 1996. ISBN 978-0262024051.\n\n            EXAMPLES::\n\n                sage: ZZ.gcd_free_basis([1])\n                []\n                sage: ZZ.gcd_free_basis([4, 30, 14, 49])\n                [2, 15, 7]\n\n                sage: Pol.<x> = QQ[]\n                sage: Pol.gcd_free_basis([\n                ....:     (x+1)^3*(x+2)^3*(x+3), (x+1)*(x+2)*(x+3),\n                ....:     (x+1)*(x+2)*(x+4)])\n                [x + 3, x + 4, x^2 + 3*x + 2]\n            ",
                    "args": [
                        "self",
                        "elts"
                    ],
                    "argspec": [
                        [
                            "self",
                            "elts"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_euclidean_domain": {
                    "__doc__": "\n            Return True, since this in an object of the category of Euclidean domains.\n\n            EXAMPLES::\n\n                sage: Parent(QQ,category=EuclideanDomains()).is_euclidean_domain()\n                True\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.euclidean_domains.EuclideanDomains"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "euclidean_degree": {
                    "__doc__": "\n            Return the degree of this element as an element of a euclidean\n            domain, i.e., for elements `a`, `b` the euclidean degree `f`\n            satisfies the usual properties:\n\n            1. if `b` is not zero, then there are elements `q` and `r` such\n               that `a = bq + r` with `r = 0` or `f(r) < f(b)`\n            2. if `a,b` are not zero, then `f(a) \\leq f(ab)`\n\n            .. NOTE::\n\n                The name ``euclidean_degree`` was chosen because the euclidean\n                function has different names in different contexts, e.g.,\n                absolute value for integers, degree for polynomials.\n\n            OUTPUT:\n\n            For non-zero elements, a natural number. For the zero element, this\n            might raise an exception or produce some other output, depending on\n            the implementation.\n\n            EXAMPLES::\n\n                sage: R.<x> = QQ[]\n                sage: x.euclidean_degree()\n                1\n                sage: ZZ.one().euclidean_degree()\n                1\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "gcd": {
                    "__doc__": "NamedBinopMethod(func, name=None, obj=None)\nFile: sage/structure/element.pyx (starting at line 3287)\n\n    A decorator to be used on binary operation methods that should operate\n    on elements of the same parent. If the parents of the arguments differ,\n    coercion is performed, then the method is re-looked up by name on the\n    first argument.\n\n    In short, using the ``NamedBinopMethod`` (alias ``coerce_binop``) decorator\n    on a method gives it the exact same semantics of the basic arithmetic\n    operations like ``_add_``, ``_sub_``, etc. in that both operands are\n    guaranteed to have exactly the same parent.\n    ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "quo_rem": {
                    "__doc__": "\n            Return the quotient and remainder of the division of this element\n            by the non-zero element ``other``.\n\n            INPUT:\n\n            - ``other`` -- an element in the same euclidean domain\n\n            OUTPUT\n\n            EXAMPLES::\n\n                sage: R.<x> = QQ[]\n                sage: x.quo_rem(x)\n                (1, 0)\n            ",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of `(R,S)`-bimodules\n\n    For `R` and `S` rings, a `(R,S)`-bimodule `X` is a left `R`-module\n    and right `S`-module such that the left and right actions commute:\n    `r*(x*s) = (r*x)*s`.\n\n    EXAMPLES::\n\n        sage: Bimodules(QQ, ZZ)\n        Category of bimodules over Rational Field on the left and Integer Ring on the right\n        sage: Bimodules(QQ, ZZ).super_categories()\n        [Category of left modules over Rational Field, Category of right modules over Integer Ring]\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of `(R,S)`-bimodules\n\n    For `R` and `S` rings, a `(R,S)`-bimodule `X` is a left `R`-module\n    and right `S`-module such that the left and right actions commute:\n    `r*(x*s) = (r*x)*s`.\n\n    EXAMPLES::\n\n        sage: Bimodules(QQ, ZZ)\n        Category of bimodules over Rational Field on the left and Integer Ring on the right\n        sage: Bimodules(QQ, ZZ).super_categories()\n        [Category of left modules over Rational Field, Category of right modules over Integer Ring]\n    ",
            "methods": {}
        },
        "name": "sage.categories.bimodules.Bimodules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Finite",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.semigroups.Semigroups",
            "sage.categories.finite_sets.FiniteSets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_semigroups.FiniteSemigroups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "idempotents": {
                    "__doc__": "\n            Returns the idempotents of the semigroup\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example(alphabet=('x','y'))\n                sage: sorted(S.idempotents())\n                ['x', 'xy', 'y', 'yx']\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "isomorphism_transformation_monoid": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method isomorphism_transformation_monoid at 0x7fe375ebb320>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": null,
                    "gap_name": "IsomorphismTransformationMonoid",
                    "mmt_name": null
                },
                "j_classes": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "j_classes_of_idempotents": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "j_transversal_of_idempotents": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of finite (multiplicative) semigroups.\n\n    A finite semigroup is a :class:`finite set <FiniteSets>` endowed\n    with an associative binary operation `*`.\n\n    .. WARNING::\n\n        Finite semigroups in Sage used to be automatically endowed\n        with an :class:`enumerated set <EnumeratedSets>` structure;\n        the default enumeration is then obtained by iteratively\n        multiplying the semigroup generators. This forced any finite\n        semigroup to either implement an enumeration, or provide\n        semigroup generators; this was often inconvenient.\n\n        Instead, finite semigroups that provide a distinguished finite\n        set of generators with :meth:`semigroup_generators` should now\n        explicitly declare themselves in the category of\n        :class:`finitely generated semigroups\n        <Semigroups.FinitelyGeneratedSemigroup>`::\n\n            sage: Semigroups().FinitelyGenerated()\n            Category of finitely generated semigroups\n\n        This is a backward incompatible change.\n\n    EXAMPLES::\n\n        sage: C = FiniteSemigroups(); C\n        Category of finite semigroups\n        sage: C.super_categories()\n        [Category of semigroups, Category of finite sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'Finite']\n        sage: C.example()\n        An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite (multiplicative) :class:`monoids <Monoids>`.\n\n    A finite monoid is a :class:`finite sets <FiniteSets>` endowed\n    with an associative unital binary operation `*`.\n\n    EXAMPLES::\n\n        sage: FiniteMonoids()\n        Category of finite monoids\n        sage: FiniteMonoids().super_categories()\n        [Category of monoids, Category of finite semigroups]\n\n    TESTS::\n\n        sage: TestSuite(FiniteMonoids()).run()\n    ",
        "axioms": [
            "Finite",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "pseudo_order": {
                    "__doc__": "\n            Returns the pair `[k, j]` with `k` minimal and `0\\leq j <k` such\n            that ``self^k == self^j``.\n\n            Note that `j` is uniquely determined.\n\n            EXAMPLES::\n\n                sage: M = FiniteMonoids().example(); M\n                An example of a finite multiplicative monoid: the integers modulo 12\n\n                sage: x = M(2)\n                sage: [ x^i for i in range(7) ]\n                [1, 2, 4, 8, 4, 8, 4]\n                sage: x.pseudo_order()\n                [4, 2]\n\n                sage: x = M(3)\n                sage: [ x^i for i in range(7) ]\n                [1, 3, 9, 3, 9, 3, 9]\n                sage: x.pseudo_order()\n                [3, 1]\n\n                sage: x = M(4)\n                sage: [ x^i for i in range(7) ]\n                [1, 4, 4, 4, 4, 4, 4]\n                sage: x.pseudo_order()\n                [2, 1]\n\n                sage: x = M(5)\n                sage: [ x^i for i in range(7) ]\n                [1, 5, 1, 5, 1, 5, 1]\n                sage: x.pseudo_order()\n                [2, 0]\n\n            TODO: more appropriate name? see, for example, Jean-Eric Pin's\n            lecture notes on semigroups.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.finite_semigroups.FiniteSemigroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite (multiplicative) :class:`monoids <Monoids>`.\n\n    A finite monoid is a :class:`finite sets <FiniteSets>` endowed\n    with an associative unital binary operation `*`.\n\n    EXAMPLES::\n\n        sage: FiniteMonoids()\n        Category of finite monoids\n        sage: FiniteMonoids().super_categories()\n        [Category of monoids, Category of finite semigroups]\n\n    TESTS::\n\n        sage: TestSuite(FiniteMonoids()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_monoids.FiniteMonoids",
        "parent_class": {
            "__doc__": "\n    The category of finite (multiplicative) :class:`monoids <Monoids>`.\n\n    A finite monoid is a :class:`finite sets <FiniteSets>` endowed\n    with an associative unital binary operation `*`.\n\n    EXAMPLES::\n\n        sage: FiniteMonoids()\n        Category of finite monoids\n        sage: FiniteMonoids().super_categories()\n        [Category of monoids, Category of finite semigroups]\n\n    TESTS::\n\n        sage: TestSuite(FiniteMonoids()).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "pseudo_order": {
                    "__doc__": "\n            Returns the pair `[k, j]` with `k` minimal and `0\\leq j <k` such\n            that ``self^k == self^j``.\n\n            Note that `j` is uniquely determined.\n\n            EXAMPLES::\n\n                sage: M = FiniteMonoids().example(); M\n                An example of a finite multiplicative monoid: the integers modulo 12\n\n                sage: x = M(2)\n                sage: [ x^i for i in range(7) ]\n                [1, 2, 4, 8, 4, 8, 4]\n                sage: x.pseudo_order()\n                [4, 2]\n\n                sage: x = M(3)\n                sage: [ x^i for i in range(7) ]\n                [1, 3, 9, 3, 9, 3, 9]\n                sage: x.pseudo_order()\n                [3, 1]\n\n                sage: x = M(4)\n                sage: [ x^i for i in range(7) ]\n                [1, 4, 4, 4, 4, 4, 4]\n                sage: x.pseudo_order()\n                [2, 1]\n\n                sage: x = M(5)\n                sage: [ x^i for i in range(7) ]\n                [1, 5, 1, 5, 1, 5, 1]\n                sage: x.pseudo_order()\n                [2, 0]\n\n            TODO: more appropriate name? see, for example, Jean-Eric Pin's\n            lecture notes on semigroups.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(QQ); C\n        Category of algebras with basis over Rational Field\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras over Rational Field,\n         Category of unital algebras with basis over Rational Field]\n\n    We construct a typical parent in this category, and do some\n    computations with it::\n\n        sage: A = C.example(); A\n        An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n\n        sage: A.category()\n        Category of algebras with basis over Rational Field\n\n        sage: A.one_basis()\n        word:\n        sage: A.one()\n        B[word: ]\n\n        sage: A.base_ring()\n        Rational Field\n        sage: A.basis().keys()\n        Finite words over {'a', 'b', 'c'}\n\n        sage: (a,b,c) = A.algebra_generators()\n        sage: a^3, b^2\n        (B[word: aaa], B[word: bb])\n        sage: a*c*b\n        B[word: acb]\n\n        sage: A.product\n        <bound method FreeAlgebra_with_category._product_from_product_on_basis_multiply of\n         An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field>\n        sage: A.product(a*b,b)\n        B[word: abb]\n\n        sage: TestSuite(A).run(verbose=True)\n        running ._test_additive_associativity() . . . pass\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_characteristic() . . . pass\n        running ._test_distributivity() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_nonzero_equal() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_zero() . . . pass\n        sage: A.__class__\n        <class 'sage.categories.examples.algebras_with_basis.FreeAlgebra_with_category'>\n        sage: A.element_class\n        <class 'sage.combinat.free_module.FreeAlgebra_with_category.element_class'>\n\n    Please see the source code of `A` (with ``A??``) for how to\n    implement other algebras with basis.\n\n    TESTS::\n\n        sage: TestSuite(AlgebrasWithBasis(QQ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.unital_algebras.UnitalAlgebras.WithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(QQ); C\n        Category of algebras with basis over Rational Field\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras over Rational Field,\n         Category of unital algebras with basis over Rational Field]\n\n    We construct a typical parent in this category, and do some\n    computations with it::\n\n        sage: A = C.example(); A\n        An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n\n        sage: A.category()\n        Category of algebras with basis over Rational Field\n\n        sage: A.one_basis()\n        word:\n        sage: A.one()\n        B[word: ]\n\n        sage: A.base_ring()\n        Rational Field\n        sage: A.basis().keys()\n        Finite words over {'a', 'b', 'c'}\n\n        sage: (a,b,c) = A.algebra_generators()\n        sage: a^3, b^2\n        (B[word: aaa], B[word: bb])\n        sage: a*c*b\n        B[word: acb]\n\n        sage: A.product\n        <bound method FreeAlgebra_with_category._product_from_product_on_basis_multiply of\n         An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field>\n        sage: A.product(a*b,b)\n        B[word: abb]\n\n        sage: TestSuite(A).run(verbose=True)\n        running ._test_additive_associativity() . . . pass\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_characteristic() . . . pass\n        running ._test_distributivity() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_nonzero_equal() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_zero() . . . pass\n        sage: A.__class__\n        <class 'sage.categories.examples.algebras_with_basis.FreeAlgebra_with_category'>\n        sage: A.element_class\n        <class 'sage.combinat.free_module.FreeAlgebra_with_category.element_class'>\n\n    Please see the source code of `A` (with ``A??``) for how to\n    implement other algebras with basis.\n\n    TESTS::\n\n        sage: TestSuite(AlgebrasWithBasis(QQ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_product_from_combinatorial_algebra_multiply": {
                    "__doc__": "\n            Returns left\\*right where left and right are elements of self.\n            product() uses either _multiply or _multiply basis to carry out\n            the actual multiplication.\n\n            EXAMPLES::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2])\n                sage: s._product_from_combinatorial_algebra_multiply(a,a)\n                s[2, 2] + s[3, 1] + s[4]\n                sage: s.product(a,a)\n                s[2, 2] + s[3, 1] + s[4]\n            ",
                    "args": [
                        "self",
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "hochschild_complex": {
                    "__doc__": "\n            Return the Hochschild complex of ``self`` with coefficients\n            in ``M``.\n\n            .. SEEALSO::\n\n                :class:`~sage.homology.hochschild_complex.HochschildComplex`\n\n            EXAMPLES::\n\n                sage: R.<x> = QQ[]\n                sage: A = algebras.DifferentialWeyl(R)\n                sage: H = A.hochschild_complex(A)\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: T = SGA.trivial_representation()\n                sage: H = SGA.hochschild_complex(T)\n            ",
                    "args": [
                        "self",
                        "M"
                    ],
                    "argspec": [
                        [
                            "self",
                            "M"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (multiplicative) semigroups.\n\n    A *semigroup* is an associative :class:`magma <Magmas>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative (see :wikipedia:`Semigroup`).\n\n    The operation `*` is not required to have a neutral element. A\n    semigroup for which such an element exists is a :class:`monoid\n    <sage.categories.monoids.Monoids>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups(); C\n        Category of semigroups\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: C.all_super_categories()\n        [Category of semigroups, Category of magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n        sage: C.axioms()\n        frozenset({'Associative'})\n        sage: C.example()\n        An example of a semigroup: the left zero semigroup\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "__pow__": {
                    "__doc__": "\n            Return ``self`` to the `n^{th}` power.\n\n            INPUT:\n\n            - ``n`` -- a positive integer\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"leftzero\")\n                sage: x = S(\"x\")\n                sage: x^1, x^2, x^3, x^4, x^5\n                ('x', 'x', 'x', 'x', 'x')\n                sage: x^0\n                Traceback (most recent call last):\n                ...\n                AssertionError\n\n            TESTS::\n\n                sage: x._pow_(17)\n                'x'\n\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_pow_": {
                    "__doc__": "\n            Return ``self`` to the `n^{th}` power.\n\n            INPUT:\n\n            - ``n`` -- a positive integer\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"leftzero\")\n                sage: x = S(\"x\")\n                sage: x^1, x^2, x^3, x^4, x^5\n                ('x', 'x', 'x', 'x', 'x')\n                sage: x^0\n                Traceback (most recent call last):\n                ...\n                AssertionError\n\n            TESTS::\n\n                sage: x._pow_(17)\n                'x'\n\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas"
        ],
        "mmt": "Semigroup",
        "morphism_class": {
            "__doc__": "\n    The category of (multiplicative) semigroups.\n\n    A *semigroup* is an associative :class:`magma <Magmas>`, that is a\n    set endowed with a multiplicative binary operation `*` which is\n    associative (see :wikipedia:`Semigroup`).\n\n    The operation `*` is not required to have a neutral element. A\n    semigroup for which such an element exists is a :class:`monoid\n    <sage.categories.monoids.Monoids>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups(); C\n        Category of semigroups\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: C.all_super_categories()\n        [Category of semigroups, Category of magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n        sage: C.axioms()\n        frozenset({'Associative'})\n        sage: C.example()\n        An example of a semigroup: the left zero semigroup\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.semigroups.Semigroups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "__truediv__": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method __truediv__ at 0x7fe375eb28c0>",
                    "args": [
                        "self",
                        "relations"
                    ],
                    "argspec": [
                        [
                            "self",
                            "relations"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": null,
                    "gap_name": "\\/",
                    "mmt_name": null
                },
                "_test_associativity": {
                    "__doc__": "\n            Test associativity for (not necessarily all) elements of this\n            semigroup.\n\n            INPUT:\n\n            - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n            EXAMPLES:\n\n            By default, this method tests only the elements returned by\n            ``self.some_elements()``::\n\n                sage: L = Semigroups().example(choice='leftzero')\n                sage: L._test_associativity()\n\n            However, the elements tested can be customized with the\n            ``elements`` keyword argument::\n\n                sage: L._test_associativity(elements = (L(1), L(2), L(3)))\n\n            See the documentation for :class:`TestSuite` for more information.\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "cayley_graph": {
                    "__doc__": "\n            Return the Cayley graph for this finite semigroup.\n\n            INPUT:\n\n            - ``side`` -- \"left\", \"right\", or \"twosided\":\n              the side on which the generators act (default:\"right\")\n            - ``simple`` -- boolean (default:False):\n              if True, returns a simple graph (no loops, no labels,\n              no multiple edges)\n            - ``generators`` -- a list, tuple, or family of elements\n              of ``self`` (default: ``self.semigroup_generators()``)\n            - ``connecting_set`` -- alias for ``generators``; deprecated\n            - ``elements`` -- a list (or iterable) of elements of ``self``\n\n            OUTPUT:\n\n            - :class:`DiGraph`\n\n            EXAMPLES:\n\n            We start with the (right) Cayley graphs of some classical groups::\n\n                sage: D4 = DihedralGroup(4); D4\n                Dihedral group of order 8 as a permutation group\n                sage: G = D4.cayley_graph()\n                sage: show(G, color_by_label=True, edge_labels=True)\n                sage: A5 = AlternatingGroup(5); A5\n                Alternating group of order 5!/2 as a permutation group\n                sage: G = A5.cayley_graph()\n                sage: G.show3d(color_by_label=True, edge_size=0.01, edge_size2=0.02, vertex_size=0.03)\n                sage: G.show3d(vertex_size=0.03, edge_size=0.01, edge_size2=0.02, vertex_colors={(1,1,1):G.vertices()}, bgcolor=(0,0,0), color_by_label=True, xres=700, yres=700, iterations=200) # long time (less than a minute)\n                sage: G.num_edges()\n                120\n\n                sage: w = WeylGroup(['A',3])\n                sage: d = w.cayley_graph(); d\n                Digraph on 24 vertices\n                sage: d.show3d(color_by_label=True, edge_size=0.01, vertex_size=0.03)\n\n            Alternative generators may be specified::\n\n                sage: G = A5.cayley_graph(generators=[A5.gens()[0]])\n                sage: G.num_edges()\n                60\n                sage: g=PermutationGroup([(i+1,j+1) for i in range(5) for j in range(5) if j!=i])\n                sage: g.cayley_graph(generators=[(1,2),(2,3)])\n                Digraph on 120 vertices\n\n            If ``elements`` is specified, then only the subgraph\n            induced and those elements is returned. Here we use it to\n            display the Cayley graph of the free monoid truncated on\n            the elements of length at most 3::\n\n                sage: M = Monoids().example(); M\n                An example of a monoid: the free monoid generated by ('a', 'b', 'c', 'd')\n                sage: elements = [ M.prod(w) for w in sum((list(Words(M.semigroup_generators(),k)) for k in range(4)),[]) ]\n                sage: G = M.cayley_graph(elements = elements)\n                sage: G.num_verts(), G.num_edges()\n                (85, 84)\n                sage: G.show3d(color_by_label=True, edge_size=0.001, vertex_size=0.01)\n\n            We now illustrate the ``side`` and ``simple`` options on\n            a semigroup::\n\n                sage: S = FiniteSemigroups().example(alphabet=('a','b'))\n                sage: g = S.cayley_graph(simple=True)\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'ab', None), ('b', 'ba', None)]\n\n            ::\n\n                sage: g = S.cayley_graph(side=\"left\", simple=True)\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'ba', None), ('ab', 'ba', None), ('b', 'ab', None),\n                ('ba', 'ab', None)]\n\n            ::\n\n                sage: g = S.cayley_graph(side=\"twosided\", simple=True)\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'ab', None), ('a', 'ba', None), ('ab', 'ba', None),\n                ('b', 'ab', None), ('b', 'ba', None), ('ba', 'ab', None)]\n\n            ::\n\n                sage: g = S.cayley_graph(side=\"twosided\")\n                sage: g.vertices()\n                ['a', 'ab', 'b', 'ba']\n                sage: g.edges()\n                [('a', 'a', (0, 'left')), ('a', 'a', (0, 'right')), ('a', 'ab', (1, 'right')), ('a', 'ba', (1, 'left')), ('ab', 'ab', (0, 'left')), ('ab', 'ab', (0, 'right')), ('ab', 'ab', (1, 'right')), ('ab', 'ba', (1, 'left')), ('b', 'ab', (0, 'left')), ('b', 'b', (1, 'left')), ('b', 'b', (1, 'right')), ('b', 'ba', (0, 'right')), ('ba', 'ab', (0, 'left')), ('ba', 'ba', (0, 'right')), ('ba', 'ba', (1, 'left')), ('ba', 'ba', (1, 'right'))]\n\n            ::\n\n                sage: s1 = SymmetricGroup(1); s = s1.cayley_graph(); s.vertices()\n                [()]\n\n            TESTS::\n\n                sage: SymmetricGroup(2).cayley_graph(side=\"both\")\n                Traceback (most recent call last):\n                ...\n                ValueError: option 'side' must be 'left', 'right' or 'twosided'\n\n            .. TODO::\n\n                - Add more options for constructing subgraphs of the\n                  Cayley graph, handling the standard use cases when\n                  exploring large/infinite semigroups (a predicate,\n                  generators of an ideal, a maximal length in term of the\n                  generators)\n\n                - Specify good default layout/plot/latex options in the graph\n\n                - Generalize to combinatorial modules with module generators / operators\n\n            AUTHORS:\n\n            - Bobby Moretti (2007-08-10)\n            - Robert Miller (2008-05-01): editing\n            - Nicolas M. Thiery (2008-12): extension to semigroups,\n              ``side``, ``simple``, and ``elements`` options, ...\n            ",
                    "args": [
                        "self",
                        "side",
                        "simple",
                        "elements",
                        "generators",
                        "connecting_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side",
                            "simple",
                            "elements",
                            "generators",
                            "connecting_set"
                        ],
                        null,
                        null,
                        [
                            "right",
                            false,
                            null,
                            null,
                            null
                        ]
                    ]
                },
                "is_d_trivial": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method is_d_trivial at 0x7fe375eb2a28>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": null,
                    "gap_name": "IsDTrivial",
                    "mmt_name": null
                },
                "is_l_trivial": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method is_l_trivial at 0x7fe375eb2938>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": null,
                    "gap_name": "IsLTrivial",
                    "mmt_name": null
                },
                "is_r_trivial": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method is_r_trivial at 0x7fe375eb29b0>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": null,
                    "gap_name": "IsRTrivial",
                    "mmt_name": null
                },
                "magma_generators": {
                    "__doc__": "\n            An alias for :meth:`semigroup_generators`.\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\"); S\n                An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n                sage: S.magma_generators()\n                Family ('a', 'b', 'c', 'd')\n                sage: S.semigroup_generators()\n                Family ('a', 'b', 'c', 'd')\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "prod": {
                    "__doc__": "\n            Return the product of the list of elements ``args``\n            inside ``self``.\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"free\")\n                sage: S.prod([S('a'), S('b'), S('c')])\n                'abc'\n                sage: S.prod([])\n                Traceback (most recent call last):\n                ...\n                AssertionError: Cannot compute an empty product in a semigroup\n            ",
                    "args": [
                        "self",
                        "args"
                    ],
                    "argspec": [
                        [
                            "self",
                            "args"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "regular_representation": {
                    "__doc__": "\n            Return the regular representation of ``self`` over ``base_ring``.\n\n            - ``side`` -- (default: ``\"left\"``) whether this is the\n              ``\"left\"`` or ``\"right\"`` regular representation\n\n            EXAMPLES::\n\n                sage: G = groups.permutation.Dihedral(4)\n                sage: G.regular_representation()\n                Left Regular Representation of Dihedral group of order 8\n                 as a permutation group over Integer Ring\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "left"
                        ]
                    ]
                },
                "semigroup_generators": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method semigroup_generators at 0x7fe375eb27d0>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "list_of_self",
                    "gap_name": "GeneratorsOfSemigroup",
                    "mmt_name": null
                },
                "subsemigroup": {
                    "__doc__": "\n            Return the multiplicative subsemigroup generated by ``generators``.\n\n            INPUT:\n\n            - ``generators`` -- a finite family of elements of\n              ``self``, or a list, iterable, ... that can be converted\n              into one (see :class:`Family`).\n\n            - ``one`` -- a unit for the subsemigroup, or ``None``.\n\n            - ``category`` -- a category\n\n            This implementation lazily constructs all the elements of\n            the semigroup, and the right Cayley graph relations\n            between them, and uses the latter as an automaton.\n\n            See :class:`~sage.sets.monoids.AutomaticSemigroup` for details.\n\n            EXAMPLES::\n\n                sage: R = IntegerModRing(15)\n                sage: M = R.subsemigroup([R(3),R(5)]); M\n                A subsemigroup of (Ring of integers modulo 15) with 2 generators\n                sage: M.list()\n                [3, 5, 9, 0, 10, 12, 6]\n\n            By default, `M` is just in the category of subsemigroups::\n\n                sage: M in Semigroups().Subobjects()\n                True\n\n            In the following example, we specify that `M` is a\n            submonoid of the finite monoid `R` (it shares the same\n            unit), and a group by itself::\n\n                sage: M = R.subsemigroup([R(-1)],\n                ....:     category=Monoids().Finite().Subobjects() & Groups()); M\n                A submonoid of (Ring of integers modulo 15) with 1 generators\n                sage: M.list()\n                [1, 14]\n                sage: M.one()\n                1\n\n            In the following example `M` is a group; however its unit\n            does not coincide with that of `R`, so `M` is only a\n            subsemigroup, and we need to specify its unit explictly::\n\n                sage: M = R.subsemigroup([R(5)],\n                ....:     category=Semigroups().Finite().Subobjects() & Groups()); M\n                Traceback (most recent call last):\n                ...\n                ValueError: For a monoid which is just a subsemigroup, the unit should be specified\n\n                sage: M = R.subsemigroup([R(5)], one=R(10),\n                ....:     category=Semigroups().Finite().Subobjects() & Groups()); M\n                A subsemigroup of (Ring of integers modulo 15) with 1 generators\n                sage: M in Groups()\n                True\n                sage: M.list()\n                [10, 5]\n                sage: M.one()\n                10\n\n            TESTS::\n\n                sage: TestSuite(M).run()\n                Failure in _test_inverse:\n                Traceback (most recent call last):\n                ...\n                The following tests failed: _test_inverse\n\n            .. TODO::\n\n                - Fix the failure in TESTS by providing a default\n                  implementation of ``__invert__`` for finite groups\n                  (or even finite monoids).\n                - Provide a default implementation of ``one`` for a\n                  finite monoid, so that we would not need to specify\n                  it explicitly?\n            ",
                    "args": [
                        "self",
                        "generators",
                        "one",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "generators",
                            "one",
                            "category"
                        ],
                        null,
                        null,
                        [
                            null,
                            null
                        ]
                    ]
                },
                "trivial_representation": {
                    "__doc__": "\n            Return the trivial representation of ``self`` over ``base_ring``.\n\n            INPUT:\n\n            - ``base_ring`` -- (optional) the base ring; the default is `\\ZZ`\n            - ``side`` -- ignored\n\n            EXAMPLES::\n\n                sage: G = groups.permutation.Dihedral(4)\n                sage: G.trivial_representation()\n                Trivial representation of Dihedral group of order 8\n                 as a permutation group over Integer Ring\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "twosided"
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "__pow__": {
                    "__doc__": "\n            Return ``self`` to the `n^{th}` power.\n\n            INPUT:\n\n            - ``n`` -- a positive integer\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"leftzero\")\n                sage: x = S(\"x\")\n                sage: x^1, x^2, x^3, x^4, x^5\n                ('x', 'x', 'x', 'x', 'x')\n                sage: x^0\n                Traceback (most recent call last):\n                ...\n                AssertionError\n\n            TESTS::\n\n                sage: x._pow_(17)\n                'x'\n\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_pow_": {
                    "__doc__": "\n            Return ``self`` to the `n^{th}` power.\n\n            INPUT:\n\n            - ``n`` -- a positive integer\n\n            EXAMPLES::\n\n                sage: S = Semigroups().example(\"leftzero\")\n                sage: x = S(\"x\")\n                sage: x^1, x^2, x^3, x^4, x^5\n                ('x', 'x', 'x', 'x', 'x')\n                sage: x^0\n                Traceback (most recent call last):\n                ...\n                AssertionError\n\n            TESTS::\n\n                sage: x._pow_(17)\n                'x'\n\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of complete discrete valuation fields\n\n    EXAMPLES::\n\n        sage: Zp(7) in CompleteDiscreteValuationFields()\n        False\n        sage: QQ in CompleteDiscreteValuationFields()\n        False\n        sage: LaurentSeriesRing(QQ,'u') in CompleteDiscreteValuationFields()\n        True\n        sage: Qp(7) in CompleteDiscreteValuationFields()\n        True\n        sage: TestSuite(CompleteDiscreteValuationFields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "precision_absolute": {
                    "__doc__": "\n            Return the absolute precision of this element.\n\n            EXAMPLES::\n\n                sage: K = Qp(7)\n                sage: x = K(7); x\n                7 + O(7^21)\n                sage: x.precision_absolute()\n                21\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "precision_relative": {
                    "__doc__": "\n            Return the relative precision of this element.\n\n            EXAMPLES::\n\n                sage: K = Qp(7)\n                sage: x = K(7); x\n                7 + O(7^21)\n                sage: x.precision_relative()\n                20\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.discrete_valuation.DiscreteValuationFields"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of complete discrete valuation fields\n\n    EXAMPLES::\n\n        sage: Zp(7) in CompleteDiscreteValuationFields()\n        False\n        sage: QQ in CompleteDiscreteValuationFields()\n        False\n        sage: LaurentSeriesRing(QQ,'u') in CompleteDiscreteValuationFields()\n        True\n        sage: Qp(7) in CompleteDiscreteValuationFields()\n        True\n        sage: TestSuite(CompleteDiscreteValuationFields()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.complete_discrete_valuation.CompleteDiscreteValuationFields",
        "parent_class": {
            "__doc__": "\n    The category of complete discrete valuation fields\n\n    EXAMPLES::\n\n        sage: Zp(7) in CompleteDiscreteValuationFields()\n        False\n        sage: QQ in CompleteDiscreteValuationFields()\n        False\n        sage: LaurentSeriesRing(QQ,'u') in CompleteDiscreteValuationFields()\n        True\n        sage: Qp(7) in CompleteDiscreteValuationFields()\n        True\n        sage: TestSuite(CompleteDiscreteValuationFields()).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.complete_discrete_valuation.CompleteDiscreteValuationFields",
            "sage.categories.discrete_valuation.DiscreteValuationFields",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.euclidean_domains.EuclideanDomains"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "precision_absolute": {
                    "__doc__": "\n            Return the absolute precision of this element.\n\n            EXAMPLES::\n\n                sage: K = Qp(7)\n                sage: x = K(7); x\n                7 + O(7^21)\n                sage: x.precision_absolute()\n                21\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "precision_relative": {
                    "__doc__": "\n            Return the relative precision of this element.\n\n            EXAMPLES::\n\n                sage: K = Qp(7)\n                sage: x = K(7); x\n                7 + O(7^21)\n                sage: x.precision_relative()\n                20\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of discrete valuation fields\n\n    EXAMPLES::\n\n        sage: Qp(7) in DiscreteValuationFields()\n        True\n        sage: TestSuite(DiscreteValuationFields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "valuation": {
                    "__doc__": "\n            Return the valuation of this element.\n\n            EXAMPLES::\n\n                sage: x = Qp(5)(50)\n                sage: x.valuation()\n                2\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.fields.Fields"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of discrete valuation fields\n\n    EXAMPLES::\n\n        sage: Qp(7) in DiscreteValuationFields()\n        True\n        sage: TestSuite(DiscreteValuationFields()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.discrete_valuation.DiscreteValuationFields",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "residue_field": {
                    "__doc__": "\n            Return the residue field of the ring of integers of \n            this discrete valuation field.\n\n            EXAMPLES::\n\n                sage: Qp(5).residue_field()\n                Finite Field of size 5\n\n                sage: K.<u> = LaurentSeriesRing(QQ)\n                sage: K.residue_field()\n                Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "uniformizer": {
                    "__doc__": "\n            Return a uniformizer of this ring.\n\n            EXAMPLES::\n\n                sage: Qp(5).uniformizer()\n                5 + O(5^21)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.discrete_valuation.DiscreteValuationFields",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "valuation": {
                    "__doc__": "\n            Return the valuation of this element.\n\n            EXAMPLES::\n\n                sage: x = Qp(5)(50)\n                sage: x.valuation()\n                2\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of quotient fields over an integral domain\n\n    EXAMPLES::\n\n        sage: QuotientFields()\n        Category of quotient fields\n        sage: QuotientFields().super_categories()\n        [Category of fields]\n\n    TESTS::\n\n        sage: TestSuite(QuotientFields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "_derivative": {
                    "__doc__": "\n            Returns the derivative of this rational function with respect to the\n            variable ``var``.\n\n            Over an ring with a working gcd implementation, the derivative of a\n            fraction `f/g`, supposed to be given in lowest terms, is computed as\n            `(f'(g/d) - f(g'/d))/(g(g'/d))`, where `d` is a greatest common\n            divisor of `f` and `g`.\n\n            INPUT:\n\n            - ``var`` - Variable with respect to which the derivative is computed\n\n            OUTPUT:\n\n            - Derivative of ``self`` with respect to ``var``\n\n            .. seealso::\n\n               :meth:`derivative`\n\n            EXAMPLES::\n\n                sage: F.<x> = Frac(QQ['x'])\n                sage: t = 1/x^2\n                sage: t._derivative(x)\n                -2/x^3\n                sage: t.derivative()\n                -2/x^3\n\n            ::\n\n                sage: F.<x,y> = Frac(QQ['x,y'])\n                sage: t = (x*y/(x+y))\n                sage: t._derivative(x)\n                y^2/(x^2 + 2*x*y + y^2)\n                sage: t._derivative(y)\n                x^2/(x^2 + 2*x*y + y^2)\n\n            TESTS::\n\n                sage: F.<t> = Frac(ZZ['t'])\n                sage: F(0).derivative()\n                0\n                sage: F(2).derivative()\n                0\n                sage: t.derivative()\n                1\n                sage: (1+t^2).derivative()\n                2*t\n                sage: (1/t).derivative()\n                -1/t^2\n                sage: ((t+2)/(t-1)).derivative()\n                -3/(t^2 - 2*t + 1)\n                sage: (t/(1+2*t+t^2)).derivative()\n                (-t + 1)/(t^3 + 3*t^2 + 3*t + 1)\n            ",
                    "args": [
                        "self",
                        "var"
                    ],
                    "argspec": [
                        [
                            "self",
                            "var"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "denominator": {
                    "__doc__": null,
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "derivative": {
                    "__doc__": "\n            The derivative of this rational function, with respect to variables\n            supplied in args.\n\n            Multiple variables and iteration counts may be supplied; see\n            documentation for the global derivative() function for more\n            details.\n\n            .. seealso::\n\n               :meth:`_derivative`\n\n            EXAMPLES::\n\n                sage: F.<x> = Frac(QQ['x'])\n                sage: (1/x).derivative()\n                -1/x^2\n\n            ::\n\n                sage: (x+1/x).derivative(x, 2)\n                2/x^3\n\n            ::\n\n                sage: F.<x,y> = Frac(QQ['x,y'])\n                sage: (1/(x+y)).derivative(x,y)\n                2/(x^3 + 3*x^2*y + 3*x*y^2 + y^3)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        null,
                        null
                    ]
                },
                "factor": {
                    "__doc__": "\n            Return the factorization of ``self`` over the base ring.\n\n            INPUT:\n\n            - ``*args`` - Arbitrary arguments suitable over the base ring\n            - ``**kwds`` - Arbitrary keyword arguments suitable over the base ring\n\n            OUTPUT:\n\n            - Factorization of ``self`` over the base ring\n\n            EXAMPLES::\n\n                sage: K.<x> = QQ[]\n                sage: f = (x^3+x)/(x-3)\n                sage: f.factor()\n                (x - 3)^-1 * x * (x^2 + 1)\n\n            Here is an example to show that :trac:`7868` has been resolved::\n\n                sage: R.<x,y> = GF(2)[]\n                sage: f = x*y/(x+y)\n                sage: f.factor()\n                (x + y)^-1 * y * x\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "numerator": {
                    "__doc__": null,
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "partial_fraction_decomposition": {
                    "__doc__": "\n            Decomposes fraction field element into a whole part and a list of\n            fraction field elements over prime power denominators.\n\n            The sum will be equal to the original fraction.\n\n            INPUT:\n\n            - decompose_powers - whether to decompose prime power\n                                 denominators as opposed to having a single\n                                 term for each irreducible factor of the\n                                 denominator (default: True)\n\n            OUTPUT:\n\n            - Partial fraction decomposition of self over the base ring.\n\n            AUTHORS:\n\n            - Robert Bradshaw (2007-05-31)\n\n            EXAMPLES::\n\n                sage: S.<t> = QQ[]\n                sage: q = 1/(t+1) + 2/(t+2) + 3/(t-3); q\n                (6*t^2 + 4*t - 6)/(t^3 - 7*t - 6)\n                sage: whole, parts = q.partial_fraction_decomposition(); parts\n                [3/(t - 3), 1/(t + 1), 2/(t + 2)]\n                sage: sum(parts) == q\n                True\n                sage: q = 1/(t^3+1) + 2/(t^2+2) + 3/(t-3)^5\n                sage: whole, parts = q.partial_fraction_decomposition(); parts\n                [1/3/(t + 1), 3/(t^5 - 15*t^4 + 90*t^3 - 270*t^2 + 405*t - 243), (-1/3*t + 2/3)/(t^2 - t + 1), 2/(t^2 + 2)]\n                sage: sum(parts) == q\n                True\n                sage: q = 2*t / (t + 3)^2\n                sage: q.partial_fraction_decomposition()\n                (0, [2/(t + 3), -6/(t^2 + 6*t + 9)])\n                sage: for p in q.partial_fraction_decomposition()[1]: print(p.factor())\n                (2) * (t + 3)^-1\n                (-6) * (t + 3)^-2\n                sage: q.partial_fraction_decomposition(decompose_powers=False)\n                (0, [2*t/(t^2 + 6*t + 9)])\n\n            We can decompose over a given algebraic extension::\n\n                sage: R.<x> = QQ[sqrt(2)][]\n                sage: r =  1/(x^4+1)\n                sage: r.partial_fraction_decomposition()\n                (0,\n                 [(-1/4*sqrt2*x + 1/2)/(x^2 - sqrt2*x + 1),\n                  (1/4*sqrt2*x + 1/2)/(x^2 + sqrt2*x + 1)])\n\n                sage: R.<x> = QQ[I][]  # of QQ[sqrt(-1)]\n                sage: r =  1/(x^4+1)\n                sage: r.partial_fraction_decomposition()\n                (0, [(-1/2*I)/(x^2 - I), 1/2*I/(x^2 + I)])\n\n            We can also ask Sage to find the least extension where the\n            denominator factors in linear terms::\n\n                sage: R.<x> = QQ[]\n                sage: r = 1/(x^4+2)\n                sage: N = r.denominator().splitting_field('a')\n                sage: N\n                Number Field in a with defining polynomial x^8 - 8*x^6 + 28*x^4 + 16*x^2 + 36\n                sage: R1.<x1>=N[]\n                sage: r1 = 1/(x1^4+2)\n                sage: r1.partial_fraction_decomposition()\n                (0,\n                 [(-1/224*a^6 + 13/448*a^4 - 5/56*a^2 - 25/224)/(x1 - 1/28*a^6 + 13/56*a^4 - 5/7*a^2 - 25/28),\n                  (1/224*a^6 - 13/448*a^4 + 5/56*a^2 + 25/224)/(x1 + 1/28*a^6 - 13/56*a^4 + 5/7*a^2 + 25/28),\n                  (-5/1344*a^7 + 43/1344*a^5 - 85/672*a^3 - 31/672*a)/(x1 - 5/168*a^7 + 43/168*a^5 - 85/84*a^3 - 31/84*a),\n                  (5/1344*a^7 - 43/1344*a^5 + 85/672*a^3 + 31/672*a)/(x1 + 5/168*a^7 - 43/168*a^5 + 85/84*a^3 + 31/84*a)])\n\n            Or we may work directly over an algebraically closed field::\n\n                sage: R.<x> = QQbar[]\n                sage: r =  1/(x^4+1)\n                sage: r.partial_fraction_decomposition()\n                (0,\n                 [(-0.1767766952966369? - 0.1767766952966369?*I)/(x - 0.7071067811865475? - 0.7071067811865475?*I),\n                  (-0.1767766952966369? + 0.1767766952966369?*I)/(x - 0.7071067811865475? + 0.7071067811865475?*I),\n                  (0.1767766952966369? - 0.1767766952966369?*I)/(x + 0.7071067811865475? - 0.7071067811865475?*I),\n                  (0.1767766952966369? + 0.1767766952966369?*I)/(x + 0.7071067811865475? + 0.7071067811865475?*I)])\n\n            We do the best we can over inexact fields::\n\n                sage: R.<x> = RealField(20)[]\n                sage: q = 1/(x^2 + x + 2)^2 + 1/(x-1); q\n                (x^4 + 2.0000*x^3 + 5.0000*x^2 + 5.0000*x + 3.0000)/(x^5 + x^4 + 3.0000*x^3 - x^2 - 4.0000)\n                sage: whole, parts = q.partial_fraction_decomposition(); parts\n                [1.0000/(x - 1.0000), 1.0000/(x^4 + 2.0000*x^3 + 5.0000*x^2 + 4.0000*x + 4.0000)]\n                sage: sum(parts)\n                (x^4 + 2.0000*x^3 + 5.0000*x^2 + 5.0000*x + 3.0000)/(x^5 + x^4 + 3.0000*x^3 - x^2 - 4.0000)\n\n            TESTS:\n\n            We test partial fraction for irreducible denominators::\n\n                sage: R.<x> = ZZ[]\n                sage: q = x^2/(x-1)\n                sage: q.partial_fraction_decomposition()\n                (x + 1, [1/(x - 1)])\n                sage: q = x^10/(x-1)^5\n                sage: whole, parts = q.partial_fraction_decomposition()\n                sage: whole + sum(parts) == q\n                True\n\n            And also over finite fields (see :trac:`6052`, :trac:`9945`)::\n\n                sage: R.<x> = GF(2)[]\n                sage: q = (x+1)/(x^3+x+1)\n                sage: q.partial_fraction_decomposition()\n                (0, [(x + 1)/(x^3 + x + 1)])\n\n                sage: R.<x> = GF(11)[]\n                sage: q = x + 1 + 1/(x+1) + x^2/(x^3 + 2*x + 9)\n                sage: q.partial_fraction_decomposition()\n                (x + 1, [1/(x + 1), x^2/(x^3 + 2*x + 9)])\n\n            And even the rationals::\n\n                sage: (26/15).partial_fraction_decomposition()\n                (1, [1/3, 2/5])\n                sage: (26/75).partial_fraction_decomposition()\n                (-1, [2/3, 3/5, 2/25])\n\n            A larger example::\n\n                sage: S.<t> = QQ[]\n                sage: r = t / (t^3+1)^5\n                sage: r.partial_fraction_decomposition()\n                (0,\n                 [-35/729/(t + 1),\n                  -35/729/(t^2 + 2*t + 1),\n                  -25/729/(t^3 + 3*t^2 + 3*t + 1),\n                  -4/243/(t^4 + 4*t^3 + 6*t^2 + 4*t + 1),\n                  -1/243/(t^5 + 5*t^4 + 10*t^3 + 10*t^2 + 5*t + 1),\n                  (35/729*t - 35/729)/(t^2 - t + 1),\n                  (25/729*t - 8/729)/(t^4 - 2*t^3 + 3*t^2 - 2*t + 1),\n                  (-1/81*t + 5/81)/(t^6 - 3*t^5 + 6*t^4 - 7*t^3 + 6*t^2 - 3*t + 1),\n                  (-2/27*t + 1/9)/(t^8 - 4*t^7 + 10*t^6 - 16*t^5 + 19*t^4 - 16*t^3 + 10*t^2 - 4*t + 1),\n                  (-2/27*t + 1/27)/(t^10 - 5*t^9 + 15*t^8 - 30*t^7 + 45*t^6 - 51*t^5 + 45*t^4 - 30*t^3 + 15*t^2 - 5*t + 1)])\n                sage: sum(r.partial_fraction_decomposition()[1]) == r\n                True\n\n            Some special cases::\n\n                sage: R = Frac(QQ['x']); x = R.gen()\n                sage: x.partial_fraction_decomposition()\n                (x, [])\n                sage: R(0).partial_fraction_decomposition()\n                (0, [])\n                sage: R(1).partial_fraction_decomposition()\n                (1, [])\n                sage: (1/x).partial_fraction_decomposition()\n                (0, [1/x])\n                sage: (1/x+1/x^3).partial_fraction_decomposition()\n                (0, [1/x, 1/x^3])\n                \n            This was fixed in :trac:`16240`::\n            \n                sage: R.<x> = QQ['x']\n                sage: p=1/(-x + 1)\n                sage: whole,parts = p.partial_fraction_decomposition()\n                sage: p == sum(parts)\n                True\n                sage: p=3/(-x^4 + 1)\n                sage: whole,parts = p.partial_fraction_decomposition()\n                sage: p == sum(parts)\n                True\n                sage: p=(6*x^2 - 9*x + 5)/(-x^3 + 3*x^2 - 3*x + 1)\n                sage: whole,parts = p.partial_fraction_decomposition()\n                sage: p == sum(parts)\n                True\n            ",
                    "args": [
                        "self",
                        "decompose_powers"
                    ],
                    "argspec": [
                        [
                            "self",
                            "decompose_powers"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.fields.Fields"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of quotient fields over an integral domain\n\n    EXAMPLES::\n\n        sage: QuotientFields()\n        Category of quotient fields\n        sage: QuotientFields().super_categories()\n        [Category of fields]\n\n    TESTS::\n\n        sage: TestSuite(QuotientFields()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.quotient_fields.QuotientFields",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.quotient_fields.QuotientFields",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "_derivative": {
                    "__doc__": "\n            Returns the derivative of this rational function with respect to the\n            variable ``var``.\n\n            Over an ring with a working gcd implementation, the derivative of a\n            fraction `f/g`, supposed to be given in lowest terms, is computed as\n            `(f'(g/d) - f(g'/d))/(g(g'/d))`, where `d` is a greatest common\n            divisor of `f` and `g`.\n\n            INPUT:\n\n            - ``var`` - Variable with respect to which the derivative is computed\n\n            OUTPUT:\n\n            - Derivative of ``self`` with respect to ``var``\n\n            .. seealso::\n\n               :meth:`derivative`\n\n            EXAMPLES::\n\n                sage: F.<x> = Frac(QQ['x'])\n                sage: t = 1/x^2\n                sage: t._derivative(x)\n                -2/x^3\n                sage: t.derivative()\n                -2/x^3\n\n            ::\n\n                sage: F.<x,y> = Frac(QQ['x,y'])\n                sage: t = (x*y/(x+y))\n                sage: t._derivative(x)\n                y^2/(x^2 + 2*x*y + y^2)\n                sage: t._derivative(y)\n                x^2/(x^2 + 2*x*y + y^2)\n\n            TESTS::\n\n                sage: F.<t> = Frac(ZZ['t'])\n                sage: F(0).derivative()\n                0\n                sage: F(2).derivative()\n                0\n                sage: t.derivative()\n                1\n                sage: (1+t^2).derivative()\n                2*t\n                sage: (1/t).derivative()\n                -1/t^2\n                sage: ((t+2)/(t-1)).derivative()\n                -3/(t^2 - 2*t + 1)\n                sage: (t/(1+2*t+t^2)).derivative()\n                (-t + 1)/(t^3 + 3*t^2 + 3*t + 1)\n            ",
                    "args": [
                        "self",
                        "var"
                    ],
                    "argspec": [
                        [
                            "self",
                            "var"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "denominator": {
                    "__doc__": null,
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "derivative": {
                    "__doc__": "\n            The derivative of this rational function, with respect to variables\n            supplied in args.\n\n            Multiple variables and iteration counts may be supplied; see\n            documentation for the global derivative() function for more\n            details.\n\n            .. seealso::\n\n               :meth:`_derivative`\n\n            EXAMPLES::\n\n                sage: F.<x> = Frac(QQ['x'])\n                sage: (1/x).derivative()\n                -1/x^2\n\n            ::\n\n                sage: (x+1/x).derivative(x, 2)\n                2/x^3\n\n            ::\n\n                sage: F.<x,y> = Frac(QQ['x,y'])\n                sage: (1/(x+y)).derivative(x,y)\n                2/(x^3 + 3*x^2*y + 3*x*y^2 + y^3)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        null,
                        null
                    ]
                },
                "factor": {
                    "__doc__": "\n            Return the factorization of ``self`` over the base ring.\n\n            INPUT:\n\n            - ``*args`` - Arbitrary arguments suitable over the base ring\n            - ``**kwds`` - Arbitrary keyword arguments suitable over the base ring\n\n            OUTPUT:\n\n            - Factorization of ``self`` over the base ring\n\n            EXAMPLES::\n\n                sage: K.<x> = QQ[]\n                sage: f = (x^3+x)/(x-3)\n                sage: f.factor()\n                (x - 3)^-1 * x * (x^2 + 1)\n\n            Here is an example to show that :trac:`7868` has been resolved::\n\n                sage: R.<x,y> = GF(2)[]\n                sage: f = x*y/(x+y)\n                sage: f.factor()\n                (x + y)^-1 * y * x\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "numerator": {
                    "__doc__": null,
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "partial_fraction_decomposition": {
                    "__doc__": "\n            Decomposes fraction field element into a whole part and a list of\n            fraction field elements over prime power denominators.\n\n            The sum will be equal to the original fraction.\n\n            INPUT:\n\n            - decompose_powers - whether to decompose prime power\n                                 denominators as opposed to having a single\n                                 term for each irreducible factor of the\n                                 denominator (default: True)\n\n            OUTPUT:\n\n            - Partial fraction decomposition of self over the base ring.\n\n            AUTHORS:\n\n            - Robert Bradshaw (2007-05-31)\n\n            EXAMPLES::\n\n                sage: S.<t> = QQ[]\n                sage: q = 1/(t+1) + 2/(t+2) + 3/(t-3); q\n                (6*t^2 + 4*t - 6)/(t^3 - 7*t - 6)\n                sage: whole, parts = q.partial_fraction_decomposition(); parts\n                [3/(t - 3), 1/(t + 1), 2/(t + 2)]\n                sage: sum(parts) == q\n                True\n                sage: q = 1/(t^3+1) + 2/(t^2+2) + 3/(t-3)^5\n                sage: whole, parts = q.partial_fraction_decomposition(); parts\n                [1/3/(t + 1), 3/(t^5 - 15*t^4 + 90*t^3 - 270*t^2 + 405*t - 243), (-1/3*t + 2/3)/(t^2 - t + 1), 2/(t^2 + 2)]\n                sage: sum(parts) == q\n                True\n                sage: q = 2*t / (t + 3)^2\n                sage: q.partial_fraction_decomposition()\n                (0, [2/(t + 3), -6/(t^2 + 6*t + 9)])\n                sage: for p in q.partial_fraction_decomposition()[1]: print(p.factor())\n                (2) * (t + 3)^-1\n                (-6) * (t + 3)^-2\n                sage: q.partial_fraction_decomposition(decompose_powers=False)\n                (0, [2*t/(t^2 + 6*t + 9)])\n\n            We can decompose over a given algebraic extension::\n\n                sage: R.<x> = QQ[sqrt(2)][]\n                sage: r =  1/(x^4+1)\n                sage: r.partial_fraction_decomposition()\n                (0,\n                 [(-1/4*sqrt2*x + 1/2)/(x^2 - sqrt2*x + 1),\n                  (1/4*sqrt2*x + 1/2)/(x^2 + sqrt2*x + 1)])\n\n                sage: R.<x> = QQ[I][]  # of QQ[sqrt(-1)]\n                sage: r =  1/(x^4+1)\n                sage: r.partial_fraction_decomposition()\n                (0, [(-1/2*I)/(x^2 - I), 1/2*I/(x^2 + I)])\n\n            We can also ask Sage to find the least extension where the\n            denominator factors in linear terms::\n\n                sage: R.<x> = QQ[]\n                sage: r = 1/(x^4+2)\n                sage: N = r.denominator().splitting_field('a')\n                sage: N\n                Number Field in a with defining polynomial x^8 - 8*x^6 + 28*x^4 + 16*x^2 + 36\n                sage: R1.<x1>=N[]\n                sage: r1 = 1/(x1^4+2)\n                sage: r1.partial_fraction_decomposition()\n                (0,\n                 [(-1/224*a^6 + 13/448*a^4 - 5/56*a^2 - 25/224)/(x1 - 1/28*a^6 + 13/56*a^4 - 5/7*a^2 - 25/28),\n                  (1/224*a^6 - 13/448*a^4 + 5/56*a^2 + 25/224)/(x1 + 1/28*a^6 - 13/56*a^4 + 5/7*a^2 + 25/28),\n                  (-5/1344*a^7 + 43/1344*a^5 - 85/672*a^3 - 31/672*a)/(x1 - 5/168*a^7 + 43/168*a^5 - 85/84*a^3 - 31/84*a),\n                  (5/1344*a^7 - 43/1344*a^5 + 85/672*a^3 + 31/672*a)/(x1 + 5/168*a^7 - 43/168*a^5 + 85/84*a^3 + 31/84*a)])\n\n            Or we may work directly over an algebraically closed field::\n\n                sage: R.<x> = QQbar[]\n                sage: r =  1/(x^4+1)\n                sage: r.partial_fraction_decomposition()\n                (0,\n                 [(-0.1767766952966369? - 0.1767766952966369?*I)/(x - 0.7071067811865475? - 0.7071067811865475?*I),\n                  (-0.1767766952966369? + 0.1767766952966369?*I)/(x - 0.7071067811865475? + 0.7071067811865475?*I),\n                  (0.1767766952966369? - 0.1767766952966369?*I)/(x + 0.7071067811865475? - 0.7071067811865475?*I),\n                  (0.1767766952966369? + 0.1767766952966369?*I)/(x + 0.7071067811865475? + 0.7071067811865475?*I)])\n\n            We do the best we can over inexact fields::\n\n                sage: R.<x> = RealField(20)[]\n                sage: q = 1/(x^2 + x + 2)^2 + 1/(x-1); q\n                (x^4 + 2.0000*x^3 + 5.0000*x^2 + 5.0000*x + 3.0000)/(x^5 + x^4 + 3.0000*x^3 - x^2 - 4.0000)\n                sage: whole, parts = q.partial_fraction_decomposition(); parts\n                [1.0000/(x - 1.0000), 1.0000/(x^4 + 2.0000*x^3 + 5.0000*x^2 + 4.0000*x + 4.0000)]\n                sage: sum(parts)\n                (x^4 + 2.0000*x^3 + 5.0000*x^2 + 5.0000*x + 3.0000)/(x^5 + x^4 + 3.0000*x^3 - x^2 - 4.0000)\n\n            TESTS:\n\n            We test partial fraction for irreducible denominators::\n\n                sage: R.<x> = ZZ[]\n                sage: q = x^2/(x-1)\n                sage: q.partial_fraction_decomposition()\n                (x + 1, [1/(x - 1)])\n                sage: q = x^10/(x-1)^5\n                sage: whole, parts = q.partial_fraction_decomposition()\n                sage: whole + sum(parts) == q\n                True\n\n            And also over finite fields (see :trac:`6052`, :trac:`9945`)::\n\n                sage: R.<x> = GF(2)[]\n                sage: q = (x+1)/(x^3+x+1)\n                sage: q.partial_fraction_decomposition()\n                (0, [(x + 1)/(x^3 + x + 1)])\n\n                sage: R.<x> = GF(11)[]\n                sage: q = x + 1 + 1/(x+1) + x^2/(x^3 + 2*x + 9)\n                sage: q.partial_fraction_decomposition()\n                (x + 1, [1/(x + 1), x^2/(x^3 + 2*x + 9)])\n\n            And even the rationals::\n\n                sage: (26/15).partial_fraction_decomposition()\n                (1, [1/3, 2/5])\n                sage: (26/75).partial_fraction_decomposition()\n                (-1, [2/3, 3/5, 2/25])\n\n            A larger example::\n\n                sage: S.<t> = QQ[]\n                sage: r = t / (t^3+1)^5\n                sage: r.partial_fraction_decomposition()\n                (0,\n                 [-35/729/(t + 1),\n                  -35/729/(t^2 + 2*t + 1),\n                  -25/729/(t^3 + 3*t^2 + 3*t + 1),\n                  -4/243/(t^4 + 4*t^3 + 6*t^2 + 4*t + 1),\n                  -1/243/(t^5 + 5*t^4 + 10*t^3 + 10*t^2 + 5*t + 1),\n                  (35/729*t - 35/729)/(t^2 - t + 1),\n                  (25/729*t - 8/729)/(t^4 - 2*t^3 + 3*t^2 - 2*t + 1),\n                  (-1/81*t + 5/81)/(t^6 - 3*t^5 + 6*t^4 - 7*t^3 + 6*t^2 - 3*t + 1),\n                  (-2/27*t + 1/9)/(t^8 - 4*t^7 + 10*t^6 - 16*t^5 + 19*t^4 - 16*t^3 + 10*t^2 - 4*t + 1),\n                  (-2/27*t + 1/27)/(t^10 - 5*t^9 + 15*t^8 - 30*t^7 + 45*t^6 - 51*t^5 + 45*t^4 - 30*t^3 + 15*t^2 - 5*t + 1)])\n                sage: sum(r.partial_fraction_decomposition()[1]) == r\n                True\n\n            Some special cases::\n\n                sage: R = Frac(QQ['x']); x = R.gen()\n                sage: x.partial_fraction_decomposition()\n                (x, [])\n                sage: R(0).partial_fraction_decomposition()\n                (0, [])\n                sage: R(1).partial_fraction_decomposition()\n                (1, [])\n                sage: (1/x).partial_fraction_decomposition()\n                (0, [1/x])\n                sage: (1/x+1/x^3).partial_fraction_decomposition()\n                (0, [1/x, 1/x^3])\n                \n            This was fixed in :trac:`16240`::\n            \n                sage: R.<x> = QQ['x']\n                sage: p=1/(-x + 1)\n                sage: whole,parts = p.partial_fraction_decomposition()\n                sage: p == sum(parts)\n                True\n                sage: p=3/(-x^4 + 1)\n                sage: whole,parts = p.partial_fraction_decomposition()\n                sage: p == sum(parts)\n                True\n                sage: p=(6*x^2 - 9*x + 5)/(-x^3 + 3*x^2 - 3*x + 1)\n                sage: whole,parts = p.partial_fraction_decomposition()\n                sage: p == sum(parts)\n                True\n            ",
                    "args": [
                        "self",
                        "decompose_powers"
                    ],
                    "argspec": [
                        [
                            "self",
                            "decompose_powers"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of modular abelian varieties over a given field.\n\n    EXAMPLES::\n\n        sage: ModularAbelianVarieties(QQ)\n        Category of modular abelian varieties over Rational Field\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of modular abelian varieties over a given field.\n\n    EXAMPLES::\n\n        sage: ModularAbelianVarieties(QQ)\n        Category of modular abelian varieties over Rational Field\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of modular abelian varieties over a given field.\n\n    EXAMPLES::\n\n        sage: ModularAbelianVarieties(QQ)\n        Category of modular abelian varieties over Rational Field\n    ",
            "methods": {}
        },
        "name": "sage.categories.modular_abelian_varieties.ModularAbelianVarieties",
        "parent_class": {
            "__doc__": "\n    The category of modular abelian varieties over a given field.\n\n    EXAMPLES::\n\n        sage: ModularAbelianVarieties(QQ)\n        Category of modular abelian varieties over Rational Field\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.modular_abelian_varieties.ModularAbelianVarieties",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of modular abelian varieties over a given field.\n\n    EXAMPLES::\n\n        sage: ModularAbelianVarieties(QQ)\n        Category of modular abelian varieties over Rational Field\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded modules.\n\n    We consider every graded module `M = \\bigoplus_i M_i` as a\n    filtered module under the (natural) filtration given by\n\n    .. MATH::\n\n        F_i = \\bigoplus_{j < i} M_j.\n\n    EXAMPLES::\n\n        sage: GradedModules(ZZ)\n        Category of graded modules over Integer Ring\n        sage: GradedModules(ZZ).super_categories()\n        [Category of filtered modules over Integer Ring]\n\n    The category of graded modules defines the graded structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Graded().additional_structure()\n        Category of graded modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(GradedModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded modules.\n\n    We consider every graded module `M = \\bigoplus_i M_i` as a\n    filtered module under the (natural) filtration given by\n\n    .. MATH::\n\n        F_i = \\bigoplus_{j < i} M_j.\n\n    EXAMPLES::\n\n        sage: GradedModules(ZZ)\n        Category of graded modules over Integer Ring\n        sage: GradedModules(ZZ).super_categories()\n        [Category of filtered modules over Integer Ring]\n\n    The category of graded modules defines the graded structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Graded().additional_structure()\n        Category of graded modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(GradedModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_modules.GradedModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of bialgebras\n\n    EXAMPLES::\n\n        sage: Bialgebras(ZZ)\n        Category of bialgebras over Integer Ring\n        sage: Bialgebras(ZZ).super_categories()\n        [Category of algebras over Integer Ring, Category of coalgebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Bialgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of bialgebras\n\n    EXAMPLES::\n\n        sage: Bialgebras(ZZ)\n        Category of bialgebras over Integer Ring\n        sage: Bialgebras(ZZ).super_categories()\n        [Category of algebras over Integer Ring, Category of coalgebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Bialgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of bialgebras\n\n    EXAMPLES::\n\n        sage: Bialgebras(ZZ)\n        Category of bialgebras over Integer Ring\n        sage: Bialgebras(ZZ).super_categories()\n        [Category of algebras over Integer Ring, Category of coalgebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Bialgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.bialgebras.Bialgebras",
        "parent_class": {
            "__doc__": "\n    The category of bialgebras\n\n    EXAMPLES::\n\n        sage: Bialgebras(ZZ)\n        Category of bialgebras over Integer Ring\n        sage: Bialgebras(ZZ).super_categories()\n        [Category of algebras over Integer Ring, Category of coalgebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Bialgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of bialgebras\n\n    EXAMPLES::\n\n        sage: Bialgebras(ZZ)\n        Category of bialgebras over Integer Ring\n        sage: Bialgebras(ZZ).super_categories()\n        [Category of algebras over Integer Ring, Category of coalgebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Bialgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Infinite"
        ],
        "element_class": {
            "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.enumerated_sets.EnumeratedSets",
            "sage.categories.sets_cat.Sets.Infinite"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_enumerated_set_iter_cardinality": {
                    "__doc__": "\n            Check that the methods :meth:`.cardinality` and\n            :meth:`.__iter__`. are consistent.\n\n            See also :class:`TestSuite`.\n\n            For infinite enumerated sets:\n\n               * :meth:`.cardinality` is supposed to return `infinity`\n\n               * :meth:`.list`` is supposed to raise a ``NotImplementedError``.\n\n            EXAMPLES::\n\n                sage: NN = InfiniteEnumeratedSets().example()\n                sage: NN._test_enumerated_set_iter_cardinality()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of infinite enumerated sets\n\n    An infinite enumerated sets is a countable set together with a\n    canonical enumeration of its elements.\n\n    EXAMPLES::\n\n        sage: InfiniteEnumeratedSets()\n        Category of infinite enumerated sets\n        sage: InfiniteEnumeratedSets().super_categories()\n        [Category of enumerated sets, Category of infinite sets]\n        sage: InfiniteEnumeratedSets().all_super_categories()\n        [Category of infinite enumerated sets,\n         Category of enumerated sets,\n         Category of infinite sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    TESTS::\n\n        sage: C = InfiniteEnumeratedSets()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of function fields.\n\n    EXAMPLES:\n\n    We create the category of function fields::\n\n        sage: C = FunctionFields()\n        sage: C\n        Category of function fields\n\n    TESTS::\n\n        sage: TestSuite(FunctionFields()).run()\n    ",
        "axioms": [
            "Division",
            "AdditiveUnital",
            "NoZeroDivisors",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.fields.Fields"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of function fields.\n\n    EXAMPLES:\n\n    We create the category of function fields::\n\n        sage: C = FunctionFields()\n        sage: C\n        Category of function fields\n\n    TESTS::\n\n        sage: TestSuite(FunctionFields()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.function_fields.FunctionFields",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.euclidean_domains.EuclideanDomains",
            "sage.categories.function_fields.FunctionFields",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of Hecke modules.\n\n    A Hecke module is a module `M` over the \\emph{anemic} Hecke\n    algebra, i.e., the Hecke algebra generated by Hecke operators\n    `T_n` with `n` coprime to the level of `M`.  (Every Hecke module\n    defines a level function, which is a positive integer.)  The\n    reason we require that `M` only be a module over the anemic Hecke\n    algebra is that many natural maps, e.g., degeneracy maps,\n    Atkin-Lehner operators, etc., are `\\Bold{T}`-module homomorphisms; but\n    they are homomorphisms over the anemic Hecke algebra.\n\n    EXAMPLES:\n\n    We create the category of Hecke modules over `\\QQ`::\n\n        sage: C = HeckeModules(RationalField()); C\n        Category of Hecke modules over Rational Field\n\n    TODO: check that this is what we want::\n\n        sage: C.super_categories()\n        [Category of vector spaces with basis over Rational Field]\n\n    # [Category of vector spaces over Rational Field]\n\n    Note that the base ring can be an arbitrary commutative ring::\n\n        sage: HeckeModules(IntegerRing())\n        Category of Hecke modules over Integer Ring\n        sage: HeckeModules(FiniteField(5))\n        Category of Hecke modules over Finite Field of size 5\n\n    The base ring doesn't have to be a principal ideal domain::\n\n        sage: HeckeModules(PolynomialRing(IntegerRing(), 'x'))\n        Category of Hecke modules over Univariate Polynomial Ring in x over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(HeckeModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of Hecke modules.\n\n    A Hecke module is a module `M` over the \\emph{anemic} Hecke\n    algebra, i.e., the Hecke algebra generated by Hecke operators\n    `T_n` with `n` coprime to the level of `M`.  (Every Hecke module\n    defines a level function, which is a positive integer.)  The\n    reason we require that `M` only be a module over the anemic Hecke\n    algebra is that many natural maps, e.g., degeneracy maps,\n    Atkin-Lehner operators, etc., are `\\Bold{T}`-module homomorphisms; but\n    they are homomorphisms over the anemic Hecke algebra.\n\n    EXAMPLES:\n\n    We create the category of Hecke modules over `\\QQ`::\n\n        sage: C = HeckeModules(RationalField()); C\n        Category of Hecke modules over Rational Field\n\n    TODO: check that this is what we want::\n\n        sage: C.super_categories()\n        [Category of vector spaces with basis over Rational Field]\n\n    # [Category of vector spaces over Rational Field]\n\n    Note that the base ring can be an arbitrary commutative ring::\n\n        sage: HeckeModules(IntegerRing())\n        Category of Hecke modules over Integer Ring\n        sage: HeckeModules(FiniteField(5))\n        Category of Hecke modules over Finite Field of size 5\n\n    The base ring doesn't have to be a principal ideal domain::\n\n        sage: HeckeModules(PolynomialRing(IntegerRing(), 'x'))\n        Category of Hecke modules over Univariate Polynomial Ring in x over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(HeckeModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of Hecke modules.\n\n    A Hecke module is a module `M` over the \\emph{anemic} Hecke\n    algebra, i.e., the Hecke algebra generated by Hecke operators\n    `T_n` with `n` coprime to the level of `M`.  (Every Hecke module\n    defines a level function, which is a positive integer.)  The\n    reason we require that `M` only be a module over the anemic Hecke\n    algebra is that many natural maps, e.g., degeneracy maps,\n    Atkin-Lehner operators, etc., are `\\Bold{T}`-module homomorphisms; but\n    they are homomorphisms over the anemic Hecke algebra.\n\n    EXAMPLES:\n\n    We create the category of Hecke modules over `\\QQ`::\n\n        sage: C = HeckeModules(RationalField()); C\n        Category of Hecke modules over Rational Field\n\n    TODO: check that this is what we want::\n\n        sage: C.super_categories()\n        [Category of vector spaces with basis over Rational Field]\n\n    # [Category of vector spaces over Rational Field]\n\n    Note that the base ring can be an arbitrary commutative ring::\n\n        sage: HeckeModules(IntegerRing())\n        Category of Hecke modules over Integer Ring\n        sage: HeckeModules(FiniteField(5))\n        Category of Hecke modules over Finite Field of size 5\n\n    The base ring doesn't have to be a principal ideal domain::\n\n        sage: HeckeModules(PolynomialRing(IntegerRing(), 'x'))\n        Category of Hecke modules over Univariate Polynomial Ring in x over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(HeckeModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.hecke_modules.HeckeModules",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_Hom_": {
                    "__doc__": "\n            Returns the homset from ``self`` to ``Y`` in the category ``category``\n\n            INPUT:\n\n            - ``Y`` -- an Hecke module\n            - ``category`` -- a subcategory of :class:`HeckeModules`() or None\n\n            The sole purpose of this method is to construct the homset\n            as a :class:`~sage.modular.hecke.homspace.HeckeModuleHomspace`. If\n            ``category`` is specified and is not a subcategory of\n            :class:`HeckeModules`, a ``TypeError`` is raised instead\n\n            This method is not meant to be called directly. Please use\n            :func:`sage.categories.homset.Hom` instead.\n\n            EXAMPLES::\n\n                sage: M = ModularForms(Gamma0(7), 4)\n                sage: H = M._Hom_(M, category = HeckeModules(QQ)); H\n                Set of Morphisms from Modular Forms space of dimension 3 for Congruence Subgroup Gamma0(7) of weight 4 over Rational Field to Modular Forms space of dimension 3 for Congruence Subgroup Gamma0(7) of weight 4 over Rational Field in Category of Hecke modules over Rational Field\n                sage: H.__class__\n                <class 'sage.modular.hecke.homspace.HeckeModuleHomspace_with_category'>\n                sage: TestSuite(H).run(skip=[\"_test_elements\", \"_test_an_element\", \"_test_elements_eq\",\n                ....:                        \"_test_elements_eq_reflexive\", \"_test_elements_eq_transitive\",\n                ....:                        \"_test_elements_eq_symmetric\", \"_test_elements_neq\", \"_test_some_elements\",\n                ....:                        \"_test_zero\", \"_test_additive_associativity\",\n                ....:                        \"_test_one\", \"_test_associativity\", \"_test_prod\"])\n\n            Fixing :meth:`_test_zero` (``__call__`` should accept a\n            function as input) and :meth:`_test_elements*` (modular\n            form morphisms elements should inherit from categories) is\n            :trac:`12879`.\n\n            TESTS::\n\n                sage: H = M._Hom_(M, category = HeckeModules(GF(5))); H\n                Traceback (most recent call last):\n                ...\n                TypeError: Category of Hecke modules over Finite Field of size 5 is not a subcategory of Category of Hecke modules over Rational Field\n\n            ",
                    "args": [
                        "self",
                        "Y",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "Y",
                            "category"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.hecke_modules.HeckeModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of Hecke modules.\n\n    A Hecke module is a module `M` over the \\emph{anemic} Hecke\n    algebra, i.e., the Hecke algebra generated by Hecke operators\n    `T_n` with `n` coprime to the level of `M`.  (Every Hecke module\n    defines a level function, which is a positive integer.)  The\n    reason we require that `M` only be a module over the anemic Hecke\n    algebra is that many natural maps, e.g., degeneracy maps,\n    Atkin-Lehner operators, etc., are `\\Bold{T}`-module homomorphisms; but\n    they are homomorphisms over the anemic Hecke algebra.\n\n    EXAMPLES:\n\n    We create the category of Hecke modules over `\\QQ`::\n\n        sage: C = HeckeModules(RationalField()); C\n        Category of Hecke modules over Rational Field\n\n    TODO: check that this is what we want::\n\n        sage: C.super_categories()\n        [Category of vector spaces with basis over Rational Field]\n\n    # [Category of vector spaces over Rational Field]\n\n    Note that the base ring can be an arbitrary commutative ring::\n\n        sage: HeckeModules(IntegerRing())\n        Category of Hecke modules over Integer Ring\n        sage: HeckeModules(FiniteField(5))\n        Category of Hecke modules over Finite Field of size 5\n\n    The base ring doesn't have to be a principal ideal domain::\n\n        sage: HeckeModules(PolynomialRing(IntegerRing(), 'x'))\n        Category of Hecke modules over Univariate Polynomial Ring in x over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(HeckeModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of regular crystals.\n\n    A crystal is called *regular* if every vertex `b` satisfies\n\n    .. MATH::\n\n        \\varepsilon_i(b) = \\max\\{ k \\mid e_i^k(b) \\neq 0 \\} \\quad \\text{and}\n        \\quad \\varphi_i(b) = \\max\\{ k \\mid f_i^k(b) \\neq 0 \\}.\n\n    .. NOTE::\n\n        Regular crystals are sometimes referred to as *normal*. When only one\n        of the conditions (on either `\\varphi_i` or `\\varepsilon_i`) holds,\n        these crystals are sometimes called *seminormal* or *semiregular*.\n\n    EXAMPLES::\n\n        sage: C = RegularCrystals()\n        sage: C\n        Category of regular crystals\n        sage: C.super_categories()\n        [Category of crystals]\n        sage: C.example()\n        Highest weight crystal of type A_3 of highest weight omega_1\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: B = RegularCrystals().example()\n        sage: TestSuite(B).run(verbose = True)\n        running ._test_an_element() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          running ._test_stembridge_local_axioms() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_enumerated_set_contains() . . . pass\n        running ._test_enumerated_set_iter_cardinality() . . . pass\n        running ._test_enumerated_set_iter_list() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_fast_iter() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_stembridge_local_axioms() . . . pass\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {
                "_test_stembridge_local_axioms": {
                    "__doc__": "\n            This implements tests for the Stembridge local characterization\n            on the element of a crystal ``self``.\n\n            The current implementation only uses the axioms for simply-laced\n            types.  Crystals of other types should still pass the test, but\n            in non-simply-laced types, passing is not a guarantee that the\n            crystal arises from a representation.\n\n            One can specify an index set smaller than the full index set of\n            the crystal, using the option ``index_set``.\n\n            Running with ``verbose=True`` will print warnings when a test fails.\n\n            REFERENCES:\n\n            .. [S2003] John R. Stembridge, A local characterization of\n               simply-laced crystals,\n               Transactions of the American Mathematical Society, Vol. 355,\n               No. 12 (Dec., 2003), pp. 4807--4823\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,1],[2]])\n                sage: t._test_stembridge_local_axioms()\n                True\n                sage: t._test_stembridge_local_axioms(index_set=[1,3])\n                True\n                sage: t._test_stembridge_local_axioms(verbose=True)\n                True\n            ",
                    "args": [
                        "self",
                        "index_set",
                        "verbose"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set",
                            "verbose"
                        ],
                        null,
                        "options",
                        [
                            null,
                            false
                        ]
                    ]
                },
                "demazure_operator_simple": {
                    "__doc__": "\n            Return the Demazure operator `D_i` applied to ``self``.\n\n            INPUT:\n\n            - ``i`` -- an element of the index set of the underlying crystal\n            - ``ring`` -- (default: ``QQ``) a ring\n\n            OUTPUT:\n\n            An element of the ``ring``-free module indexed by the underlying\n            crystal.\n\n            Let `r = \\langle \\mathrm{wt}(b), \\alpha^{\\vee}_i \\rangle`, then\n            `D_i(b)` is defined as follows:\n\n            - If `r \\geq 0`, this returns the sum of the elements obtained\n              from ``self`` by application of `f_i^k` for `0 \\leq k \\leq r`.\n            - If `r < 0`, this returns the opposite of the sum of the\n              elements obtained by application of `e_i^k` for `0 < k < -r`.\n\n            REFERENCES:\n\n            .. [L1995] Peter Littelmann, Crystal graphs and Young tableaux,\n               J. Algebra 175 (1995), no. 1, 65--87.\n\n            .. [K1993] Masaki Kashiwara, The crystal base and Littelmann's\n               refined Demazure character formula,\n               Duke Math. J. 71 (1993), no. 3, 839--858.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t = T(rows=[[1,2],[2]])\n                sage: t.demazure_operator_simple(2)\n                B[[[1, 2], [2]]] + B[[[1, 3], [2]]] + B[[[1, 3], [3]]]\n                sage: t.demazure_operator_simple(2).parent()\n                Free module generated by The crystal of tableaux of type ['A', 2] and shape(s) [[2, 1]] over Integer Ring\n\n                sage: t.demazure_operator_simple(1)\n                0\n\n                sage: K = crystals.KirillovReshetikhin(['A',2,1],2,1)\n                sage: t = K(rows=[[3],[2]])\n                sage: t.demazure_operator_simple(0)\n                B[[[1, 2]]] + B[[[2, 3]]]\n\n            TESTS::\n\n                sage: K = crystals.KirillovReshetikhin(['A',2,1],1,1)\n                sage: x = K.an_element(); x\n                [[1]]\n                sage: x.demazure_operator_simple(0)\n                0\n                sage: x.demazure_operator_simple(0, ring = QQ).parent()\n                Free module generated by Kirillov-Reshetikhin crystal of type ['A', 2, 1] with (r,s)=(1,1) over Rational Field\n            ",
                    "args": [
                        "self",
                        "i",
                        "ring"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "ring"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "dual_equivalence_class": {
                    "__doc__": "\n            Return the dual equivalence class indexed by ``index_set``\n            of ``self``.\n\n            The dual equivalence class of an element `b \\in B`\n            is the set of all elements of `B` reachable from\n            `b` via sequences of `i`-elementary dual equivalence\n            relations (i.e., `i`-elementary dual equivalence\n            transformations and their inverses) for `i` in the index\n            set of `B`.\n\n            For this to be well-defined, the element `b` has to be\n            of weight `0` with respect to `I`; that is, we need to have\n            `\\varepsilon_j(b) = \\varphi_j(b)` for all `j \\in I`.\n\n            See [Assaf08]_. See also :meth:`dual_equivalence_graph` for\n            a definition of `i`-elementary dual equivalence\n            transformations.\n\n            INPUT:\n\n            - ``index_set`` -- (optional) the index set `I`\n              (default: the whole index set of the crystal); this has\n              to be a subset of the index set of the crystal (as a list\n              or tuple)\n\n            OUTPUT:\n\n            The dual equivalence class of ``self`` indexed by the\n            subset ``index_set``. This class is returned as an\n            undirected edge-colored multigraph. The color of an edge\n            is the index `i` of the dual equivalence relation it\n            encodes.\n\n            .. SEEALSO::\n\n                - :meth:`~sage.categories.regular_crystals.RegularCrystals.ParentMethods.dual_equivalence_graph`\n                - :meth:`sage.combinat.partition.Partition.dual_equivalence_graph`\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',3], shape=[2,2])\n                sage: G = T(2,1,4,3).dual_equivalence_class()\n                sage: sorted(G.edges())\n                [([[1, 3], [2, 4]], [[1, 2], [3, 4]], 2),\n                 ([[1, 3], [2, 4]], [[1, 2], [3, 4]], 3)]\n                sage: T = crystals.Tableaux(['A',4], shape=[3,2])\n                sage: G = T(2,1,4,3,5).dual_equivalence_class()\n                sage: sorted(G.edges())\n                [([[1, 3, 5], [2, 4]], [[1, 3, 4], [2, 5]], 4),\n                 ([[1, 3, 5], [2, 4]], [[1, 2, 5], [3, 4]], 2),\n                 ([[1, 3, 5], [2, 4]], [[1, 2, 5], [3, 4]], 3),\n                 ([[1, 3, 4], [2, 5]], [[1, 2, 4], [3, 5]], 2),\n                 ([[1, 2, 4], [3, 5]], [[1, 2, 3], [4, 5]], 3),\n                 ([[1, 2, 4], [3, 5]], [[1, 2, 3], [4, 5]], 4)]\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "stembridgeDel_depth": {
                    "__doc__": "\n            Return the difference in the `j`-depth of ``self`` and `f_i` of\n            ``self``, where `i` and `j` are in the index set of the\n            underlying crystal. This function is useful for checking the\n            Stembridge local axioms for crystal bases.\n\n            The `i`-depth of a crystal node `x` is `\\varepsilon_i(x)`.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,1],[2]])\n                sage: t.stembridgeDel_depth(1,2)\n                0\n                sage: s=T(rows=[[1,3],[3]])\n                sage: s.stembridgeDel_depth(1,2)\n                -1\n            ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "stembridgeDel_rise": {
                    "__doc__": "\n            Return the difference in the `j`-rise of ``self`` and `f_i` of\n            ``self``, where `i` and `j` are in the index set of the\n            underlying crystal. This function is useful for checking the\n            Stembridge local axioms for crystal bases.\n\n            The `i`-rise of a crystal node `x` is `\\varphi_i(x)`.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,1],[2]])\n                sage: t.stembridgeDel_rise(1,2)\n                -1\n                sage: s=T(rows=[[1,3],[3]])\n                sage: s.stembridgeDel_rise(1,2)\n                0\n            ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "stembridgeDelta_depth": {
                    "__doc__": "\n            Return the difference in the `j`-depth of ``self`` and `e_i`\n            of ``self``, where `i` and `j` are in the index set of the\n            underlying crystal. This function is useful for checking the\n            Stembridge local axioms for crystal bases.\n\n            The `i`-depth of a crystal node `x` is `-\\varepsilon_i(x)`.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,2],[2]])\n                sage: t.stembridgeDelta_depth(1,2)\n                0\n                sage: s=T(rows=[[2,3],[3]])\n                sage: s.stembridgeDelta_depth(1,2)\n                -1\n            ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "stembridgeDelta_rise": {
                    "__doc__": "\n            Return the difference in the `j`-rise of ``self`` and `e_i` of\n            ``self``, where `i` and `j` are in the index set of the\n            underlying crystal. This function is useful for checking the\n            Stembridge local axioms for crystal bases.\n\n            The `i`-rise of a crystal node `x` is `\\varphi_i(x)`.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,2],[2]])\n                sage: t.stembridgeDelta_rise(1,2)\n                -1\n                sage: s=T(rows=[[2,3],[3]])\n                sage: s.stembridgeDelta_rise(1,2)\n                0\n            ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "stembridgeTriple": {
                    "__doc__": "\n            Let `A` be the Cartan matrix of the crystal, `x` a crystal element,\n            and let `i` and `j` be in the index set of the crystal.\n            Further, set\n            ``b=stembridgeDelta_depth(x,i,j)``, and\n            ``c=stembridgeDelta_rise(x,i,j))``.\n            If ``x.e(i)`` is non-empty, this function returns the triple\n            `( A_{ij}, b, c )`; otherwise it returns ``None``.\n            By the Stembridge local characterization of crystal bases,\n            one should have `A_{ij}=b+c`.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,1],[2]])\n                sage: t.stembridgeTriple(1,2)\n                sage: s=T(rows=[[1,2],[2]])\n                sage: s.stembridgeTriple(1,2)\n                (-1, 0, -1)\n\n                sage: T = crystals.Tableaux(['B',2], shape=[2,1])\n                sage: t=T(rows=[[1,2],[2]])\n                sage: t.stembridgeTriple(1,2)\n                (-2, 0, -2)\n                sage: s=T(rows=[[-1,-1],[0]])\n                sage: s.stembridgeTriple(1,2)\n                (-2, -2, 0)\n                sage: u=T(rows=[[0,2],[1]])\n                sage: u.stembridgeTriple(1,2)\n                (-2, -1, -1)\n            ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.crystals.Crystals"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.regular_crystals.RegularCrystals",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_stembridge_local_axioms": {
                    "__doc__": "\n            This implements tests for the Stembridge local characterization\n            on the finite crystal ``self``.\n\n            The current implementation only uses the rules for simply-laced\n            types.  Crystals of other types should still pass the test, but\n            expansion of this test to non-simply laced type would be desirable.\n\n            One can specify an index set smaller than the full index set of\n            the crystal, using the option ``index_set``.\n\n            Running with ``verbose=True`` will print each node for which a\n            local axiom test applies.\n\n            Running with ``complete=True`` will continue to run the test past\n            the first failure of the local axioms.  This is probably only\n            useful in conjunction with the verbose option, to see all places\n            where the local axioms fail.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',3], shape=[2,1])\n                sage: T._test_stembridge_local_axioms()\n                True\n                sage: T._test_stembridge_local_axioms(verbose=True)\n                True\n                sage: T._test_stembridge_local_axioms(index_set=[1,3])\n                True\n\n                sage: B=Crystals().example(choice='naive')\n                sage: B._test_stembridge_local_axioms()\n                Traceback (most recent call last):\n                ...\n                AssertionError: None\n            ",
                    "args": [
                        "self",
                        "index_set",
                        "verbose",
                        "complete"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set",
                            "verbose",
                            "complete"
                        ],
                        null,
                        "options",
                        [
                            null,
                            false,
                            false
                        ]
                    ]
                },
                "demazure_operator": {
                    "__doc__": "\n            Returns the application of Demazure operators `D_i` for `i` from\n            ``reduced_word`` on ``element``.\n\n            INPUT:\n\n            - ``element`` -- an element of a free module indexed by the\n              underlying crystal\n            - ``reduced_word`` -- a reduced word of the Weyl group of the\n              same type as the underlying crystal\n\n            OUTPUT:\n\n            - an element of the free module indexed by the underlying crystal\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: C = CombinatorialFreeModule(QQ,T)\n                sage: t = T.highest_weight_vector()\n                sage: b = 2*C(t)\n                sage: T.demazure_operator(b,[1,2,1])\n                2*B[[[1, 1], [2]]] + 2*B[[[1, 2], [2]]] + 2*B[[[1, 3], [2]]] + 2*B[[[1, 1], [3]]]\n                + 2*B[[[1, 2], [3]]] + 2*B[[[1, 3], [3]]] + 2*B[[[2, 2], [3]]] + 2*B[[[2, 3], [3]]]\n\n            The Demazure operator is idempotent::\n\n                sage: T = crystals.Tableaux(\"A1\",shape=[4])\n                sage: C = CombinatorialFreeModule(QQ,T)\n                sage: b = C(T.module_generators[0]); b\n                B[[[1, 1, 1, 1]]]\n                sage: e = T.demazure_operator(b,[1]); e\n                B[[[1, 1, 1, 1]]] + B[[[1, 1, 1, 2]]] + B[[[1, 1, 2, 2]]] + B[[[1, 2, 2, 2]]] + B[[[2, 2, 2, 2]]]\n                sage: e == T.demazure_operator(e,[1])\n                True\n\n                sage: all(T.demazure_operator(T.demazure_operator(C(t),[1]),[1]) == T.demazure_operator(C(t),[1]) for t in T)\n                True\n            ",
                    "args": [
                        "self",
                        "element",
                        "reduced_word"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element",
                            "reduced_word"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "demazure_subcrystal": {
                    "__doc__": "\n            Return the subcrystal corresponding to the application of\n            Demazure operators `D_i` for `i` from ``reduced_word`` on\n            ``element``.\n\n            INPUT:\n\n            - ``element`` -- an element of a free module indexed by the\n              underlying crystal\n            - ``reduced_word`` -- a reduced word of the Weyl group of the\n              same type as the underlying crystal\n            - ``only_support`` -- (default: ``True``) only include arrows\n              corresponding the the support of ``reduced_word``\n\n            OUTPUT:\n\n            - the Demazure subcrystal \n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t = T.highest_weight_vector()\n                sage: S = T.demazure_subcrystal(t, [1,2])\n                sage: list(S)\n                [[[1, 1], [2]], [[1, 1], [3]], [[1, 2], [2]],\n                 [[1, 2], [3]], [[2, 2], [3]]]\n                sage: S = T.demazure_subcrystal(t, [2,1])\n                sage: list(S)\n                [[[1, 1], [2]], [[1, 1], [3]], [[1, 2], [2]],\n                 [[1, 3], [2]], [[1, 3], [3]]]\n\n            We construct an example where we don't only want the arrows\n            indicated by the support of the reduced word::\n\n                sage: K = crystals.KirillovReshetikhin(['A',1,1], 1, 2)\n                sage: mg = K.module_generator()\n                sage: S = K.demazure_subcrystal(mg, [1])\n                sage: S.digraph().edges()\n                [([[1, 1]], [[1, 2]], 1), ([[1, 2]], [[2, 2]], 1)]\n                sage: S = K.demazure_subcrystal(mg, [1], only_support=False)\n                sage: S.digraph().edges()\n                [([[1, 1]], [[1, 2]], 1),\n                 ([[1, 2]], [[1, 1]], 0),\n                 ([[1, 2]], [[2, 2]], 1),\n                 ([[2, 2]], [[1, 2]], 0)]\n            ",
                    "args": [
                        "self",
                        "element",
                        "reduced_word",
                        "only_support"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element",
                            "reduced_word",
                            "only_support"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "dual_equivalence_graph": {
                    "__doc__": "\n            Return the dual equivalence graph indexed by ``index_set``\n            on the subset ``X`` of ``self``.\n\n            Let `b \\in B` be an element of weight `0`, so `\\varepsilon_j(b)\n            = \\varphi_j(b)` for all `j \\in I`, where `I` is the indexing\n            set. We say `b'` is an `i`-elementary dual equivalence\n            transformation of `b` (where `i \\in I`) if\n\n            * `\\varepsilon_i(b) = 1` and `\\varepsilon_{i-1}(b) = 0`, and\n            * `b' = f_{i-1} f_i e_{i-1} e_i b`.\n\n            We can do the inverse procedure by interchanging `i` and `i-1`\n            above.\n\n            .. NOTE::\n\n                If the index set is not an ordered interval, we let\n                `i - 1` mean the index appearing before `i` in `I`.\n\n            This definition comes from [Assaf08]_ Section 4 (where our\n            `\\varphi_j(b)` and `\\varepsilon_j(b)` are denoted by\n            `\\epsilon(b, j)` and `-\\delta(b, j)`, respectively).\n\n            The dual equivalence graph of `B` is defined to be the\n            colored graph whose vertices are the elements of `B` of\n            weight `0`, and whose edges of color `i` (for `i \\in I`)\n            connect pairs `\\{ b, b' \\}` such that `b'` is an\n            `i`-elementary dual equivalence transformation of `b`.\n\n            .. NOTE::\n\n                This dual equivalence graph is a generalization of\n                `\\mathcal{G}\\left(\\mathcal{X}\\right)` in [Assaf08]_\n                Section 4 except we do not require\n                `\\varepsilon_i(b) = 0, 1` for all `i`.\n\n            This definition can be generalized by choosing a subset `X`\n            of the set of all vertices of `B` of weight `0`, and\n            restricting the dual equivalence graph to the vertex set\n            `X`.\n\n            INPUT:\n\n            - ``X`` -- (optional) the vertex set `X` (default:\n              the whole set of vertices of ``self`` of weight `0`)\n            - ``index_set`` -- (optional) the index set `I`\n              (default: the whole index set of ``self``); this has\n              to be a subset of the index set of ``self`` (as a list\n              or tuple)\n            - ``directed`` -- (default: ``True``) whether to have the\n              dual equivalence graph be directed, where the head of\n              an edge `b - b'` is `b` and the tail is\n              `b' = f_{i-1} f_i e_{i-1} e_i b`)\n\n            .. SEEALSO::\n\n                :meth:`sage.combinat.partition.Partition.dual_equivalence_graph`\n\n            REFERENCES:\n\n            .. [Assaf08] Sami Assaf. *A combinatorial realization of Schur-Weyl\n               duality via crystal graphs and dual equivalence graphs*.\n               FPSAC 2008, 141-152, Discrete Math. Theor. Comput. Sci. Proc.,\n               AJ, Assoc. Discrete Math. Theor. Comput. Sci., (2008).\n               :arxiv:`0804.1587v1`\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',3], shape=[2,2])\n                sage: G = T.dual_equivalence_graph()\n                sage: sorted(G.edges())\n                [([[1, 3], [2, 4]], [[1, 2], [3, 4]], 2),\n                 ([[1, 2], [3, 4]], [[1, 3], [2, 4]], 3)]\n                sage: T = crystals.Tableaux(['A',4], shape=[3,2])\n                sage: G = T.dual_equivalence_graph()\n                sage: sorted(G.edges())\n                [([[1, 3, 5], [2, 4]], [[1, 3, 4], [2, 5]], 4),\n                 ([[1, 3, 5], [2, 4]], [[1, 2, 5], [3, 4]], 2),\n                 ([[1, 3, 4], [2, 5]], [[1, 2, 4], [3, 5]], 2),\n                 ([[1, 2, 5], [3, 4]], [[1, 3, 5], [2, 4]], 3),\n                 ([[1, 2, 4], [3, 5]], [[1, 2, 3], [4, 5]], 3),\n                 ([[1, 2, 3], [4, 5]], [[1, 2, 4], [3, 5]], 4)]\n\n                sage: T = crystals.Tableaux(['A',4], shape=[3,1])\n                sage: G = T.dual_equivalence_graph(index_set=[1,2,3])\n                sage: G.vertices()\n                [[[1, 3, 4], [2]], [[1, 2, 4], [3]], [[1, 2, 3], [4]]]\n                sage: G.edges()\n                [([[1, 3, 4], [2]], [[1, 2, 4], [3]], 2),\n                 ([[1, 2, 4], [3]], [[1, 2, 3], [4]], 3)]\n\n            TESTS::\n\n                sage: T = crystals.Tableaux(['A',4], shape=[3,1])\n                sage: G = T.dual_equivalence_graph(index_set=[2,3])\n                sage: sorted(G.edges())\n                [([[1, 2, 4], [3]], [[1, 2, 3], [4]], 3),\n                 ([[2, 4, 5], [3]], [[2, 3, 5], [4]], 3)]\n                sage: sorted(G.vertices())\n                [[[1, 3, 4], [2]],\n                 [[1, 2, 4], [3]],\n                 [[2, 4, 5], [3]],\n                 [[1, 2, 3], [4]],\n                 [[2, 3, 5], [4]],\n                 [[1, 1, 1], [5]],\n                 [[1, 1, 5], [5]],\n                 [[1, 5, 5], [5]],\n                 [[2, 3, 4], [5]]]\n            ",
                    "args": [
                        "self",
                        "X",
                        "index_set",
                        "directed"
                    ],
                    "argspec": [
                        [
                            "self",
                            "X",
                            "index_set",
                            "directed"
                        ],
                        null,
                        null,
                        [
                            null,
                            null,
                            true
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.crystals.Crystals",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "_test_stembridge_local_axioms": {
                    "__doc__": "\n            This implements tests for the Stembridge local characterization\n            on the element of a crystal ``self``.\n\n            The current implementation only uses the axioms for simply-laced\n            types.  Crystals of other types should still pass the test, but\n            in non-simply-laced types, passing is not a guarantee that the\n            crystal arises from a representation.\n\n            One can specify an index set smaller than the full index set of\n            the crystal, using the option ``index_set``.\n\n            Running with ``verbose=True`` will print warnings when a test fails.\n\n            REFERENCES:\n\n            .. [S2003] John R. Stembridge, A local characterization of\n               simply-laced crystals,\n               Transactions of the American Mathematical Society, Vol. 355,\n               No. 12 (Dec., 2003), pp. 4807--4823\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,1],[2]])\n                sage: t._test_stembridge_local_axioms()\n                True\n                sage: t._test_stembridge_local_axioms(index_set=[1,3])\n                True\n                sage: t._test_stembridge_local_axioms(verbose=True)\n                True\n            ",
                    "args": [
                        "self",
                        "index_set",
                        "verbose"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set",
                            "verbose"
                        ],
                        null,
                        "options",
                        [
                            null,
                            false
                        ]
                    ]
                },
                "demazure_operator_simple": {
                    "__doc__": "\n            Return the Demazure operator `D_i` applied to ``self``.\n\n            INPUT:\n\n            - ``i`` -- an element of the index set of the underlying crystal\n            - ``ring`` -- (default: ``QQ``) a ring\n\n            OUTPUT:\n\n            An element of the ``ring``-free module indexed by the underlying\n            crystal.\n\n            Let `r = \\langle \\mathrm{wt}(b), \\alpha^{\\vee}_i \\rangle`, then\n            `D_i(b)` is defined as follows:\n\n            - If `r \\geq 0`, this returns the sum of the elements obtained\n              from ``self`` by application of `f_i^k` for `0 \\leq k \\leq r`.\n            - If `r < 0`, this returns the opposite of the sum of the\n              elements obtained by application of `e_i^k` for `0 < k < -r`.\n\n            REFERENCES:\n\n            .. [L1995] Peter Littelmann, Crystal graphs and Young tableaux,\n               J. Algebra 175 (1995), no. 1, 65--87.\n\n            .. [K1993] Masaki Kashiwara, The crystal base and Littelmann's\n               refined Demazure character formula,\n               Duke Math. J. 71 (1993), no. 3, 839--858.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t = T(rows=[[1,2],[2]])\n                sage: t.demazure_operator_simple(2)\n                B[[[1, 2], [2]]] + B[[[1, 3], [2]]] + B[[[1, 3], [3]]]\n                sage: t.demazure_operator_simple(2).parent()\n                Free module generated by The crystal of tableaux of type ['A', 2] and shape(s) [[2, 1]] over Integer Ring\n\n                sage: t.demazure_operator_simple(1)\n                0\n\n                sage: K = crystals.KirillovReshetikhin(['A',2,1],2,1)\n                sage: t = K(rows=[[3],[2]])\n                sage: t.demazure_operator_simple(0)\n                B[[[1, 2]]] + B[[[2, 3]]]\n\n            TESTS::\n\n                sage: K = crystals.KirillovReshetikhin(['A',2,1],1,1)\n                sage: x = K.an_element(); x\n                [[1]]\n                sage: x.demazure_operator_simple(0)\n                0\n                sage: x.demazure_operator_simple(0, ring = QQ).parent()\n                Free module generated by Kirillov-Reshetikhin crystal of type ['A', 2, 1] with (r,s)=(1,1) over Rational Field\n            ",
                    "args": [
                        "self",
                        "i",
                        "ring"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "ring"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "dual_equivalence_class": {
                    "__doc__": "\n            Return the dual equivalence class indexed by ``index_set``\n            of ``self``.\n\n            The dual equivalence class of an element `b \\in B`\n            is the set of all elements of `B` reachable from\n            `b` via sequences of `i`-elementary dual equivalence\n            relations (i.e., `i`-elementary dual equivalence\n            transformations and their inverses) for `i` in the index\n            set of `B`.\n\n            For this to be well-defined, the element `b` has to be\n            of weight `0` with respect to `I`; that is, we need to have\n            `\\varepsilon_j(b) = \\varphi_j(b)` for all `j \\in I`.\n\n            See [Assaf08]_. See also :meth:`dual_equivalence_graph` for\n            a definition of `i`-elementary dual equivalence\n            transformations.\n\n            INPUT:\n\n            - ``index_set`` -- (optional) the index set `I`\n              (default: the whole index set of the crystal); this has\n              to be a subset of the index set of the crystal (as a list\n              or tuple)\n\n            OUTPUT:\n\n            The dual equivalence class of ``self`` indexed by the\n            subset ``index_set``. This class is returned as an\n            undirected edge-colored multigraph. The color of an edge\n            is the index `i` of the dual equivalence relation it\n            encodes.\n\n            .. SEEALSO::\n\n                - :meth:`~sage.categories.regular_crystals.RegularCrystals.ParentMethods.dual_equivalence_graph`\n                - :meth:`sage.combinat.partition.Partition.dual_equivalence_graph`\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',3], shape=[2,2])\n                sage: G = T(2,1,4,3).dual_equivalence_class()\n                sage: sorted(G.edges())\n                [([[1, 3], [2, 4]], [[1, 2], [3, 4]], 2),\n                 ([[1, 3], [2, 4]], [[1, 2], [3, 4]], 3)]\n                sage: T = crystals.Tableaux(['A',4], shape=[3,2])\n                sage: G = T(2,1,4,3,5).dual_equivalence_class()\n                sage: sorted(G.edges())\n                [([[1, 3, 5], [2, 4]], [[1, 3, 4], [2, 5]], 4),\n                 ([[1, 3, 5], [2, 4]], [[1, 2, 5], [3, 4]], 2),\n                 ([[1, 3, 5], [2, 4]], [[1, 2, 5], [3, 4]], 3),\n                 ([[1, 3, 4], [2, 5]], [[1, 2, 4], [3, 5]], 2),\n                 ([[1, 2, 4], [3, 5]], [[1, 2, 3], [4, 5]], 3),\n                 ([[1, 2, 4], [3, 5]], [[1, 2, 3], [4, 5]], 4)]\n            ",
                    "args": [
                        "self",
                        "index_set"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "stembridgeDel_depth": {
                    "__doc__": "\n            Return the difference in the `j`-depth of ``self`` and `f_i` of\n            ``self``, where `i` and `j` are in the index set of the\n            underlying crystal. This function is useful for checking the\n            Stembridge local axioms for crystal bases.\n\n            The `i`-depth of a crystal node `x` is `\\varepsilon_i(x)`.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,1],[2]])\n                sage: t.stembridgeDel_depth(1,2)\n                0\n                sage: s=T(rows=[[1,3],[3]])\n                sage: s.stembridgeDel_depth(1,2)\n                -1\n            ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "stembridgeDel_rise": {
                    "__doc__": "\n            Return the difference in the `j`-rise of ``self`` and `f_i` of\n            ``self``, where `i` and `j` are in the index set of the\n            underlying crystal. This function is useful for checking the\n            Stembridge local axioms for crystal bases.\n\n            The `i`-rise of a crystal node `x` is `\\varphi_i(x)`.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,1],[2]])\n                sage: t.stembridgeDel_rise(1,2)\n                -1\n                sage: s=T(rows=[[1,3],[3]])\n                sage: s.stembridgeDel_rise(1,2)\n                0\n            ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "stembridgeDelta_depth": {
                    "__doc__": "\n            Return the difference in the `j`-depth of ``self`` and `e_i`\n            of ``self``, where `i` and `j` are in the index set of the\n            underlying crystal. This function is useful for checking the\n            Stembridge local axioms for crystal bases.\n\n            The `i`-depth of a crystal node `x` is `-\\varepsilon_i(x)`.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,2],[2]])\n                sage: t.stembridgeDelta_depth(1,2)\n                0\n                sage: s=T(rows=[[2,3],[3]])\n                sage: s.stembridgeDelta_depth(1,2)\n                -1\n            ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "stembridgeDelta_rise": {
                    "__doc__": "\n            Return the difference in the `j`-rise of ``self`` and `e_i` of\n            ``self``, where `i` and `j` are in the index set of the\n            underlying crystal. This function is useful for checking the\n            Stembridge local axioms for crystal bases.\n\n            The `i`-rise of a crystal node `x` is `\\varphi_i(x)`.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,2],[2]])\n                sage: t.stembridgeDelta_rise(1,2)\n                -1\n                sage: s=T(rows=[[2,3],[3]])\n                sage: s.stembridgeDelta_rise(1,2)\n                0\n            ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "stembridgeTriple": {
                    "__doc__": "\n            Let `A` be the Cartan matrix of the crystal, `x` a crystal element,\n            and let `i` and `j` be in the index set of the crystal.\n            Further, set\n            ``b=stembridgeDelta_depth(x,i,j)``, and\n            ``c=stembridgeDelta_rise(x,i,j))``.\n            If ``x.e(i)`` is non-empty, this function returns the triple\n            `( A_{ij}, b, c )`; otherwise it returns ``None``.\n            By the Stembridge local characterization of crystal bases,\n            one should have `A_{ij}=b+c`.\n\n            EXAMPLES::\n\n                sage: T = crystals.Tableaux(['A',2], shape=[2,1])\n                sage: t=T(rows=[[1,1],[2]])\n                sage: t.stembridgeTriple(1,2)\n                sage: s=T(rows=[[1,2],[2]])\n                sage: s.stembridgeTriple(1,2)\n                (-1, 0, -1)\n\n                sage: T = crystals.Tableaux(['B',2], shape=[2,1])\n                sage: t=T(rows=[[1,2],[2]])\n                sage: t.stembridgeTriple(1,2)\n                (-2, 0, -2)\n                sage: s=T(rows=[[-1,-1],[0]])\n                sage: s.stembridgeTriple(1,2)\n                (-2, -2, 0)\n                sage: u=T(rows=[[0,2],[1]])\n                sage: u.stembridgeTriple(1,2)\n                (-2, -1, -1)\n            ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of left modules\n    left modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with left multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: LeftModules(ZZ)\n        Category of left modules over Integer Ring\n        sage: LeftModules(ZZ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(LeftModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of left modules\n    left modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with left multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: LeftModules(ZZ)\n        Category of left modules over Integer Ring\n        sage: LeftModules(ZZ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(LeftModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.left_modules.LeftModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of associative and unital algebras over a given base ring.\n\n    An associative and unital algebra over a ring `R` is a module over\n    `R` which is itself a ring.\n\n    .. WARNING::\n\n        :class:`Algebras` will be eventually be replaced by\n        :class:`.magmatic_algebras.MagmaticAlgebras`\n        for consistency with e.g. :wikipedia:`Algebras` which assumes\n        neither associativity nor the existence of a unit (see\n        :trac:`15043`).\n\n    .. TODO:: Should `R` be a commutative ring?\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ)\n        Category of algebras over Integer Ring\n        sage: sorted(Algebras(ZZ).super_categories(), key=str)\n        [Category of associative algebras over Integer Ring,\n         Category of rings,\n         Category of unital algebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.rings.Rings",
            "sage.categories.associative_algebras.AssociativeAlgebras",
            "sage.categories.unital_algebras.UnitalAlgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of associative and unital algebras over a given base ring.\n\n    An associative and unital algebra over a ring `R` is a module over\n    `R` which is itself a ring.\n\n    .. WARNING::\n\n        :class:`Algebras` will be eventually be replaced by\n        :class:`.magmatic_algebras.MagmaticAlgebras`\n        for consistency with e.g. :wikipedia:`Algebras` which assumes\n        neither associativity nor the existence of a unit (see\n        :trac:`15043`).\n\n    .. TODO:: Should `R` be a commutative ring?\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ)\n        Category of algebras over Integer Ring\n        sage: sorted(Algebras(ZZ).super_categories(), key=str)\n        [Category of associative algebras over Integer Ring,\n         Category of rings,\n         Category of unital algebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras",
        "parent_class": {
            "__doc__": "\n    The category of associative and unital algebras over a given base ring.\n\n    An associative and unital algebra over a ring `R` is a module over\n    `R` which is itself a ring.\n\n    .. WARNING::\n\n        :class:`Algebras` will be eventually be replaced by\n        :class:`.magmatic_algebras.MagmaticAlgebras`\n        for consistency with e.g. :wikipedia:`Algebras` which assumes\n        neither associativity nor the existence of a unit (see\n        :trac:`15043`).\n\n    .. TODO:: Should `R` be a commutative ring?\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ)\n        Category of algebras over Integer Ring\n        sage: sorted(Algebras(ZZ).super_categories(), key=str)\n        [Category of associative algebras over Integer Ring,\n         Category of rings,\n         Category of unital algebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of rings\n\n    Associative rings with unit, not necessarily commutative\n\n    EXAMPLES::\n\n        sage: Rings()\n        Category of rings\n        sage: sorted(Rings().super_categories(), key=str)\n        [Category of rngs, Category of semirings]\n\n        sage: sorted(Rings().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse',\n         'AdditiveUnital', 'Associative', 'Distributive', 'Unital']\n\n        sage: Rings() is (CommutativeAdditiveGroups() & Monoids()).Distributive()\n        True\n        sage: Rings() is Rngs().Unital()\n        True\n        sage: Rings() is Semirings().AdditiveInverse()\n        True\n\n    TESTS::\n\n        sage: TestSuite(Rings()).run()\n\n    .. TODO::\n\n        (see: http://trac.sagemath.org/sage_trac/wiki/CategoriesRoadMap)\n\n        - Make Rings() into a subcategory or alias of Algebras(ZZ);\n\n        - A parent P in the category ``Rings()`` should automatically be\n          in the category ``Algebras(P)``.\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "is_unit": {
                    "__doc__": "\n            Return whether this element is a unit in the ring.\n\n            .. NOTE::\n\n                This is a generic implementation for (non-commutative) rings\n                which only works for the one element, its additive inverse, and\n                the zero element.  Most rings should provide a more specialized\n                implementation.\n\n            EXAMPLES::\n\n                sage: MS = MatrixSpace(ZZ, 2)\n                sage: MS.one().is_unit()\n                True\n                sage: MS.zero().is_unit()\n                False\n                sage: MS([1,2,3,4]).is_unit()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.rngs.Rngs",
            "sage.categories.semirings.Semirings"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of rings\n\n    Associative rings with unit, not necessarily commutative\n\n    EXAMPLES::\n\n        sage: Rings()\n        Category of rings\n        sage: sorted(Rings().super_categories(), key=str)\n        [Category of rngs, Category of semirings]\n\n        sage: sorted(Rings().axioms())\n        ['AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse',\n         'AdditiveUnital', 'Associative', 'Distributive', 'Unital']\n\n        sage: Rings() is (CommutativeAdditiveGroups() & Monoids()).Distributive()\n        True\n        sage: Rings() is Rngs().Unital()\n        True\n        sage: Rings() is Semirings().AdditiveInverse()\n        True\n\n    TESTS::\n\n        sage: TestSuite(Rings()).run()\n\n    .. TODO::\n\n        (see: http://trac.sagemath.org/sage_trac/wiki/CategoriesRoadMap)\n\n        - Make Rings() into a subcategory or alias of Algebras(ZZ);\n\n        - A parent P in the category ``Rings()`` should automatically be\n          in the category ``Algebras(P)``.\n    ",
            "methods": {}
        },
        "name": "sage.categories.rings.Rings",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_Hom_": {
                    "__doc__": "\n            Returns the homset from ``self`` to ``Y`` in the category ``category``\n\n            INPUT:\n\n            - ``Y`` -- a ring\n            - ``category`` -- a subcategory of :class:`Rings`() or None\n\n            The sole purpose of this method is to construct the homset\n            as a :class:`~sage.rings.homset.RingHomset`. If\n            ``category`` is specified and is not a subcategory of\n            :class:`Rings`, a ``TypeError`` is raised instead\n\n            This method is not meant to be called directly. Please use\n            :func:`sage.categories.homset.Hom` instead.\n\n            EXAMPLES::\n\n                sage: H = QQ._Hom_(QQ, category = Rings()); H\n                Set of Homomorphisms from Rational Field to Rational Field\n                sage: H.__class__\n                <class 'sage.rings.homset.RingHomset_generic_with_category'>\n\n            TESTS::\n\n                sage: Hom(QQ, QQ, category = Rings()).__class__\n                <class 'sage.rings.homset.RingHomset_generic_with_category'>\n\n                sage: Hom(CyclotomicField(3), QQ, category = Rings()).__class__\n                <class 'sage.rings.number_field.morphism.CyclotomicFieldHomset_with_category'>\n\n                sage: TestSuite(Hom(QQ, QQ, category = Rings())).run() # indirect doctest\n\n            ",
                    "args": [
                        "self",
                        "Y",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "Y",
                            "category"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__getitem__": {
                    "__doc__": "\n            Extend this ring by one or several elements to create a polynomial\n            ring, a power series ring, or an algebraic extension.\n\n            This is a convenience method intended primarily for interactive\n            use.\n\n            .. SEEALSO::\n\n                :func:`~sage.rings.polynomial.polynomial_ring_constructor.PolynomialRing`,\n                :func:`~sage.rings.power_series_ring.PowerSeriesRing`,\n                :meth:`~sage.rings.ring.Ring.extension`,\n                :meth:`sage.rings.integer_ring.IntegerRing_class.__getitem__`,\n                :meth:`sage.rings.matrix_space.MatrixSpace.__getitem__`,\n                :meth:`sage.structure.parent.Parent.__getitem__`\n\n            EXAMPLES:\n\n            We create several polynomial rings::\n\n                sage: ZZ['x']\n                Univariate Polynomial Ring in x over Integer Ring\n                sage: QQ['x']\n                Univariate Polynomial Ring in x over Rational Field\n                sage: GF(17)['abc']\n                Univariate Polynomial Ring in abc over Finite Field of size 17\n                sage: GF(17)['a,b,c']\n                Multivariate Polynomial Ring in a, b, c over Finite Field of size 17\n                sage: GF(17)['a']['b']\n                Univariate Polynomial Ring in b over Univariate Polynomial Ring in a over Finite Field of size 17\n\n            We can also create power series rings by using double brackets::\n\n                sage: QQ[['t']]\n                Power Series Ring in t over Rational Field\n                sage: ZZ[['W']]\n                Power Series Ring in W over Integer Ring\n\n                sage: ZZ[['x,y,z']]\n                Multivariate Power Series Ring in x, y, z over Integer Ring\n                sage: ZZ[['x','T']]\n                Multivariate Power Series Ring in x, T over Integer Ring\n\n            Use :func:`~sage.rings.fraction_field.Frac` or\n            :meth:`~sage.rings.ring.CommutativeRing.fraction_field` to obtain\n            the fields of rational functions and Laurent series::\n\n                sage: Frac(QQ['t'])\n                Fraction Field of Univariate Polynomial Ring in t over Rational Field\n                sage: Frac(QQ[['t']])\n                Laurent Series Ring in t over Rational Field\n                sage: QQ[['t']].fraction_field()\n                Laurent Series Ring in t over Rational Field\n\n            Note that the same syntax can be used to create number fields::\n\n                sage: QQ[I]\n                Number Field in I with defining polynomial x^2 + 1\n                sage: QQ[sqrt(2)]\n                Number Field in sqrt2 with defining polynomial x^2 - 2\n                sage: QQ[sqrt(2),sqrt(3)]\n                Number Field in sqrt2 with defining polynomial x^2 - 2 over its base field\n\n            and orders in number fields::\n\n                sage: ZZ[I]\n                Order in Number Field in I with defining polynomial x^2 + 1\n                sage: ZZ[sqrt(5)]\n                Order in Number Field in sqrt5 with defining polynomial x^2 - 5\n                sage: ZZ[sqrt(2)+sqrt(3)]\n                Order in Number Field in a with defining polynomial x^4 - 10*x^2 + 1\n\n            TESTS:\n\n            A few corner cases::\n\n                sage: QQ[()]\n                Multivariate Polynomial Ring in no variables over Rational Field\n\n                sage: QQ[[]]\n                Traceback (most recent call last):\n                ...\n                TypeError: power series rings must have at least one variable\n\n            Some flexibility is allowed when specifying variables::\n\n                sage: QQ[\"x\", SR.var('y'), polygen(CC, 'z')]\n                Multivariate Polynomial Ring in x, y, z over Rational Field\n                sage: QQ[[\"x\", SR.var('y'), polygen(CC, 'z')]]\n                Multivariate Power Series Ring in x, y, z over Rational Field\n\n            but more baroque expressions do not work::\n\n                sage: QQ['a,b','c']\n                Traceback (most recent call last):\n                ...\n                ValueError: variable name 'a,b' is not alphanumeric\n                sage: QQ[['a,b','c']]\n                Traceback (most recent call last):\n                ...\n                ValueError: variable name 'a,b' is not alphanumeric\n\n                sage: QQ[[['x']]]\n                Traceback (most recent call last):\n                ...\n                TypeError: expected R[...] or R[[...]], not R[[[...]]]\n\n            Extension towers are built as follows and use distinct generator names::\n\n                sage: K = QQ[2^(1/3), 2^(1/2), 3^(1/3)]\n                sage: K\n                Number Field in a with defining polynomial x^3 - 2 over its base field\n                sage: K.base_field()\n                Number Field in sqrt2 with defining polynomial x^2 - 2 over its base field\n                sage: K.base_field().base_field()\n                Number Field in b with defining polynomial x^3 - 3\n\n            ",
                    "args": [
                        "self",
                        "arg"
                    ],
                    "argspec": [
                        [
                            "self",
                            "arg"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_ideal_class_": {
                    "__doc__": "\n            Return the class that is used to implement ideals of this ring.\n\n            NOTE:\n\n            We copy the code from :class:`~sage.rings.ring.Ring`. This is\n            necessary because not all rings inherit from that class, such\n            as matrix algebras.\n\n            INPUT:\n\n            - ``n`` (optional integer, default 0): The number of generators\n              of the ideal to be created.\n\n            OUTPUT:\n\n            The class that is used to implement ideals of this ring with\n            ``n`` generators.\n\n            NOTE:\n\n            Often principal ideals (``n==1``) are implemented via a different\n            class.\n\n            EXAMPLES::\n\n                sage: MS = MatrixSpace(QQ,2,2)\n                sage: MS._ideal_class_()\n                <class 'sage.rings.noncommutative_ideals.Ideal_nc'>\n\n            We don't know of a commutative ring in Sage that does not inherit\n            from the base class of rings. So, we need to cheat in the next\n            example::\n\n                sage: super(Ring,QQ)._ideal_class_.__module__\n                'sage.categories.rings'\n                sage: super(Ring,QQ)._ideal_class_()\n                <class 'sage.rings.ideal.Ideal_generic'>\n                sage: super(Ring,QQ)._ideal_class_(1)\n                <class 'sage.rings.ideal.Ideal_principal'>\n                sage: super(Ring,QQ)._ideal_class_(2)\n                <class 'sage.rings.ideal.Ideal_generic'>\n\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        [
                            0
                        ]
                    ]
                },
                "_mul_": {
                    "__doc__": "\n            Multiplication of rings with, e.g., lists.\n\n            NOTE:\n\n            This method is used to create ideals. It is\n            the same as the multiplication method for\n            :class:`~sage.rings.ring.Ring`. However, not\n            all parents that belong to the category of\n            rings also inherits from the base class of\n            rings. Therefore, we implemented a ``__mul__``\n            method for parents, that calls a ``_mul_``\n            method implemented here. See :trac:`7797`.\n\n            INPUT:\n\n            - `x`, an object to multiply with.\n            - `switch_sides` (optional bool): If ``False``,\n              the product is ``self*x``; if ``True``, the\n              product is ``x*self``.\n\n            EXAMPLE:\n\n            As we mentioned above, this method is called\n            when a ring is involved that does not inherit\n            from the base class of rings. This is the case,\n            e.g., for matrix algebras::\n\n                sage: MS = MatrixSpace(QQ,2,2)\n                sage: isinstance(MS,Ring)\n                False\n                sage: MS in Rings()\n                True\n                sage: MS*2     # indirect doctest\n                Left Ideal\n                (\n                  [2 0]\n                  [0 2]\n                )\n                 of Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n\n            In the next example, the ring and the other factor switch sides\n            in the product::\n\n                sage: [MS.2]*MS\n                Right Ideal\n                (\n                  [0 0]\n                  [1 0]\n                )\n                 of Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n\n            AUTHOR:\n\n            - Simon King (2011-03-22)\n\n            ",
                    "args": [
                        "self",
                        "x",
                        "switch_sides"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "switch_sides"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "_test_characteristic": {
                    "__doc__": "\n            Run generic tests on the method :meth:`characteristic`.\n\n            See also: :class:`TestSuite`.\n\n            EXAMPLES::\n\n                sage: ZZ._test_characteristic()\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "bracket": {
                    "__doc__": "\n            Returns the Lie bracket `[x, y] = x y - y x` of `x` and `y`.\n\n            INPUT:\n\n             - ``x``, ``y`` -- elements of ``self``\n\n            EXAMPLES::\n\n                sage: F = AlgebrasWithBasis(QQ).example()\n                sage: F\n                An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n                sage: a,b,c = F.algebra_generators()\n                sage: F.bracket(a,b)\n                B[word: ab] - B[word: ba]\n\n            This measures the default of commutation between `x` and `y`.\n            `F` endowed with the bracket operation is a Lie algebra;\n            in particular, it satisfies Jacobi's identity::\n\n                sage: F.bracket( F.bracket(a,b), c) + F.bracket(F.bracket(b,c),a) + F.bracket(F.bracket(c,a),b)\n                0\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "characteristic": {
                    "__doc__": "\n            Return the characteristic of this ring.\n\n            EXAMPLES::\n\n                sage: QQ.characteristic()\n                0\n                sage: GF(19).characteristic()\n                19\n                sage: Integers(8).characteristic()\n                8\n                sage: Zp(5).characteristic()\n                0\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "ideal": {
                    "__doc__": "\n            Create an ideal of this ring.\n\n            NOTE:\n\n            The code is copied from the base class\n            :class:`~sage.rings.ring.Ring`. This is\n            because there are rings that do not inherit\n            from that class, such as matrix algebras.\n            See :trac:`7797`.\n\n            INPUT:\n\n            - An element or a list/tuple/sequence of elements.\n            - ``coerce`` (optional bool, default ``True``):\n              First coerce the elements into this ring.\n            - ``side``, optional string, one of ``\"twosided\"``\n              (default), ``\"left\"``, ``\"right\"``: determines\n              whether the resulting ideal is twosided, a left\n              ideal or a right ideal.\n\n            EXAMPLE::\n\n                sage: MS = MatrixSpace(QQ,2,2)\n                sage: isinstance(MS,Ring)\n                False\n                sage: MS in Rings()\n                True\n                sage: MS.ideal(2)\n                Twosided Ideal\n                (\n                  [2 0]\n                  [0 2]\n                )\n                 of Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n                sage: MS.ideal([MS.0,MS.1],side='right')\n                Right Ideal\n                (\n                  [1 0]\n                  [0 0],\n                <BLANKLINE>\n                  [0 1]\n                  [0 0]\n                )\n                 of Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "ideal_monoid": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "is_ring": {
                    "__doc__": "\n            Return True, since this in an object of the category of rings.\n\n            EXAMPLES::\n\n                sage: Parent(QQ,category=Rings()).is_ring()\n                True\n\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_zero": {
                    "__doc__": "\n            Return ``True`` if this is the zero ring.\n\n            EXAMPLES::\n\n                sage: Integers(1).is_zero()\n                True\n                sage: Integers(2).is_zero()\n                False\n                sage: QQ.is_zero()\n                False\n                sage: R.<x> = ZZ[]\n                sage: R.quo(1).is_zero()\n                True\n                sage: R.<x> = GF(101)[]\n                sage: R.quo(77).is_zero()\n                True\n                sage: R.quo(x^2+1).is_zero()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "quo": {
                    "__doc__": "\n            Quotient of a ring by a two-sided ideal.\n\n            NOTE:\n\n            This is a synonym for :meth:`quotient`.\n\n            EXAMPLE::\n\n                sage: MS = MatrixSpace(QQ,2)\n                sage: I = MS*MS.gens()*MS\n\n            ``MS`` is not an instance of :class:`~sage.rings.ring.Ring`.\n\n            However it is an instance of the parent class of the\n            category of rings. The quotient method is inherited from\n            there::\n\n                sage: isinstance(MS,sage.rings.ring.Ring)\n                False\n                sage: isinstance(MS,Rings().parent_class)\n                True\n                sage: MS.quo(I,names = ['a','b','c','d'])\n                Quotient of Full MatrixSpace of 2 by 2 dense matrices over Rational Field by the ideal\n                (\n                  [1 0]\n                  [0 0],\n                <BLANKLINE>\n                  [0 1]\n                  [0 0],\n                <BLANKLINE>\n                  [0 0]\n                  [1 0],\n                <BLANKLINE>\n                  [0 0]\n                  [0 1]\n                )\n\n            ",
                    "args": [
                        "self",
                        "I",
                        "names"
                    ],
                    "argspec": [
                        [
                            "self",
                            "I",
                            "names"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "quotient": {
                    "__doc__": "\n            Quotient of a ring by a two-sided ideal.\n\n            INPUT:\n\n            - ``I``: A twosided ideal of this ring.\n            - ``names``: a list of strings to be used as names\n              for the variables in the quotient ring.\n\n            EXAMPLES:\n\n            Usually, a ring inherits a method :meth:`sage.rings.ring.Ring.quotient`.\n            So, we need a bit of effort to make the following example work with the\n            category framework::\n\n                sage: F.<x,y,z> = FreeAlgebra(QQ)\n                sage: from sage.rings.noncommutative_ideals import Ideal_nc\n                sage: from itertools import product\n                sage: class PowerIdeal(Ideal_nc):\n                ....:  def __init__(self, R, n):\n                ....:      self._power = n\n                ....:      Ideal_nc.__init__(self, R, [R.prod(m) for m in product(R.gens(), repeat=n)])\n                ....:  def reduce(self, x):\n                ....:      R = self.ring()\n                ....:      return add([c*R(m) for m,c in x if len(m) < self._power], R(0))\n                ....:\n                sage: I = PowerIdeal(F,3)\n                sage: Q = Rings().parent_class.quotient(F, I); Q\n                Quotient of Free Algebra on 3 generators (x, y, z) over Rational Field by the ideal (x^3, x^2*y, x^2*z, x*y*x, x*y^2, x*y*z, x*z*x, x*z*y, x*z^2, y*x^2, y*x*y, y*x*z, y^2*x, y^3, y^2*z, y*z*x, y*z*y, y*z^2, z*x^2, z*x*y, z*x*z, z*y*x, z*y^2, z*y*z, z^2*x, z^2*y, z^3)\n                sage: Q.0\n                xbar\n                sage: Q.1\n                ybar\n                sage: Q.2\n                zbar\n                sage: Q.0*Q.1\n                xbar*ybar\n                sage: Q.0*Q.1*Q.0\n                0\n            ",
                    "args": [
                        "self",
                        "I",
                        "names"
                    ],
                    "argspec": [
                        [
                            "self",
                            "I",
                            "names"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "quotient_ring": {
                    "__doc__": "\n            Quotient of a ring by a two-sided ideal.\n\n            NOTE:\n\n            This is a synonyme for :meth:`quotient`.\n\n            EXAMPLE::\n\n                sage: MS = MatrixSpace(QQ,2)\n                sage: I = MS*MS.gens()*MS\n\n            ``MS`` is not an instance of :class:`~sage.rings.ring.Ring`,\n            but it is an instance of the parent class of the category of\n            rings. The quotient method is inherited from there::\n\n                sage: isinstance(MS,sage.rings.ring.Ring)\n                False\n                sage: isinstance(MS,Rings().parent_class)\n                True\n                sage: MS.quotient_ring(I,names = ['a','b','c','d'])\n                Quotient of Full MatrixSpace of 2 by 2 dense matrices over Rational Field by the ideal\n                (\n                  [1 0]\n                  [0 0],\n                <BLANKLINE>\n                  [0 1]\n                  [0 0],\n                <BLANKLINE>\n                  [0 0]\n                  [1 0],\n                <BLANKLINE>\n                  [0 0]\n                  [0 1]\n                )\n\n            ",
                    "args": [
                        "self",
                        "I",
                        "names"
                    ],
                    "argspec": [
                        [
                            "self",
                            "I",
                            "names"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "is_unit": {
                    "__doc__": "\n            Return whether this element is a unit in the ring.\n\n            .. NOTE::\n\n                This is a generic implementation for (non-commutative) rings\n                which only works for the one element, its additive inverse, and\n                the zero element.  Most rings should provide a more specialized\n                implementation.\n\n            EXAMPLES::\n\n                sage: MS = MatrixSpace(ZZ, 2)\n                sage: MS.one().is_unit()\n                True\n                sage: MS.zero().is_unit()\n                False\n                sage: MS([1,2,3,4]).is_unit()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of coalgebras\n\n    EXAMPLES::\n\n        sage: Coalgebras(QQ)\n        Category of coalgebras over Rational Field\n        sage: Coalgebras(QQ).super_categories()\n        [Category of vector spaces over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(Coalgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "coproduct": {
                    "__doc__": "\n            Returns the coproduct of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.coproduct()\n                (B[(1,2,3)], B[(1,2,3)] # B[(1,2,3)])\n                sage: b, b.coproduct()\n                (B[(1,3)], B[(1,3)] # B[(1,3)])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit": {
                    "__doc__": "\n            Returns the counit of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.counit()\n                (B[(1,2,3)], 1)\n                sage: b, b.counit()\n                (B[(1,3)], 1)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of coalgebras\n\n    EXAMPLES::\n\n        sage: Coalgebras(QQ)\n        Category of coalgebras over Rational Field\n        sage: Coalgebras(QQ).super_categories()\n        [Category of vector spaces over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(Coalgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "coproduct": {
                    "__doc__": "\n            Returns the coproduct of x.\n\n            Eventually, there will be a default implementation,\n            delegating to the overloading mechanism and forcing the\n            conversion back\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, A.coproduct(a)\n                (B[(1,2,3)], B[(1,2,3)] # B[(1,2,3)])\n                sage: b, A.coproduct(b)\n                (B[(1,3)], B[(1,3)] # B[(1,3)])\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit": {
                    "__doc__": "\n            Returns the counit of x.\n\n            Eventually, there will be a default implementation,\n            delegating to the overloading mechanism and forcing the\n            conversion back\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, A.counit(a)\n                (B[(1,2,3)], 1)\n                sage: b, A.counit(b)\n                (B[(1,3)], 1)\n\n            TODO: implement some tests of the axioms of coalgebras, bialgebras\n            and Hopf algebras using the counit.\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "coproduct": {
                    "__doc__": "\n            Returns the coproduct of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.coproduct()\n                (B[(1,2,3)], B[(1,2,3)] # B[(1,2,3)])\n                sage: b, b.coproduct()\n                (B[(1,3)], B[(1,3)] # B[(1,3)])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit": {
                    "__doc__": "\n            Returns the counit of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.counit()\n                (B[(1,2,3)], 1)\n                sage: b, b.counit()\n                (B[(1,3)], 1)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of abstract simplicial complexes.\n\n    An abstract simplicial complex `A` is a collection of sets `X`\n    such that:\n\n    - `\\emptyset \\in A`,\n    - if `X \\subset Y \\in A`, then `X \\in A`.\n\n    .. TODO::\n\n        Implement the category of simplicial complexes considered\n        as :class:`CW complexes <sage.categories.cw_complexes.CWComplexes>`\n        and rename this to the category of ``AbstractSimplicialComplexes``\n        with appropriate functors.\n\n    EXAMPLES::\n\n        sage: from sage.categories.simplicial_complexes import SimplicialComplexes\n        sage: C = SimplicialComplexes(); C\n        Category of simplicial complexes\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of abstract simplicial complexes.\n\n    An abstract simplicial complex `A` is a collection of sets `X`\n    such that:\n\n    - `\\emptyset \\in A`,\n    - if `X \\subset Y \\in A`, then `X \\in A`.\n\n    .. TODO::\n\n        Implement the category of simplicial complexes considered\n        as :class:`CW complexes <sage.categories.cw_complexes.CWComplexes>`\n        and rename this to the category of ``AbstractSimplicialComplexes``\n        with appropriate functors.\n\n    EXAMPLES::\n\n        sage: from sage.categories.simplicial_complexes import SimplicialComplexes\n        sage: C = SimplicialComplexes(); C\n        Category of simplicial complexes\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of abstract simplicial complexes.\n\n    An abstract simplicial complex `A` is a collection of sets `X`\n    such that:\n\n    - `\\emptyset \\in A`,\n    - if `X \\subset Y \\in A`, then `X \\in A`.\n\n    .. TODO::\n\n        Implement the category of simplicial complexes considered\n        as :class:`CW complexes <sage.categories.cw_complexes.CWComplexes>`\n        and rename this to the category of ``AbstractSimplicialComplexes``\n        with appropriate functors.\n\n    EXAMPLES::\n\n        sage: from sage.categories.simplicial_complexes import SimplicialComplexes\n        sage: C = SimplicialComplexes(); C\n        Category of simplicial complexes\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.simplicial_complexes.SimplicialComplexes",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "faces": {
                    "__doc__": "\n            Return the faces of ``self``.\n\n            EXAMPLES::\n\n                sage: S = SimplicialComplex([[1,3,4], [1,2],[2,5],[4,5]])\n                sage: S.faces()\n                {-1: {()},\n                 0: {(1,), (2,), (3,), (4,), (5,)},\n                 1: {(1, 2), (1, 3), (1, 4), (2, 5), (3, 4), (4, 5)},\n                 2: {(1, 3, 4)}}\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "facets": {
                    "__doc__": "\n            Return the facets of ``self``.\n\n            EXAMPLES::\n\n                sage: S = SimplicialComplex([[1,3,4], [1,2],[2,5],[4,5]])\n                sage: S.facets()\n                {(1, 2), (1, 3, 4), (2, 5), (4, 5)}\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.simplicial_complexes.SimplicialComplexes",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of abstract simplicial complexes.\n\n    An abstract simplicial complex `A` is a collection of sets `X`\n    such that:\n\n    - `\\emptyset \\in A`,\n    - if `X \\subset Y \\in A`, then `X \\in A`.\n\n    .. TODO::\n\n        Implement the category of simplicial complexes considered\n        as :class:`CW complexes <sage.categories.cw_complexes.CWComplexes>`\n        and rename this to the category of ``AbstractSimplicialComplexes``\n        with appropriate functors.\n\n    EXAMPLES::\n\n        sage: from sage.categories.simplicial_complexes import SimplicialComplexes\n        sage: C = SimplicialComplexes(); C\n        Category of simplicial complexes\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of posets i.e. sets with a partial order structure.\n\n    EXAMPLES::\n\n        sage: Posets()\n        Category of posets\n        sage: Posets().super_categories()\n        [Category of sets]\n        sage: P = Posets().example(); P\n        An example of a poset: sets ordered by inclusion\n\n    The partial order is implemented by the mandatory method\n    :meth:`~Posets.ParentMethods.le`::\n\n        sage: x = P(Set([1,3])); y = P(Set([1,2,3]))\n        sage: x, y\n        ({1, 3}, {1, 2, 3})\n        sage: P.le(x, y)\n        True\n        sage: P.le(x, x)\n        True\n        sage: P.le(y, x)\n        False\n\n    The other comparison methods are called\n    :meth:`~Posets.ParentMethods.lt`, :meth:`~Posets.ParentMethods.ge`,\n    :meth:`~Posets.ParentMethods.gt`, following Python's naming\n    convention in :mod:`operator`. Default implementations are\n    provided::\n\n        sage: P.lt(x, x)\n        False\n        sage: P.ge(y, x)\n        True\n\n    Unless the poset is a facade (see :class:`Sets.Facade`), one can\n    compare directly its elements using the usual Python operators::\n\n        sage: D = Poset((divisors(30), attrcall(\"divides\")), facade = False)\n        sage: D(3) <= D(6)\n        True\n        sage: D(3) <= D(3)\n        True\n        sage: D(3) <= D(5)\n        False\n        sage: D(3) < D(3)\n        False\n        sage: D(10) >= D(5)\n        True\n\n    At this point, this has to be implemented by hand. Once\n    :trac:`10130` will be resolved, this will be automatically\n    provided by this category::\n\n        sage: x < y      # todo: not implemented\n        True\n        sage: x < x      # todo: not implemented\n        False\n        sage: x <= x     # todo: not implemented\n        True\n        sage: y >= x     # todo: not implemented\n        True\n\n    .. seealso:: :func:`Poset`, :class:`FinitePosets`, :class:`LatticePosets`\n\n    TESTS::\n\n        sage: C = Posets()\n        sage: TestSuite(C).run()\n\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of posets i.e. sets with a partial order structure.\n\n    EXAMPLES::\n\n        sage: Posets()\n        Category of posets\n        sage: Posets().super_categories()\n        [Category of sets]\n        sage: P = Posets().example(); P\n        An example of a poset: sets ordered by inclusion\n\n    The partial order is implemented by the mandatory method\n    :meth:`~Posets.ParentMethods.le`::\n\n        sage: x = P(Set([1,3])); y = P(Set([1,2,3]))\n        sage: x, y\n        ({1, 3}, {1, 2, 3})\n        sage: P.le(x, y)\n        True\n        sage: P.le(x, x)\n        True\n        sage: P.le(y, x)\n        False\n\n    The other comparison methods are called\n    :meth:`~Posets.ParentMethods.lt`, :meth:`~Posets.ParentMethods.ge`,\n    :meth:`~Posets.ParentMethods.gt`, following Python's naming\n    convention in :mod:`operator`. Default implementations are\n    provided::\n\n        sage: P.lt(x, x)\n        False\n        sage: P.ge(y, x)\n        True\n\n    Unless the poset is a facade (see :class:`Sets.Facade`), one can\n    compare directly its elements using the usual Python operators::\n\n        sage: D = Poset((divisors(30), attrcall(\"divides\")), facade = False)\n        sage: D(3) <= D(6)\n        True\n        sage: D(3) <= D(3)\n        True\n        sage: D(3) <= D(5)\n        False\n        sage: D(3) < D(3)\n        False\n        sage: D(10) >= D(5)\n        True\n\n    At this point, this has to be implemented by hand. Once\n    :trac:`10130` will be resolved, this will be automatically\n    provided by this category::\n\n        sage: x < y      # todo: not implemented\n        True\n        sage: x < x      # todo: not implemented\n        False\n        sage: x <= x     # todo: not implemented\n        True\n        sage: y >= x     # todo: not implemented\n        True\n\n    .. seealso:: :func:`Poset`, :class:`FinitePosets`, :class:`LatticePosets`\n\n    TESTS::\n\n        sage: C = Posets()\n        sage: TestSuite(C).run()\n\n    ",
            "methods": {}
        },
        "name": "sage.categories.posets.Posets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "directed_subset": {
                    "__doc__": "\n            Return the order filter or the order ideal generated by a\n            list of elements.\n\n            If ``direction`` is 'up', the order filter (upper set) is\n            being returned.\n\n            If ``direction`` is 'down', the order ideal (lower set) is\n            being returned.\n\n            INPUT:\n\n            - elements -- a list of elements.\n\n            - direction -- 'up' or 'down'.\n\n            EXAMPLES::\n\n                sage: B = Posets.BooleanLattice(4)\n                sage: B.directed_subset([3, 8], 'up')\n                [3, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n                sage: B.directed_subset([7, 10], 'down')\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 10]\n            ",
                    "args": [
                        "self",
                        "elements",
                        "direction"
                    ],
                    "argspec": [
                        [
                            "self",
                            "elements",
                            "direction"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "ge": {
                    "__doc__": "\n            Return whether `x \\ge y` in the poset ``self``.\n\n            INPUT:\n\n            - ``x``, ``y`` -- elements of ``self``.\n\n            This default implementation delegates the work to :meth:`le`.\n\n            EXAMPLES::\n\n                sage: D = Poset((divisors(30), attrcall(\"divides\")))\n                sage: D.ge( 6, 3 )\n                True\n                sage: D.ge( 3, 3 )\n                True\n                sage: D.ge( 3, 5 )\n                False\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "gt": {
                    "__doc__": "\n            Return whether `x > y` in the poset ``self``.\n\n            INPUT:\n\n            - ``x``, ``y`` -- elements of ``self``.\n\n            This default implementation delegates the work to :meth:`lt`.\n\n            EXAMPLES::\n\n                sage: D = Poset((divisors(30), attrcall(\"divides\")))\n                sage: D.gt( 3, 6 )\n                False\n                sage: D.gt( 3, 3 )\n                False\n                sage: D.gt( 3, 5 )\n                False\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_antichain_of_poset": {
                    "__doc__": "\n            Return whether an iterable ``o`` is an antichain of\n            ``self``.\n\n            INPUT:\n\n            - ``o`` -- an iterable (e. g., list, set, or tuple)\n              containing some elements of ``self``\n\n            OUTPUT:\n\n            ``True`` if the subset of ``self`` consisting of the entries\n            of ``o`` is an antichain of ``self``, and ``False`` otherwise.\n\n            EXAMPLES::\n\n                sage: P = Poset((divisors(12), attrcall(\"divides\")), facade=True, linear_extension=True)\n                sage: sorted(P.list())\n                [1, 2, 3, 4, 6, 12]\n                sage: P.is_antichain_of_poset([1, 3])\n                False\n                sage: P.is_antichain_of_poset([3, 1])\n                False\n                sage: P.is_antichain_of_poset([1, 1, 3])\n                False\n                sage: P.is_antichain_of_poset([])\n                True\n                sage: P.is_antichain_of_poset([1])\n                True\n                sage: P.is_antichain_of_poset([1, 1])\n                True\n                sage: P.is_antichain_of_poset([3, 4])\n                True\n                sage: P.is_antichain_of_poset([3, 4, 12])\n                False\n                sage: P.is_antichain_of_poset([6, 4])\n                True\n                sage: P.is_antichain_of_poset(i for i in divisors(12) if (2 < i and i < 6))\n                True\n                sage: P.is_antichain_of_poset(i for i in divisors(12) if (2 <= i and i < 6))\n                False\n\n                sage: Q = Poset({2: [3, 1], 3: [4], 1: [4]})\n                sage: Q.is_antichain_of_poset((1, 2))\n                False\n                sage: Q.is_antichain_of_poset((2, 4))\n                False\n                sage: Q.is_antichain_of_poset((4, 2))\n                False\n                sage: Q.is_antichain_of_poset((2, 2))\n                True\n                sage: Q.is_antichain_of_poset((3, 4))\n                False\n                sage: Q.is_antichain_of_poset((3, 1))\n                True\n                sage: Q.is_antichain_of_poset((1, ))\n                True\n                sage: Q.is_antichain_of_poset(())\n                True\n\n            An infinite poset::\n\n                sage: from sage.categories.examples.posets import FiniteSetsOrderedByInclusion\n                sage: R = FiniteSetsOrderedByInclusion()\n                sage: R.is_antichain_of_poset([R(set([3, 1, 2])), R(set([1, 4])), R(set([4, 5]))])\n                True\n                sage: R.is_antichain_of_poset([R(set([3, 1, 2, 4])), R(set([1, 4])), R(set([4, 5]))])\n                False\n            ",
                    "args": [
                        "self",
                        "o"
                    ],
                    "argspec": [
                        [
                            "self",
                            "o"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_chain_of_poset": {
                    "__doc__": "\n            Return whether an iterable ``o`` is a chain of ``self``,\n            including a check for ``o`` being ordered from smallest\n            to largest element if the keyword ``ordered`` is set to\n            ``True``.\n\n            INPUT:\n\n            - ``o`` -- an iterable (e. g., list, set, or tuple)\n              containing some elements of ``self``\n\n            - ``ordered`` -- a Boolean (default: ``False``) which\n              decides whether the notion of a chain includes being\n              ordered\n\n            OUTPUT:\n\n            If ``ordered`` is set to ``False``, the truth value of\n            the following assertion is returned: The subset of ``self``\n            formed by the elements of ``o`` is a chain in ``self``.\n\n            If ``ordered`` is set to ``True``, the truth value of\n            the following assertion is returned: Every element of the\n            list ``o`` is (strictly!) smaller than its successor in\n            ``self``. (This makes no sense if ``ordered`` is a set.)\n\n            EXAMPLES::\n\n                sage: P = Poset((divisors(12), attrcall(\"divides\")), facade=True, linear_extension=True)\n                sage: sorted(P.list())\n                [1, 2, 3, 4, 6, 12]\n                sage: P.is_chain_of_poset([1, 3])\n                True\n                sage: P.is_chain_of_poset([3, 1])\n                True\n                sage: P.is_chain_of_poset([1, 3], ordered=True)\n                True\n                sage: P.is_chain_of_poset([3, 1], ordered=True)\n                False\n                sage: P.is_chain_of_poset([])\n                True\n                sage: P.is_chain_of_poset([], ordered=True)\n                True\n                sage: P.is_chain_of_poset((2, 12, 6))\n                True\n                sage: P.is_chain_of_poset((2, 6, 12), ordered=True)\n                True\n                sage: P.is_chain_of_poset((2, 12, 6), ordered=True)\n                False\n                sage: P.is_chain_of_poset((2, 12, 6, 3))\n                False\n                sage: P.is_chain_of_poset((2, 3))\n                False\n\n                sage: Q = Poset({2: [3, 1], 3: [4], 1: [4]})\n                sage: Q.is_chain_of_poset([1, 2], ordered=True)\n                False\n                sage: Q.is_chain_of_poset([1, 2])\n                True\n                sage: Q.is_chain_of_poset([2, 1], ordered=True)\n                True\n                sage: Q.is_chain_of_poset([2, 1, 1], ordered=True)\n                False\n                sage: Q.is_chain_of_poset([3])\n                True\n                sage: Q.is_chain_of_poset([4, 2, 3])\n                True\n                sage: Q.is_chain_of_poset([4, 2, 3], ordered=True)\n                False\n                sage: Q.is_chain_of_poset([2, 3, 4], ordered=True)\n                True\n\n            Examples with infinite posets::\n\n                sage: from sage.categories.examples.posets import FiniteSetsOrderedByInclusion\n                sage: R = FiniteSetsOrderedByInclusion()\n                sage: R.is_chain_of_poset([R(set([3, 1, 2])), R(set([1, 4])), R(set([4, 5]))])\n                False\n                sage: R.is_chain_of_poset([R(set([3, 1, 2])), R(set([1, 2])), R(set([1]))], ordered=True)\n                False\n                sage: R.is_chain_of_poset([R(set([3, 1, 2])), R(set([1, 2])), R(set([1]))])\n                True\n\n                sage: from sage.categories.examples.posets import PositiveIntegersOrderedByDivisibilityFacade\n                sage: T = PositiveIntegersOrderedByDivisibilityFacade()\n                sage: T.is_chain_of_poset((T(3), T(4), T(7)))\n                False\n                sage: T.is_chain_of_poset((T(3), T(6), T(3)))\n                True\n                sage: T.is_chain_of_poset((T(3), T(6), T(3)), ordered=True)\n                False\n                sage: T.is_chain_of_poset((T(3), T(3), T(6)))\n                True\n                sage: T.is_chain_of_poset((T(3), T(3), T(6)), ordered=True)\n                False\n                sage: T.is_chain_of_poset((T(3), T(6)), ordered=True)\n                True\n                sage: T.is_chain_of_poset((), ordered=True)\n                True\n                sage: T.is_chain_of_poset((T(3),), ordered=True)\n                True\n                sage: T.is_chain_of_poset((T(q) for q in divisors(27)))\n                True\n                sage: T.is_chain_of_poset((T(q) for q in divisors(18)))\n                False\n            ",
                    "args": [
                        "self",
                        "o",
                        "ordered"
                    ],
                    "argspec": [
                        [
                            "self",
                            "o",
                            "ordered"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "is_order_filter": {
                    "__doc__": "\n            Return whether ``o`` is an order filter of ``self``, assuming ``self``\n            has no infinite ascending path.\n\n            INPUT:\n\n            - ``o`` -- a list (or set, or tuple) containing some elements of ``self``\n\n            EXAMPLES::\n\n                sage: P = Poset((divisors(12), attrcall(\"divides\")), facade=True, linear_extension=True)\n                sage: sorted(P.list())\n                [1, 2, 3, 4, 6, 12]\n                sage: P.is_order_filter([4, 12])\n                True\n                sage: P.is_order_filter([])\n                True\n                sage: P.is_order_filter({3, 4, 12})\n                False\n                sage: P.is_order_filter({3, 6, 12})\n                True\n\n            ",
                    "args": [
                        "self",
                        "o"
                    ],
                    "argspec": [
                        [
                            "self",
                            "o"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_order_ideal": {
                    "__doc__": "\n            Return whether ``o`` is an order ideal of ``self``, assuming ``self``\n            has no infinite descending path.\n\n            INPUT:\n\n            - ``o`` -- a list (or set, or tuple) containing some elements of ``self``\n\n            EXAMPLES::\n\n                sage: P = Poset((divisors(12), attrcall(\"divides\")), facade=True, linear_extension=True)\n                sage: sorted(P.list())\n                [1, 2, 3, 4, 6, 12]\n                sage: P.is_order_ideal([1, 3])\n                True\n                sage: P.is_order_ideal([])\n                True\n                sage: P.is_order_ideal({1, 3})\n                True\n                sage: P.is_order_ideal([1, 3, 4])\n                False\n\n            ",
                    "args": [
                        "self",
                        "o"
                    ],
                    "argspec": [
                        [
                            "self",
                            "o"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "le": {
                    "__doc__": "\n            Return whether `x \\le y` in the poset ``self``.\n\n            INPUT:\n\n            - ``x``, ``y`` -- elements of ``self``.\n\n            EXAMPLES::\n\n                sage: D = Poset((divisors(30), attrcall(\"divides\")))\n                sage: D.le( 3, 6 )\n                True\n                sage: D.le( 3, 3 )\n                True\n                sage: D.le( 3, 5 )\n                False\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "lower_covers": {
                    "__doc__": "\n            Return the lower covers of `x`, that is, the elements `y`\n            such that `y<x` and there exists no `z` such that `y<z<x`.\n\n            EXAMPLES::\n\n                sage: D = Poset((divisors(30), attrcall(\"divides\")))\n                sage: D.lower_covers(15)\n                [3, 5]\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "lt": {
                    "__doc__": "\n            Return whether `x < y` in the poset ``self``.\n\n            INPUT:\n\n            - ``x``, ``y`` -- elements of ``self``.\n\n            This default implementation delegates the work to :meth:`le`.\n\n            EXAMPLES::\n\n                sage: D = Poset((divisors(30), attrcall(\"divides\")))\n                sage: D.lt( 3, 6 )\n                True\n                sage: D.lt( 3, 3 )\n                False\n                sage: D.lt( 3, 5 )\n                False\n            ",
                    "args": [
                        "self",
                        "x",
                        "y"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "y"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "order_filter": {
                    "__doc__": "\n            Return the order filter generated by a list of elements.\n\n            A subset `I` of a poset is said to be an order filter if, for\n            any `x` in `I` and `y` such that `y \\ge x`, then `y` is in `I`.\n\n            This is also called the upper set generated by these elements.\n\n            EXAMPLES::\n\n                sage: B = Posets.BooleanLattice(4)\n                sage: B.order_filter([3,8])\n                [3, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n            ",
                    "args": [
                        "self",
                        "elements"
                    ],
                    "argspec": [
                        [
                            "self",
                            "elements"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "order_ideal": {
                    "__doc__": "\n            Return the order ideal in ``self`` generated by the elements\n            of an iterable ``elements``.\n\n            A subset `I` of a poset is said to be an order ideal if, for\n            any `x` in `I` and `y` such that `y \\le x`, then `y` is in `I`.\n\n            This is also called the lower set generated by these elements.\n\n            EXAMPLES::\n\n                sage: B = Posets.BooleanLattice(4)\n                sage: B.order_ideal([7,10])\n                [0, 1, 2, 3, 4, 5, 6, 7, 8, 10]\n            ",
                    "args": [
                        "self",
                        "elements"
                    ],
                    "argspec": [
                        [
                            "self",
                            "elements"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "order_ideal_toggle": {
                    "__doc__": "\n            Return the result of toggling the element ``v`` in the\n            order ideal ``I``.\n\n            If `v` is an element of a poset `P`, then toggling the\n            element `v` is an automorphism of the set `J(P)` of all\n            order ideals of `P`. It is defined as follows: If `I`\n            is an order ideal of `P`, then the image of `I` under\n            toggling the element `v` is\n\n            - the set `I \\cup \\{ v \\}`, if `v \\not\\in I` but\n              every element of `P` smaller than `v` is in `I`;\n\n            - the set `I \\setminus \\{ v \\}`, if `v \\in I` but\n              no element of `P` greater than `v` is in `I`;\n\n            - `I` otherwise.\n\n            This image always is an order ideal of `P`.\n\n            EXAMPLES::\n\n                sage: P = Poset({1: [2,3], 2: [4], 3: []})\n                sage: I = Set({1, 2})\n                sage: I in P.order_ideals_lattice()\n                True\n                sage: P.order_ideal_toggle(I, 1)\n                {1, 2}\n                sage: P.order_ideal_toggle(I, 2)\n                {1}\n                sage: P.order_ideal_toggle(I, 3)\n                {1, 2, 3}\n                sage: P.order_ideal_toggle(I, 4)\n                {1, 2, 4}\n                sage: P4 = Posets(4)\n                sage: all(all(all(P.order_ideal_toggle(P.order_ideal_toggle(I, i), i) == I\n                ....:               for i in range(4))\n                ....:          for I in P.order_ideals_lattice(facade=True))\n                ....:     for P in P4)\n                True\n            ",
                    "args": [
                        "self",
                        "I",
                        "v"
                    ],
                    "argspec": [
                        [
                            "self",
                            "I",
                            "v"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "order_ideal_toggles": {
                    "__doc__": "\n            Return the result of toggling the elements of the list (or\n            iterable) ``vs`` (one by one, from left to right) in the order\n            ideal ``I``.\n\n            See :meth:`order_ideal_toggle` for a definition of toggling.\n\n            EXAMPLES::\n\n                sage: P = Poset({1: [2,3], 2: [4], 3: []})\n                sage: I = Set({1, 2})\n                sage: P.order_ideal_toggles(I, [1,2,3,4])\n                {1, 3}\n                sage: P.order_ideal_toggles(I, (1,2,3,4))\n                {1, 3}\n            ",
                    "args": [
                        "self",
                        "I",
                        "vs"
                    ],
                    "argspec": [
                        [
                            "self",
                            "I",
                            "vs"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "principal_lower_set": {
                    "__doc__": "\n            Return the order ideal generated by an element ``x``.\n\n            This is also called the lower set generated by this element.\n\n            EXAMPLES::\n\n                sage: B = Posets.BooleanLattice(4)\n                sage: B.principal_order_ideal(6)\n                [0, 2, 4, 6]\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "principal_order_filter": {
                    "__doc__": "\n            Return the order filter generated by an element ``x``.\n\n            This is also called the upper set generated by this element.\n\n            EXAMPLES::\n\n                sage: B = Posets.BooleanLattice(4)\n                sage: B.principal_order_filter(2)\n                [2, 3, 6, 7, 10, 11, 14, 15]\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "principal_order_ideal": {
                    "__doc__": "\n            Return the order ideal generated by an element ``x``.\n\n            This is also called the lower set generated by this element.\n\n            EXAMPLES::\n\n                sage: B = Posets.BooleanLattice(4)\n                sage: B.principal_order_ideal(6)\n                [0, 2, 4, 6]\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "principal_upper_set": {
                    "__doc__": "\n            Return the order filter generated by an element ``x``.\n\n            This is also called the upper set generated by this element.\n\n            EXAMPLES::\n\n                sage: B = Posets.BooleanLattice(4)\n                sage: B.principal_order_filter(2)\n                [2, 3, 6, 7, 10, 11, 14, 15]\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "upper_covers": {
                    "__doc__": "\n            Return the upper covers of `x`, that is, the elements `y`\n            such that `x<y` and there exists no `z` such that `x<z<y`.\n\n            EXAMPLES::\n\n                sage: D = Poset((divisors(30), attrcall(\"divides\")))\n                sage: D.upper_covers(3)\n                [6, 15]\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.posets.Posets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis",
            "sage.categories.unital_algebras.UnitalAlgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.unital_algebras.UnitalAlgebras.WithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "from_base_ring_from_one_basis": {
                    "__doc__": "\n                Implement the canonical embeding from the ground ring.\n\n                INPUT:\n\n                - ``r`` -- an element of the coefficient ring\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example()\n                    sage: A.from_base_ring_from_one_basis(3)\n                    3*B[word: ]\n                    sage: A.from_base_ring(3)\n                    3*B[word: ]\n                    sage: A(3)\n                    3*B[word: ]\n                ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "one_basis": {
                    "__doc__": "\n                When the one of an algebra with basis is an element of\n                this basis, this optional method can return the index of\n                this element. This is used to provide a default\n                implementation of :meth:`.one`, and an optimized default\n                implementation of :meth:`.from_base_ring`.\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example()\n                    sage: A.one_basis()\n                    word: \n                    sage: A.one()\n                    B[word: ]\n                    sage: A.from_base_ring(4)\n                    4*B[word: ]\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "one_from_one_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.super_modules.SuperModules",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.Super",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of classical crystals constructed by tensor\n        product of classical crystals.\n        ",
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": "\n        The category of classical crystals constructed by tensor\n        product of classical crystals.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.classical_crystals.ClassicalCrystals",
            "sage.categories.finite_crystals.FiniteCrystals.TensorProducts",
            "sage.categories.regular_crystals.RegularCrystals.TensorProducts",
            "sage.categories.highest_weight_crystals.HighestWeightCrystals.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of classical crystals constructed by tensor\n        product of classical crystals.\n        ",
            "methods": {}
        },
        "name": "sage.categories.classical_crystals.ClassicalCrystals.TensorProducts",
        "parent_class": {
            "__doc__": "\n        The category of classical crystals constructed by tensor\n        product of classical crystals.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals",
            "sage.categories.crystals.Crystals.TensorProducts",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of classical crystals constructed by tensor\n        product of classical crystals.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of finite crystals constructed by tensor\n        product of finite crystals.\n        ",
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": "\n        The category of finite crystals constructed by tensor\n        product of finite crystals.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_crystals.FiniteCrystals",
            "sage.categories.crystals.Crystals.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of finite crystals constructed by tensor\n        product of finite crystals.\n        ",
            "methods": {}
        },
        "name": "sage.categories.finite_crystals.FiniteCrystals.TensorProducts",
        "parent_class": {
            "__doc__": "\n        The category of finite crystals constructed by tensor\n        product of finite crystals.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals",
            "sage.categories.crystals.Crystals.TensorProducts",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of finite crystals constructed by tensor\n        product of finite crystals.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of monoids constructed as Cartesian products of monoids.\n\n        This construction gives the direct product of monoids. See\n        :wikipedia:`Direct_product` for more information.\n        ",
        "axioms": [
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": "\n        The category of monoids constructed as Cartesian products of monoids.\n\n        This construction gives the direct product of monoids. See\n        :wikipedia:`Direct_product` for more information.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.semigroups.Semigroups.CartesianProducts",
            "sage.categories.magmas.Magmas.Unital.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of monoids constructed as Cartesian products of monoids.\n\n        This construction gives the direct product of monoids. See\n        :wikipedia:`Direct_product` for more information.\n        ",
            "methods": {}
        },
        "name": "sage.categories.monoids.Monoids.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of monoids constructed as Cartesian products of monoids.\n\n        This construction gives the direct product of monoids. See\n        :wikipedia:`Direct_product` for more information.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of subquotient semi-groups.\n\n        EXAMPLES::\n\n            sage: Semigroups().Subquotients().all_super_categories()\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        The category of subquotient semi-groups.\n\n        EXAMPLES::\n\n            sage: Semigroups().Subquotients().all_super_categories()\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.semigroups.Semigroups",
            "sage.categories.magmas.Magmas.Subquotients"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of subquotient semi-groups.\n\n        EXAMPLES::\n\n            sage: Semigroups().Subquotients().all_super_categories()\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "name": "sage.categories.semigroups.Semigroups.Subquotients",
        "parent_class": {
            "__doc__": "\n        The category of subquotient semi-groups.\n\n        EXAMPLES::\n\n            sage: Semigroups().Subquotients().all_super_categories()\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of subquotient semi-groups.\n\n        EXAMPLES::\n\n            sage: Semigroups().Subquotients().all_super_categories()\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n\n            [Category of subquotients of semigroups,\n             Category of semigroups,\n             Category of subquotients of magmas,\n             Category of magmas,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
        "axioms": [
            "Infinite",
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.weyl_groups.WeylGroups",
            "sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "name": "sage.categories.category.JoinCategory",
        "parent_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis",
            "sage.categories.sets_cat.Sets.Algebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Infinite"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.sets_cat.Sets.Infinite",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "is_empty": {
                    "__doc__": "\n                Return whether this set is empty.\n\n                Since this set is infinite this always returns ``False``.\n\n                EXAMPLES::\n\n                    sage: C = InfiniteEnumeratedSets().example()\n                    sage: C.is_empty()\n                    False\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "mmt.Modules.GAP"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.WithBasis.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of generalized Coxeter groups.\n\n    A generalized Coxeter group is a group with a presentation of\n    the following form:\n\n    .. MATH::\n\n        \\langle s_i \\mid s_i^{p_i}, s_i s_j \\cdots = s_j s_i \\cdots \\rangle,\n\n    where `p_i > 1`, `i \\in I`, and the factors in the braid relation\n    occur `m_{ij} = m_{ji}` times for all `i \\neq j \\in I`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.generalized_coxeter_groups import GeneralizedCoxeterGroups\n        sage: C = GeneralizedCoxeterGroups(); C\n        Category of generalized coxeter groups\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "FinitelyGeneratedAsMagma",
            "Unital"
        ],
        "element_class": {
            "__doc__": "\n    The category of generalized Coxeter groups.\n\n    A generalized Coxeter group is a group with a presentation of\n    the following form:\n\n    .. MATH::\n\n        \\langle s_i \\mid s_i^{p_i}, s_i s_j \\cdots = s_j s_i \\cdots \\rangle,\n\n    where `p_i > 1`, `i \\in I`, and the factors in the braid relation\n    occur `m_{ij} = m_{ji}` times for all `i \\neq j \\in I`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.generalized_coxeter_groups import GeneralizedCoxeterGroups\n        sage: C = GeneralizedCoxeterGroups(); C\n        Category of generalized coxeter groups\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of generalized Coxeter groups.\n\n    A generalized Coxeter group is a group with a presentation of\n    the following form:\n\n    .. MATH::\n\n        \\langle s_i \\mid s_i^{p_i}, s_i s_j \\cdots = s_j s_i \\cdots \\rangle,\n\n    where `p_i > 1`, `i \\in I`, and the factors in the braid relation\n    occur `m_{ij} = m_{ji}` times for all `i \\neq j \\in I`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.generalized_coxeter_groups import GeneralizedCoxeterGroups\n        sage: C = GeneralizedCoxeterGroups(); C\n        Category of generalized coxeter groups\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.generalized_coxeter_groups.GeneralizedCoxeterGroups",
        "parent_class": {
            "__doc__": "\n    The category of generalized Coxeter groups.\n\n    A generalized Coxeter group is a group with a presentation of\n    the following form:\n\n    .. MATH::\n\n        \\langle s_i \\mid s_i^{p_i}, s_i s_j \\cdots = s_j s_i \\cdots \\rangle,\n\n    where `p_i > 1`, `i \\in I`, and the factors in the braid relation\n    occur `m_{ij} = m_{ji}` times for all `i \\neq j \\in I`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.generalized_coxeter_groups import GeneralizedCoxeterGroups\n        sage: C = GeneralizedCoxeterGroups(); C\n        Category of generalized coxeter groups\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of generalized Coxeter groups.\n\n    A generalized Coxeter group is a group with a presentation of\n    the following form:\n\n    .. MATH::\n\n        \\langle s_i \\mid s_i^{p_i}, s_i s_j \\cdots = s_j s_i \\cdots \\rangle,\n\n    where `p_i > 1`, `i \\in I`, and the factors in the braid relation\n    occur `m_{ij} = m_{ji}` times for all `i \\neq j \\in I`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.generalized_coxeter_groups import GeneralizedCoxeterGroups\n        sage: C = GeneralizedCoxeterGroups(); C\n        Category of generalized coxeter groups\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.modules.Modules.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modules.Modules.TensorProducts"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.DualObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        A category for subobjects of sets.\n\n        .. SEEALSO:: :meth:`Sets().Subobjects`\n\n        EXAMPLES::\n\n            sage: Sets().Subobjects()\n            Category of subobjects of sets\n            sage: Sets().Subobjects().all_super_categories()\n            [Category of subobjects of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n        A category for subobjects of sets.\n\n        .. SEEALSO:: :meth:`Sets().Subobjects`\n\n        EXAMPLES::\n\n            sage: Sets().Subobjects()\n            Category of subobjects of sets\n            sage: Sets().Subobjects().all_super_categories()\n            [Category of subobjects of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        A category for subobjects of sets.\n\n        .. SEEALSO:: :meth:`Sets().Subobjects`\n\n        EXAMPLES::\n\n            sage: Sets().Subobjects()\n            Category of subobjects of sets\n            sage: Sets().Subobjects().all_super_categories()\n            [Category of subobjects of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "name": "sage.categories.sets_cat.Sets.Subobjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.sets_cat.Sets.Subobjects",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        A category for subobjects of sets.\n\n        .. SEEALSO:: :meth:`Sets().Subobjects`\n\n        EXAMPLES::\n\n            sage: Sets().Subobjects()\n            Category of subobjects of sets\n            sage: Sets().Subobjects().all_super_categories()\n            [Category of subobjects of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_modules.FilteredModules",
        "parent_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of crystals constructed by tensor product of crystals.\n        ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n        The category of crystals constructed by tensor product of crystals.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.crystals.Crystals"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of crystals constructed by tensor product of crystals.\n        ",
            "methods": {}
        },
        "name": "sage.categories.crystals.Crystals.TensorProducts",
        "parent_class": {
            "__doc__": "\n        The category of crystals constructed by tensor product of crystals.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.crystals.Crystals",
            "sage.categories.crystals.Crystals.TensorProducts",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of crystals constructed by tensor product of crystals.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.modules.Modules.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.DualObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Associative",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.semigroups.Semigroups",
            "mmt.Magmas.GAP"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.Semigroups.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all modules over a base ring `R`.\n\n    An `R`-module `M` is a left and right `R`-module over a\n    commutative ring `R` such that:\n\n    .. MATH::\n\n        r*(x*s) = (r*x)*s \\qquad  \\forall r,s \\in R \\text{ and } x \\in M\n\n    INPUT:\n\n    - ``base_ring`` -- a ring `R` or subcategory of ``Rings()``\n    - ``dispatch`` -- a boolean (for internal use; default: ``True``)\n\n    When the base ring is a field, the category of vector spaces is\n    returned instead (unless ``dispatch == False``).\n\n    .. WARNING::\n\n        Outside of the context of symmetric modules over a commutative\n        ring, the specifications of this category are fuzzy and not\n        yet set in stone (see below). The code in this category and\n        its subcategories is therefore prone to bugs or arbitrary\n        limitations in this case.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ)\n        Category of modules over Integer Ring\n        sage: Modules(QQ)\n        Category of vector spaces over Rational Field\n\n        sage: Modules(Rings())\n        Category of modules over rings\n        sage: Modules(FiniteFields())\n        Category of vector spaces over finite fields\n\n        sage: Modules(Integers(9))\n        Category of modules over Ring of integers modulo 9\n\n        sage: Modules(Integers(9)).super_categories()\n        [Category of bimodules over Ring of integers modulo 9 on the left and Ring of integers modulo 9 on the right]\n\n        sage: Modules(ZZ).super_categories()\n        [Category of bimodules over Integer Ring on the left and Integer Ring on the right]\n\n        sage: Modules == RingModules\n        True\n\n        sage: Modules(ZZ['x']).is_abelian()   # see #6081\n        True\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ)).run()\n\n    .. TODO::\n\n        - Clarify the distinction, if any, with ``BiModules(R, R)``.\n          In particular, if `R` is a commutative ring (e.g. a field),\n          some pieces of the code possibly assume that `M` is a\n          *symmetric `R`-`R`-bimodule*:\n\n          .. MATH::\n\n              r*x = x*r \\qquad  \\forall r \\in R \\text{ and } x \\in M\n\n        - Make sure that non symmetric modules are properly supported\n          by all the code, and advertise it.\n\n        - Make sure that non commutative rings are properly supported\n          by all the code, and advertise it.\n\n        - Add support for base semirings.\n\n        - Implement a ``FreeModules(R)`` category, when so prompted by a\n          concrete use case: e.g.  modeling a free module with several\n          bases (using :meth:`Sets.SubcategoryMethods.Realizations`)\n          or with an atlas of local maps (see e.g. :trac:`15916`).\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "__mul__": {
                    "__doc__": "Modules__mul__(Element left, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 86)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``left`` -- an element of a :class:`module <Modules>`\n    - ``right`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the right\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: x * int(2)\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__rmul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a\n    Cython method in :mod:`sage.categories.magmas_cython`::\n\n        sage: x.__mul__.im_func is Modules.ElementMethods.__mul__.im_func\n        True\n        sage: x.__mul__.im_func is sage.categories.coercion_methods.Modules__mul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__rmul__": {
                    "__doc__": "Modules__rmul__(Element right, left)\nFile: sage/categories/coercion_methods.pyx (starting at line 122)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``right`` -- an element of a :class:`module <Modules>`\n    - ``left`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the left\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: int(2) * x\n        2*B['a']\n        sage: x.__rmul__(int(2))\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__mul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a Cython\n    method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__rmul__.im_func is Modules.ElementMethods.__rmul__.im_func\n        True\n        sage: x.__rmul__.im_func is sage.categories.coercion_methods.Modules__rmul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "right",
                        "left"
                    ],
                    "argspec": [
                        [
                            "right",
                            "left"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.bimodules.Bimodules"
        ],
        "mmt": "Modules",
        "morphism_class": {
            "__doc__": "\n    The category of all modules over a base ring `R`.\n\n    An `R`-module `M` is a left and right `R`-module over a\n    commutative ring `R` such that:\n\n    .. MATH::\n\n        r*(x*s) = (r*x)*s \\qquad  \\forall r,s \\in R \\text{ and } x \\in M\n\n    INPUT:\n\n    - ``base_ring`` -- a ring `R` or subcategory of ``Rings()``\n    - ``dispatch`` -- a boolean (for internal use; default: ``True``)\n\n    When the base ring is a field, the category of vector spaces is\n    returned instead (unless ``dispatch == False``).\n\n    .. WARNING::\n\n        Outside of the context of symmetric modules over a commutative\n        ring, the specifications of this category are fuzzy and not\n        yet set in stone (see below). The code in this category and\n        its subcategories is therefore prone to bugs or arbitrary\n        limitations in this case.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ)\n        Category of modules over Integer Ring\n        sage: Modules(QQ)\n        Category of vector spaces over Rational Field\n\n        sage: Modules(Rings())\n        Category of modules over rings\n        sage: Modules(FiniteFields())\n        Category of vector spaces over finite fields\n\n        sage: Modules(Integers(9))\n        Category of modules over Ring of integers modulo 9\n\n        sage: Modules(Integers(9)).super_categories()\n        [Category of bimodules over Ring of integers modulo 9 on the left and Ring of integers modulo 9 on the right]\n\n        sage: Modules(ZZ).super_categories()\n        [Category of bimodules over Integer Ring on the left and Integer Ring on the right]\n\n        sage: Modules == RingModules\n        True\n\n        sage: Modules(ZZ['x']).is_abelian()   # see #6081\n        True\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ)).run()\n\n    .. TODO::\n\n        - Clarify the distinction, if any, with ``BiModules(R, R)``.\n          In particular, if `R` is a commutative ring (e.g. a field),\n          some pieces of the code possibly assume that `M` is a\n          *symmetric `R`-`R`-bimodule*:\n\n          .. MATH::\n\n              r*x = x*r \\qquad  \\forall r \\in R \\text{ and } x \\in M\n\n        - Make sure that non symmetric modules are properly supported\n          by all the code, and advertise it.\n\n        - Make sure that non commutative rings are properly supported\n          by all the code, and advertise it.\n\n        - Add support for base semirings.\n\n        - Implement a ``FreeModules(R)`` category, when so prompted by a\n          concrete use case: e.g.  modeling a free module with several\n          bases (using :meth:`Sets.SubcategoryMethods.Realizations`)\n          or with an atlas of local maps (see e.g. :trac:`15916`).\n    ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "tensor_square": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "__mul__": {
                    "__doc__": "Modules__mul__(Element left, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 86)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``left`` -- an element of a :class:`module <Modules>`\n    - ``right`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the right\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: x * int(2)\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__rmul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a\n    Cython method in :mod:`sage.categories.magmas_cython`::\n\n        sage: x.__mul__.im_func is Modules.ElementMethods.__mul__.im_func\n        True\n        sage: x.__mul__.im_func is sage.categories.coercion_methods.Modules__mul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__rmul__": {
                    "__doc__": "Modules__rmul__(Element right, left)\nFile: sage/categories/coercion_methods.pyx (starting at line 122)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``right`` -- an element of a :class:`module <Modules>`\n    - ``left`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the left\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: int(2) * x\n        2*B['a']\n        sage: x.__rmul__(int(2))\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__mul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a Cython\n    method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__rmul__.im_func is Modules.ElementMethods.__rmul__.im_func\n        True\n        sage: x.__rmul__.im_func is sage.categories.coercion_methods.Modules__rmul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "right",
                        "left"
                    ],
                    "argspec": [
                        [
                            "right",
                            "left"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        Check that Sage knows that Cartesian products of finite commutative\n        rings is a finite commutative ring.\n\n        EXAMPLES::\n\n            sage: cartesian_product([Zmod(34), GF(5)]) in Rings().Commutative().Finite()\n            True\n        ",
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Finite",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        Check that Sage knows that Cartesian products of finite commutative\n        rings is a finite commutative ring.\n\n        EXAMPLES::\n\n            sage: cartesian_product([Zmod(34), GF(5)]) in Rings().Commutative().Finite()\n            True\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_rings.CommutativeRings",
            "sage.categories.finite_monoids.FiniteMonoids"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        Check that Sage knows that Cartesian products of finite commutative\n        rings is a finite commutative ring.\n\n        EXAMPLES::\n\n            sage: cartesian_product([Zmod(34), GF(5)]) in Rings().Commutative().Finite()\n            True\n        ",
            "methods": {}
        },
        "name": "sage.categories.commutative_rings.CommutativeRings.Finite",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "cyclotomic_cosets": {
                    "__doc__": "\n                Return the (multiplicative) orbits of ``q`` in the ring.\n\n                Let `R` be a finite commutative ring. The group of invertible\n                elements `R^*` in `R` gives rise to a group action on `R` by\n                multiplication.  An orbit of the subgroup generated by an\n                invertible element `q` is called a `q`-*cyclotomic coset* (since\n                in a finite ring, each invertible element is a root of unity).\n\n                These cosets arise in the theory of minimal polynomials of\n                finite fields, duadic codes and combinatorial designs. Fix a\n                primitive element `z` of `GF(q^k)`. The minimal polynomial of\n                `z^s` over `GF(q)` is given by\n\n                .. math::\n\n                         M_s(x) = \\prod_{i \\in C_s} (x - z^i),\n\n\n                where `C_s` is the `q`-cyclotomic coset mod `n` containing `s`,\n                `n = q^k - 1`.\n\n                .. NOTE::\n\n                    When `R = \\ZZ / n \\ZZ` the smallest element of each coset is\n                    sometimes callled a *coset leader*. This function returns\n                    sorted lists so that the coset leader will always be the\n                    first element of the coset.\n\n                INPUT:\n\n                - ``q`` -- an invertible element of the ring\n\n                - ``cosets`` -- an optional lists of elements of ``self``. If\n                  provided, the function only return the list of cosets that\n                  contain some element from ``cosets``.\n\n                OUTPUT:\n\n                A list of lists.\n\n                EXAMPLES::\n\n                    sage: Zmod(11).cyclotomic_cosets(2)\n                    [[0], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]\n                    sage: Zmod(15).cyclotomic_cosets(2)\n                    [[0], [1, 2, 4, 8], [3, 6, 9, 12], [5, 10], [7, 11, 13, 14]]\n\n                Since the group of invertible elements of a finite field is\n                cyclic, the set of squares is a particular case of cyclotomic\n                coset::\n\n                    sage: K = GF(25,'z')\n                    sage: a = K.multiplicative_generator()\n                    sage: K.cyclotomic_cosets(a**2,cosets=[1])\n                    [[1, 2, 3, 4, z + 1, z + 3,\n                      2*z + 1, 2*z + 2, 3*z + 3,\n                      3*z + 4, 4*z + 2, 4*z + 4]]\n                    sage: sorted(b for b in K if not b.is_zero() and b.is_square())\n                    [1, 2, 3, 4, z + 1, z + 3,\n                     2*z + 1, 2*z + 2, 3*z + 3,\n                     3*z + 4, 4*z + 2, 4*z + 4]\n\n                We compute some examples of minimal polynomials::\n\n                    sage: K = GF(27,'z')\n                    sage: a = K.multiplicative_generator()\n                    sage: R.<X> = PolynomialRing(K, 'X')\n                    sage: a.minimal_polynomial('X')\n                    X^3 + 2*X + 1\n                    sage: cyc3 = Zmod(26).cyclotomic_cosets(3,cosets=[1]); cyc3\n                    [[1, 3, 9]]\n                    sage: prod(X - a**i for i in cyc3[0])\n                    X^3 + 2*X + 1\n\n                    sage: (a**7).minimal_polynomial('X')\n                    X^3 + X^2 + 2*X + 1\n                    sage: cyc7 = Zmod(26).cyclotomic_cosets(3,cosets=[7]); cyc7\n                    [[7, 11, 21]]\n                    sage: prod(X - a**i for i in cyc7[0])\n                    X^3 + X^2 + 2*X + 1\n\n                Cyclotomic cosets of fields are useful in combinatorial design\n                theory to provide so called difference families (see\n                :wikipedia:`Difference_set` and\n                :mod:`~sage.combinat.designs.difference_family`). This is\n                illustrated on the following examples::\n\n                    sage: K = GF(5)\n                    sage: a = K.multiplicative_generator()\n                    sage: H = K.cyclotomic_cosets(a**2, cosets=[1,2]); H\n                    [[1, 4], [2, 3]]\n                    sage: sorted(x-y for D in H for x in D for y in D if x != y)\n                    [1, 2, 3, 4]\n\n                    sage: K = GF(37)\n                    sage: a = K.multiplicative_generator()\n                    sage: H = K.cyclotomic_cosets(a**4, cosets=[1]); H\n                    [[1, 7, 9, 10, 12, 16, 26, 33, 34]]\n                    sage: sorted(x-y for D in H for x in D for y in D if x != y)\n                    [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, ..., 33, 34, 34, 35, 35, 36, 36]\n\n                The method ``cyclotomic_cosets`` works on any finite commutative\n                ring::\n\n                    sage: R = cartesian_product([GF(7), Zmod(14)])\n                    sage: a = R((3,5))\n                    sage: R.cyclotomic_cosets((3,5), [(1,1)])\n                    [[(1, 1), (3, 5), (2, 11), (6, 13), (4, 9), (5, 3)]]\n                ",
                    "args": [
                        "self",
                        "q",
                        "cosets"
                    ],
                    "argspec": [
                        [
                            "self",
                            "q",
                            "cosets"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n        Check that Sage knows that Cartesian products of finite commutative\n        rings is a finite commutative ring.\n\n        EXAMPLES::\n\n            sage: cartesian_product([Zmod(34), GF(5)]) in Rings().Commutative().Finite()\n            True\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules.CartesianProducts",
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.DualObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of hopf algebras with basis constructed by tensor product of hopf algebras with basis\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis",
            "sage.categories.hopf_algebras.HopfAlgebras.TensorProducts",
            "sage.categories.algebras_with_basis.AlgebrasWithBasis.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of hopf algebras with basis constructed by tensor product of hopf algebras with basis\n        ",
            "methods": {}
        },
        "name": "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modules.Modules.TensorProducts"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        A category for quotients of sets.\n\n        .. SEEALSO:: :meth:`Sets().Quotients`\n\n        EXAMPLES::\n\n            sage: Sets().Quotients()\n            Category of quotients of sets\n            sage: Sets().Quotients().all_super_categories()\n            [Category of quotients of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n        A category for quotients of sets.\n\n        .. SEEALSO:: :meth:`Sets().Quotients`\n\n        EXAMPLES::\n\n            sage: Sets().Quotients()\n            Category of quotients of sets\n            sage: Sets().Quotients().all_super_categories()\n            [Category of quotients of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        A category for quotients of sets.\n\n        .. SEEALSO:: :meth:`Sets().Quotients`\n\n        EXAMPLES::\n\n            sage: Sets().Quotients()\n            Category of quotients of sets\n            sage: Sets().Quotients().all_super_categories()\n            [Category of quotients of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "name": "sage.categories.sets_cat.Sets.Quotients",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Quotients",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "subcategory_class": {
            "__doc__": "\n        A category for quotients of sets.\n\n        .. SEEALSO:: :meth:`Sets().Quotients`\n\n        EXAMPLES::\n\n            sage: Sets().Quotients()\n            Category of quotients of sets\n            sage: Sets().Quotients().all_super_categories()\n            [Category of quotients of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.DualObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "is_central": {
                    "__doc__": "\n                Return whether the element ``self`` is central.\n\n                EXAMPLES::\n\n                    sage: SG4=SymmetricGroupAlgebra(ZZ,4)\n                    sage: SG4(1).is_central()\n                    True\n                    sage: SG4(Permutation([1,3,2,4])).is_central()\n                    False\n                    sage: A=GroupAlgebras(QQ).example(); A\n                    Group algebra of Dihedral group of order 8 as a permutation group over Rational Field\n                    sage: sum(i for i in A.basis()).is_central()\n                    True\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.semigroups.Semigroups.Algebras",
            "sage.categories.magmas.Magmas.Unital.Algebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.monoids.Monoids.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "is_central": {
                    "__doc__": "\n                Return whether the element ``self`` is central.\n\n                EXAMPLES::\n\n                    sage: SG4=SymmetricGroupAlgebra(ZZ,4)\n                    sage: SG4(1).is_central()\n                    True\n                    sage: SG4(Permutation([1,3,2,4])).is_central()\n                    False\n                    sage: A=GroupAlgebras(QQ).example(); A\n                    Group algebra of Dihedral group of order 8 as a permutation group over Rational Field\n                    sage: sum(i for i in A.basis()).is_central()\n                    True\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.bialgebras.Bialgebras.Super"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.hopf_algebras.HopfAlgebras.Super",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.super_modules.SuperModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "__neg__": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method __neg__ at 0x7fe375eb2758>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "AdditiveInverse",
                    "mmt_name": null
                },
                "__nonzero__": {
                    "__doc__": "\n                Return whether ``self`` is not zero.\n\n                All parents in the category ``CommutativeAdditiveMonoids()``\n                should implement this method.\n\n                .. note:: This is currently not useful because this method is\n                   overridden by ``Element``.\n\n                TESTS::\n\n                    sage: S = CommutativeAdditiveMonoids().example()\n                    sage: bool(S.zero())\n                    False\n                    sage: bool(S.an_element())\n                    True\n                 ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__sub__": {
                    "__doc__": "\n                Return the difference between ``left`` and ``right``, if it exists.\n\n                This top-level implementation delegates the work to\n                the ``_sub_`` method or to coercion. See the extensive\n                documentation at the top of :ref:`sage.structure.element`.\n\n                EXAMPLES::\n\n                    sage: F = CombinatorialFreeModule(QQ, ['a','b'])\n                    sage: a,b = F.basis()\n                    sage: a - b\n                    B['a'] - B['b']\n                ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_sub_": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method _sub_ at 0x7fe375eb26e0>",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "\\-",
                    "mmt_name": null
                },
                "_test_nonzero_equal": {
                    "__doc__": "\n                Test that ``.__nonzero__()`` behave consistently\n                with `` == 0``.\n\n                TESTS::\n\n                    sage: S = CommutativeAdditiveMonoids().example()\n                    sage: S.zero()._test_nonzero_equal()\n                    sage: S.an_element()._test_nonzero_equal()\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "mmt": "NeutralElement",
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_zero": {
                    "__doc__": "\n                Test that ``self.zero()`` is an element of self and\n                is neutral for the addition.\n\n                INPUT:\n\n                - ``options`` -- any keyword arguments accepted\n                  by :meth:`_tester`\n\n                EXAMPLES:\n\n                By default, this method tests only the elements returned by\n                ``self.some_elements()``::\n\n                    sage: S = CommutativeAdditiveMonoids().example()\n                    sage: S._test_zero()\n\n                However, the elements tested can be customized with the\n                ``elements`` keyword argument::\n\n                    sage: (a,b,c,d) = S.additive_semigroup_generators()\n                    sage: S._test_zero(elements = (a, a+c))\n\n                See the documentation for :class:`TestSuite` for\n                more information.\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "is_empty": {
                    "__doc__": "\n                Return whether this set is empty.\n\n                Since this set is an additive magma it has a zero element and\n                hence is not empty. This method thus always returns ``False``.\n\n                EXAMPLES::\n\n                    sage: A = AdditiveAbelianGroup([3,3])\n                    sage: A in AdditiveMagmas()\n                    True\n                    sage: A.is_empty()\n                    False\n\n                    sage: B = CommutativeAdditiveMonoids().example()\n                    sage: B.is_empty()\n                    False\n\n                TESTS:\n\n                We check that the method `is_empty` is inherited from this\n                category in both examples above::\n\n                    sage: A.is_empty.__module__\n                    'sage.categories.additive_magmas'\n                    sage: B.is_empty.__module__\n                    'sage.categories.additive_magmas'\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "zero": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method zero at 0x7fe375eb2668>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "self",
                    "gap_name": "Zero",
                    "mmt_name": "neutral"
                },
                "zero_element": {
                    "__doc__": "\n                Backward compatibility alias for ``self.zero()``.\n\n                TESTS::\n\n                    sage: from sage.geometry.polyhedron.parent import Polyhedra\n                    sage: P = Polyhedra(QQ, 3)\n                    sage: P.zero_element()\n                    doctest:...: DeprecationWarning: .zero_element() is deprecated. Use .zero() instead\n                    See http://trac.sagemath.org/17694 for details.\n                    A 0-dimensional polyhedron in QQ^3 defined as the convex hull of 1 vertex\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "__neg__": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method __neg__ at 0x7fe375eb2758>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "AdditiveInverse",
                    "mmt_name": null
                },
                "__nonzero__": {
                    "__doc__": "\n                Return whether ``self`` is not zero.\n\n                All parents in the category ``CommutativeAdditiveMonoids()``\n                should implement this method.\n\n                .. note:: This is currently not useful because this method is\n                   overridden by ``Element``.\n\n                TESTS::\n\n                    sage: S = CommutativeAdditiveMonoids().example()\n                    sage: bool(S.zero())\n                    False\n                    sage: bool(S.an_element())\n                    True\n                 ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__sub__": {
                    "__doc__": "\n                Return the difference between ``left`` and ``right``, if it exists.\n\n                This top-level implementation delegates the work to\n                the ``_sub_`` method or to coercion. See the extensive\n                documentation at the top of :ref:`sage.structure.element`.\n\n                EXAMPLES::\n\n                    sage: F = CombinatorialFreeModule(QQ, ['a','b'])\n                    sage: a,b = F.basis()\n                    sage: a - b\n                    B['a'] - B['b']\n                ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_sub_": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method _sub_ at 0x7fe375eb26e0>",
                    "args": [
                        "self",
                        "other"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "\\-",
                    "mmt_name": null
                },
                "_test_nonzero_equal": {
                    "__doc__": "\n                Test that ``.__nonzero__()`` behave consistently\n                with `` == 0``.\n\n                TESTS::\n\n                    sage: S = CommutativeAdditiveMonoids().example()\n                    sage: S.zero()._test_nonzero_equal()\n                    sage: S.an_element()._test_nonzero_equal()\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras with basis constructed by tensor product of algebras with basis\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of algebras with basis\n            ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.algebras.Algebras.TensorProducts",
            "sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of algebras with basis constructed by tensor product of algebras with basis\n        ",
            "methods": {}
        },
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis.TensorProducts",
        "parent_class": {
            "__doc__": "\n            implements operations on tensor products of algebras with basis\n            ",
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modules.Modules.TensorProducts"
        ],
        "subcategory_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of algebras with basis\n            ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Inverse",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas.Unital"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Unital.Inverse",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of highest weight crystals constructed by tensor\n        product of highest weight crystals.\n        ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n        The category of highest weight crystals constructed by tensor\n        product of highest weight crystals.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.crystals.Crystals.TensorProducts",
            "sage.categories.highest_weight_crystals.HighestWeightCrystals"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of highest weight crystals constructed by tensor\n        product of highest weight crystals.\n        ",
            "methods": {}
        },
        "name": "sage.categories.highest_weight_crystals.HighestWeightCrystals.TensorProducts",
        "parent_class": {
            "__doc__": "\n            Implements operations on tensor products of crystals.\n            ",
            "methods": {}
        },
        "structure": [
            "sage.categories.crystals.Crystals",
            "sage.categories.crystals.Crystals.TensorProducts",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of highest weight crystals constructed by tensor\n        product of highest weight crystals.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of additive groups.\n\n    An *additive group* is a set with an internal binary operation `+` which\n    is associative, admits a zero, and where every element can be negated.\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: from sage.categories.additive_monoids import AdditiveMonoids\n        sage: AdditiveGroups()\n        Category of additive groups\n        sage: AdditiveGroups().super_categories()\n        [Category of additive inverse additive unital additive magmas,\n         Category of additive monoids]\n        sage: AdditiveGroups().all_super_categories()\n        [Category of additive groups,\n         Category of additive inverse additive unital additive magmas,\n         Category of additive monoids,\n         Category of additive unital additive magmas,\n         Category of additive semigroups,\n         Category of additive magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: AdditiveGroups().axioms()\n        frozenset({'AdditiveAssociative', 'AdditiveInverse', 'AdditiveUnital'})\n        sage: AdditiveGroups() is AdditiveMonoids().AdditiveInverse()\n        True\n\n    TESTS::\n\n        sage: C = AdditiveGroups()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of additive groups.\n\n    An *additive group* is a set with an internal binary operation `+` which\n    is associative, admits a zero, and where every element can be negated.\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: from sage.categories.additive_monoids import AdditiveMonoids\n        sage: AdditiveGroups()\n        Category of additive groups\n        sage: AdditiveGroups().super_categories()\n        [Category of additive inverse additive unital additive magmas,\n         Category of additive monoids]\n        sage: AdditiveGroups().all_super_categories()\n        [Category of additive groups,\n         Category of additive inverse additive unital additive magmas,\n         Category of additive monoids,\n         Category of additive unital additive magmas,\n         Category of additive semigroups,\n         Category of additive magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: AdditiveGroups().axioms()\n        frozenset({'AdditiveAssociative', 'AdditiveInverse', 'AdditiveUnital'})\n        sage: AdditiveGroups() is AdditiveMonoids().AdditiveInverse()\n        True\n\n    TESTS::\n\n        sage: C = AdditiveGroups()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.AdditiveInverse",
            "sage.categories.additive_monoids.AdditiveMonoids"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of additive groups.\n\n    An *additive group* is a set with an internal binary operation `+` which\n    is associative, admits a zero, and where every element can be negated.\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: from sage.categories.additive_monoids import AdditiveMonoids\n        sage: AdditiveGroups()\n        Category of additive groups\n        sage: AdditiveGroups().super_categories()\n        [Category of additive inverse additive unital additive magmas,\n         Category of additive monoids]\n        sage: AdditiveGroups().all_super_categories()\n        [Category of additive groups,\n         Category of additive inverse additive unital additive magmas,\n         Category of additive monoids,\n         Category of additive unital additive magmas,\n         Category of additive semigroups,\n         Category of additive magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: AdditiveGroups().axioms()\n        frozenset({'AdditiveAssociative', 'AdditiveInverse', 'AdditiveUnital'})\n        sage: AdditiveGroups() is AdditiveMonoids().AdditiveInverse()\n        True\n\n    TESTS::\n\n        sage: C = AdditiveGroups()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.additive_groups.AdditiveGroups",
        "parent_class": {
            "__doc__": "\n    The category of additive groups.\n\n    An *additive group* is a set with an internal binary operation `+` which\n    is associative, admits a zero, and where every element can be negated.\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: from sage.categories.additive_monoids import AdditiveMonoids\n        sage: AdditiveGroups()\n        Category of additive groups\n        sage: AdditiveGroups().super_categories()\n        [Category of additive inverse additive unital additive magmas,\n         Category of additive monoids]\n        sage: AdditiveGroups().all_super_categories()\n        [Category of additive groups,\n         Category of additive inverse additive unital additive magmas,\n         Category of additive monoids,\n         Category of additive unital additive magmas,\n         Category of additive semigroups,\n         Category of additive magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: AdditiveGroups().axioms()\n        frozenset({'AdditiveAssociative', 'AdditiveInverse', 'AdditiveUnital'})\n        sage: AdditiveGroups() is AdditiveMonoids().AdditiveInverse()\n        True\n\n    TESTS::\n\n        sage: C = AdditiveGroups()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of additive groups.\n\n    An *additive group* is a set with an internal binary operation `+` which\n    is associative, admits a zero, and where every element can be negated.\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_groups import AdditiveGroups\n        sage: from sage.categories.additive_monoids import AdditiveMonoids\n        sage: AdditiveGroups()\n        Category of additive groups\n        sage: AdditiveGroups().super_categories()\n        [Category of additive inverse additive unital additive magmas,\n         Category of additive monoids]\n        sage: AdditiveGroups().all_super_categories()\n        [Category of additive groups,\n         Category of additive inverse additive unital additive magmas,\n         Category of additive monoids,\n         Category of additive unital additive magmas,\n         Category of additive semigroups,\n         Category of additive magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: AdditiveGroups().axioms()\n        frozenset({'AdditiveAssociative', 'AdditiveInverse', 'AdditiveUnital'})\n        sage: AdditiveGroups() is AdditiveMonoids().AdditiveInverse()\n        True\n\n    TESTS::\n\n        sage: C = AdditiveGroups()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of regular crystals constructed by tensor\n        product of regular crystals.\n        ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n        The category of regular crystals constructed by tensor\n        product of regular crystals.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.crystals.Crystals.TensorProducts",
            "sage.categories.regular_crystals.RegularCrystals"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of regular crystals constructed by tensor\n        product of regular crystals.\n        ",
            "methods": {}
        },
        "name": "sage.categories.regular_crystals.RegularCrystals.TensorProducts",
        "parent_class": {
            "__doc__": "\n        The category of regular crystals constructed by tensor\n        product of regular crystals.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.crystals.Crystals",
            "sage.categories.crystals.Crystals.TensorProducts",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of regular crystals constructed by tensor\n        product of regular crystals.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of topological spaces.\n\n    EXAMPLES::\n\n        sage: Sets().Topological()\n        Category of topological spaces\n        sage: Sets().Topological().super_categories()\n        [Category of sets]\n\n    The category of topological spaces defines the topological structure,\n    which shall be preserved by morphisms::\n\n        sage: Sets().Topological().additional_structure()\n        Category of topological spaces\n\n    TESTS::\n\n        sage: TestSuite(Sets().Topological()).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of topological spaces.\n\n    EXAMPLES::\n\n        sage: Sets().Topological()\n        Category of topological spaces\n        sage: Sets().Topological().super_categories()\n        [Category of sets]\n\n    The category of topological spaces defines the topological structure,\n    which shall be preserved by morphisms::\n\n        sage: Sets().Topological().additional_structure()\n        Category of topological spaces\n\n    TESTS::\n\n        sage: TestSuite(Sets().Topological()).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of topological spaces.\n\n    EXAMPLES::\n\n        sage: Sets().Topological()\n        Category of topological spaces\n        sage: Sets().Topological().super_categories()\n        [Category of sets]\n\n    The category of topological spaces defines the topological structure,\n    which shall be preserved by morphisms::\n\n        sage: Sets().Topological().additional_structure()\n        Category of topological spaces\n\n    TESTS::\n\n        sage: TestSuite(Sets().Topological()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.topological_spaces.TopologicalSpaces",
        "parent_class": {
            "__doc__": "\n    The category of topological spaces.\n\n    EXAMPLES::\n\n        sage: Sets().Topological()\n        Category of topological spaces\n        sage: Sets().Topological().super_categories()\n        [Category of sets]\n\n    The category of topological spaces defines the topological structure,\n    which shall be preserved by morphisms::\n\n        sage: Sets().Topological().additional_structure()\n        Category of topological spaces\n\n    TESTS::\n\n        sage: TestSuite(Sets().Topological()).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.topological_spaces.TopologicalSpaces",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of topological spaces.\n\n    EXAMPLES::\n\n        sage: Sets().Topological()\n        Category of topological spaces\n        sage: Sets().Topological().super_categories()\n        [Category of sets]\n\n    The category of topological spaces defines the topological structure,\n    which shall be preserved by morphisms::\n\n        sage: Sets().Topological().additional_structure()\n        Category of topological spaces\n\n    TESTS::\n\n        sage: TestSuite(Sets().Topological()).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.WithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        Category of commutative (abelian) groups.\n\n        A group `G` is *commutative* if `xy = yx` for all `x,y \\in G`.\n        ",
        "axioms": [
            "Inverse",
            "Commutative",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": "\n        Category of commutative (abelian) groups.\n\n        A group `G` is *commutative* if `xy = yx` for all `x,y \\in G`.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.groups.Groups",
            "sage.categories.monoids.Monoids.Commutative"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        Category of commutative (abelian) groups.\n\n        A group `G` is *commutative* if `xy = yx` for all `x,y \\in G`.\n        ",
            "methods": {}
        },
        "name": "sage.categories.groups.Groups.Commutative",
        "parent_class": {
            "__doc__": "\n        Category of commutative (abelian) groups.\n\n        A group `G` is *commutative* if `xy = yx` for all `x,y \\in G`.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n        Category of commutative (abelian) groups.\n\n        A group `G` is *commutative* if `xy = yx` for all `x,y \\in G`.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Finite",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_sets.FiniteSets",
            "mmt.Sets.GAP"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.Finite.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups.CartesianProducts",
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "base_ring": {
                    "__doc__": "\n                Return the base ring of this Cartesian product.\n\n                EXAMPLES::\n\n                    sage: E = CombinatorialFreeModule(ZZ, [1,2,3])\n                    sage: F = CombinatorialFreeModule(ZZ, [2,3,4])\n                    sage: C = cartesian_product([E, F]); C\n                    Free module generated by {1, 2, 3} over Integer Ring (+)\n                    Free module generated by {2, 3, 4} over Integer Ring\n                    sage: C.base_ring()\n                    Integer Ring\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "FiniteDimensional",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.FiniteDimensional",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_algebras.FilteredAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "graded_algebra": {
                    "__doc__": "\n            Return the associated graded algebra to ``self``.\n\n            .. TODO::\n\n                Implement a version of the associated graded algebra\n                which does not require ``self`` to have a\n                distinguished basis.\n\n            EXAMPLES::\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: A.graded_algebra()\n                Graded Algebra of An example of a filtered algebra with basis:\n                 the universal enveloping algebra of\n                 Lie algebra of RR^3 with cross product over Integer Ring\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "FiniteDimensional",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "mmt.WithBasis.GAP",
            "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.FiniteDimensional.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        Category of topological groups.\n\n        A topological group `G` is a group which has a topology such that\n        multiplication and taking inverses are continuous functions.\n\n        REFERENCES:\n\n        - :wikipedia:`Topological_group`\n        ",
        "axioms": [
            "Inverse",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": "\n        Category of topological groups.\n\n        A topological group `G` is a group which has a topology such that\n        multiplication and taking inverses are continuous functions.\n\n        REFERENCES:\n\n        - :wikipedia:`Topological_group`\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.groups.Groups",
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        Category of topological groups.\n\n        A topological group `G` is a group which has a topology such that\n        multiplication and taking inverses are continuous functions.\n\n        REFERENCES:\n\n        - :wikipedia:`Topological_group`\n        ",
            "methods": {}
        },
        "name": "sage.categories.groups.Groups.Topological",
        "parent_class": {
            "__doc__": "\n        Category of topological groups.\n\n        A topological group `G` is a group which has a topology such that\n        multiplication and taking inverses are continuous functions.\n\n        REFERENCES:\n\n        - :wikipedia:`Topological_group`\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "subcategory_class": {
            "__doc__": "\n        Category of topological groups.\n\n        A topological group `G` is a group which has a topology such that\n        multiplication and taking inverses are continuous functions.\n\n        REFERENCES:\n\n        - :wikipedia:`Topological_group`\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        Category of finite simplicial complexes.\n        ",
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": "\n        Category of finite simplicial complexes.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_sets.FiniteSets",
            "sage.categories.simplicial_complexes.SimplicialComplexes"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        Category of finite simplicial complexes.\n        ",
            "methods": {}
        },
        "name": "sage.categories.simplicial_complexes.SimplicialComplexes.Finite",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "dimension": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.simplicial_complexes.SimplicialComplexes",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        Category of finite simplicial complexes.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "mmt.AdditiveSemigroups.GAP",
            "mmt.AdditiveUnital.GAP",
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.Modules.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.super_algebras.SuperAlgebras",
            "sage.categories.coalgebras.Coalgebras.Super"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.bialgebras.Bialgebras.Super",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.super_modules.SuperModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.facade_sets.FacadeSets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "facade_for": {
                    "__doc__": "\n            Returns the parents this set is a facade for\n\n            This default implementation assumes that ``self`` has\n            an attribute ``_facade_for``, typically initialized by\n            :meth:`Parent.__init__`. If the attribute is not present, the method\n            raises a NotImplementedError.\n\n            EXAMPLES::\n\n                sage: S = Sets().Facade().example(); S\n                An example of facade set: the monoid of positive integers\n                sage: S.facade_for()\n                (Integer Ring,)\n\n            Check that :trac:`13801` is corrected::\n\n                sage: class A(Parent):\n                ....:     def __init__(self):\n                ....:         Parent.__init__(self, category=Sets(), facade=True)\n                sage: a = A()\n                sage: a.facade_for()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: this parent did not specify which parents it is a facade for\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Realizations"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Realizations",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "product_by_coercion": {
                    "__doc__": "\n                Default implementation of product for realizations.\n\n                This method coerces to the realization specified by\n                ``self.realization_of().a_realization()``, computes\n                the product in that realization, and then coerces\n                back.\n\n                EXAMPLES::\n\n                    sage: Out = Sets().WithRealizations().example().Out(); Out\n                    The subset algebra of {1, 2, 3} over Rational Field in the Out basis\n                    sage: Out.product\n                    <bound method SubsetAlgebra.Out_with_category.product_by_coercion of The subset algebra of {1, 2, 3} over Rational Field in the Out basis>\n                    sage: Out.product.__module__\n                    'sage.categories.magmas'\n                    sage: x = Out.an_element()\n                    sage: y = Out.an_element()\n                    sage: Out.product(x, y)\n                    Out[{}] + 4*Out[{1}] + 9*Out[{2}] + Out[{1, 2}]\n\n                ",
                    "args": [
                        "self",
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Unital",
            "Inverse",
            "Associative",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "mmt.Unital.GAP",
            "sage.categories.groups.Groups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.Groups.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of left modules\n    left modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with left multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: LeftModules(ZZ)\n        Category of left modules over Integer Ring\n        sage: LeftModules(ZZ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(LeftModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of left modules\n    left modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with left multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: LeftModules(ZZ)\n        Category of left modules over Integer Ring\n        sage: LeftModules(ZZ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(LeftModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.left_modules.LeftModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.sets_cat.Sets.WithRealizations"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.monoids.Monoids.WithRealizations",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.graded_algebras.GradedAlgebras",
            "sage.categories.super_modules.SuperModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.super_algebras.SuperAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.super_modules.SuperModules"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of additive monoids.\n\n    An *additive monoid* is a unital :class:`additive semigroup\n    <sage.categories.additive_semigroups.AdditiveSemigroups>`, that\n    is a set endowed with a binary operation `+` which is associative\n    and admits a zero (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_monoids import AdditiveMonoids\n        sage: C = AdditiveMonoids(); C\n        Category of additive monoids\n        sage: C.super_categories()\n        [Category of additive unital additive magmas, Category of additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveUnital']\n        sage: from sage.categories.additive_semigroups import AdditiveSemigroups\n        sage: C is AdditiveSemigroups().AdditiveUnital()\n        True\n\n    TESTS::\n\n        sage: C.Algebras(QQ).is_subcategory(AlgebrasWithBasis(QQ))\n        True\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveAssociative",
            "AdditiveUnital"
        ],
        "element_class": {
            "__doc__": "\n    The category of additive monoids.\n\n    An *additive monoid* is a unital :class:`additive semigroup\n    <sage.categories.additive_semigroups.AdditiveSemigroups>`, that\n    is a set endowed with a binary operation `+` which is associative\n    and admits a zero (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_monoids import AdditiveMonoids\n        sage: C = AdditiveMonoids(); C\n        Category of additive monoids\n        sage: C.super_categories()\n        [Category of additive unital additive magmas, Category of additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveUnital']\n        sage: from sage.categories.additive_semigroups import AdditiveSemigroups\n        sage: C is AdditiveSemigroups().AdditiveUnital()\n        True\n\n    TESTS::\n\n        sage: C.Algebras(QQ).is_subcategory(AlgebrasWithBasis(QQ))\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_semigroups.AdditiveSemigroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of additive monoids.\n\n    An *additive monoid* is a unital :class:`additive semigroup\n    <sage.categories.additive_semigroups.AdditiveSemigroups>`, that\n    is a set endowed with a binary operation `+` which is associative\n    and admits a zero (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_monoids import AdditiveMonoids\n        sage: C = AdditiveMonoids(); C\n        Category of additive monoids\n        sage: C.super_categories()\n        [Category of additive unital additive magmas, Category of additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveUnital']\n        sage: from sage.categories.additive_semigroups import AdditiveSemigroups\n        sage: C is AdditiveSemigroups().AdditiveUnital()\n        True\n\n    TESTS::\n\n        sage: C.Algebras(QQ).is_subcategory(AlgebrasWithBasis(QQ))\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.additive_monoids.AdditiveMonoids",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "sum": {
                    "__doc__": "\n            Return the sum of the elements in ``args``, as an element\n            of ``self``.\n\n            INPUT:\n\n            - ``args`` -- a list (or iterable) of elements of ``self``\n\n            EXAMPLES::\n\n                sage: S = CommutativeAdditiveMonoids().example()\n                sage: (a,b,c,d) = S.additive_semigroup_generators()\n                sage: S.sum((a,b,a,c,a,b))\n                3*a + c + 2*b\n                sage: S.sum(())\n                0\n                sage: S.sum(()).parent() == S\n                True\n            ",
                    "args": [
                        "self",
                        "args"
                    ],
                    "argspec": [
                        [
                            "self",
                            "args"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of additive monoids.\n\n    An *additive monoid* is a unital :class:`additive semigroup\n    <sage.categories.additive_semigroups.AdditiveSemigroups>`, that\n    is a set endowed with a binary operation `+` which is associative\n    and admits a zero (see :wikipedia:`Monoid`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_monoids import AdditiveMonoids\n        sage: C = AdditiveMonoids(); C\n        Category of additive monoids\n        sage: C.super_categories()\n        [Category of additive unital additive magmas, Category of additive semigroups]\n        sage: sorted(C.axioms())\n        ['AdditiveAssociative', 'AdditiveUnital']\n        sage: from sage.categories.additive_semigroups import AdditiveSemigroups\n        sage: C is AdditiveSemigroups().AdditiveUnital()\n        True\n\n    TESTS::\n\n        sage: C.Algebras(QQ).is_subcategory(AlgebrasWithBasis(QQ))\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules with basis constructed by tensor product of\n        modules with basis.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of modules\n            with basis.\n            ",
            "methods": {
                "apply_multilinear_morphism": {
                    "__doc__": "\n                Return the result of applying the morphism induced by ``f``\n                to ``self``.\n\n                INPUT:\n\n                - ``f`` -- a multilinear morphism from the component\n                  modules of the parent tensor product to any module\n\n                - ``codomain`` -- the codomain of ``f`` (optional)\n\n                By the universal property of the tensor product, ``f``\n                induces a linear morphism from `self.parent()` to the\n                target module. Returns the result of applying that\n                morphism to ``self``.\n\n                The codomain is used for optimizations purposes\n                only. If it's not provided, it's recovered by calling\n                ``f`` on the zero input.\n\n                EXAMPLES:\n\n                We start with simple (admittedly not so interesting)\n                examples, with two modules `A` and `B`::\n\n                    sage: A = CombinatorialFreeModule(ZZ, [1,2], prefix=\"A\"); A.rename(\"A\")\n                    sage: B = CombinatorialFreeModule(ZZ, [3,4], prefix=\"B\"); B.rename(\"B\")\n\n                and `f` the bilinear morphism `(a,b) \\mapsto b \\otimes a`\n                from `A \\times B` to `B \\otimes A`::\n\n                    sage: def f(a,b):\n                    ....:     return tensor([b,a])\n\n                Now, calling applying `f` on `a \\otimes b` returns the same\n                as `f(a,b)`::\n\n                    sage: a = A.monomial(1) + 2 * A.monomial(2); a\n                    A[1] + 2*A[2]\n                    sage: b = B.monomial(3) - 2 * B.monomial(4); b\n                    B[3] - 2*B[4]\n                    sage: f(a,b)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n\n                `f` may be a bilinear morphism to any module over the\n                base ring of `A` and `B`. Here the codomain is `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients(), 0) * sum(b.coefficients(), 0)\n                    sage: f(a,b)\n                    -3\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    -3\n\n                Mind the `0` in the sums above; otherwise `f` would\n                not return `0` in `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients()) * sum(b.coefficients())\n                    sage: type(f(A.zero(), B.zero()))\n                    <type 'int'>\n\n                Which would be wrong and break this method::\n\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    Traceback (most recent call last):\n                    ...\n                    AttributeError: 'int' object has no attribute 'parent'\n\n                Here we consider an example where the codomain is a\n                module with basis with a different base ring::\n\n                    sage: C = CombinatorialFreeModule(QQ, [(1,3),(2,4)], prefix=\"C\"); C.rename(\"C\")\n                    sage: def f(a,b):\n                    ....:     return C.sum_of_terms( [((1,3), QQ(a[1]*b[3])), ((2,4), QQ(a[2]*b[4]))] )\n                    sage: f(a,b)\n                    C[(1, 3)] - 4*C[(2, 4)]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    C[(1, 3)] - 4*C[(2, 4)]\n\n                 We conclude with a real life application, where we\n                 check that the antipode of the Hopf algebra of\n                 Symmetric functions on the Schur basis satisfies its\n                 defining formula::\n\n                    sage: Sym = SymmetricFunctions(QQ)\n                    sage: s = Sym.schur()\n                    sage: def f(a,b): return a*b.antipode()\n                    sage: x = 4*s.an_element(); x\n                    8*s[] + 8*s[1] + 12*s[2]\n                    sage: x.coproduct().apply_multilinear_morphism(f)\n                    8*s[]\n                    sage: x.coproduct().apply_multilinear_morphism(f) == x.counit()\n                    True\n\n                We recover the constant term of `x`, as desired.\n\n                .. TODO::\n\n                    Extract a method to linearize a multilinear\n                    morphism, and delegate the work there.\n                ",
                    "args": [
                        "self",
                        "f",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "codomain"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.modules.Modules.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules with basis constructed by tensor product of\n        modules with basis.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts",
        "parent_class": {
            "__doc__": "\n            Implements operations on tensor products of modules with basis.\n            ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of modules\n            with basis.\n            ",
            "methods": {
                "apply_multilinear_morphism": {
                    "__doc__": "\n                Return the result of applying the morphism induced by ``f``\n                to ``self``.\n\n                INPUT:\n\n                - ``f`` -- a multilinear morphism from the component\n                  modules of the parent tensor product to any module\n\n                - ``codomain`` -- the codomain of ``f`` (optional)\n\n                By the universal property of the tensor product, ``f``\n                induces a linear morphism from `self.parent()` to the\n                target module. Returns the result of applying that\n                morphism to ``self``.\n\n                The codomain is used for optimizations purposes\n                only. If it's not provided, it's recovered by calling\n                ``f`` on the zero input.\n\n                EXAMPLES:\n\n                We start with simple (admittedly not so interesting)\n                examples, with two modules `A` and `B`::\n\n                    sage: A = CombinatorialFreeModule(ZZ, [1,2], prefix=\"A\"); A.rename(\"A\")\n                    sage: B = CombinatorialFreeModule(ZZ, [3,4], prefix=\"B\"); B.rename(\"B\")\n\n                and `f` the bilinear morphism `(a,b) \\mapsto b \\otimes a`\n                from `A \\times B` to `B \\otimes A`::\n\n                    sage: def f(a,b):\n                    ....:     return tensor([b,a])\n\n                Now, calling applying `f` on `a \\otimes b` returns the same\n                as `f(a,b)`::\n\n                    sage: a = A.monomial(1) + 2 * A.monomial(2); a\n                    A[1] + 2*A[2]\n                    sage: b = B.monomial(3) - 2 * B.monomial(4); b\n                    B[3] - 2*B[4]\n                    sage: f(a,b)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n\n                `f` may be a bilinear morphism to any module over the\n                base ring of `A` and `B`. Here the codomain is `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients(), 0) * sum(b.coefficients(), 0)\n                    sage: f(a,b)\n                    -3\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    -3\n\n                Mind the `0` in the sums above; otherwise `f` would\n                not return `0` in `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients()) * sum(b.coefficients())\n                    sage: type(f(A.zero(), B.zero()))\n                    <type 'int'>\n\n                Which would be wrong and break this method::\n\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    Traceback (most recent call last):\n                    ...\n                    AttributeError: 'int' object has no attribute 'parent'\n\n                Here we consider an example where the codomain is a\n                module with basis with a different base ring::\n\n                    sage: C = CombinatorialFreeModule(QQ, [(1,3),(2,4)], prefix=\"C\"); C.rename(\"C\")\n                    sage: def f(a,b):\n                    ....:     return C.sum_of_terms( [((1,3), QQ(a[1]*b[3])), ((2,4), QQ(a[2]*b[4]))] )\n                    sage: f(a,b)\n                    C[(1, 3)] - 4*C[(2, 4)]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    C[(1, 3)] - 4*C[(2, 4)]\n\n                 We conclude with a real life application, where we\n                 check that the antipode of the Hopf algebra of\n                 Symmetric functions on the Schur basis satisfies its\n                 defining formula::\n\n                    sage: Sym = SymmetricFunctions(QQ)\n                    sage: s = Sym.schur()\n                    sage: def f(a,b): return a*b.antipode()\n                    sage: x = 4*s.an_element(); x\n                    8*s[] + 8*s[1] + 12*s[2]\n                    sage: x.coproduct().apply_multilinear_morphism(f)\n                    8*s[]\n                    sage: x.coproduct().apply_multilinear_morphism(f) == x.counit()\n                    True\n\n                We recover the constant term of `x`, as desired.\n\n                .. TODO::\n\n                    Extract a method to linearize a multilinear\n                    morphism, and delegate the work there.\n                ",
                    "args": [
                        "self",
                        "f",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "codomain"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "__div__": {
                    "__doc__": "__truediv__(left, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 248)\n\n    Return the result of the division of ``left`` by ``right``, if possible.\n\n    This top-level implementation delegates the work to\n    the ``_div_`` method if ``left`` and ``right`` have\n    the same parent and to coercion otherwise. See the\n    extensive documentation at the top of\n    :ref:`sage.structure.element`.\n\n    INPUT:\n\n    - ``self`` -- an element of a :class:`unital magma <Magmas.Unital>`\n    - ``right`` -- an object\n\n    .. SEEALSO:: :meth:`Magmas.Unital.ElementMethods._div_`\n\n    EXAMPLES::\n\n        sage: G = FreeGroup(2)\n        sage: x0, x1 = G.group_generators()\n        sage: c1 = cartesian_product([x0, x1])\n        sage: c2 = cartesian_product([x1, x0])\n        sage: c1.__div__(c2)\n        (x0*x1^-1, x1*x0^-1)\n        sage: c1 / c2\n        (x0*x1^-1, x1*x0^-1)\n\n    Division supports coercion::\n\n        sage: C = cartesian_product([G, G])\n        sage: H = Hom(G, C)\n        sage: phi = H(lambda g: cartesian_product([g, g]))\n        sage: phi.register_as_coercion()\n        sage: x1 / c1\n        (x1*x0^-1, 1)\n        sage: c1 / x1\n        (x0*x1^-1, 1)\n\n    Depending on how the division itself is implemented in\n    ``_div_``, division may fail even when ``right``\n    actually divides ``left``::\n\n        sage: x = cartesian_product([2, 1])\n        sage: y = cartesian_product([1, 1])\n        sage: x / y\n        (2, 1)\n        sage: x / x\n        Traceback (most recent call last):\n        ...\n        TypeError: no conversion of this rational to integer\n\n    This is :meth:`Magmas.Unital.ElementMethods.__truediv__`, implemented\n    as a Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__truediv__.im_func is Magmas.Unital.ElementMethods.__truediv__.im_func\n        True\n        sage: x.__truediv__.im_func is sage.categories.coercion_methods.__truediv__\n        True\n    ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__invert__": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method __invert__ at 0x7fe45111b320>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "Inverse",
                    "mmt_name": "inverse"
                },
                "__truediv__": {
                    "__doc__": "__truediv__(left, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 248)\n\n    Return the result of the division of ``left`` by ``right``, if possible.\n\n    This top-level implementation delegates the work to\n    the ``_div_`` method if ``left`` and ``right`` have\n    the same parent and to coercion otherwise. See the\n    extensive documentation at the top of\n    :ref:`sage.structure.element`.\n\n    INPUT:\n\n    - ``self`` -- an element of a :class:`unital magma <Magmas.Unital>`\n    - ``right`` -- an object\n\n    .. SEEALSO:: :meth:`Magmas.Unital.ElementMethods._div_`\n\n    EXAMPLES::\n\n        sage: G = FreeGroup(2)\n        sage: x0, x1 = G.group_generators()\n        sage: c1 = cartesian_product([x0, x1])\n        sage: c2 = cartesian_product([x1, x0])\n        sage: c1.__div__(c2)\n        (x0*x1^-1, x1*x0^-1)\n        sage: c1 / c2\n        (x0*x1^-1, x1*x0^-1)\n\n    Division supports coercion::\n\n        sage: C = cartesian_product([G, G])\n        sage: H = Hom(G, C)\n        sage: phi = H(lambda g: cartesian_product([g, g]))\n        sage: phi.register_as_coercion()\n        sage: x1 / c1\n        (x1*x0^-1, 1)\n        sage: c1 / x1\n        (x0*x1^-1, 1)\n\n    Depending on how the division itself is implemented in\n    ``_div_``, division may fail even when ``right``\n    actually divides ``left``::\n\n        sage: x = cartesian_product([2, 1])\n        sage: y = cartesian_product([1, 1])\n        sage: x / y\n        (2, 1)\n        sage: x / x\n        Traceback (most recent call last):\n        ...\n        TypeError: no conversion of this rational to integer\n\n    This is :meth:`Magmas.Unital.ElementMethods.__truediv__`, implemented\n    as a Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__truediv__.im_func is Magmas.Unital.ElementMethods.__truediv__.im_func\n        True\n        sage: x.__truediv__.im_func is sage.categories.coercion_methods.__truediv__\n        True\n    ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_div_": {
                    "__doc__": "\n                Default implementation of division, multiplying (on the right) by the inverse.\n\n                INPUT:\n\n                - ``left``, ``right`` -- two elements of the same unital magma\n\n                .. SEEALSO:: :meth:`__div__`\n\n                EXAMPLES::\n\n                    sage: G = FreeGroup(2)\n                    sage: x0, x1 = G.group_generators()\n                    sage: c1 = cartesian_product([x0, x1])\n                    sage: c2 = cartesian_product([x1, x0])\n                    sage: c1._div_(c2)\n                    (x0*x1^-1, x1*x0^-1)\n\n                With this implementation, division will fail as soon\n                as ``right`` is not invertible, even if ``right``\n                actually divides ``left``::\n\n                    sage: x = cartesian_product([2, 1])\n                    sage: y = cartesian_product([1, 1])\n                    sage: x / y\n                    (2, 1)\n                    sage: x / x\n                    Traceback (most recent call last):\n                    ...\n                    TypeError: no conversion of this rational to integer\n\n                TESTS::\n\n                    sage: c1._div_.__module__\n                    'sage.categories.magmas'\n                ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas"
        ],
        "mmt": "NeutralElement",
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Unital",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_one": {
                    "__doc__": "\n                Test that ``self.one()`` is an element of ``self`` and is\n                neutral for the operation ``*``.\n\n                INPUT:\n\n                - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n                EXAMPLES:\n\n                By default, this method tests only the elements returned by\n                ``self.some_elements()``::\n\n                    sage: S = Monoids().example()\n                    sage: S._test_one()\n\n                However, the elements tested can be customized with the\n                ``elements`` keyword argument::\n\n                    sage: S._test_one(elements = (S('a'), S('b')))\n\n                See the documentation for :class:`TestSuite` for more information.\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "is_empty": {
                    "__doc__": "\n                Return whether ``self`` is empty.\n\n                Since this set is a unital magma it is not empty and this method\n                always return ``False``.\n\n                EXAMPLES::\n\n                    sage: S = SymmetricGroup(2)\n                    sage: S.is_empty()\n                    False\n\n                    sage: M = Monoids().example()\n                    sage: M.is_empty()\n                    False\n\n                TESTS::\n\n                    sage: S.is_empty.__module__\n                    'sage.categories.magmas'\n                    sage: M.is_empty.__module__\n                    'sage.categories.magmas'\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "one": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method one at 0x7fe452dfe848>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "self",
                    "gap_name": "One",
                    "mmt_name": "neutral"
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "__div__": {
                    "__doc__": "__truediv__(left, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 248)\n\n    Return the result of the division of ``left`` by ``right``, if possible.\n\n    This top-level implementation delegates the work to\n    the ``_div_`` method if ``left`` and ``right`` have\n    the same parent and to coercion otherwise. See the\n    extensive documentation at the top of\n    :ref:`sage.structure.element`.\n\n    INPUT:\n\n    - ``self`` -- an element of a :class:`unital magma <Magmas.Unital>`\n    - ``right`` -- an object\n\n    .. SEEALSO:: :meth:`Magmas.Unital.ElementMethods._div_`\n\n    EXAMPLES::\n\n        sage: G = FreeGroup(2)\n        sage: x0, x1 = G.group_generators()\n        sage: c1 = cartesian_product([x0, x1])\n        sage: c2 = cartesian_product([x1, x0])\n        sage: c1.__div__(c2)\n        (x0*x1^-1, x1*x0^-1)\n        sage: c1 / c2\n        (x0*x1^-1, x1*x0^-1)\n\n    Division supports coercion::\n\n        sage: C = cartesian_product([G, G])\n        sage: H = Hom(G, C)\n        sage: phi = H(lambda g: cartesian_product([g, g]))\n        sage: phi.register_as_coercion()\n        sage: x1 / c1\n        (x1*x0^-1, 1)\n        sage: c1 / x1\n        (x0*x1^-1, 1)\n\n    Depending on how the division itself is implemented in\n    ``_div_``, division may fail even when ``right``\n    actually divides ``left``::\n\n        sage: x = cartesian_product([2, 1])\n        sage: y = cartesian_product([1, 1])\n        sage: x / y\n        (2, 1)\n        sage: x / x\n        Traceback (most recent call last):\n        ...\n        TypeError: no conversion of this rational to integer\n\n    This is :meth:`Magmas.Unital.ElementMethods.__truediv__`, implemented\n    as a Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__truediv__.im_func is Magmas.Unital.ElementMethods.__truediv__.im_func\n        True\n        sage: x.__truediv__.im_func is sage.categories.coercion_methods.__truediv__\n        True\n    ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__invert__": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method __invert__ at 0x7fe45111b320>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "parent",
                    "gap_name": "Inverse",
                    "mmt_name": "inverse"
                },
                "__truediv__": {
                    "__doc__": "__truediv__(left, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 248)\n\n    Return the result of the division of ``left`` by ``right``, if possible.\n\n    This top-level implementation delegates the work to\n    the ``_div_`` method if ``left`` and ``right`` have\n    the same parent and to coercion otherwise. See the\n    extensive documentation at the top of\n    :ref:`sage.structure.element`.\n\n    INPUT:\n\n    - ``self`` -- an element of a :class:`unital magma <Magmas.Unital>`\n    - ``right`` -- an object\n\n    .. SEEALSO:: :meth:`Magmas.Unital.ElementMethods._div_`\n\n    EXAMPLES::\n\n        sage: G = FreeGroup(2)\n        sage: x0, x1 = G.group_generators()\n        sage: c1 = cartesian_product([x0, x1])\n        sage: c2 = cartesian_product([x1, x0])\n        sage: c1.__div__(c2)\n        (x0*x1^-1, x1*x0^-1)\n        sage: c1 / c2\n        (x0*x1^-1, x1*x0^-1)\n\n    Division supports coercion::\n\n        sage: C = cartesian_product([G, G])\n        sage: H = Hom(G, C)\n        sage: phi = H(lambda g: cartesian_product([g, g]))\n        sage: phi.register_as_coercion()\n        sage: x1 / c1\n        (x1*x0^-1, 1)\n        sage: c1 / x1\n        (x0*x1^-1, 1)\n\n    Depending on how the division itself is implemented in\n    ``_div_``, division may fail even when ``right``\n    actually divides ``left``::\n\n        sage: x = cartesian_product([2, 1])\n        sage: y = cartesian_product([1, 1])\n        sage: x / y\n        (2, 1)\n        sage: x / x\n        Traceback (most recent call last):\n        ...\n        TypeError: no conversion of this rational to integer\n\n    This is :meth:`Magmas.Unital.ElementMethods.__truediv__`, implemented\n    as a Cython method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__truediv__.im_func is Magmas.Unital.ElementMethods.__truediv__.im_func\n        True\n        sage: x.__truediv__.im_func is sage.categories.coercion_methods.__truediv__\n        True\n    ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_div_": {
                    "__doc__": "\n                Default implementation of division, multiplying (on the right) by the inverse.\n\n                INPUT:\n\n                - ``left``, ``right`` -- two elements of the same unital magma\n\n                .. SEEALSO:: :meth:`__div__`\n\n                EXAMPLES::\n\n                    sage: G = FreeGroup(2)\n                    sage: x0, x1 = G.group_generators()\n                    sage: c1 = cartesian_product([x0, x1])\n                    sage: c2 = cartesian_product([x1, x0])\n                    sage: c1._div_(c2)\n                    (x0*x1^-1, x1*x0^-1)\n\n                With this implementation, division will fail as soon\n                as ``right`` is not invertible, even if ``right``\n                actually divides ``left``::\n\n                    sage: x = cartesian_product([2, 1])\n                    sage: y = cartesian_product([1, 1])\n                    sage: x / y\n                    (2, 1)\n                    sage: x / x\n                    Traceback (most recent call last):\n                    ...\n                    TypeError: no conversion of this rational to integer\n\n                TESTS::\n\n                    sage: c1._div_.__module__\n                    'sage.categories.magmas'\n                ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Finite",
            "Associative",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_semigroups.FiniteSemigroups",
            "mmt.Semigroups.GAP",
            "mmt.Finite.GAP"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.Finite.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.homsets.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.modular_abelian_varieties.ModularAbelianVarieties.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.homsets.Homsets",
            "sage.categories.modular_abelian_varieties.ModularAbelianVarieties.Homsets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.monoids.Monoids.Subquotients",
            "sage.categories.semigroups.Semigroups.Quotients"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.Quotients",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets.Quotients",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        A category for subquotients of sets.\n\n        .. SEEALSO:: :meth:`Sets().Subquotients`\n\n        EXAMPLES::\n\n            sage: Sets().Subquotients()\n            Category of subquotients of sets\n            sage: Sets().Subquotients().all_super_categories()\n            [Category of subquotients of sets, Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {
                "lift": {
                    "__doc__": "\n                Lift ``self`` to the ambient space for its parent.\n\n                EXAMPLES::\n\n                    sage: S = Semigroups().Subquotients().example()\n                    sage: s = S.an_element()\n                    sage: s, s.parent()\n                    (42, An example of a (sub)quotient semigroup: a quotient of the left zero semigroup)\n                    sage: S.lift(s), S.lift(s).parent()\n                    (42, An example of a semigroup: the left zero semigroup)\n                    sage: s.lift(), s.lift().parent()\n                    (42, An example of a semigroup: the left zero semigroup)\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        A category for subquotients of sets.\n\n        .. SEEALSO:: :meth:`Sets().Subquotients`\n\n        EXAMPLES::\n\n            sage: Sets().Subquotients()\n            Category of subquotients of sets\n            sage: Sets().Subquotients().all_super_categories()\n            [Category of subquotients of sets, Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "name": "sage.categories.sets_cat.Sets.Subquotients",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_repr_": {
                    "__doc__": "\n                EXAMPLES::\n\n                    sage: from sage.categories.examples.semigroups import IncompleteSubquotientSemigroup\n                    sage: S = IncompleteSubquotientSemigroup()\n                    sage: S._repr_()\n                    'A subquotient of An example of a semigroup: the left zero semigroup'\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "ambient": {
                    "__doc__": "\n                Return the ambient space for ``self``.\n\n                EXAMPLES::\n\n                    sage: Semigroups().Subquotients().example().ambient()\n                    An example of a semigroup: the left zero semigroup\n\n                .. SEEALSO::\n\n                    :meth:`Sets.SubcategoryMethods.Subquotients` for the\n                    specifications and :meth:`.lift` and :meth:`.retract`.\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "lift": {
                    "__doc__": "\n                Lift `x` to the ambient space for ``self``.\n\n                INPUT:\n\n                - ``x`` -- an element of ``self``\n\n                EXAMPLES::\n\n                    sage: S = Semigroups().Subquotients().example()\n                    sage: s = S.an_element()\n                    sage: s, s.parent()\n                    (42, An example of a (sub)quotient semigroup: a quotient of the left zero semigroup)\n                    sage: S.lift(s), S.lift(s).parent()\n                    (42, An example of a semigroup: the left zero semigroup)\n                    sage: s.lift(), s.lift().parent()\n                    (42, An example of a semigroup: the left zero semigroup)\n\n                .. SEEALSO::\n\n                    :class:`Sets.SubcategoryMethods.Subquotients` for\n                    the specifications, :meth:`.ambient`, :meth:`.retract`,\n                    and also :meth:`Sets.Subquotients.ElementMethods.lift`.\n                ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "retract": {
                    "__doc__": "\n                Retract ``x`` to ``self``.\n\n                INPUT:\n\n                - ``x`` -- an element of the ambient space for ``self``\n\n                .. SEEALSO::\n\n                    :class:`Sets.SubcategoryMethods.Subquotients` for\n                    the specifications, :meth:`.ambient`, :meth:`.retract`,\n                    and also :meth:`Sets.Subquotients.ElementMethods.retract`.\n\n                EXAMPLES::\n\n                    sage: S = Semigroups().Subquotients().example()\n                    sage: s = S.ambient().an_element()\n                    sage: s, s.parent()\n                    (42, An example of a semigroup: the left zero semigroup)\n                    sage: S.retract(s), S.retract(s).parent()\n                    (42, An example of a (sub)quotient semigroup: a quotient of the left zero semigroup)\n                ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "lift": {
                    "__doc__": "\n                Lift ``self`` to the ambient space for its parent.\n\n                EXAMPLES::\n\n                    sage: S = Semigroups().Subquotients().example()\n                    sage: s = S.an_element()\n                    sage: s, s.parent()\n                    (42, An example of a (sub)quotient semigroup: a quotient of the left zero semigroup)\n                    sage: S.lift(s), S.lift(s).parent()\n                    (42, An example of a semigroup: the left zero semigroup)\n                    sage: s.lift(), s.lift().parent()\n                    (42, An example of a semigroup: the left zero semigroup)\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.enumerated_sets.EnumeratedSets",
            "mmt.Sets.GAP"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.EnumeratedSets.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets",
            "sage.categories.finite_sets.FiniteSets.Subquotients",
            "sage.categories.sets_cat.Sets.IsomorphicObjects"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.IsomorphicObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets.IsomorphicObjects",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.sets_cat.Sets.Quotients",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Subobjects"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        TESTS::\n\n            sage: TestSuite(HeckeModules(ZZ).Homsets()).run()\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        TESTS::\n\n            sage: TestSuite(HeckeModules(ZZ).Homsets()).run()\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces",
            "sage.categories.homsets.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        TESTS::\n\n            sage: TestSuite(HeckeModules(ZZ).Homsets()).run()\n        ",
            "methods": {}
        },
        "name": "sage.categories.hecke_modules.HeckeModules.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hecke_modules.HeckeModules.Homsets",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n        TESTS::\n\n            sage: TestSuite(HeckeModules(ZZ).Homsets()).run()\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Connected",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis",
            "sage.categories.filtered_modules.FilteredModules.Connected"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis.Connected",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.category.JoinCategory"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis.WithRealizations",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        A category for isomorphic objects of sets.\n\n        EXAMPLES::\n\n            sage: Sets().IsomorphicObjects()\n            Category of isomorphic objects of sets\n            sage: Sets().IsomorphicObjects().all_super_categories()\n            [Category of isomorphic objects of sets,\n             Category of subobjects of sets, Category of quotients of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n        A category for isomorphic objects of sets.\n\n        EXAMPLES::\n\n            sage: Sets().IsomorphicObjects()\n            Category of isomorphic objects of sets\n            sage: Sets().IsomorphicObjects().all_super_categories()\n            [Category of isomorphic objects of sets,\n             Category of subobjects of sets, Category of quotients of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets.Subobjects",
            "sage.categories.sets_cat.Sets.Quotients"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        A category for isomorphic objects of sets.\n\n        EXAMPLES::\n\n            sage: Sets().IsomorphicObjects()\n            Category of isomorphic objects of sets\n            sage: Sets().IsomorphicObjects().all_super_categories()\n            [Category of isomorphic objects of sets,\n             Category of subobjects of sets, Category of quotients of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "name": "sage.categories.sets_cat.Sets.IsomorphicObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets.IsomorphicObjects",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.sets_cat.Sets.Quotients",
            "sage.categories.sets_cat.Sets.Subobjects",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n        A category for isomorphic objects of sets.\n\n        EXAMPLES::\n\n            sage: Sets().IsomorphicObjects()\n            Category of isomorphic objects of sets\n            sage: Sets().IsomorphicObjects().all_super_categories()\n            [Category of isomorphic objects of sets,\n             Category of subobjects of sets, Category of quotients of sets,\n             Category of subquotients of sets,\n             Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.CartesianProducts",
            "sage.categories.monoids.Monoids.CartesianProducts",
            "sage.categories.modules.Modules.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.CartesianProducts",
        "parent_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "JTrivial"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.JTrivial",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.algebras.Algebras.CartesianProducts",
            "sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
            "methods": {}
        },
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "one_from_cartesian_product_of_one_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "FiniteDimensional",
            "AdditiveCommutative",
            "WithBasis"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.finite_sets.FiniteSets.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.Algebras"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite Coxeter groups.\n\n    EXAMPLES::\n\n        sage: CoxeterGroups.Finite()\n        Category of finite coxeter groups\n        sage: FiniteCoxeterGroups().super_categories()\n        [Category of finite generalized coxeter groups,\n         Category of coxeter groups]\n\n        sage: G = CoxeterGroups().Finite().example()\n        sage: G.cayley_graph(side = \"right\").plot()\n        Graphics object consisting of 40 graphics primitives\n\n    Here are some further examples::\n\n        sage: WeylGroups().Finite().example()\n        The symmetric group on {0, ..., 3}\n\n        sage: WeylGroup([\"B\", 3])\n        Weyl Group of type ['B', 3] (as a matrix group acting on the ambient space)\n\n    Those other examples will eventually be also in this category::\n\n        sage: SymmetricGroup(4)\n        Symmetric group of order 4! as a permutation group\n        sage: DihedralGroup(5)\n        Dihedral group of order 10 as a permutation group\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "FinitelyGeneratedAsMagma",
            "Unital",
            "Finite",
            "WellGenerated"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "coxeter_knuth_graph": {
                    "__doc__": "\n            Return the Coxeter-Knuth graph of type `A`.\n\n            The Coxeter-Knuth graph of type `A` is generated by the Coxeter-Knuth relations which are\n            given by `a a+1 a \\sim a+1 a a+1`, `abc \\sim acb` if `b<a<c` and `abc \\sim bac` if `a<c<b`.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',4], prefix='s')\n                sage: w = W.from_reduced_word([1,2,1,3,2])\n                sage: D = w.coxeter_knuth_graph()\n                sage: D.vertices()\n                [(1, 2, 1, 3, 2),\n                (1, 2, 3, 1, 2),\n                (2, 1, 2, 3, 2),\n                (2, 1, 3, 2, 3),\n                (2, 3, 1, 2, 3)]\n                sage: D.edges()\n                [((1, 2, 1, 3, 2), (1, 2, 3, 1, 2), None),\n                ((1, 2, 1, 3, 2), (2, 1, 2, 3, 2), None),\n                ((2, 1, 2, 3, 2), (2, 1, 3, 2, 3), None),\n                ((2, 1, 3, 2, 3), (2, 3, 1, 2, 3), None)]\n\n                sage: w = W.from_reduced_word([1,3])\n                sage: D = w.coxeter_knuth_graph()\n                sage: D.vertices()\n                [(1, 3), (3, 1)]\n                sage: D.edges()\n                []\n\n            TESTS::\n\n                sage: W = WeylGroup(['B',4], prefix='s')\n                sage: w = W.from_reduced_word([1,2])\n                sage: w.coxeter_knuth_graph()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: This has only been implemented in finite type A so far!\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coxeter_knuth_neighbor": {
                    "__doc__": "\n            Return the Coxeter-Knuth (oriented) neighbors of the reduced word `w` of ``self``.\n\n            INPUT:\n\n            - ``w`` -- reduced word of ``self``\n\n            The Coxeter-Knuth relations are given by `a a+1 a \\sim a+1 a a+1`, `abc \\sim acb`\n            if `b<a<c` and `abc \\sim bac` if `a<c<b`. This method returns all neighbors of\n            ``w`` under the Coxeter-Knuth relations oriented from left to right.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',4], prefix='s')\n                sage: word = [1,2,1,3,2]\n                sage: w = W.from_reduced_word(word)\n                sage: w.coxeter_knuth_neighbor(word)\n                {(1, 2, 3, 1, 2), (2, 1, 2, 3, 2)}\n\n                sage: word = [1,2,1,3,2,4,3]\n                sage: w = W.from_reduced_word(word)\n                sage: w.coxeter_knuth_neighbor(word)\n                {(1, 2, 1, 3, 4, 2, 3), (1, 2, 3, 1, 2, 4, 3), (2, 1, 2, 3, 2, 4, 3)}\n\n            TESTS::\n\n                sage: W = WeylGroup(['B',4], prefix='s')\n                sage: word = [1,2]\n                sage: w = W.from_reduced_word(word)\n                sage: w.coxeter_knuth_neighbor(word)\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: This has only been implemented in finite type A so far!\n            ",
                    "args": [
                        "self",
                        "w"
                    ],
                    "argspec": [
                        [
                            "self",
                            "w"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.generalized_coxeter_groups.GeneralizedCoxeterGroups.Finite",
            "sage.categories.coxeter_groups.CoxeterGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite Coxeter groups.\n\n    EXAMPLES::\n\n        sage: CoxeterGroups.Finite()\n        Category of finite coxeter groups\n        sage: FiniteCoxeterGroups().super_categories()\n        [Category of finite generalized coxeter groups,\n         Category of coxeter groups]\n\n        sage: G = CoxeterGroups().Finite().example()\n        sage: G.cayley_graph(side = \"right\").plot()\n        Graphics object consisting of 40 graphics primitives\n\n    Here are some further examples::\n\n        sage: WeylGroups().Finite().example()\n        The symmetric group on {0, ..., 3}\n\n        sage: WeylGroup([\"B\", 3])\n        Weyl Group of type ['B', 3] (as a matrix group acting on the ambient space)\n\n    Those other examples will eventually be also in this category::\n\n        sage: SymmetricGroup(4)\n        Symmetric group of order 4! as a permutation group\n        sage: DihedralGroup(5)\n        Dihedral group of order 10 as a permutation group\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_coxeter_groups.FiniteCoxeterGroups",
        "parent_class": {
            "__doc__": "\n        Ambiguity resolution: the implementation of ``some_elements``\n        is preferable to that of :class:`FiniteGroups`. The same holds\n        for ``__iter__``, although a breath first search would be more\n        natural; at least this maintains backward compatibility after\n        :trac:`13589`.\n\n        TESTS::\n\n            sage: W = FiniteCoxeterGroups().example(3)\n\n            sage: W.some_elements.__module__\n            'sage.categories.complex_reflection_or_generalized_coxeter_groups'\n            sage: W.__iter__.__module__\n            'sage.categories.coxeter_groups'\n\n            sage: W.some_elements()\n            [(1,), (2,), (), (1, 2)]\n            sage: list(W)\n            [(), (1,), (2,), (1, 2), (2, 1), (1, 2, 1)]\n        ",
            "methods": {
                "bruhat_poset": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "cambrian_lattice": {
                    "__doc__": "\n            Return the `c`-Cambrian lattice on delta sequences.\n\n            See :arxiv:`1503.00710` and :arxiv:`math/0611106`.\n\n            Delta sequences are certain 2-colored minimal factorizations\n            of ``c`` into reflections.\n\n            INPUT:\n\n            - ``c`` -- a standard Coxeter element in ``self``\n              (as a tuple, or as an element of ``self``)\n\n            - ``on_roots`` (optional, default ``False``) -- if\n              ``on_roots`` is ``True``, the lattice is realized on\n              roots rather than on reflections. In order for this to\n              work, the ElementMethod ``reflection_to_root`` must be\n              available.\n\n            EXAMPLES::\n\n                sage: CoxeterGroup([\"A\", 2]).cambrian_lattice((1,2))\n                Finite lattice containing 5 elements\n\n                sage: CoxeterGroup([\"B\", 2]).cambrian_lattice((1,2))\n                Finite lattice containing 6 elements\n\n                sage: CoxeterGroup([\"G\", 2]).cambrian_lattice((1,2))\n                Finite lattice containing 8 elements\n            ",
                    "args": [
                        "self",
                        "c",
                        "on_roots"
                    ],
                    "argspec": [
                        [
                            "self",
                            "c",
                            "on_roots"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "inversion_sequence": {
                    "__doc__": "\n            Return the inversion sequence corresponding to the ``word``\n            in indices of simple generators of ``self``.\n\n            If ``word`` corresponds to `[w_0,w_1,...w_k]`, the output is\n            `[w_0,w_0w_1w_0,\\ldots,w_0w_1\\cdots w_k \\cdots w_1 w_0]`.\n\n            INPUT:\n\n            - ``word`` -- a word in the indices of the simple\n              generators of ``self``.\n\n            EXAMPLES::\n\n                sage: CoxeterGroup([\"A\", 2]).inversion_sequence([1,2,1])\n                [\n                [-1  1]  [ 0 -1]  [ 1  0]\n                [ 0  1], [-1  0], [ 1 -1]\n                ]\n\n                sage: [t.reduced_word() for t in CoxeterGroup([\"A\",3]).inversion_sequence([2,1,3,2,1,3])]\n                [[2], [1, 2, 1], [2, 3, 2], [1, 2, 3, 2, 1], [3], [1]]\n\n            ",
                    "args": [
                        "self",
                        "word"
                    ],
                    "argspec": [
                        [
                            "self",
                            "word"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "long_element": {
                    "__doc__": "\n            Return the longest element of ``self``, or of the\n            parabolic subgroup corresponding to the given ``index_set``.\n\n            INPUT:\n\n            - ``index_set`` -- a subset (as a list or iterable) of the\n              nodes of the Dynkin diagram; (default: all of them)\n\n            - ``as_word`` -- boolean (default ``False``). If ``True``, then\n              return instead a reduced decomposition of the longest element.\n\n            Should this method be called maximal_element? longest_element?\n\n            EXAMPLES::\n\n                sage: D10 = FiniteCoxeterGroups().example(10)\n                sage: D10.long_element()\n                (1, 2, 1, 2, 1, 2, 1, 2, 1, 2)\n                sage: D10.long_element([1])\n                (1,)\n                sage: D10.long_element([2])\n                (2,)\n                sage: D10.long_element([])\n                ()\n\n                sage: D7 = FiniteCoxeterGroups().example(7)\n                sage: D7.long_element()\n                (1, 2, 1, 2, 1, 2, 1)\n\n            One can require instead a reduced word for w0::\n\n                sage: A3 = CoxeterGroup(['A', 3])\n                sage: A3.long_element(as_word=True)\n                [1, 2, 1, 3, 2, 1]\n            ",
                    "args": [
                        "self",
                        "index_set",
                        "as_word"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index_set",
                            "as_word"
                        ],
                        null,
                        null,
                        [
                            null,
                            false
                        ]
                    ]
                },
                "m_cambrian_lattice": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "reflections_from_w0": {
                    "__doc__": "\n            Return the reflections of ``self`` using the inversion set\n            of ``w_0``.\n\n            EXAMPLES::\n\n                sage: WeylGroup(['A',2]).reflections_from_w0()\n                [\n                [0 1 0]  [0 0 1]  [1 0 0]\n                [1 0 0]  [0 1 0]  [0 0 1]\n                [0 0 1], [1 0 0], [0 1 0]\n                ]\n\n                sage: WeylGroup(['A',3]).reflections_from_w0()\n                [\n                [0 1 0 0]  [0 0 1 0]  [1 0 0 0]  [0 0 0 1]  [1 0 0 0]  [1 0 0 0]\n                [1 0 0 0]  [0 1 0 0]  [0 0 1 0]  [0 1 0 0]  [0 0 0 1]  [0 1 0 0]\n                [0 0 1 0]  [1 0 0 0]  [0 1 0 0]  [0 0 1 0]  [0 0 1 0]  [0 0 0 1]\n                [0 0 0 1], [0 0 0 1], [0 0 0 1], [1 0 0 0], [0 1 0 0], [0 0 1 0]\n                ]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "weak_lattice": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "weak_poset": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "coxeter_knuth_graph": {
                    "__doc__": "\n            Return the Coxeter-Knuth graph of type `A`.\n\n            The Coxeter-Knuth graph of type `A` is generated by the Coxeter-Knuth relations which are\n            given by `a a+1 a \\sim a+1 a a+1`, `abc \\sim acb` if `b<a<c` and `abc \\sim bac` if `a<c<b`.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',4], prefix='s')\n                sage: w = W.from_reduced_word([1,2,1,3,2])\n                sage: D = w.coxeter_knuth_graph()\n                sage: D.vertices()\n                [(1, 2, 1, 3, 2),\n                (1, 2, 3, 1, 2),\n                (2, 1, 2, 3, 2),\n                (2, 1, 3, 2, 3),\n                (2, 3, 1, 2, 3)]\n                sage: D.edges()\n                [((1, 2, 1, 3, 2), (1, 2, 3, 1, 2), None),\n                ((1, 2, 1, 3, 2), (2, 1, 2, 3, 2), None),\n                ((2, 1, 2, 3, 2), (2, 1, 3, 2, 3), None),\n                ((2, 1, 3, 2, 3), (2, 3, 1, 2, 3), None)]\n\n                sage: w = W.from_reduced_word([1,3])\n                sage: D = w.coxeter_knuth_graph()\n                sage: D.vertices()\n                [(1, 3), (3, 1)]\n                sage: D.edges()\n                []\n\n            TESTS::\n\n                sage: W = WeylGroup(['B',4], prefix='s')\n                sage: w = W.from_reduced_word([1,2])\n                sage: w.coxeter_knuth_graph()\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: This has only been implemented in finite type A so far!\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coxeter_knuth_neighbor": {
                    "__doc__": "\n            Return the Coxeter-Knuth (oriented) neighbors of the reduced word `w` of ``self``.\n\n            INPUT:\n\n            - ``w`` -- reduced word of ``self``\n\n            The Coxeter-Knuth relations are given by `a a+1 a \\sim a+1 a a+1`, `abc \\sim acb`\n            if `b<a<c` and `abc \\sim bac` if `a<c<b`. This method returns all neighbors of\n            ``w`` under the Coxeter-Knuth relations oriented from left to right.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',4], prefix='s')\n                sage: word = [1,2,1,3,2]\n                sage: w = W.from_reduced_word(word)\n                sage: w.coxeter_knuth_neighbor(word)\n                {(1, 2, 3, 1, 2), (2, 1, 2, 3, 2)}\n\n                sage: word = [1,2,1,3,2,4,3]\n                sage: w = W.from_reduced_word(word)\n                sage: w.coxeter_knuth_neighbor(word)\n                {(1, 2, 1, 3, 4, 2, 3), (1, 2, 3, 1, 2, 4, 3), (2, 1, 2, 3, 2, 4, 3)}\n\n            TESTS::\n\n                sage: W = WeylGroup(['B',4], prefix='s')\n                sage: word = [1,2]\n                sage: w = W.from_reduced_word(word)\n                sage: w.coxeter_knuth_neighbor(word)\n                Traceback (most recent call last):\n                ...\n                NotImplementedError: This has only been implemented in finite type A so far!\n            ",
                    "args": [
                        "self",
                        "w"
                    ],
                    "argspec": [
                        [
                            "self",
                            "w"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of group algebras over a given base ring.\n\n        EXAMPLES::\n\n            sage: GroupAlgebras(IntegerRing())\n            Category of group algebras over Integer Ring\n            sage: GroupAlgebras(IntegerRing()).super_categories()\n            [Category of hopf algebras with basis over Integer Ring,\n             Category of monoid algebras over Integer Ring]\n\n        Here is how to create the group algebra of a group `G`::\n\n            sage: G = DihedralGroup(5)\n            sage: QG = G.algebra(QQ); QG\n            Group algebra of Dihedral group of order 10 as a permutation group over Rational Field\n\n        and an example of computation::\n\n            sage: g = G.an_element(); g\n            (1,2,3,4,5)\n            sage: (QG.term(g) + 1)**3\n            B[()] + 3*B[(1,2,3,4,5)] + 3*B[(1,3,5,2,4)] + B[(1,4,2,5,3)]\n\n        .. TODO::\n\n            - Check which methods would be better located in\n              ``Monoid.Algebras`` or ``Groups.Finite.Algebras``.\n\n        TESTS::\n\n            sage: A = GroupAlgebras(QQ).example(GL(3, GF(11)))\n            sage: A.one_basis()\n            [1 0 0]\n            [0 1 0]\n            [0 0 1]\n            sage: A = SymmetricGroupAlgebra(QQ,4)\n            sage: x = Permutation([4,3,2,1])\n            sage: A.product_on_basis(x,x)\n            [1, 2, 3, 4]\n\n            sage: C = GroupAlgebras(ZZ)\n            sage: TestSuite(C).run()\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "central_form": {
                    "__doc__": "\n                Return ``self`` expressed in the canonical basis of the center\n                of the group algebra.\n\n                INPUT:\n\n                - ``self`` -- an element of the center of the group algebra\n\n                OUTPUT:\n\n                - A formal linear combination of the conjugacy class\n                  representatives representing its coordinates in the\n                  canonical basis of the center. See\n                  :meth:`Groups.Algebras.ParentMethods.center_basis` for\n                  details.\n\n                .. WARNING::\n\n                    - This method requires the underlying group to\n                      have a method ``conjugacy_classes_representatives``\n                      (every permutation group has one, thanks GAP!).\n                    - This method does not check that the element is\n                      indeed central. Use the method\n                      :meth:`Monoids.Algebras.ElementMethods.is_central`\n                      for this purpose.\n                    - This function has a complexity linear in the\n                      number of conjugacy classes of the group. One\n                      could easily implement a function whose\n                      complexity is linear in the size of the support\n                      of ``self``.\n\n                EXAMPLES::\n\n                    sage: QS3 = SymmetricGroup(3).algebra(QQ)\n                    sage: A = QS3([2,3,1]) + QS3([3,1,2])\n                    sage: A.central_form()\n                    B[(1,2,3)]\n                    sage: QS4 = SymmetricGroup(4).algebra(QQ)\n                    sage: B = sum(len(s.cycle_type())*QS4(s) for s in Permutations(4))\n                    sage: B.central_form()\n                    4*B[()] + 3*B[(1,2)] + 2*B[(1,2)(3,4)] + 2*B[(1,2,3)] + B[(1,2,3,4)]\n\n                    sage: QG = GroupAlgebras(QQ).example(PermutationGroup([[(1,2,3),(4,5)],[(3,4)]]))\n                    sage: sum(i for i in QG.basis()).central_form()\n                    B[()] + B[(4,5)] + B[(3,4,5)] + B[(2,3)(4,5)] + B[(2,3,4,5)] + B[(1,2)(3,4,5)] + B[(1,2,3,4,5)]\n\n                .. SEEALSO::\n\n                    - :meth:`Groups.Algebras.ParentMethods.center_basis`\n                    - :meth:`Monoids.Algebras.ElementMethods.is_central`\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis",
            "sage.categories.monoids.Monoids.Algebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of group algebras over a given base ring.\n\n        EXAMPLES::\n\n            sage: GroupAlgebras(IntegerRing())\n            Category of group algebras over Integer Ring\n            sage: GroupAlgebras(IntegerRing()).super_categories()\n            [Category of hopf algebras with basis over Integer Ring,\n             Category of monoid algebras over Integer Ring]\n\n        Here is how to create the group algebra of a group `G`::\n\n            sage: G = DihedralGroup(5)\n            sage: QG = G.algebra(QQ); QG\n            Group algebra of Dihedral group of order 10 as a permutation group over Rational Field\n\n        and an example of computation::\n\n            sage: g = G.an_element(); g\n            (1,2,3,4,5)\n            sage: (QG.term(g) + 1)**3\n            B[()] + 3*B[(1,2,3,4,5)] + 3*B[(1,3,5,2,4)] + B[(1,4,2,5,3)]\n\n        .. TODO::\n\n            - Check which methods would be better located in\n              ``Monoid.Algebras`` or ``Groups.Finite.Algebras``.\n\n        TESTS::\n\n            sage: A = GroupAlgebras(QQ).example(GL(3, GF(11)))\n            sage: A.one_basis()\n            [1 0 0]\n            [0 1 0]\n            [0 0 1]\n            sage: A = SymmetricGroupAlgebra(QQ,4)\n            sage: x = Permutation([4,3,2,1])\n            sage: A.product_on_basis(x,x)\n            [1, 2, 3, 4]\n\n            sage: C = GroupAlgebras(ZZ)\n            sage: TestSuite(C).run()\n        ",
            "methods": {}
        },
        "name": "sage.categories.groups.Groups.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "center_basis": {
                    "__doc__": "\n                Return a basis of the center of the group algebra.\n\n                The canonical basis of the center of the group algebra\n                is the family `(f_\\sigma)_{\\sigma\\in C}`, where `C` is\n                any collection of representatives of the conjugacy\n                classes of the group, and `f_\\sigma` is the sum of the\n                elements in the conjugacy class of `\\sigma`.\n\n                OUTPUT:\n\n                - ``list`` of elements of ``self``\n\n                .. WARNING::\n\n                    - This method requires the underlying group to\n                      have a method ``conjugacy_classes``\n                      (every permutation group has one, thanks GAP!).\n\n                EXAMPLES::\n\n                    sage: SymmetricGroup(3).algebra(QQ).center_basis()\n                    [(), (2,3) + (1,2) + (1,3), (1,2,3) + (1,3,2)]\n\n                .. SEEALSO::\n\n                    - :meth:`Groups.Algebras.ElementMethods.central_form`\n                    - :meth:`Monoids.Algebras.ElementMethods.is_central`\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "group": {
                    "__doc__": "\n                Return the underlying group of the group algebra.\n\n                EXAMPLES::\n\n                    sage: GroupAlgebras(QQ).example(GL(3, GF(11))).group()\n                    General Linear Group of degree 3 over Finite Field of size 11\n                    sage: SymmetricGroup(10).algebra(QQ).group()\n                    Symmetric group of order 10! as a permutation group\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "central_form": {
                    "__doc__": "\n                Return ``self`` expressed in the canonical basis of the center\n                of the group algebra.\n\n                INPUT:\n\n                - ``self`` -- an element of the center of the group algebra\n\n                OUTPUT:\n\n                - A formal linear combination of the conjugacy class\n                  representatives representing its coordinates in the\n                  canonical basis of the center. See\n                  :meth:`Groups.Algebras.ParentMethods.center_basis` for\n                  details.\n\n                .. WARNING::\n\n                    - This method requires the underlying group to\n                      have a method ``conjugacy_classes_representatives``\n                      (every permutation group has one, thanks GAP!).\n                    - This method does not check that the element is\n                      indeed central. Use the method\n                      :meth:`Monoids.Algebras.ElementMethods.is_central`\n                      for this purpose.\n                    - This function has a complexity linear in the\n                      number of conjugacy classes of the group. One\n                      could easily implement a function whose\n                      complexity is linear in the size of the support\n                      of ``self``.\n\n                EXAMPLES::\n\n                    sage: QS3 = SymmetricGroup(3).algebra(QQ)\n                    sage: A = QS3([2,3,1]) + QS3([3,1,2])\n                    sage: A.central_form()\n                    B[(1,2,3)]\n                    sage: QS4 = SymmetricGroup(4).algebra(QQ)\n                    sage: B = sum(len(s.cycle_type())*QS4(s) for s in Permutations(4))\n                    sage: B.central_form()\n                    4*B[()] + 3*B[(1,2)] + 2*B[(1,2)(3,4)] + 2*B[(1,2,3)] + B[(1,2,3,4)]\n\n                    sage: QG = GroupAlgebras(QQ).example(PermutationGroup([[(1,2,3),(4,5)],[(3,4)]]))\n                    sage: sum(i for i in QG.basis()).central_form()\n                    B[()] + B[(4,5)] + B[(3,4,5)] + B[(2,3)(4,5)] + B[(2,3,4,5)] + B[(1,2)(3,4,5)] + B[(1,2,3,4,5)]\n\n                .. SEEALSO::\n\n                    - :meth:`Groups.Algebras.ParentMethods.center_basis`\n                    - :meth:`Monoids.Algebras.ElementMethods.is_central`\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "FiniteDimensional",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_dimensional_hopf_algebras_with_basis.FiniteDimensionalHopfAlgebrasWithBasis",
            "sage.categories.groups.Groups.Algebras",
            "sage.categories.finite_sets.FiniteSets.Algebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.finite_groups.FiniteGroups.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.semigroups.Semigroups",
            "sage.categories.magmas.Magmas.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.semigroups.Semigroups.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered algebras with a distinguished\n    homogeneous basis.\n\n    A filtered algebra with basis over a commutative ring `R`\n    is a filtered algebra over `R` endowed with the structure\n    of a filtered module with basis (with the same underlying\n    filtered-module structure). See\n    :class:`~sage.categories.filtered_algebras.FilteredAlgebras` and\n    :class:`~sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis`\n    for these two notions.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(ZZ).Filtered(); C\n        Category of filtered algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras with basis over Integer Ring,\n         Category of filtered algebras over Integer Ring,\n         Category of filtered modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.filtered_algebras.FilteredAlgebras",
            "sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered algebras with a distinguished\n    homogeneous basis.\n\n    A filtered algebra with basis over a commutative ring `R`\n    is a filtered algebra over `R` endowed with the structure\n    of a filtered module with basis (with the same underlying\n    filtered-module structure). See\n    :class:`~sage.categories.filtered_algebras.FilteredAlgebras` and\n    :class:`~sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis`\n    for these two notions.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(ZZ).Filtered(); C\n        Category of filtered algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras with basis over Integer Ring,\n         Category of filtered algebras over Integer Ring,\n         Category of filtered modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_algebras_with_basis.FilteredAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of right modules\n    right modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with right multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: RightModules(QQ)\n        Category of right modules over Rational Field\n        sage: RightModules(QQ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(RightModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of right modules\n    right modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with right multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: RightModules(QQ)\n        Category of right modules over Rational Field\n        sage: RightModules(QQ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(RightModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.right_modules.RightModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis",
            "sage.categories.sets_cat.Sets.Algebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "Distributive",
            "AdditiveAssociative",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital",
            "sage.categories.semigroups.Semigroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital.Associative",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.sets_cat.Sets.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.Algebras"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of Hopf algebras constructed by tensor product of Hopf algebras\n        ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.algebras.Algebras.TensorProducts",
            "sage.categories.coalgebras.Coalgebras.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of Hopf algebras constructed by tensor product of Hopf algebras\n        ",
            "methods": {}
        },
        "name": "sage.categories.hopf_algebras.HopfAlgebras.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modules.Modules.TensorProducts"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of additive semigroups.\n\n    An *additive semigroup* is an associative :class:`additive magma\n    <AdditiveMagmas>`, that is a set endowed with an operation `+`\n    which is associative.\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_semigroups import AdditiveSemigroups\n        sage: C = AdditiveSemigroups(); C\n        Category of additive semigroups\n        sage: C.super_categories()\n        [Category of additive magmas]\n        sage: C.all_super_categories()\n        [Category of additive semigroups,\n         Category of additive magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: C.axioms()\n        frozenset({'AdditiveAssociative'})\n        sage: C is AdditiveMagmas().AdditiveAssociative()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveAssociative"
        ],
        "element_class": {
            "__doc__": "\n    The category of additive semigroups.\n\n    An *additive semigroup* is an associative :class:`additive magma\n    <AdditiveMagmas>`, that is a set endowed with an operation `+`\n    which is associative.\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_semigroups import AdditiveSemigroups\n        sage: C = AdditiveSemigroups(); C\n        Category of additive semigroups\n        sage: C.super_categories()\n        [Category of additive magmas]\n        sage: C.all_super_categories()\n        [Category of additive semigroups,\n         Category of additive magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: C.axioms()\n        frozenset({'AdditiveAssociative'})\n        sage: C is AdditiveMagmas().AdditiveAssociative()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "mmt": "Semigroup",
        "morphism_class": {
            "__doc__": "\n    The category of additive semigroups.\n\n    An *additive semigroup* is an associative :class:`additive magma\n    <AdditiveMagmas>`, that is a set endowed with an operation `+`\n    which is associative.\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_semigroups import AdditiveSemigroups\n        sage: C = AdditiveSemigroups(); C\n        Category of additive semigroups\n        sage: C.super_categories()\n        [Category of additive magmas]\n        sage: C.all_super_categories()\n        [Category of additive semigroups,\n         Category of additive magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: C.axioms()\n        frozenset({'AdditiveAssociative'})\n        sage: C is AdditiveMagmas().AdditiveAssociative()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.additive_semigroups.AdditiveSemigroups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_additive_associativity": {
                    "__doc__": "\n            Test associativity for (not necessarily all) elements of this\n            additive semigroup.\n\n            INPUT:\n\n            - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n            EXAMPLES:\n\n            By default, this method tests only the elements returned by\n            ``self.some_elements()``::\n\n                sage: S = CommutativeAdditiveSemigroups().example()\n                sage: S._test_additive_associativity()\n\n            However, the elements tested can be customized with the\n            ``elements`` keyword argument::\n\n                sage: (a,b,c,d) = S.additive_semigroup_generators()\n                sage: S._test_additive_associativity(elements = (a, b+c, d))\n\n            See the documentation for :class:`TestSuite` for more information.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of additive semigroups.\n\n    An *additive semigroup* is an associative :class:`additive magma\n    <AdditiveMagmas>`, that is a set endowed with an operation `+`\n    which is associative.\n\n    EXAMPLES::\n\n        sage: from sage.categories.additive_semigroups import AdditiveSemigroups\n        sage: C = AdditiveSemigroups(); C\n        Category of additive semigroups\n        sage: C.super_categories()\n        [Category of additive magmas]\n        sage: C.all_super_categories()\n        [Category of additive semigroups,\n         Category of additive magmas,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n        sage: C.axioms()\n        frozenset({'AdditiveAssociative'})\n        sage: C is AdditiveMagmas().AdditiveAssociative()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.sets_cat.Sets.Realizations",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "__init_extra__": {
                    "__doc__": "\n                Register ``self`` as a realization of ``self.realization_of``.\n\n                TESTS::\n\n                    sage: A = Sets().WithRealizations().example()\n                    sage: A.realizations()    # indirect doctest\n                    [The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis,\n                     The subset algebra of {1, 2, 3} over Rational Field in the In basis,\n                     The subset algebra of {1, 2, 3} over Rational Field in the Out basis]\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_realization_name": {
                    "__doc__": "\n                Return the name of this realization.\n\n                In this default implementation, this is guessed from\n                the name of its class.\n\n                EXAMPLES::\n\n                    sage: A = Sets().WithRealizations().example(); A\n                    The subset algebra of {1, 2, 3} over Rational Field\n                    sage: In = A.In(); In\n                    The subset algebra of {1, 2, 3} over Rational Field in the In basis\n                    sage: In._realization_name()\n                    'In'\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_repr_": {
                    "__doc__": "\n                EXAMPLES::\n\n                    sage: A = Sets().WithRealizations().example(); A\n                    The subset algebra of {1, 2, 3} over Rational Field\n                    sage: In = A.In(); In\n                    The subset algebra of {1, 2, 3} over Rational Field in the In basis\n\n                In the example above, :meth:`repr` was overriden by\n                the category ``A.Realizations()``. We now add a new\n                (fake) realization which is not in\n                ``A.Realizations()`` to actually exercise this\n                method::\n\n                    sage: from sage.categories.realizations import Realizations\n                    sage: class Blah(Parent):\n                    ...       pass\n                    sage: P = Blah(category = Sets.WithRealizations.ParentMethods.Realizations(A))\n                    sage: P     # indirect doctest\n                    The subset algebra of {1, 2, 3} over Rational Field in the realization Blah\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "realization_of": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of groups constructed as Cartesian products of groups.\n\n        This construction gives the direct product of groups. See\n        :wikipedia:`Direct_product` and :wikipedia:`Direct_product_of_groups`\n        for more information.\n        ",
        "axioms": [
            "Inverse",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": "\n        The category of groups constructed as Cartesian products of groups.\n\n        This construction gives the direct product of groups. See\n        :wikipedia:`Direct_product` and :wikipedia:`Direct_product_of_groups`\n        for more information.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.monoids.Monoids.CartesianProducts",
            "sage.categories.groups.Groups",
            "sage.categories.magmas.Magmas.Unital.Inverse.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of groups constructed as Cartesian products of groups.\n\n        This construction gives the direct product of groups. See\n        :wikipedia:`Direct_product` and :wikipedia:`Direct_product_of_groups`\n        for more information.\n        ",
            "methods": {}
        },
        "name": "sage.categories.groups.Groups.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "order": {
                    "__doc__": "\n                Return the cardinality of self.\n\n                EXAMPLES::\n\n                    sage: C = cartesian_product([SymmetricGroup(10), SL(2,GF(3))])\n                    sage: C.order()\n                    87091200\n\n                TESTS::\n\n                    sage: C.order.__module__\n                    'sage.categories.groups'\n\n                .. TODO::\n\n                    this method is just here to prevent\n                    ``FiniteGroups.ParentMethods`` to call\n                    ``_cardinality_from_iterator``.\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of groups constructed as Cartesian products of groups.\n\n        This construction gives the direct product of groups. See\n        :wikipedia:`Direct_product` and :wikipedia:`Direct_product_of_groups`\n        for more information.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.homsets.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.homsets.Homsets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.Homsets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.super_modules_with_basis.SuperModulesWithBasis",
            "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis",
            "sage.categories.coalgebras.Coalgebras.Super"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis.Super",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets",
            "sage.categories.enumerated_sets.EnumeratedSets.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.CartesianProducts",
        "parent_class": {
            "__doc__": "\n            TESTS:\n\n            Ideally, these tests should be just after the declaration of the\n            associated attributes. But doing this way, Sage will not consider\n            them as a doctest.\n\n            We check that Cartesian products of finite enumerated sets\n            inherit various methods from `Sets.CartesianProducts`\n            and not from :class:`EnumeratedSets.Finite`::\n\n                sage: C = cartesian_product([Partitions(10), Permutations(20)])\n                sage: C in EnumeratedSets().Finite()\n                True\n\n                sage: C.random_element.__module__\n                'sage.categories.sets_cat'\n\n                sage: C.cardinality.__module__\n                'sage.categories.sets_cat'\n\n                sage: C.__iter__.__module__\n                'sage.categories.sets_cat'\n            ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.semigroups.Semigroups.Subquotients",
            "sage.categories.sets_cat.Sets.Quotients"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.semigroups.Semigroups.Quotients",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.Quotients",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "FinitelyGeneratedAsMagma"
        ],
        "element_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "magma_generators": {
                    "__doc__": "\n            Return distinguished magma generators for ``self``.\n\n            OUTPUT: a finite family\n\n            This method should be implemented by all\n            :class:`finitely generated magmas <FinitelyGeneratedMagmas>`.\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example()\n                sage: S.magma_generators()\n                Family ('a', 'b', 'c', 'd')\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) magmas.\n\n    See :meth:`Magmas.SubcategoryMethods.FinitelyGeneratedAsMagma` for\n    details.\n\n    EXAMPLES::\n\n        sage: C = Magmas().FinitelyGeneratedAsMagma(); C\n        Category of finitely generated magmas\n        sage: C.super_categories()\n        [Category of magmas]\n        sage: sorted(C.axioms())\n        ['FinitelyGeneratedAsMagma']\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.enumerated_sets.EnumeratedSets.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "first": {
                    "__doc__": "\n                Return the first element.\n\n                EXAMPLES::\n\n                    sage: cartesian_product([ZZ]*10).first()\n                    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas",
            "mmt.Sets.GAP"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.Magmas.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Finite"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_sets.FiniteSets",
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.finite_sets.FiniteSets.Subquotients",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.AdditiveInverse.CartesianProducts",
            "sage.categories.additive_semigroups.AdditiveSemigroups.CartesianProducts",
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        Category of commutative (abelian) monoids.\n\n        A monoid `M` is *commutative* if `xy = yx` for all `x,y \\in M`.\n        ",
        "axioms": [
            "Commutative",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": "\n        Category of commutative (abelian) monoids.\n\n        A monoid `M` is *commutative* if `xy = yx` for all `x,y \\in M`.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.magmas.Magmas.Commutative"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        Category of commutative (abelian) monoids.\n\n        A monoid `M` is *commutative* if `xy = yx` for all `x,y \\in M`.\n        ",
            "methods": {}
        },
        "name": "sage.categories.monoids.Monoids.Commutative",
        "parent_class": {
            "__doc__": "\n        Category of commutative (abelian) monoids.\n\n        A monoid `M` is *commutative* if `xy = yx` for all `x,y \\in M`.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        Category of commutative (abelian) monoids.\n\n        A monoid `M` is *commutative* if `xy = yx` for all `x,y \\in M`.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "categories.objects.GAP",
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.Sets.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.sets_cat.Sets.Realizations"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.Realizations",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "coproduct_by_coercion": {
                    "__doc__": "\n                Return the coproduct by coercion if ``coproduct_by_basis``\n                is not implemented.\n\n                EXAMPLES::\n\n                    sage: Sym = SymmetricFunctions(QQ)\n                    sage: m = Sym.monomial()\n                    sage: f = m[2,1]\n                    sage: f.coproduct.__module__\n                    'sage.categories.coalgebras'\n                    sage: m.coproduct_on_basis\n                    NotImplemented\n                    sage: m.coproduct == m.coproduct_by_coercion\n                    True\n                    sage: f.coproduct()\n                    m[] # m[2, 1] + m[1] # m[2] + m[2] # m[1] + m[2, 1] # m[]\n\n                ::\n\n                    sage: N = NonCommutativeSymmetricFunctions(QQ)\n                    sage: R = N.ribbon()\n                    sage: R.coproduct_by_coercion.__module__\n                    'sage.categories.coalgebras'\n                    sage: R.coproduct_on_basis\n                    NotImplemented\n                    sage: R.coproduct == R.coproduct_by_coercion\n                    True\n                    sage: R[1].coproduct()\n                    R[] # R[1] + R[1] # R[]\n                ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit_by_coercion": {
                    "__doc__": "\n                Return the counit of ``x`` if ``counit_by_basis`` is\n                not implemented.\n\n                EXAMPLES::\n\n                    sage: sp = SymmetricFunctions(QQ).sp()\n                    sage: sp.an_element()\n                    2*sp[] + 2*sp[1] + 3*sp[2]\n                    sage: sp.counit(sp.an_element())\n                    2\n\n                    sage: o = SymmetricFunctions(QQ).o()\n                    sage: o.an_element()\n                    2*o[] + 2*o[1] + 3*o[2]\n                    sage: o.counit(o.an_element())\n                    -1\n                ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade",
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.WithRealizations",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.WithRealizations",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.commutative_algebras.CommutativeAlgebras",
            "sage.categories.additive_semigroups.AdditiveSemigroups.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative.Algebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Algebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas.Unital.Realizations",
            "sage.categories.coalgebras.Coalgebras.Realizations"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.hopf_algebras.HopfAlgebras.Realizations",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "antipode_by_coercion": {
                    "__doc__": "\n                Returns the image of ``x`` by the antipode\n\n                This default implementation coerces to the default\n                realization, computes the antipode there, and coerces the\n                result back.\n\n                EXAMPLES::\n\n                    sage: N = NonCommutativeSymmetricFunctions(QQ)\n                    sage: R = N.ribbon()\n                    sage: R.antipode_by_coercion.__module__\n                    'sage.categories.hopf_algebras'\n                    sage: R.antipode_by_coercion(R[1,3,1])\n                    -R[2, 1, 2]\n                ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of `(R,S)`-bimodules\n\n    For `R` and `S` rings, a `(R,S)`-bimodule `X` is a left `R`-module\n    and right `S`-module such that the left and right actions commute:\n    `r*(x*s) = (r*x)*s`.\n\n    EXAMPLES::\n\n        sage: Bimodules(QQ, ZZ)\n        Category of bimodules over Rational Field on the left and Integer Ring on the right\n        sage: Bimodules(QQ, ZZ).super_categories()\n        [Category of left modules over Rational Field, Category of right modules over Integer Ring]\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of `(R,S)`-bimodules\n\n    For `R` and `S` rings, a `(R,S)`-bimodule `X` is a left `R`-module\n    and right `S`-module such that the left and right actions commute:\n    `r*(x*s) = (r*x)*s`.\n\n    EXAMPLES::\n\n        sage: Bimodules(QQ, ZZ)\n        Category of bimodules over Rational Field on the left and Integer Ring on the right\n        sage: Bimodules(QQ, ZZ).super_categories()\n        [Category of left modules over Rational Field, Category of right modules over Integer Ring]\n    ",
            "methods": {}
        },
        "name": "sage.categories.bimodules.Bimodules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.TensorProducts",
        "parent_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules",
            "sage.categories.homsets.HomsetsOf"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "base_ring": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.homsets.HomsetsOf",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.modules.Modules.Homsets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.semigroups.Semigroups.Subquotients"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.monoids.Monoids.Subquotients",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered modules with a distinguished basis.\n\n    A *filtered module with basis* over a ring `R` means\n    (for the purpose of this code) a filtered `R`-module `M`\n    with filtration `(F_i)_{i \\in I}` (typically `I = \\NN`)\n    endowed with a basis `(b_j)_{j \\in J}` of `M` and a partition\n    `J = \\bigsqcup_{i \\in I} J_i` of the set `J` (it is allowed\n    that some `J_i` are empty) such that for every `n \\in I`,\n    the subfamily `(b_j)_{j \\in U_n}`, where\n    `U_n = \\bigcup_{i \\leq n} J_i`, is a basis of the\n    `R`-submodule `F_n`.\n\n    For every `i \\in I`, the `R`-submodule of `M` spanned by\n    `(b_j)_{j \\in J_i}` is called the `i`-*th graded component*\n    (aka the `i`-*th homogeneous component*) of the filtered\n    module with basis `M`; the elements of this submodule are\n    referred to as *homogeneous elements of degree* `i`.\n    The `R`-module `M` is the direct sum of its `i`-th graded\n    components over all `i \\in I`, and thus becomes a graded\n    `R`-module with basis.\n    Conversely, any graded `R`-module with basis canonically\n    becomes a filtered `R`-module with basis (by defining\n    `F_n = \\bigoplus_{i \\leq n} G_i` where `G_i` is the `i`-th\n    graded component, and defining `J_i` as the indexing set\n    of the basis of the `i`-th graded component). Hence, the\n    notion of a filtered `R`-module with basis is equivalent\n    to the notion of a graded `R`-module with basis.\n\n    However, the *category* of filtered `R`-modules with basis is not\n    the category of graded `R`-modules with basis. Indeed, the *morphisms*\n    of filtered `R`-modules with basis are defined to be morphisms of\n    `R`-modules which send each `F_n` of the domain to the corresponding\n    `F_n` of the target; in contrast, the morphisms of graded `R`-modules\n    with basis must preserve each homogeneous component. Also,\n    the notion of a filtered algebra with basis differs from\n    that of a graded algebra with basis.\n\n    .. NOTE::\n\n        Currently, to make use of the functionality of this class,\n        an instance of ``FilteredModulesWithBasis`` should fulfill\n        the contract of a :class:`CombinatorialFreeModule` (most\n        likely by inheriting from it). It should also have the\n        indexing set `J` encoded as its ``_indices`` attribute,\n        and ``_indices.subset(size=i)`` should yield the subset\n        `J_i` (as an iterable). If the latter conditions are not\n        satisfied, then :meth:`basis` must be overridden.\n\n    .. NOTE::\n\n        One should implement a ``degree_on_basis`` method in the parent\n        class in order to fully utilize the methods of this category.\n        This might become a required abstract method in the future.\n\n    EXAMPLES::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered(); C\n        Category of filtered modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules over Integer Ring,\n         Category of modules with basis over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Filtered()\n        True\n\n    TESTS::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered()\n        sage: TestSuite(C).run()\n        sage: C = ModulesWithBasis(QQ).Filtered()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "degree_on_basis": {
                    "__doc__": "\n            Return the degree of the basis element indexed by ``m``\n            in ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(QQ).example()\n                sage: A.degree_on_basis(Partition((2,1)))\n                3\n                sage: A.degree_on_basis(Partition((4,2,1,1,1,1)))\n                10\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component": {
                    "__doc__": "\n            Return the homogeneous component of degree ``n`` of the\n            element ``self``.\n\n            Let `m` be an element of a filtered `R`-module `M` with\n            basis. Then, `m` can be uniquely written in the form\n            `m = \\sum_{i \\in I} m_i`, where each `m_i` is a\n            homogeneous element of degree `i`. For `n \\in I`, we\n            define the homogeneous component of degree `n` of the\n            element `m` to be `m_n`.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.homogeneous_component(-1)\n                0\n                sage: g.homogeneous_component(0)\n                1\n                sage: g.homogeneous_component(2)\n                -2*U['x']*U['y']\n                sage: g.homogeneous_component(5)\n                0\n                sage: g.homogeneous_component(7)\n                U['x']^2*U['y']^2*U['z']^3\n                sage: g.homogeneous_component(8)\n                0\n\n            TESTS:\n\n            Check that this really returns ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.homogeneous_component(3).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_homogeneous": {
                    "__doc__": "\n            Return whether the element ``self`` is homogeneous.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x=A(Partition((3,2,1)))\n                sage: y=A(Partition((4,4,1)))\n                sage: z=A(Partition((2,2,2)))\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x - y).is_homogeneous()\n                False\n                sage: (x+2*z).is_homogeneous()\n                True\n\n            Here is an example with a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x^3 - y^2).is_homogeneous()\n                True\n                sage: ((x + y)^2).is_homogeneous()\n                False\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis, or at least on a definition of homogeneous\n            components)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).is_homogeneous()\n                True\n                sage: (y*x).is_homogeneous()\n                False\n                sage: A.one().is_homogeneous()\n                True\n                sage: A.zero().is_homogeneous()\n                True\n                sage: (A.one()+x).is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "maximal_degree": {
                    "__doc__": "\n            The maximum of the degrees of the homogeneous components\n            of ``self``.\n\n            This is also the smallest `i` such that ``self`` belongs\n            to `F_i`. Hence, it does not depend on the basis of the\n            parent of ``self``.\n\n            .. SEEALSO:: :meth:`homogeneous_degree`\n\n            EXAMPLES:\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.maximal_degree()\n                6\n                sage: (x + 2*z).maximal_degree()\n                6\n                sage: (y - x).maximal_degree()\n                9\n                sage: (3*z).maximal_degree()\n                6\n\n            Now, we test this on a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.maximal_degree()\n                2\n                sage: (x^3 + 4*y^2).maximal_degree()\n                6\n                sage: ((1 + x)^3).maximal_degree()\n                6\n\n            Let us now test a filtered algebra::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).maximal_degree()\n                2\n                sage: (y*x).maximal_degree()\n                2\n                sage: A.one().maximal_degree()\n                0\n                sage: A.zero().maximal_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n                sage: (A.one()+x).maximal_degree()\n                1\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "truncate": {
                    "__doc__": "\n            Return the sum of the homogeneous components of degree\n            strictly less than ``n`` of ``self``.\n\n            See :meth:`homogeneous_component` for the notion of a\n            homogeneous component.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(-1)\n                0\n                sage: g.truncate(0)\n                0\n                sage: g.truncate(2)\n                2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(3)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(5)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(7)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(8)\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.truncate(0).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered modules with a distinguished basis.\n\n    A *filtered module with basis* over a ring `R` means\n    (for the purpose of this code) a filtered `R`-module `M`\n    with filtration `(F_i)_{i \\in I}` (typically `I = \\NN`)\n    endowed with a basis `(b_j)_{j \\in J}` of `M` and a partition\n    `J = \\bigsqcup_{i \\in I} J_i` of the set `J` (it is allowed\n    that some `J_i` are empty) such that for every `n \\in I`,\n    the subfamily `(b_j)_{j \\in U_n}`, where\n    `U_n = \\bigcup_{i \\leq n} J_i`, is a basis of the\n    `R`-submodule `F_n`.\n\n    For every `i \\in I`, the `R`-submodule of `M` spanned by\n    `(b_j)_{j \\in J_i}` is called the `i`-*th graded component*\n    (aka the `i`-*th homogeneous component*) of the filtered\n    module with basis `M`; the elements of this submodule are\n    referred to as *homogeneous elements of degree* `i`.\n    The `R`-module `M` is the direct sum of its `i`-th graded\n    components over all `i \\in I`, and thus becomes a graded\n    `R`-module with basis.\n    Conversely, any graded `R`-module with basis canonically\n    becomes a filtered `R`-module with basis (by defining\n    `F_n = \\bigoplus_{i \\leq n} G_i` where `G_i` is the `i`-th\n    graded component, and defining `J_i` as the indexing set\n    of the basis of the `i`-th graded component). Hence, the\n    notion of a filtered `R`-module with basis is equivalent\n    to the notion of a graded `R`-module with basis.\n\n    However, the *category* of filtered `R`-modules with basis is not\n    the category of graded `R`-modules with basis. Indeed, the *morphisms*\n    of filtered `R`-modules with basis are defined to be morphisms of\n    `R`-modules which send each `F_n` of the domain to the corresponding\n    `F_n` of the target; in contrast, the morphisms of graded `R`-modules\n    with basis must preserve each homogeneous component. Also,\n    the notion of a filtered algebra with basis differs from\n    that of a graded algebra with basis.\n\n    .. NOTE::\n\n        Currently, to make use of the functionality of this class,\n        an instance of ``FilteredModulesWithBasis`` should fulfill\n        the contract of a :class:`CombinatorialFreeModule` (most\n        likely by inheriting from it). It should also have the\n        indexing set `J` encoded as its ``_indices`` attribute,\n        and ``_indices.subset(size=i)`` should yield the subset\n        `J_i` (as an iterable). If the latter conditions are not\n        satisfied, then :meth:`basis` must be overridden.\n\n    .. NOTE::\n\n        One should implement a ``degree_on_basis`` method in the parent\n        class in order to fully utilize the methods of this category.\n        This might become a required abstract method in the future.\n\n    EXAMPLES::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered(); C\n        Category of filtered modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules over Integer Ring,\n         Category of modules with basis over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Filtered()\n        True\n\n    TESTS::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered()\n        sage: TestSuite(C).run()\n        sage: C = ModulesWithBasis(QQ).Filtered()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "from_graded_conversion": {
                    "__doc__": "\n            Return the inverse of the canonical `R`-module isomorphism\n            `A \\to \\operatorname{gr} A` induced by the basis of `A`\n            (where `A = ` ``self``). This inverse is an isomorphism\n            `\\operatorname{gr} A \\to A`.\n\n            This is an isomorphism of `R`-modules. See\n            the class documentation :class:`AssociatedGradedAlgebra`.\n\n            .. SEEALSO::\n\n                :meth:`to_graded_conversion`\n\n            EXAMPLES::\n\n                sage: A = Modules(QQ).WithBasis().Filtered().example()\n                sage: p = -2 * A.an_element(); p\n                -4*P[] - 4*P[1] - 6*P[2]\n                sage: q = A.to_graded_conversion()(p); q\n                -4*Bbar[[]] - 4*Bbar[[1]] - 6*Bbar[[2]]\n                sage: A.from_graded_conversion()(q) == p\n                True\n                sage: q.parent() is A.graded_algebra()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "graded_algebra": {
                    "__doc__": "\n            Return the associated graded module to ``self``.\n\n            See :class:`~sage.algebras.associated_graded.AssociatedGradedAlgebra`\n            for the definition and the properties of this.\n\n            If the filtered module ``self`` with basis is called `A`,\n            then this method returns `\\operatorname{gr} A`. The method\n            :meth:`to_graded_conversion` returns the canonical\n            `R`-module isomorphism `A \\to \\operatorname{gr} A` induced\n            by the basis of `A`, and the method\n            :meth:`from_graded_conversion` returns the inverse of this\n            isomorphism. The method :meth:`projection` projects\n            elements of `A` onto `\\operatorname{gr} A` according to\n            their place in the filtration on `A`.\n\n            .. WARNING::\n\n                When not overridden, this method returns the default\n                implementation of an associated graded module --\n                namely, ``AssociatedGradedAlgebra(self)``, where\n                ``AssociatedGradedAlgebra`` is\n                :class:`~sage.algebras.associated_graded.AssociatedGradedAlgebra`.\n                But some instances of :class:`FilteredModulesWithBasis`\n                override this method, as the associated graded module\n                often is (isomorphic) to a simpler object (for instance,\n                the associated graded module of a graded module can be\n                identified with the graded module itself). Generic code\n                that uses associated graded modules (such as the code\n                of the :meth:`induced_graded_map` method below) should\n                make sure to only communicate with them via the\n                :meth:`to_graded_conversion`,\n                :meth:`from_graded_conversion` and\n                :meth:`projection` methods (in particular,\n                do not expect there to be a conversion from ``self``\n                to ``self.graded_algebra()``; this currently does not\n                work for Clifford algebras). Similarly, when\n                overriding :meth:`graded_algebra`, make sure to\n                accordingly redefine these three methods, unless their\n                definitions below still apply to your case (this will\n                happen whenever the basis of your :meth:`graded_algebra`\n                has the same indexing set as ``self``, and the partition\n                of this indexing set according to degree is the same as\n                for ``self``).\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: A.graded_algebra()\n                Graded Module of An example of a filtered module with basis:\n                 the free module on partitions over Integer Ring\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component": {
                    "__doc__": "\n            Return the ``d``-th homogeneous component of ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(ZZ).example()\n                sage: A.homogeneous_component(4)\n                Degree 4 homogeneous component of An example of a graded module\n                 with basis: the free module on partitions over Integer Ring\n            ",
                    "args": [
                        "self",
                        "d"
                    ],
                    "argspec": [
                        [
                            "self",
                            "d"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component_basis": {
                    "__doc__": "\n            Return a basis for the ``d``-th homogeneous component of ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(ZZ).example()\n                sage: A.homogeneous_component_basis(4)\n                Lazy family (Term map from Partitions to An example of a graded module with basis:\n                             the free module on partitions over Integer Ring(i))_{i in Partitions of the integer 4}\n\n                sage: cat = GradedModulesWithBasis(ZZ)\n                sage: C = CombinatorialFreeModule(ZZ, ['a', 'b'], category=cat)\n                sage: C.degree_on_basis = lambda x: 1 if x == 'a' else 2\n                sage: C.homogeneous_component_basis(1)\n                Finite family {'a': B['a']}\n                sage: C.homogeneous_component_basis(2)\n                Finite family {'b': B['b']}\n            ",
                    "args": [
                        "self",
                        "d"
                    ],
                    "argspec": [
                        [
                            "self",
                            "d"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "induced_graded_map": {
                    "__doc__": "\n            Return the graded linear map between the associated graded\n            modules of ``self`` and ``other`` canonically induced by\n            the filtration-preserving map ``f : self -> other``.\n\n            Let `A` and `B` be two filtered modules with basis, and let\n            `(F_i)_{i \\in I}` and `(G_i)_{i \\in I}` be their\n            filtrations. Let `f : A \\to B` be a linear map which\n            preserves the filtration (i.e., satisfies `f(F_i) \\subseteq\n            G_i` for all `i \\in I`). Then, there is a canonically\n            defined graded linear map\n            `\\operatorname{gr} f : \\operatorname{gr} A \\to\n            \\operatorname{gr} B` which satisfies\n\n            .. MATH::\n\n                (\\operatorname{gr} f) (p_i(a)) = p_i(f(a))\n                \\qquad \\text{for all } i \\in I \\text{ and } a \\in F_i ,\n\n            where the `p_i` on the left hand side is the canonical\n            projection from `F_i` onto the `i`-th graded component\n            of `\\operatorname{gr} A`, while the `p_i` on the right\n            hand side is the canonical projection from `G_i` onto\n            the `i`-th graded component of `\\operatorname{gr} B`.\n\n            INPUT:\n\n            - ``other`` -- a filtered algebra with basis\n\n            - ``f`` -- a filtration-preserving linear map from ``self``\n              to ``other`` (can be given as a morphism or as a function)\n\n            OUTPUT:\n\n            The graded linear map `\\operatorname{gr} f`.\n\n            EXAMPLES:\n\n            **Example 1.**\n\n            We start with the free `\\QQ`-module with basis the set of all\n            partitions::\n\n                sage: A = Modules(QQ).WithBasis().Filtered().example(); A\n                An example of a filtered module with basis: the free module\n                 on partitions over Rational Field\n                sage: M = A.indices(); M\n                Partitions\n                sage: p1, p2, p21, p321 = [A.basis()[Partition(i)] for i in [[1], [2], [2,1], [3,2,1]]]\n\n            Let us define a map from ``A`` to itself which acts on the\n            basis by sending every partition `\\lambda` to the sum of\n            the conjugates of all partitions `\\mu` for which\n            `\\lambda / \\mu` is a horizontal strip::\n\n                sage: def map_on_basis(lam):\n                ....:     return A.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = A.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=A)\n                sage: f(p1)\n                P[] + P[1]\n                sage: f(p2)\n                P[] + P[1] + P[1, 1]\n                sage: f(p21)\n                P[1] + P[1, 1] + P[2] + P[2, 1]\n                sage: f(p21 - p1)\n                -P[] + P[1, 1] + P[2] + P[2, 1]\n                sage: f(p321)\n                P[2, 1] + P[2, 1, 1] + P[2, 2] + P[2, 2, 1]\n                 + P[3, 1] + P[3, 1, 1] + P[3, 2] + P[3, 2, 1]\n\n            We now compute `\\operatorname{gr} f` ::\n\n                sage: grA = A.graded_algebra(); grA\n                Graded Module of An example of a filtered module with basis:\n                 the free module on partitions over Rational Field\n                sage: pp1, pp2, pp21, pp321 = [A.to_graded_conversion()(i) for i in [p1, p2, p21, p321]]\n                sage: pp2 + 4 * pp21\n                Bbar[[2]] + 4*Bbar[[2, 1]]\n                sage: grf = A.induced_graded_map(A, f); grf\n                Generic endomorphism of Graded Module of An example of a\n                 filtered module with basis:\n                 the free module on partitions over Rational Field\n                sage: grf(pp1)\n                Bbar[[1]]\n                sage: grf(pp2 + 4 * pp21)\n                Bbar[[1, 1]] + 4*Bbar[[2, 1]]\n\n            **Example 2.**\n\n            We shall now construct `\\operatorname{gr} f` for a\n            different map `f` out of the same ``A``; the new map\n            `f` will lead into a graded algebra already, namely into\n            the algebra of symmetric functions::\n\n                sage: h = SymmetricFunctions(QQ).h()\n                sage: def map_on_basis(lam):  # redefining map_on_basis\n                ....:     return h.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = A.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=h)  # redefining f\n                sage: f(p1)\n                h[] + h[1]\n                sage: f(p2)\n                h[] + h[1] + h[1, 1]\n                sage: f(A.zero())\n                0\n                sage: f(p2 - 3*p1)\n                -2*h[] - 2*h[1] + h[1, 1]\n\n            The algebra ``h`` of symmetric functions in the `h`-basis\n            is already graded, so its associated graded algebra is\n            implemented as itself::\n\n                sage: grh = h.graded_algebra(); grh is h\n                True\n                sage: grf = A.induced_graded_map(h, f); grf\n                Generic morphism:\n                  From: Graded Module of An example of a filtered\n                   module with basis: the free module on partitions\n                   over Rational Field\n                  To:   Symmetric Functions over Rational Field\n                   in the homogeneous basis\n                sage: grf(pp1)\n                h[1]\n                sage: grf(pp2)\n                h[1, 1]\n                sage: grf(pp321)\n                h[3, 2, 1]\n                sage: grf(pp2 - 3*pp1)\n                -3*h[1] + h[1, 1]\n                sage: grf(pp21)\n                h[2, 1]\n                sage: grf(grA.zero())\n                0\n\n            **Example 3.**\n\n            After having had a graded module as the codomain, let us try to\n            have one as the domain instead. Our new ``f`` will go from ``h``\n            to ``A``::\n\n                sage: def map_on_basis(lam):  # redefining map_on_basis\n                ....:     return A.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = h.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=A)  # redefining f\n                sage: f(h[1])\n                P[] + P[1]\n                sage: f(h[2])\n                P[] + P[1] + P[1, 1]\n                sage: f(h[1, 1])\n                P[1] + P[2]\n                sage: f(h[2, 2])\n                P[1, 1] + P[2, 1] + P[2, 2]\n                sage: f(h[3, 2, 1])\n                P[2, 1] + P[2, 1, 1] + P[2, 2] + P[2, 2, 1]\n                 + P[3, 1] + P[3, 1, 1] + P[3, 2] + P[3, 2, 1]\n                sage: f(h.one())\n                P[]\n                sage: grf = h.induced_graded_map(A, f); grf\n                Generic morphism:\n                  From: Symmetric Functions over Rational Field\n                   in the homogeneous basis\n                  To:   Graded Module of An example of a filtered\n                   module with basis: the free module on partitions\n                   over Rational Field\n                sage: grf(h[1])\n                Bbar[[1]]\n                sage: grf(h[2])\n                Bbar[[1, 1]]\n                sage: grf(h[1, 1])\n                Bbar[[2]]\n                sage: grf(h[2, 2])\n                Bbar[[2, 2]]\n                sage: grf(h[3, 2, 1])\n                Bbar[[3, 2, 1]]\n                sage: grf(h.one())\n                Bbar[[]]\n\n            **Example 4.**\n\n            The construct `\\operatorname{gr} f` also makes sense when `f`\n            is a filtration-preserving map between graded modules. ::\n\n                sage: def map_on_basis(lam):  # redefining map_on_basis\n                ....:     return h.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = h.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=h)  # redefining f\n                sage: f(h[1])\n                h[] + h[1]\n                sage: f(h[2])\n                h[] + h[1] + h[1, 1]\n                sage: f(h[1, 1])\n                h[1] + h[2]\n                sage: f(h[2, 1])\n                h[1] + h[1, 1] + h[2] + h[2, 1]\n                sage: f(h.one())\n                h[]\n                sage: grf = h.induced_graded_map(h, f); grf\n                Generic endomorphism of Symmetric Functions over Rational\n                 Field in the homogeneous basis\n                sage: grf(h[1])\n                h[1]\n                sage: grf(h[2])\n                h[1, 1]\n                sage: grf(h[1, 1])\n                h[2]\n                sage: grf(h[2, 1])\n                h[2, 1]\n                sage: grf(h.one())\n                h[]\n            ",
                    "args": [
                        "self",
                        "other",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "projection": {
                    "__doc__": "\n            Return the `i`-th projection `p_i : F_i \\to G_i` (in the\n            notations of the class documentation\n            :class:`AssociatedGradedAlgebra`, where `A = ` ``self``).\n\n            This method actually does not return the map `p_i` itself,\n            but an extension of `p_i` to the whole `R`-module `A`.\n            This extension is the composition of the `R`-module\n            isomorphism `A \\to \\operatorname{gr} A` with the canonical\n            projection of the graded `R`-module `\\operatorname{gr} A`\n            onto its `i`-th graded component `G_i`. The codomain of\n            this map is `\\operatorname{gr} A`, although its actual\n            image is `G_i`. The map `p_i` is obtained from this map\n            by restricting its domain to `F_i` and its image to `G_i`.\n\n            EXAMPLES::\n\n                sage: A = Modules(ZZ).WithBasis().Filtered().example()\n                sage: p = -2 * A.an_element(); p\n                -4*P[] - 4*P[1] - 6*P[2]\n                sage: q = A.projection(2)(p); q\n                -6*Bbar[[2]]\n                sage: q.parent() is A.graded_algebra()\n                True\n                sage: A.projection(3)(p)\n                0\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "to_graded_conversion": {
                    "__doc__": "\n            Return the canonical `R`-module isomorphism\n            `A \\to \\operatorname{gr} A` induced by the basis of `A`\n            (where `A = ` ``self``).\n\n            This is an isomorphism of `R`-modules. See\n            the class documentation :class:`AssociatedGradedAlgebra`.\n\n            .. SEEALSO::\n\n                :meth:`from_graded_conversion`\n\n            EXAMPLES::\n\n                sage: A = Modules(QQ).WithBasis().Filtered().example()\n                sage: p = -2 * A.an_element(); p\n                -4*P[] - 4*P[1] - 6*P[2]\n                sage: q = A.to_graded_conversion()(p); q\n                -4*Bbar[[]] - 4*Bbar[[1]] - 6*Bbar[[2]]\n                sage: q.parent() is A.graded_algebra()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "degree_on_basis": {
                    "__doc__": "\n            Return the degree of the basis element indexed by ``m``\n            in ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(QQ).example()\n                sage: A.degree_on_basis(Partition((2,1)))\n                3\n                sage: A.degree_on_basis(Partition((4,2,1,1,1,1)))\n                10\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component": {
                    "__doc__": "\n            Return the homogeneous component of degree ``n`` of the\n            element ``self``.\n\n            Let `m` be an element of a filtered `R`-module `M` with\n            basis. Then, `m` can be uniquely written in the form\n            `m = \\sum_{i \\in I} m_i`, where each `m_i` is a\n            homogeneous element of degree `i`. For `n \\in I`, we\n            define the homogeneous component of degree `n` of the\n            element `m` to be `m_n`.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.homogeneous_component(-1)\n                0\n                sage: g.homogeneous_component(0)\n                1\n                sage: g.homogeneous_component(2)\n                -2*U['x']*U['y']\n                sage: g.homogeneous_component(5)\n                0\n                sage: g.homogeneous_component(7)\n                U['x']^2*U['y']^2*U['z']^3\n                sage: g.homogeneous_component(8)\n                0\n\n            TESTS:\n\n            Check that this really returns ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.homogeneous_component(3).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_homogeneous": {
                    "__doc__": "\n            Return whether the element ``self`` is homogeneous.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x=A(Partition((3,2,1)))\n                sage: y=A(Partition((4,4,1)))\n                sage: z=A(Partition((2,2,2)))\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x - y).is_homogeneous()\n                False\n                sage: (x+2*z).is_homogeneous()\n                True\n\n            Here is an example with a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x^3 - y^2).is_homogeneous()\n                True\n                sage: ((x + y)^2).is_homogeneous()\n                False\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis, or at least on a definition of homogeneous\n            components)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).is_homogeneous()\n                True\n                sage: (y*x).is_homogeneous()\n                False\n                sage: A.one().is_homogeneous()\n                True\n                sage: A.zero().is_homogeneous()\n                True\n                sage: (A.one()+x).is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "maximal_degree": {
                    "__doc__": "\n            The maximum of the degrees of the homogeneous components\n            of ``self``.\n\n            This is also the smallest `i` such that ``self`` belongs\n            to `F_i`. Hence, it does not depend on the basis of the\n            parent of ``self``.\n\n            .. SEEALSO:: :meth:`homogeneous_degree`\n\n            EXAMPLES:\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.maximal_degree()\n                6\n                sage: (x + 2*z).maximal_degree()\n                6\n                sage: (y - x).maximal_degree()\n                9\n                sage: (3*z).maximal_degree()\n                6\n\n            Now, we test this on a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.maximal_degree()\n                2\n                sage: (x^3 + 4*y^2).maximal_degree()\n                6\n                sage: ((1 + x)^3).maximal_degree()\n                6\n\n            Let us now test a filtered algebra::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).maximal_degree()\n                2\n                sage: (y*x).maximal_degree()\n                2\n                sage: A.one().maximal_degree()\n                0\n                sage: A.zero().maximal_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n                sage: (A.one()+x).maximal_degree()\n                1\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "truncate": {
                    "__doc__": "\n            Return the sum of the homogeneous components of degree\n            strictly less than ``n`` of ``self``.\n\n            See :meth:`homogeneous_component` for the notion of a\n            homogeneous component.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(-1)\n                0\n                sage: g.truncate(0)\n                0\n                sage: g.truncate(2)\n                2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(3)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(5)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(7)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(8)\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.truncate(0).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Commutative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Commutative",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "is_commutative": {
                    "__doc__": "\n                Return ``True``, since commutative magmas are commutative.\n\n                EXAMPLES::\n\n                    sage: Parent(QQ,category=CommutativeRings()).is_commutative()\n                    True\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of subquotient magmas.\n\n        See :meth:`Sets.SubcategoryMethods.Subquotients` for the\n        general setup for subquotients. In the case of a subquotient\n        magma `S` of a magma `G`, the condition that `r` be a\n        morphism in ``As`` can be rewritten as follows:\n\n         - for any two `a,b \\in S` the identity\n           `a \\times_S b = r(l(a) \\times_G l(b))` holds.\n\n        This is used by this category to implement the product\n        `\\times_S` of `S` from `l` and `r` and the product of `G`.\n\n        EXAMPLES::\n\n            sage: Semigroups().Subquotients().all_super_categories()\n            [Category of subquotients of semigroups, Category of semigroups,\n             Category of subquotients of magmas, Category of magmas,\n             Category of subquotients of sets, Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n        The category of subquotient magmas.\n\n        See :meth:`Sets.SubcategoryMethods.Subquotients` for the\n        general setup for subquotients. In the case of a subquotient\n        magma `S` of a magma `G`, the condition that `r` be a\n        morphism in ``As`` can be rewritten as follows:\n\n         - for any two `a,b \\in S` the identity\n           `a \\times_S b = r(l(a) \\times_G l(b))` holds.\n\n        This is used by this category to implement the product\n        `\\times_S` of `S` from `l` and `r` and the product of `G`.\n\n        EXAMPLES::\n\n            sage: Semigroups().Subquotients().all_super_categories()\n            [Category of subquotients of semigroups, Category of semigroups,\n             Category of subquotients of magmas, Category of magmas,\n             Category of subquotients of sets, Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.Subquotients"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of subquotient magmas.\n\n        See :meth:`Sets.SubcategoryMethods.Subquotients` for the\n        general setup for subquotients. In the case of a subquotient\n        magma `S` of a magma `G`, the condition that `r` be a\n        morphism in ``As`` can be rewritten as follows:\n\n         - for any two `a,b \\in S` the identity\n           `a \\times_S b = r(l(a) \\times_G l(b))` holds.\n\n        This is used by this category to implement the product\n        `\\times_S` of `S` from `l` and `r` and the product of `G`.\n\n        EXAMPLES::\n\n            sage: Semigroups().Subquotients().all_super_categories()\n            [Category of subquotients of semigroups, Category of semigroups,\n             Category of subquotients of magmas, Category of magmas,\n             Category of subquotients of sets, Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Subquotients",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of subquotient magmas.\n\n        See :meth:`Sets.SubcategoryMethods.Subquotients` for the\n        general setup for subquotients. In the case of a subquotient\n        magma `S` of a magma `G`, the condition that `r` be a\n        morphism in ``As`` can be rewritten as follows:\n\n         - for any two `a,b \\in S` the identity\n           `a \\times_S b = r(l(a) \\times_G l(b))` holds.\n\n        This is used by this category to implement the product\n        `\\times_S` of `S` from `l` and `r` and the product of `G`.\n\n        EXAMPLES::\n\n            sage: Semigroups().Subquotients().all_super_categories()\n            [Category of subquotients of semigroups, Category of semigroups,\n             Category of subquotients of magmas, Category of magmas,\n             Category of subquotients of sets, Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of metric spaces.\n\n    A *metric* on a set `S` is a function `d : S \\times S \\to \\RR`\n    such that:\n\n    - `d(a, b) \\geq 0`,\n    - `d(a, b) = 0` if and only if `a = b`.\n\n    A metric space is a set `S` with a distinguished metric.\n\n    .. RUBRIC:: Implementation\n\n    Objects in this category must implement either a ``dist`` on the parent\n    or the elements or ``metric`` on the parent; otherwise this will cause\n    an infinite recursion.\n\n    .. TODO::\n\n        - Implement a general geodesics class.\n        - Implement a category for metric additive groups\n          and move the generic distance `d(a, b) = |a - b|` there.\n        - Incorperate the length of a geodesic as part of the default\n          distance cycle.\n\n    EXAMPLES::\n\n        sage: from sage.categories.metric_spaces import MetricSpaces\n        sage: C = MetricSpaces()\n        sage: C\n        Category of metric spaces\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {
                "abs": {
                    "__doc__": "\n            Return the absolute value of ``self``.\n\n            EXAMPLES::\n\n                sage: CC(I).abs()\n                1.00000000000000\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "dist": {
                    "__doc__": "\n            Return the distance between ``self`` and ``other``.\n\n            EXAMPLES::\n\n                sage: UHP = HyperbolicPlane().UHP()\n                sage: p1 = UHP.get_point(5 + 7*I)\n                sage: p2 = UHP.get_point(1 + I)\n                sage: p1.dist(p2)\n                arccosh(33/7)\n            ",
                    "args": [
                        "self",
                        "b"
                    ],
                    "argspec": [
                        [
                            "self",
                            "b"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of metric spaces.\n\n    A *metric* on a set `S` is a function `d : S \\times S \\to \\RR`\n    such that:\n\n    - `d(a, b) \\geq 0`,\n    - `d(a, b) = 0` if and only if `a = b`.\n\n    A metric space is a set `S` with a distinguished metric.\n\n    .. RUBRIC:: Implementation\n\n    Objects in this category must implement either a ``dist`` on the parent\n    or the elements or ``metric`` on the parent; otherwise this will cause\n    an infinite recursion.\n\n    .. TODO::\n\n        - Implement a general geodesics class.\n        - Implement a category for metric additive groups\n          and move the generic distance `d(a, b) = |a - b|` there.\n        - Incorperate the length of a geodesic as part of the default\n          distance cycle.\n\n    EXAMPLES::\n\n        sage: from sage.categories.metric_spaces import MetricSpaces\n        sage: C = MetricSpaces()\n        sage: C\n        Category of metric spaces\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.metric_spaces.MetricSpaces",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_metric": {
                    "__doc__": "\n            Test that this metric space has a properly implemented metric.\n\n            INPUT:\n\n            - ``options`` -- any keyword arguments accepted\n              by :meth:`_tester`\n\n            EXAMPLES::\n\n                sage: UHP = HyperbolicPlane().UHP()\n                sage: UHP._test_metric()\n                sage: elts = [UHP.random_element() for i in range(5)]\n                sage: UHP._test_metric(some_elements=elts)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "dist": {
                    "__doc__": "\n            Return the distance between ``a`` and ``b`` in ``self``.\n\n            EXAMPLES::\n\n                sage: UHP = HyperbolicPlane().UHP()\n                sage: p1 = UHP.get_point(5 + 7*I)\n                sage: p2 = UHP.get_point(1.0 + I)\n                sage: UHP.dist(p1, p2)\n                2.23230104635820\n\n                sage: PD = HyperbolicPlane().PD()\n                sage: PD.dist(PD.get_point(0), PD.get_point(I/2))\n                arccosh(5/3)\n\n            TESTS::\n\n                sage: RR.dist(-1, pi)\n                4.14159265358979\n                sage: RDF.dist(1, -1/2)\n                1.5\n                sage: CC.dist(3, 2)\n                1.00000000000000\n                sage: CC.dist(-1, I)\n                1.41421356237310\n                sage: CDF.dist(-1, I)\n                1.4142135623730951\n            ",
                    "args": [
                        "self",
                        "a",
                        "b"
                    ],
                    "argspec": [
                        [
                            "self",
                            "a",
                            "b"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "metric": {
                    "__doc__": "\n            Return the metric of ``self``.\n\n            EXAMPLES::\n\n                sage: UHP = HyperbolicPlane().UHP()\n                sage: m = UHP.metric()\n                sage: p1 = UHP.get_point(5 + 7*I)\n                sage: p2 = UHP.get_point(1.0 + I)\n                sage: m(p1, p2)\n                2.23230104635820\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.topological_spaces.TopologicalSpaces",
            "sage.categories.metric_spaces.MetricSpaces",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "abs": {
                    "__doc__": "\n            Return the absolute value of ``self``.\n\n            EXAMPLES::\n\n                sage: CC(I).abs()\n                1.00000000000000\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "dist": {
                    "__doc__": "\n            Return the distance between ``self`` and ``other``.\n\n            EXAMPLES::\n\n                sage: UHP = HyperbolicPlane().UHP()\n                sage: p1 = UHP.get_point(5 + 7*I)\n                sage: p2 = UHP.get_point(1 + I)\n                sage: p1.dist(p2)\n                arccosh(33/7)\n            ",
                    "args": [
                        "self",
                        "b"
                    ],
                    "argspec": [
                        [
                            "self",
                            "b"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        TESTS::\n\n            sage: TestSuite(Semigroups().Algebras(QQ)).run()\n            sage: TestSuite(Semigroups().Finite().Algebras(QQ)).run()\n        ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        TESTS::\n\n            sage: TestSuite(Semigroups().Algebras(QQ)).run()\n            sage: TestSuite(Semigroups().Finite().Algebras(QQ)).run()\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.associative_algebras.AssociativeAlgebras",
            "sage.categories.magmas.Magmas.Algebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        TESTS::\n\n            sage: TestSuite(Semigroups().Algebras(QQ)).run()\n            sage: TestSuite(Semigroups().Finite().Algebras(QQ)).run()\n        ",
            "methods": {}
        },
        "name": "sage.categories.semigroups.Semigroups.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        TESTS::\n\n            sage: TestSuite(Semigroups().Algebras(QQ)).run()\n            sage: TestSuite(Semigroups().Finite().Algebras(QQ)).run()\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Finite",
            "Associative",
            "FinitelyGeneratedAsMagma"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups",
            "sage.categories.finite_semigroups.FiniteSemigroups",
            "sage.categories.finite_enumerated_sets.FiniteEnumeratedSets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Unital",
            "Associative",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.monoids.Monoids",
            "mmt.Semigroups.GAP",
            "mmt.Unital.GAP"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.Unital.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        EXAMPLES::\n\n            sage: C = Sets().CartesianProducts().example()\n            sage: C\n            The Cartesian product of (Set of prime numbers (basic implementation),\n             An example of an infinite enumerated set: the non negative integers,\n             An example of a finite enumerated set: {1,2,3})\n            sage: C.category()\n            Category of Cartesian products of sets\n            sage: C.categories()\n            [Category of Cartesian products of sets, Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n            sage: TestSuite(C).run()\n        ",
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {
                "cartesian_factors": {
                    "__doc__": "\n                Return the Cartesian factors of ``self``.\n\n                EXAMPLES::\n\n                    sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.__custom_name = \"F\"\n                    sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.__custom_name = \"G\"\n                    sage: H = CombinatorialFreeModule(ZZ, [4,7]); H.__custom_name = \"H\"\n                    sage: S = cartesian_product([F, G, H])\n                    sage: x = S.monomial((0,4)) + 2 * S.monomial((0,5)) + 3 * S.monomial((1,6)) + 4 * S.monomial((2,4)) + 5 * S.monomial((2,7))\n                    sage: x.cartesian_factors()\n                    (B[4] + 2*B[5], 3*B[6], 4*B[4] + 5*B[7])\n                    sage: [s.parent() for s in x.cartesian_factors()]\n                    [F, G, H]\n                    sage: S.zero().cartesian_factors()\n                    (0, 0, 0)\n                    sage: [s.parent() for s in S.zero().cartesian_factors()]\n                    [F, G, H]\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "cartesian_projection": {
                    "__doc__": "\n                Return the projection of ``self`` onto the `i`-th\n                factor of the Cartesian product.\n\n                INPUT:\n\n                - ``i`` -- the index of a factor of the Cartesian product\n\n                EXAMPLES::\n\n                    sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.__custom_name = \"F\"\n                    sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.__custom_name = \"G\"\n                    sage: S = cartesian_product([F, G])\n                    sage: x = S.monomial((0,4)) + 2 * S.monomial((0,5)) + 3 * S.monomial((1,6))\n                    sage: x.cartesian_projection(0)\n                    B[4] + 2*B[5]\n                    sage: x.cartesian_projection(1)\n                    3*B[6]\n                ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "summand_projection": {
                    "__doc__": "Deprecated: Use :func:`cartesian_projection` instead.\nSee :trac:`10963` for details.\n\n",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "summand_split": {
                    "__doc__": "Deprecated: Use :func:`cartesian_factors` instead.\nSee :trac:`10963` for details.\n\n",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        EXAMPLES::\n\n            sage: C = Sets().CartesianProducts().example()\n            sage: C\n            The Cartesian product of (Set of prime numbers (basic implementation),\n             An example of an infinite enumerated set: the non negative integers,\n             An example of a finite enumerated set: {1,2,3})\n            sage: C.category()\n            Category of Cartesian products of sets\n            sage: C.categories()\n            [Category of Cartesian products of sets, Category of sets,\n             Category of sets with partial maps,\n             Category of objects]\n            sage: TestSuite(C).run()\n        ",
            "methods": {}
        },
        "name": "sage.categories.sets_cat.Sets.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "__iter__": {
                    "__doc__": "\n                Return a lexicographic iterator for the elements of this Cartesian product.\n\n                EXAMPLES::\n\n                    sage: for x,y in cartesian_product([Set([1,2]), Set(['a','b'])]):\n                    ....:     print((x, y))\n                    (1, 'a')\n                    (1, 'b')\n                    (2, 'a')\n                    (2, 'b')\n\n                    sage: A = FiniteEnumeratedSets()([\"a\", \"b\"])\n                    sage: B = FiniteEnumeratedSets().example(); B\n                    An example of a finite enumerated set: {1,2,3}\n                    sage: C = cartesian_product([A, B, A]); C\n                    The Cartesian product of ({'a', 'b'}, An example of a finite enumerated set: {1,2,3}, {'a', 'b'})\n                    sage: C in FiniteEnumeratedSets()\n                    True\n                    sage: list(C)\n                    [('a', 1, 'a'), ('a', 1, 'b'), ('a', 2, 'a'), ('a', 2, 'b'), ('a', 3, 'a'), ('a', 3, 'b'),\n                     ('b', 1, 'a'), ('b', 1, 'b'), ('b', 2, 'a'), ('b', 2, 'b'), ('b', 3, 'a'), ('b', 3, 'b')]\n                    sage: C.__iter__.__module__\n                    'sage.categories.enumerated_sets'\n\n                    sage: F22 = GF(2).cartesian_product(GF(2))\n                    sage: list(F22)\n                    [(0, 0), (0, 1), (1, 0), (1, 1)]\n\n                    sage: C = cartesian_product([Permutations(10)]*4)\n                    sage: it = iter(C)\n                    sage: next(it)\n                    ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n                     [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n                     [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n                     [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n                    sage: next(it)\n                    ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n                     [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n                     [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n                     [1, 2, 3, 4, 5, 6, 7, 8, 10, 9])\n\n                .. WARNING::\n\n                    The elements are returned in lexicographic order,\n                    which gives a valid enumeration only if all\n                    factors, but possibly the first one, are\n                    finite. So the following one is fine::\n\n                        sage: it = iter(cartesian_product([ZZ, GF(2)]))\n                        sage: [next(it) for _ in range(10)]\n                        [(0, 0), (0, 1), (1, 0), (1, 1),\n                         (-1, 0), (-1, 1), (2, 0), (2, 1),\n                         (-2, 0), (-2, 1)]\n\n                    But this one is not::\n\n                        sage: it = iter(cartesian_product([GF(2), ZZ]))\n                        sage: [next(it) for _ in range(10)]\n                        doctest:...: UserWarning: Sage is not able to determine\n                        whether the factors of this Cartesian product are\n                        finite. The lexicographic ordering might not go through\n                        all elements.\n                        [(0, 0), (0, 1), (0, -1), (0, 2), (0, -2),\n                         (0, 3), (0, -3), (0, 4), (0, -4), (0, 5)]\n\n                .. NOTE::\n\n                    Here it would be faster to use :func:`itertools.product` for sets\n                    of small size. But the latter expands all factor in memory!\n                    So we can not reasonably use it in general.\n\n                ALGORITHM:\n\n                Recipe 19.9 in the Python Cookbook by Alex Martelli\n                and David Ascher.\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_cartesian_product_of_elements": {
                    "__doc__": "\n                Return the Cartesian product of the given ``elements``.\n\n                This method should accept any iterable.\n\n                INPUT:\n\n                - ``elements`` -- an iterable (e.g. a tuple or a list) of\n                  elements of each Cartesian factor of ``self``\n\n                EXAMPLES::\n\n                    sage: S1 = Sets().example()\n                    sage: S2 = InfiniteEnumeratedSets().example()\n                    sage: X = [S2, S1, S2]\n                    sage: C = cartesian_product(X)\n                    sage: C._cartesian_product_of_elements([S.an_element() for S in X])\n                    (42, 47, 42)\n                    sage: C._cartesian_product_of_elements(S.an_element() for S in X)\n                    (42, 47, 42)\n                ",
                    "args": [
                        "self",
                        "elements"
                    ],
                    "argspec": [
                        [
                            "self",
                            "elements"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_sets_keys": {
                    "__doc__": "\n                Return the indices of the Cartesian factors of ``self``.\n\n                EXAMPLES::\n\n                    sage: cartesian_product([QQ, ZZ, ZZ])._sets_keys()\n                    {0, 1, 2}\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "cartesian_factors": {
                    "__doc__": "\n                Return the Cartesian factors of ``self``.\n\n                EXAMPLES::\n\n                    sage: cartesian_product([QQ, ZZ, ZZ]).cartesian_factors()\n                    (Rational Field, Integer Ring, Integer Ring)\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "cartesian_projection": {
                    "__doc__": "\n                Return the natural projection onto the `i`-th\n                Cartesian factor of ``self``.\n\n                INPUT:\n\n                - ``i`` -- the index of a Cartesian factor of ``self``\n\n                EXAMPLES::\n\n                    sage: C = Sets().CartesianProducts().example(); C\n                    The Cartesian product of (Set of prime numbers (basic implementation),\n                     An example of an infinite enumerated set: the non negative integers,\n                     An example of a finite enumerated set: {1,2,3})\n                    sage: x = C.an_element(); x\n                    (47, 42, 1)\n                    sage: pi = C.cartesian_projection(1)\n                    sage: pi(x)\n                    42\n                ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_empty": {
                    "__doc__": "\n                Return whether this set is empty.\n\n                EXAMPLES::\n\n\n                    sage: S1 = FiniteEnumeratedSet([1,2,3])\n                    sage: S2 = Set([])\n                    sage: cartesian_product([S1,ZZ]).is_empty()\n                    False\n                    sage: cartesian_product([S1,S2,S1]).is_empty()\n                    True\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "cartesian_factors": {
                    "__doc__": "\n                Return the Cartesian factors of ``self``.\n\n                EXAMPLES::\n\n                    sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.__custom_name = \"F\"\n                    sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.__custom_name = \"G\"\n                    sage: H = CombinatorialFreeModule(ZZ, [4,7]); H.__custom_name = \"H\"\n                    sage: S = cartesian_product([F, G, H])\n                    sage: x = S.monomial((0,4)) + 2 * S.monomial((0,5)) + 3 * S.monomial((1,6)) + 4 * S.monomial((2,4)) + 5 * S.monomial((2,7))\n                    sage: x.cartesian_factors()\n                    (B[4] + 2*B[5], 3*B[6], 4*B[4] + 5*B[7])\n                    sage: [s.parent() for s in x.cartesian_factors()]\n                    [F, G, H]\n                    sage: S.zero().cartesian_factors()\n                    (0, 0, 0)\n                    sage: [s.parent() for s in S.zero().cartesian_factors()]\n                    [F, G, H]\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "cartesian_projection": {
                    "__doc__": "\n                Return the projection of ``self`` onto the `i`-th\n                factor of the Cartesian product.\n\n                INPUT:\n\n                - ``i`` -- the index of a factor of the Cartesian product\n\n                EXAMPLES::\n\n                    sage: F = CombinatorialFreeModule(ZZ, [4,5]); F.__custom_name = \"F\"\n                    sage: G = CombinatorialFreeModule(ZZ, [4,6]); G.__custom_name = \"G\"\n                    sage: S = cartesian_product([F, G])\n                    sage: x = S.monomial((0,4)) + 2 * S.monomial((0,5)) + 3 * S.monomial((1,6))\n                    sage: x.cartesian_projection(0)\n                    B[4] + 2*B[5]\n                    sage: x.cartesian_projection(1)\n                    3*B[6]\n                ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "summand_projection": {
                    "__doc__": "Deprecated: Use :func:`cartesian_projection` instead.\nSee :trac:`10963` for details.\n\n",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "summand_split": {
                    "__doc__": "Deprecated: Use :func:`cartesian_factors` instead.\nSee :trac:`10963` for details.\n\n",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "__call_on_basis__": {
                    "__doc__": "\n                Construct a morphism in this homset from a function defined\n                on the basis.\n\n                INPUT:\n\n                - ``on_basis`` -- a function from the indices of the\n                  basis of the domain of ``self`` to the codomain of\n                  ``self``\n\n                This method simply delegates the work to\n                :meth:`ModulesWithBasis.ParentMethods.module_morphism`. It\n                is used by :meth:`Homset.__call__` to handle the\n                ``on_basis`` argument, and will disapear as soon as\n                the logic will be generalized.\n\n                EXAMPLES::\n\n                    sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                    sage: H = Hom(X, Y)\n                    sage: x = X.basis()\n\n                    sage: phi = H(on_basis = lambda i: Y.monomial(i) + 2*Y.monomial(i+1)) # indirect doctest\n                    sage: phi\n                    Generic morphism:\n                    From: X\n                    To:   Y\n                    sage: phi(x[1] + x[3])\n                    B[1] + 2*B[2] + B[3] + 2*B[4]\n\n                Diagonal functions can be constructed using the ``diagonal`` option::\n\n                    sage: X = CombinatorialFreeModule(QQ, [1,2,3,4]); X.rename(\"X\")\n                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4], key=\"Y\"); Y.rename(\"Y\")\n                    sage: H = Hom(X, Y)\n                    sage: x = X.basis()\n                    sage: phi = H(diagonal = lambda x: x^2)\n                    sage: phi(x[1] + x[2] + x[3])\n                    B[1] + 4*B[2] + 9*B[3]\n\n                TESTS::\n\n                As for usual homsets, the argument can be a Python function::\n\n                    sage: phi = H(lambda x: Y.zero())\n                    sage: phi\n                    Generic morphism:\n                      From: X\n                      To:   Y\n                    sage: phi(x[1] + x[3])\n                    0\n\n               We check that the homset category is properly set up::\n\n                    sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                    sage: H = Hom(X, Y)\n                    sage: H.zero().category_for()\n                    Category of finite dimensional vector spaces with basis over Rational Field\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.homsets.HomsetsOf",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.modules.Modules.Homsets",
            "sage.categories.modules_with_basis.ModulesWithBasis.Homsets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of non-associative algebras over a given base ring.\n\n    A non-associative algebra over a ring `R` is a module over `R`\n    which s also a unital magma.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`UnitalAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.unital_algebras import UnitalAlgebras\n        sage: C = UnitalAlgebras(ZZ); C\n        Category of unital algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Unital()\n        True\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "Distributive"
        ],
        "element_class": {
            "__doc__": "\n        ``Magmas.Element.__mul__`` is preferable to ``Modules.Element.__mul__``\n        since the later does not handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of non-associative algebras over a given base ring.\n\n    A non-associative algebra over a ring `R` is a module over `R`\n    which s also a unital magma.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`UnitalAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.unital_algebras import UnitalAlgebras\n        sage: C = UnitalAlgebras(ZZ); C\n        Category of unital algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Unital()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.unital_algebras.UnitalAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "from_base_ring": {
                    "__doc__": "\n            Return the canonical embedding of ``r`` into ``self``.\n\n            INPUT:\n\n            - ``r`` -- an element of ``self.base_ring()``\n\n            EXAMPLES::\n\n                sage: A = AlgebrasWithBasis(QQ).example(); A\n                An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n                sage: A.from_base_ring(1)\n                B[word: ]\n            ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        ``Magmas.Element.__mul__`` is preferable to ``Modules.Element.__mul__``\n        since the later does not handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Associative",
            "FinitelyGeneratedAsMagma"
        ],
        "element_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.semigroups.Semigroups",
            "sage.categories.finitely_generated_magmas.FinitelyGeneratedMagmas",
            "sage.categories.enumerated_sets.EnumeratedSets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "ideal": {
                    "__doc__": "\n            Return the ``side``-sided ideal generated by ``gens``.\n\n            This brute force implementation recursively multiplies the\n            elements of ``gens`` by the distinguished generators of\n            this semigroup.\n\n            .. SEEALSO:: :meth:`semigroup_generators`\n\n            INPUT:\n\n            - ``gens`` -- a list (or iterable) of elements of ``self``\n            - ``side`` -- [default: \"twosided\"] \"left\", \"right\" or \"twosided\"\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example()\n                sage: list(S.ideal([S('cab')], side=\"left\"))\n                ['cab', 'acb', 'dcab', 'bca', 'abc', 'adcb', 'bdca',\n                 'cba', 'cdab', 'bac', 'dacb', 'dbca', 'adbc', 'bcda',\n                 'dbac', 'dabc', 'cbda', 'cdba', 'abdc', 'bdac', 'dcba',\n                 'cadb', 'badc', 'acdb', 'abcd', 'cbad', 'bacd', 'acbd',\n                 'bcad', 'cabd']\n                sage: list(S.ideal([S('cab')], side=\"right\"))\n                ['cab', 'cabd']\n                sage: list(S.ideal([S('cab')], side=\"twosided\"))\n                ['cab', 'acb', 'dcab', 'bca', 'cabd', 'abc', 'adcb',\n                 'acbd', 'bdca', 'bcad', 'cba', 'cdab', 'bac', 'dacb',\n                 'dbca', 'abcd', 'cbad', 'bacd', 'bcda', 'dbac', 'dabc',\n                 'cbda', 'cdba', 'abdc', 'adbc', 'bdac', 'dcba', 'cadb',\n                 'badc', 'acdb']\n                sage: list(S.ideal([S('cab')]))\n                ['cab', 'acb', 'dcab', 'bca', 'cabd', 'abc', 'adcb',\n                 'acbd', 'bdca', 'bcad', 'cba', 'cdab', 'bac', 'dacb',\n                 'dbca', 'abcd', 'cbad', 'bacd', 'bcda', 'dbac', 'dabc',\n                 'cbda', 'cdba', 'abdc', 'adbc', 'bdac', 'dcba', 'cadb',\n                 'badc', 'acdb']\n            ",
                    "args": [
                        "self",
                        "gens",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "gens",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "twosided"
                        ]
                    ]
                },
                "succ_generators": {
                    "__doc__": "\n            Return the successor function of the ``side``-sided Cayley\n            graph of ``self``.\n\n            This is a function that maps an element of ``self`` to all\n            the products of ``x`` by a generator of this semigroup,\n            where the product is taken on the left, right, or both\n            sides.\n\n            INPUT:\n\n            - ``side``: \"left\", \"right\", or \"twosided\"\n\n            .. TODO:: Design choice:\n\n               - find a better name for this method\n               - should we return a set? a family?\n\n            EXAMPLES::\n\n                sage: S = FiniteSemigroups().example()\n                sage: S.succ_generators(\"left\" )(S('ca'))\n                ('ac', 'bca', 'ca', 'dca')\n                sage: S.succ_generators(\"right\")(S('ca'))\n                ('ca', 'cab', 'ca', 'cad')\n                sage: S.succ_generators(\"twosided\" )(S('ca'))\n                ('ac', 'bca', 'ca', 'dca', 'ca', 'cab', 'ca', 'cad')\n\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "twosided"
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of finitely generated (multiplicative) semigroups.\n\n    A :class:`finitely generated semigroup <Semigroups>` is a\n    :class:`semigroup <Semigroups>` endowed with a distinguished\n    finite set of generators (see\n    :meth:`FinitelyGeneratedSemigroups.ParentMethods.semigroup_generators`). This\n    makes it into an :class:`enumerated set <EnumeratedSets>`.\n\n    EXAMPLES::\n\n        sage: C = Semigroups().FinitelyGenerated(); C\n        Category of finitely generated semigroups\n        sage: C.super_categories()\n        [Category of semigroups,\n         Category of finitely generated magmas,\n         Category of enumerated sets]\n        sage: sorted(C.axioms())\n        ['Associative', 'FinitelyGeneratedAsMagma']\n        sage: C.example()\n        An example of a semigroup: the free semigroup generated by ('a', 'b', 'c', 'd')\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of associative algebras over a given base ring.\n\n    An associative algebra over a ring `R` is a module over `R` which\n    is also a not necessarily unital ring.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`AssociativeAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.associative_algebras import AssociativeAlgebras\n        sage: C = AssociativeAlgebras(ZZ); C\n        Category of associative algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Associative()\n        True\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        An abstract class for elements of an associative algebra.\n\n        .. NOTE::\n\n            ``Magmas.Element.__mul__`` is preferable to\n            ``Modules.Element.__mul__`` since the later does not\n            handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.rngs.Rngs",
            "sage.categories.magmatic_algebras.MagmaticAlgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of associative algebras over a given base ring.\n\n    An associative algebra over a ring `R` is a module over `R` which\n    is also a not necessarily unital ring.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`AssociativeAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.associative_algebras import AssociativeAlgebras\n        sage: C = AssociativeAlgebras(ZZ); C\n        Category of associative algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Associative()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.associative_algebras.AssociativeAlgebras",
        "parent_class": {
            "__doc__": "\n    The category of associative algebras over a given base ring.\n\n    An associative algebra over a ring `R` is a module over `R` which\n    is also a not necessarily unital ring.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`AssociativeAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.associative_algebras import AssociativeAlgebras\n        sage: C = AssociativeAlgebras(ZZ); C\n        Category of associative algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Associative()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n        An abstract class for elements of an associative algebra.\n\n        .. NOTE::\n\n            ``Magmas.Element.__mul__`` is preferable to\n            ``Modules.Element.__mul__`` since the later does not\n            handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas",
            "mmt.Sets.GAP"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.AdditiveMagmas.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_rings.CommutativeRings",
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.CartesianProducts",
            "sage.categories.monoids.Monoids.CartesianProducts",
            "sage.categories.magmas.Magmas.Commutative.CartesianProducts",
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.commutative_rings.CommutativeRings.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.objects.Objects"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "categories.objects.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.facade_sets.FacadeSets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.sets_cat.Sets.WithRealizations",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "Realizations": {
                    "__doc__": null,
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        "args",
                        "opts",
                        null
                    ]
                },
                "_register_realization": {
                    "__doc__": "\n                EXAMPLES::\n\n                    sage: A = Sets().WithRealizations().example(QQ['x']); A\n                    The subset algebra of {1, 2, 3} over Univariate Polynomial Ring in x over Rational Field\n                    sage: class ANewRealizationOfA(CombinatorialFreeModule):\n                    ....:     pass\n                    sage: category = A.Realizations() & Algebras(QQ[x]).WithBasis()\n                    sage: R = ANewRealizationOfA(A.base_ring(), A.F().basis().keys(), category = category)\n                    sage: R in A.realizations()  # indirect doctest\n                    True\n\n                Note: the test above uses ``QQ[x]`` to not interfer\n                with other tests.\n                ",
                    "args": [
                        "self",
                        "realization"
                    ],
                    "argspec": [
                        [
                            "self",
                            "realization"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_test_with_realizations": {
                    "__doc__": "\n                Test that this parent with realizations is\n                properly implemented.\n\n                INPUT:\n\n                - ``options`` -- any keyword arguments accepted\n                  by :meth:`_tester`\n\n                EXAMPLES::\n\n                    sage: A = Sets().WithRealizations().example()\n                    sage: A._test_with_realizations()\n\n                See the documentation for :class:`TestSuite`\n                for more information.\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "a_realization": {
                    "__doc__": "\n                Return a realization of ``self``.\n\n                EXAMPLES::\n\n                    sage: A = Sets().WithRealizations().example(); A\n                    The subset algebra of {1, 2, 3} over Rational Field\n                    sage: A.a_realization()\n                    The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "inject_shorthands": {
                    "__doc__": "\n                Import standard shorthands into the global namespace.\n\n                INPUT:\n\n                - ``verbose`` -- boolean (default ``True``) if ``True``, prints the defined shorthands\n\n                EXAMPLES::\n\n                    sage: Q = QuasiSymmetricFunctions(ZZ)\n                    sage: Q.inject_shorthands()\n                    Injecting M as shorthand for Quasisymmetric functions over\n                    the Integer Ring in the Monomial basis\n                    Injecting F as shorthand for Quasisymmetric functions over\n                    the Integer Ring in the Fundamental basis\n                    Injecting dI as shorthand for Quasisymmetric functions over\n                    the Integer Ring in the dualImmaculate basis\n                    Injecting QS as shorthand for Quasisymmetric functions over\n                    the Integer Ring in the Quasisymmetric Schur basis\n                    sage: F[1,2,1] + 5*M[1,3] + F[2]^2\n                    5*F[1, 1, 1, 1] - 5*F[1, 1, 2] - 3*F[1, 2, 1] + 6*F[1, 3] +\n                    2*F[2, 2] + F[3, 1] + F[4]\n                    sage: F\n                    Quasisymmetric functions over the Integer Ring in the\n                    Fundamental basis\n                    sage: M\n                    Quasisymmetric functions over the Integer Ring in the\n                    Monomial basis\n                ",
                    "args": [
                        "self",
                        "verbose"
                    ],
                    "argspec": [
                        [
                            "self",
                            "verbose"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "realizations": {
                    "__doc__": "\n                Return all the realizations of ``self`` that ``self``\n                is aware of.\n\n                EXAMPLES::\n\n                    sage: A = Sets().WithRealizations().example(); A\n                    The subset algebra of {1, 2, 3} over Rational Field\n                    sage: A.realizations()\n                    [The subset algebra of {1, 2, 3} over Rational Field in the Fundamental basis, The subset algebra of {1, 2, 3} over Rational Field in the In basis, The subset algebra of {1, 2, 3} over Rational Field in the Out basis]\n\n                .. NOTE::\n\n                    Constructing a parent ``P`` in the category\n                    ``A.Realizations()`` automatically adds ``P`` to\n                    this list by calling ``A._register_realization(A)``\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "FiniteDimensional",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.FiniteDimensional",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of complete metric spaces.\n        ",
        "axioms": [
            "Complete"
        ],
        "element_class": {
            "__doc__": "\n        The category of complete metric spaces.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.metric_spaces.MetricSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of complete metric spaces.\n        ",
            "methods": {}
        },
        "name": "sage.categories.metric_spaces.MetricSpaces.Complete",
        "parent_class": {
            "__doc__": "\n        The category of complete metric spaces.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.topological_spaces.TopologicalSpaces",
            "sage.categories.metric_spaces.MetricSpaces",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of complete metric spaces.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.homsets.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.homsets.HomsetsOf",
        "parent_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.homsets.Homsets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.homsets.HomsetsOf"
        ],
        "subcategory_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of modules with a distinguished basis.\n\n    The elements are represented by expanding them in the distinguished basis.\n    The morphisms are not required to respect the distinguished basis.\n\n    EXAMPLES::\n\n        sage: ModulesWithBasis(ZZ)\n        Category of modules with basis over Integer Ring\n        sage: ModulesWithBasis(ZZ).super_categories()\n        [Category of modules over Integer Ring]\n\n    If the base ring is actually a field, this constructs instead the\n    category of vector spaces with basis::\n\n        sage: ModulesWithBasis(QQ)\n        Category of vector spaces with basis over Rational Field\n\n        sage: ModulesWithBasis(QQ).super_categories()\n        [Category of modules with basis over Rational Field,\n         Category of vector spaces over Rational Field]\n\n    Let `X` and `Y` be two modules with basis. We can build `Hom(X,Y)`::\n\n        sage: X = CombinatorialFreeModule(QQ, [1,2]); X.__custom_name = \"X\"\n        sage: Y = CombinatorialFreeModule(QQ, [3,4]); Y.__custom_name = \"Y\"\n        sage: H = Hom(X, Y); H\n        Set of Morphisms from X to Y in Category of finite dimensional vector spaces with basis over Rational Field\n\n    The simplest morphism is the zero map::\n\n        sage: H.zero()         # todo: move this test into module once we have an example\n        Generic morphism:\n          From: X\n          To:   Y\n\n    which we can apply to elements of `X`::\n\n        sage: x = X.monomial(1) + 3 * X.monomial(2)\n        sage: H.zero()(x)\n        0\n\n    EXAMPLES:\n\n    We now construct a more interesting morphism by extending a\n    function by linearity::\n\n        sage: phi = H(on_basis = lambda i: Y.monomial(i+2)); phi\n        Generic morphism:\n          From: X\n          To:   Y\n        sage: phi(x)\n        B[3] + 3*B[4]\n\n    We can retrieve the function acting on indices of the basis::\n\n        sage: f = phi.on_basis()\n        sage: f(1), f(2)\n        (B[3], B[4])\n\n    `Hom(X,Y)` has a natural module structure (except for the zero,\n    the operations are not yet implemented though). However since the\n    dimension is not necessarily finite, it is not a module with\n    basis; but see :class:`FiniteDimensionalModulesWithBasis` and\n    :class:`GradedModulesWithBasis`::\n\n        sage: H in ModulesWithBasis(QQ), H in Modules(QQ)\n        (False, True)\n\n    Some more playing around with categories and higher order homsets::\n\n        sage: H.category()\n        Category of homsets of modules with basis over Rational Field\n        sage: Hom(H, H).category()\n        Category of endsets of homsets of modules with basis over Rational Field\n\n    .. TODO:: ``End(X)`` is an algebra.\n\n    .. NOTE::\n\n        This category currently requires an implementation of an\n        element method ``support``. Once :trac:`18066` is merged, an\n        implementation of an ``items`` method will be required.\n\n    TESTS::\n\n        sage: f = H.zero().on_basis()\n        sage: f(1)\n        0\n        sage: f(2)\n        0\n\n        sage: TestSuite(ModulesWithBasis(ZZ)).run()\n\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "__getitem__": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self``.\n\n            EXAMPLES::\n\n                sage: p = Partition([2,1])\n                sage: q = Partition([1,1,1])\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s(p)\n                sage: a._coefficient_fast([2,1])\n                Traceback (most recent call last):\n                ...\n                TypeError: unhashable type: 'list'\n\n            ::\n\n                sage: a._coefficient_fast(p)\n                1\n                sage: a._coefficient_fast(q)\n                0\n                sage: a[p]\n                1\n                sage: a[q]\n                0\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__len__": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: len(f)\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: len(z)\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficient": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self`` and raise an error\n            if ``m`` is not in the basis indexing set.\n\n            INPUT:\n\n            - ``m`` -- a basis index of the parent of ``self``\n\n            OUTPUT:\n\n            The ``B[m]``-coordinate of ``self`` with respect to the basis\n            ``B``. Here, ``B`` denotes the given basis of the parent of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: s = CombinatorialFreeModule(QQ, Partitions())\n                sage: z = s([4]) - 2*s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficient([4])\n                1\n                sage: z.coefficient([2,1])\n                -2\n                sage: z.coefficient(Partition([2,1]))\n                -2\n                sage: z.coefficient([1,2])\n                Traceback (most recent call last):\n                ...\n                AssertionError: [1, 2] should be an element of Partitions\n                sage: z.coefficient(Composition([2,1]))\n                Traceback (most recent call last):\n                ...\n                AssertionError: [2, 1] should be an element of Partitions\n\n            Test that ``coefficient`` also works for those parents that do\n            not yet have an element_class::\n\n                sage: G = DihedralGroup(3)\n                sage: F = CombinatorialFreeModule(QQ, G)\n                sage: hasattr(G, \"element_class\")\n                False\n                sage: g = G.an_element()\n                sage: (2*F.monomial(g)).coefficient(g)\n                2\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficients": {
                    "__doc__": "\n            Return a list of the (non-zero) coefficients appearing on\n            the basis elements in ``self`` (in an arbitrary order).\n\n            INPUT:\n\n            - ``sort`` -- (default: ``True``) to sort the coefficients\n              based upon the default ordering of the indexing set\n\n            .. SEEALSO::\n\n                :meth:`~sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis.ElementMethods.dense_coefficient_list`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.coefficients()\n                [1, -3]\n                sage: f = B['c'] - 3*B['a']\n                sage: f.coefficients()\n                [-3, 1]\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficients()\n                [1, 1, 1, 1]\n            ",
                    "args": [
                        "self",
                        "sort"
                    ],
                    "argspec": [
                        [
                            "self",
                            "sort"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "is_zero": {
                    "__doc__": "\n            Return ``True`` if and only if ``self == 0``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.is_zero()\n                False\n                sage: F.zero().is_zero()\n                True\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: s([2,1]).is_zero()\n                False\n                sage: s(0).is_zero()\n                True\n                sage: (s([2,1]) - s([2,1])).is_zero()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "leading_coefficient": {
                    "__doc__": "\n            Returns the leading coefficient of ``self``.\n\n            This is the coefficient of the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\")\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_coefficient()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_coefficient(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_coefficient()\n                -5\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_item": {
                    "__doc__": "\n            Return the pair ``(k, c)`` where\n\n            .. MATH::\n\n                c \\cdot (\\mbox{the basis element indexed by } k)\n\n            is the leading term of ``self``.\n\n            Here 'leading term' means that the corresponding basis element is\n            maximal.  Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be\n            provided.  This should return a negative value if ``x < y``, ``0``\n            if ``x == y`` and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_item()\n                (3, 4)\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_item(cmp=cmp)\n                (1, 3)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_item()\n                ([3], -5)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_monomial": {
                    "__doc__": "\n            Return the leading monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_monomial()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_monomial(cmp=cmp)\n                B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_monomial()\n                s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_support": {
                    "__doc__": "\n            Return the maximal element of the support of ``self``. Note\n            that this may not be the term which actually appears first when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_support()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_support(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_support()\n                [3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_term": {
                    "__doc__": "\n            Return the leading term of ``self``.\n\n            This is the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_term()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_term(cmp=cmp)\n                3*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_term()\n                -5*s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "length": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.length()\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.length()\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_coefficients": {
                    "__doc__": "\n            Mapping a function on coefficients.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the coefficient ring of the\n              free module\n\n            Return a new element of ``self.parent()`` obtained by applying the\n            function ``f`` to all of the coefficients of ``self``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.map_coefficients(lambda x: x+5)\n                6*B['a'] + 2*B['c']\n\n            Killed coefficients are handled properly::\n\n                sage: f.map_coefficients(lambda x: 0)\n                0\n                sage: list(f.map_coefficients(lambda x: 0))\n                []\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_coefficients(lambda x: x*2)\n                2*s[2, 1] + 4*s[3, 2]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_item": {
                    "__doc__": "\n            Mapping a function on items.\n\n            INPUT:\n\n            - ``f`` -- a function mapping pairs ``(index, coeff)`` to\n              other such pairs\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function `f` to all items ``(index, coeff)`` of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_item(lambda i, c: (-i, 2*c))\n                6*B[-1] + 4*B[0] + 4*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_item(lambda i, c: (1, 2*c))\n                14*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = lambda m,c: (m.conjugate(), 2*c)\n                sage: a = s([2,1]) + s([1,1,1])\n                sage: a.map_item(f)\n                2*s[2, 1] + 2*s[3]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function ``f`` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support(lambda i: -i)\n                3*B[-1] + 2*B[0] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support(lambda i: 1)\n                7*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_support(lambda x: x.conjugate())\n                s[2, 1] + 2*s[2, 2, 1]\n\n            TESTS::\n\n                sage: B.zero()      # This actually failed at some point!!! See #8890\n                0\n\n                sage: y = B.zero().map_support(lambda i: i/0); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support_skip_none": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Returns a new element of ``self.parent()`` obtained by\n            applying the function `f` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support_skip_none(lambda i: -i if i else None)\n                3*B[-1] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support_skip_none(lambda i: 1 if i else None)\n                5*B[1]\n\n            TESTS::\n\n                sage: y = x.map_support_skip_none(lambda i: None); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "monomial_coefficients": {
                    "__doc__": "\n            Return a dictionary whose keys are indices of basis elements\n            in the support of ``self`` and whose values are the\n            corresponding coefficients.\n\n            INPUT:\n\n            - ``copy`` -- (default: ``True``) if ``self`` is internally\n              represented by a dictionary ``d``, then make a copy of ``d``;\n              if ``False``, then this can cause undesired behavior by\n              mutating ``d``\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a']\n                1\n                sage: d['c']\n                3\n\n            TESTS:\n\n            We check that we make a copy of the coefficient dictionary::\n\n                sage: F = CombinatorialFreeModule(ZZ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a'] = 5\n                sage: f\n                B['a'] + 3*B['c']\n            ",
                    "args": [
                        "self",
                        "copy"
                    ],
                    "argspec": [
                        [
                            "self",
                            "copy"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "monomials": {
                    "__doc__": "\n            Return a list of the monomials of ``self`` (in an arbitrary\n            order).\n\n            The monomials of an element `a` are defined to be the basis\n            elements whose corresponding coefficients of `a` are\n            non-zero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.monomials()\n                [B['a'], B['c']]\n\n                sage: (F.zero()).monomials()\n                []\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support": {
                    "__doc__": "\n            Return a list of the objects indexing the basis of\n            ``self.parent()`` whose corresponding coefficients of\n            ``self`` are non-zero.\n\n            This method returns these objects in an arbitrary order.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: sorted(f.support())\n                ['a', 'c']\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: sorted(z.support())\n                [[1], [1, 1, 1], [2, 1], [4]]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support_of_term": {
                    "__doc__": "\n            Return the support of ``self``, where ``self`` is a monomial\n            (possibly with coefficient).\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3,4]); X.rename(\"X\")\n                sage: X.monomial(2).support_of_term()\n                2\n                sage: X.term(3, 2).support_of_term()\n                3\n\n            An exception is raised if ``self`` has more than one term::\n\n                sage: (X.monomial(2) + X.monomial(3)).support_of_term()\n                Traceback (most recent call last):\n                ...\n                ValueError: B[2] + B[3] is not a single term\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "tensor": {
                    "__doc__": "\n            Return the tensor product of its arguments, as an element of\n            the tensor product of the parents of those elements.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example()\n                sage: (a,b,c) = A.algebra_generators()\n                sage: a.tensor(b, c)\n                B[word: a] # B[word: b] # B[word: c]\n\n            FIXME: is this a policy that we want to enforce on all parents?\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "elements",
                        null,
                        null
                    ]
                },
                "terms": {
                    "__doc__": "\n            Return a list of the (non-zero) terms of ``self`` (in an\n            arbitrary order).\n\n            .. SEEALSO:: :meth:`monomials`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.terms()\n                [B['a'], 2*B['c']]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "trailing_coefficient": {
                    "__doc__": "\n            Return the trailing coefficient of ``self``.\n\n            This is the coefficient of the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_coefficient()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_coefficient(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_coefficient()\n                2\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_item": {
                    "__doc__": "\n            Returns the pair ``(c, k)`` where ``c*self.parent().monomial(k)``\n            is the trailing term of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_item()\n                (1, 3)\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_item(cmp=cmp)\n                (3, 1)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_item()\n                ([1], 2)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_monomial": {
                    "__doc__": "\n            Return the trailing monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_monomial()\n                B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_monomial(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_monomial()\n                s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_support": {
                    "__doc__": "\n            Return the minimal element of the support of ``self``. Note\n            that this may not be the term which actually appears last when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, `0` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.trailing_support()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_support(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_support()\n                [1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_term": {
                    "__doc__": "\n            Return the trailing term of ``self``.\n\n            This is the term whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_term()\n                3*B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_term(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_term()\n                2*s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {
                "_on_basis": {
                    "__doc__": "\n            Return the image of ``self`` on the basis element indexed by ``i``.\n\n            INPUT:\n\n            - ``i`` -- the index of an element of the basis of the domain of ``self``\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3]); X.rename(\"X\")\n                sage: phi = End(X)(lambda x: 2*x)\n                sage: phi._on_basis(3)\n                2*B[3]\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "on_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_apply_module_endomorphism": {
                    "__doc__": "\n            This takes in a function ``on_basis`` from the basis indices\n            to the elements of ``self``, and applies it linearly to ``x``.\n\n            EXAMPLES::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = lambda part: 2*s(part.conjugate())\n                sage: s._apply_module_endomorphism( s([2,1]) + s([1,1,1]), f)\n                2*s[2, 1] + 2*s[3]\n            ",
                    "args": [
                        "self",
                        "x",
                        "on_basis"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "on_basis"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_apply_module_morphism": {
                    "__doc__": "\n            Return the image of ``x`` under the module morphism defined by\n            extending :func:`on_basis` by linearity.\n\n            INPUT:\n\n            - ``x`` -- a element of ``self``\n\n            - ``on_basis`` -- a function that takes in an object indexing\n              a basis element and returns an element of the codomain\n\n            - ``codomain`` -- (optional) the codomain of the morphism (by\n              default, it is computed using :func:`on_basis`)\n\n            If ``codomain`` is not specified, then the function tries to\n            compute the codomain of the module morphism by finding the image\n            of one of the elements in the support; hence :func:`on_basis`\n            should return an element whose parent is the codomain.\n\n            EXAMPLES::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([3]) + s([2,1]) + s([1,1,1])\n                sage: b = 2*a\n                sage: f = lambda part: Integer( len(part) )\n                sage: s._apply_module_morphism(a, f) #1+2+3\n                6\n                sage: s._apply_module_morphism(b, f) #2*(1+2+3)\n                12\n                sage: s._apply_module_morphism(s(0), f)\n                0\n                sage: s._apply_module_morphism(s(1), f)\n                0\n                sage: s._apply_module_morphism(s(1), lambda part: len(part), ZZ)\n                0\n                sage: s._apply_module_morphism(s(1), lambda part: len(part))\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain could not be determined\n            ",
                    "args": [
                        "self",
                        "x",
                        "on_basis",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "on_basis",
                            "codomain"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "_module_morphism": {
                    "__doc__": "\n            Construct a module morphism from ``self`` to ``codomain``.\n\n            Let ``self`` be a module `X` with a basis indexed by `I`.\n            This constructs a morphism `f: X \\to Y` by linearity from\n            a map `I \\to Y` which is to be its restriction to the\n            basis `(x_i)_{i \\in I}` of `X`. Some variants are possible\n            too.\n\n            INPUT:\n\n            - ``self`` -- a parent `X` in ``ModulesWithBasis(R)`` with\n              basis `x=(x_i)_{i\\in I}`.\n\n            Exactly one of the four following options must be\n            specified in order to define the morphism:\n\n            - ``on_basis`` -- a function `f` from `I` to `Y`\n            - ``diagonal`` -- a function `d` from `I` to `R`\n            - ``function`` -- a function `f` from `X` to `Y`\n            - ``matrix``   -- a matrix of size `\\dim Y \\times \\dim X`\n              (if the keyword ``side`` is set to ``'left'``) or\n              `\\dim Y \\times \\dim X` (if this keyword is ``'right'``)\n\n            Further options include:\n\n            - ``codomain`` -- the codomain `Y` of the morphism (default:\n              ``f.codomain()`` if it's defined; otherwise it must be specified)\n\n            - ``category`` -- a category or ``None`` (default: `None``)\n\n            - ``zero`` -- the zero of the codomain (default: ``codomain.zero()``);\n              can be used (with care) to define affine maps.\n              Only meaningful with ``on_basis``.\n\n            - ``position`` -- a non-negative integer specifying which\n              positional argument in used as the input of the function `f`\n              (default: 0); this is currently only used with ``on_basis``.\n\n            - ``triangular`` --  (default: ``None``) ``\"upper\"`` or\n              ``\"lower\"`` or ``None``:\n\n              * ``\"upper\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.leading_support`\n                of the image of the basis vector `x_i` is `i`, or\n\n              * ``\"lower\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.trailing_support`\n                of the image of the basis vector `x_i` is `i`.\n\n            - ``unitriangular`` -- (default: ``False``) a boolean.\n              Only meaningful for a triangular morphism.\n              As a shorthand, one may use ``unitriangular=\"lower\"``\n              for ``triangular=\"lower\", unitriangular=True``.\n\n            - ``side`` -- \"left\" or \"right\" (default: \"left\")\n              Only meaningful for a morphism built from a matrix.\n\n            EXAMPLES:\n\n            With the ``on_basis`` option, this returns a function `g`\n            obtained by extending `f` by linearity on the\n            ``position``-th positional argument. For example, for\n            ``position == 1`` and a ternary function `f`, one has:\n\n            .. MATH::\n\n                g\\left( a,\\ \\sum_i \\lambda_i x_i,\\ c \\right)\n                = \\sum_i \\lambda_i f(a, i, c).\n\n            ::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1), codomain = Y)\n                sage: x = X.basis(); y = Y.basis()\n                sage: phi(x[1] + x[3])\n                B[1] + 2*B[2] + B[3] + 2*B[4]\n\n                sage: phi\n                Generic morphism:\n                From: X\n                To:   Y\n\n            By default, the category is the first of\n            ``Modules(R).WithBasis().FiniteDimensional()``,\n            ``Modules(R).WithBasis()``, ``Modules(R)``, and\n            ``CommutativeAdditiveMonoids()`` that contains both the\n            domain and the codomain::\n\n                sage: phi.category_for()\n                Category of finite dimensional vector spaces with basis over Rational Field\n\n            With the ``zero`` argument, one can define affine morphisms::\n\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1),\n                ....:                         codomain = Y, zero = 10*y[1])\n                sage: phi(x[1] + x[3])\n                11*B[1] + 2*B[2] + B[3] + 2*B[4]\n\n            In this special case, the default category is ``Sets()``::\n\n                sage: phi.category_for()\n                Category of sets\n\n            One can construct morphisms with the base ring as codomain::\n\n                sage: X = CombinatorialFreeModule(ZZ,[1,-1])\n                sage: phi = X.module_morphism( on_basis=lambda i: i, codomain=ZZ )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (ZZ is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n            Or more generaly any ring admitting a coercion map from\n            the base ring::\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=RR )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1.00000000000000\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (RR is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                3\n\n                sage: phi = Y.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Ring of integers modulo 4) should be a module over the base ring of the domain(=Y)\n\n            On can also define module morphisms between free modules\n            over different base rings; here we implement the natural\n            map from `X = \\RR^2` to `Y = \\CC`::\n\n                sage: X = CombinatorialFreeModule(RR,['x','y'])\n                sage: Y = CombinatorialFreeModule(CC,['z'])\n                sage: x = X.monomial('x')\n                sage: y = X.monomial('y')\n                sage: z = Y.monomial('z')\n                sage: def on_basis( a ):\n                ....:     if a == 'x':\n                ....:         return CC(1) * z\n                ....:     elif a == 'y':\n                ....:         return CC(I) * z\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: v = 3 * x + 2 * y; v\n                3.00000000000000*B['x'] + 2.00000000000000*B['y']\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (CC is currently not in Modules(RR)!)\n                Category of vector spaces over Real Field with 53 bits of precision\n\n                sage: Y = CombinatorialFreeModule(CC['q'],['z'])\n                sage: z = Y.monomial('z')\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n\n            Of course, there should be a coercion between the\n            respective base rings of the domain and the codomain for\n            this to be meaningful::\n\n                sage: Y = CombinatorialFreeModule(QQ,['z'])\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'z'} over Rational Field)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n\n                sage: Y = CombinatorialFreeModule(RR['q'],['z'])\n                sage: phi = Y.module_morphism( on_basis=on_basis, codomain=X )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'z'} over Univariate Polynomial Ring in q over Real Field with 53 bits of precision)\n\n\n            With the ``diagonal=d`` argument, this constructs the\n            module morphism `g` such that\n\n            .. MATH::\n\n                `g(x_i) = d(i) y_i`.\n\n            This assumes that the respective bases `x` and `y` of `X`\n            and `Y` have the same index set `I`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, codomain=X)\n                sage: x = X.basis()\n                sage: phi(x[1]), phi(x[2]), phi(x[3])\n                (B[1], 2*B[2], 6*B[3])\n\n            See also: :class:`sage.modules.with_basis.morphism.DiagonalModuleMorphism`.\n\n            With the ``matrix=m`` argument, this constructs the module\n            morphism whose matrix in the distinguished basis of `X`\n            and `Y` is `m`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(ZZ, [3,4]); Y.rename(\"Y\"); y = Y.basis()\n                sage: m = matrix([[0,1,2],[3,5,0]])\n                sage: phi = X.module_morphism(matrix=m, codomain=Y)\n                sage: phi(x[1])\n                3*B[4]\n                sage: phi(x[2])\n                B[3] + 5*B[4]\n\n\n            See also: :class:`sage.modules.with_basis.morphism.ModuleMorphismFromMatrix`.\n\n            With ``triangular=\"upper\"``, the constructed module morphism is\n            assumed to be upper triangular; that is its matrix in the\n            distinguished basis of `X` and `Y` would be upper triangular with\n            invertible elements on its diagonal. This is used to compute\n            preimages and to invert the morphism::\n\n                sage: I = range(1,200)\n                sage: X = CombinatorialFreeModule(QQ, I); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(QQ, I); Y.rename(\"Y\"); y = Y.basis()\n                sage: f = Y.sum_of_monomials * divisors\n                sage: phi = X.module_morphism(f, triangular=\"upper\", codomain = Y)\n                sage: phi(x[2])\n                B[1] + B[2]\n                sage: phi(x[6])\n                B[1] + B[2] + B[3] + B[6]\n                sage: phi(x[30])\n                B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]\n                sage: phi.preimage(y[2])\n                -B[1] + B[2]\n                sage: phi.preimage(y[6])\n                B[1] - B[2] - B[3] + B[6]\n                sage: phi.preimage(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n                sage: (phi^-1)(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n\n            Since :trac:`8678`, one can also define a triangular\n            morphism from a function::\n\n                sage: X = CombinatorialFreeModule(QQ, [0,1,2,3,4]); x = X.basis()\n                sage: from sage.modules.with_basis.morphism import TriangularModuleMorphismFromFunction\n                sage: def f(x): return x + X.term(0, sum(x.coefficients()))\n                sage: phi = X.module_morphism(function=f, codomain=X, triangular=\"upper\")\n                sage: phi(x[2] + 3*x[4])\n                4*B[0] + B[2] + 3*B[4]\n                sage: phi.preimage(_)\n                B[2] + 3*B[4]\n\n            For details and further optional arguments, see\n            :class:`sage.modules.with_basis.morphism.TriangularModuleMorphism`.\n\n            .. WARNING::\n\n                As a temporary measure, until multivariate morphisms\n                are implemented, the constructed morphism is in\n                ``Hom(codomain, domain, category)``. This is only\n                correct for unary functions.\n\n            .. TODO::\n\n               - Should codomain be ``self`` by default in the\n                 diagonal, triangular, and matrix cases?\n\n               - Support for diagonal morphisms between modules not\n                 sharing the same index set\n\n            TESTS::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, matrix=matrix(), codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(matrix=factorial, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: matrix (=factorial) should be a matrix\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=3, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: diagonal (=3) should be a function\n\n            ",
                    "args": [
                        "self",
                        "on_basis",
                        "matrix",
                        "function",
                        "diagonal",
                        "triangular",
                        "unitriangular"
                    ],
                    "argspec": [
                        [
                            "self",
                            "on_basis",
                            "matrix",
                            "function",
                            "diagonal",
                            "triangular",
                            "unitriangular"
                        ],
                        null,
                        "keywords",
                        [
                            null,
                            null,
                            null,
                            null,
                            null,
                            false
                        ]
                    ]
                },
                "_repr_": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: class FooBar(CombinatorialFreeModule): pass\n                sage: C = FooBar(QQ, (1,2,3)); C # indirect doctest\n                Free module generated by {1, 2, 3} over Rational Field\n\n                sage: C._name = \"foobar\"; C\n                foobar over Rational Field\n\n                sage: C.rename(\"barfoo\"); C\n                barfoo\n\n                sage: class FooBar(Parent):\n                ....:     def basis(self): return Family({1:\"foo\", 2:\"bar\"})\n                ....:     def base_ring(self): return QQ\n                sage: FooBar(category = ModulesWithBasis(QQ))\n                Free module generated by [1, 2] over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_sum_of_monomials": {
                    "__doc__": "\n            TESTS::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])\n                sage: F._sum_of_monomials(['a', 'b'])\n                B['a'] + B['b']\n            ",
                    "args": [
                        "self",
                        "indices"
                    ],
                    "argspec": [
                        [
                            "self",
                            "indices"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "echelon_form": {
                    "__doc__": "\n            Return a basis in echelon form of the subspace spanned by\n            a finite set of elements.\n\n            INPUT:\n\n            - ``elements`` -- a list or finite iterable of elements of ``self``\n            - ``row_reduced`` -- (default: ``False``) whether to compute the\n              basis for the row reduced echelon form\n\n            OUTPUT:\n\n            A list of elements of ``self`` whose expressions as\n            vectors form a matrix in echelon form. If ``base_ring`` is\n            specified, then the calculation is achieved in this base\n            ring.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: V = X.echelon_form([x[0]-x[1], x[0]-x[2],x[1]-x[2]]); V\n                [x[0] - x[2], x[1] - x[2]]\n                sage: matrix(map(vector, V))\n                [ 1  0 -1]\n                [ 0  1 -1]\n\n            ::\n\n                sage: F = CombinatorialFreeModule(ZZ, [1,2,3,4])\n                sage: B = F.basis()\n                sage: elements = [B[1]-17*B[2]+6*B[3], B[1]-17*B[2]+B[4]]\n                sage: F.echelon_form(elements)\n                [B[1] - 17*B[2] + B[4], 6*B[3] - B[4]]\n\n            ::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: a,b,c = F.basis()\n                sage: F.echelon_form([8*a+b+10*c, -3*a+b-c, a-b-c])\n                [B['a'] + B['c'], B['b'] + 2*B['c']]\n\n            ::\n\n                sage: R.<x,y> = QQ[]\n                sage: C = CombinatorialFreeModule(R, range(3), prefix='x')\n                sage: x = C.basis()\n                sage: C.echelon_form([x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]])\n                [x[0] - x[2], x[1] - x[2]]\n            ",
                    "args": [
                        "self",
                        "elements",
                        "row_reduced"
                    ],
                    "argspec": [
                        [
                            "self",
                            "elements",
                            "row_reduced"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "linear_combination": {
                    "__doc__": "\n            Return the linear combination `\\lambda_1 v_1 + \\cdots +\n            \\lambda_k v_k` (resp.  the linear combination `v_1 \\lambda_1 +\n            \\cdots + v_k \\lambda_k`) where ``iter_of_elements_coeff`` iterates\n            through the sequence `((\\lambda_1, v_1), ..., (\\lambda_k, v_k))`.\n\n            INPUT:\n\n            - ``iter_of_elements_coeff`` -- iterator of pairs\n              ``(element, coeff)`` with ``element`` in ``self`` and\n              ``coeff`` in ``self.base_ring()``\n\n            - ``factor_on_left`` -- (optional) if ``True``, the coefficients\n              are multiplied from the left; if ``False``, the coefficients\n              are multiplied from the right\n\n            EXAMPLES::\n\n                sage: m = matrix([[0,1],[1,1]])\n                sage: J.<a,b,c> = JordanAlgebra(m)\n                sage: J.linear_combination(((a+b, 1), (-2*b + c, -1)))\n                1 + (3, -1)\n            ",
                    "args": [
                        "self",
                        "iter_of_elements_coeff",
                        "factor_on_left"
                    ],
                    "argspec": [
                        [
                            "self",
                            "iter_of_elements_coeff",
                            "factor_on_left"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "module_morphism": {
                    "__doc__": "\n            Construct a module morphism from ``self`` to ``codomain``.\n\n            Let ``self`` be a module `X` with a basis indexed by `I`.\n            This constructs a morphism `f: X \\to Y` by linearity from\n            a map `I \\to Y` which is to be its restriction to the\n            basis `(x_i)_{i \\in I}` of `X`. Some variants are possible\n            too.\n\n            INPUT:\n\n            - ``self`` -- a parent `X` in ``ModulesWithBasis(R)`` with\n              basis `x=(x_i)_{i\\in I}`.\n\n            Exactly one of the four following options must be\n            specified in order to define the morphism:\n\n            - ``on_basis`` -- a function `f` from `I` to `Y`\n            - ``diagonal`` -- a function `d` from `I` to `R`\n            - ``function`` -- a function `f` from `X` to `Y`\n            - ``matrix``   -- a matrix of size `\\dim Y \\times \\dim X`\n              (if the keyword ``side`` is set to ``'left'``) or\n              `\\dim Y \\times \\dim X` (if this keyword is ``'right'``)\n\n            Further options include:\n\n            - ``codomain`` -- the codomain `Y` of the morphism (default:\n              ``f.codomain()`` if it's defined; otherwise it must be specified)\n\n            - ``category`` -- a category or ``None`` (default: `None``)\n\n            - ``zero`` -- the zero of the codomain (default: ``codomain.zero()``);\n              can be used (with care) to define affine maps.\n              Only meaningful with ``on_basis``.\n\n            - ``position`` -- a non-negative integer specifying which\n              positional argument in used as the input of the function `f`\n              (default: 0); this is currently only used with ``on_basis``.\n\n            - ``triangular`` --  (default: ``None``) ``\"upper\"`` or\n              ``\"lower\"`` or ``None``:\n\n              * ``\"upper\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.leading_support`\n                of the image of the basis vector `x_i` is `i`, or\n\n              * ``\"lower\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.trailing_support`\n                of the image of the basis vector `x_i` is `i`.\n\n            - ``unitriangular`` -- (default: ``False``) a boolean.\n              Only meaningful for a triangular morphism.\n              As a shorthand, one may use ``unitriangular=\"lower\"``\n              for ``triangular=\"lower\", unitriangular=True``.\n\n            - ``side`` -- \"left\" or \"right\" (default: \"left\")\n              Only meaningful for a morphism built from a matrix.\n\n            EXAMPLES:\n\n            With the ``on_basis`` option, this returns a function `g`\n            obtained by extending `f` by linearity on the\n            ``position``-th positional argument. For example, for\n            ``position == 1`` and a ternary function `f`, one has:\n\n            .. MATH::\n\n                g\\left( a,\\ \\sum_i \\lambda_i x_i,\\ c \\right)\n                = \\sum_i \\lambda_i f(a, i, c).\n\n            ::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1), codomain = Y)\n                sage: x = X.basis(); y = Y.basis()\n                sage: phi(x[1] + x[3])\n                B[1] + 2*B[2] + B[3] + 2*B[4]\n\n                sage: phi\n                Generic morphism:\n                From: X\n                To:   Y\n\n            By default, the category is the first of\n            ``Modules(R).WithBasis().FiniteDimensional()``,\n            ``Modules(R).WithBasis()``, ``Modules(R)``, and\n            ``CommutativeAdditiveMonoids()`` that contains both the\n            domain and the codomain::\n\n                sage: phi.category_for()\n                Category of finite dimensional vector spaces with basis over Rational Field\n\n            With the ``zero`` argument, one can define affine morphisms::\n\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1),\n                ....:                         codomain = Y, zero = 10*y[1])\n                sage: phi(x[1] + x[3])\n                11*B[1] + 2*B[2] + B[3] + 2*B[4]\n\n            In this special case, the default category is ``Sets()``::\n\n                sage: phi.category_for()\n                Category of sets\n\n            One can construct morphisms with the base ring as codomain::\n\n                sage: X = CombinatorialFreeModule(ZZ,[1,-1])\n                sage: phi = X.module_morphism( on_basis=lambda i: i, codomain=ZZ )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (ZZ is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n            Or more generaly any ring admitting a coercion map from\n            the base ring::\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=RR )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1.00000000000000\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (RR is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                3\n\n                sage: phi = Y.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Ring of integers modulo 4) should be a module over the base ring of the domain(=Y)\n\n            On can also define module morphisms between free modules\n            over different base rings; here we implement the natural\n            map from `X = \\RR^2` to `Y = \\CC`::\n\n                sage: X = CombinatorialFreeModule(RR,['x','y'])\n                sage: Y = CombinatorialFreeModule(CC,['z'])\n                sage: x = X.monomial('x')\n                sage: y = X.monomial('y')\n                sage: z = Y.monomial('z')\n                sage: def on_basis( a ):\n                ....:     if a == 'x':\n                ....:         return CC(1) * z\n                ....:     elif a == 'y':\n                ....:         return CC(I) * z\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: v = 3 * x + 2 * y; v\n                3.00000000000000*B['x'] + 2.00000000000000*B['y']\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (CC is currently not in Modules(RR)!)\n                Category of vector spaces over Real Field with 53 bits of precision\n\n                sage: Y = CombinatorialFreeModule(CC['q'],['z'])\n                sage: z = Y.monomial('z')\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n\n            Of course, there should be a coercion between the\n            respective base rings of the domain and the codomain for\n            this to be meaningful::\n\n                sage: Y = CombinatorialFreeModule(QQ,['z'])\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'z'} over Rational Field)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n\n                sage: Y = CombinatorialFreeModule(RR['q'],['z'])\n                sage: phi = Y.module_morphism( on_basis=on_basis, codomain=X )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'z'} over Univariate Polynomial Ring in q over Real Field with 53 bits of precision)\n\n\n            With the ``diagonal=d`` argument, this constructs the\n            module morphism `g` such that\n\n            .. MATH::\n\n                `g(x_i) = d(i) y_i`.\n\n            This assumes that the respective bases `x` and `y` of `X`\n            and `Y` have the same index set `I`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, codomain=X)\n                sage: x = X.basis()\n                sage: phi(x[1]), phi(x[2]), phi(x[3])\n                (B[1], 2*B[2], 6*B[3])\n\n            See also: :class:`sage.modules.with_basis.morphism.DiagonalModuleMorphism`.\n\n            With the ``matrix=m`` argument, this constructs the module\n            morphism whose matrix in the distinguished basis of `X`\n            and `Y` is `m`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(ZZ, [3,4]); Y.rename(\"Y\"); y = Y.basis()\n                sage: m = matrix([[0,1,2],[3,5,0]])\n                sage: phi = X.module_morphism(matrix=m, codomain=Y)\n                sage: phi(x[1])\n                3*B[4]\n                sage: phi(x[2])\n                B[3] + 5*B[4]\n\n\n            See also: :class:`sage.modules.with_basis.morphism.ModuleMorphismFromMatrix`.\n\n            With ``triangular=\"upper\"``, the constructed module morphism is\n            assumed to be upper triangular; that is its matrix in the\n            distinguished basis of `X` and `Y` would be upper triangular with\n            invertible elements on its diagonal. This is used to compute\n            preimages and to invert the morphism::\n\n                sage: I = range(1,200)\n                sage: X = CombinatorialFreeModule(QQ, I); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(QQ, I); Y.rename(\"Y\"); y = Y.basis()\n                sage: f = Y.sum_of_monomials * divisors\n                sage: phi = X.module_morphism(f, triangular=\"upper\", codomain = Y)\n                sage: phi(x[2])\n                B[1] + B[2]\n                sage: phi(x[6])\n                B[1] + B[2] + B[3] + B[6]\n                sage: phi(x[30])\n                B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]\n                sage: phi.preimage(y[2])\n                -B[1] + B[2]\n                sage: phi.preimage(y[6])\n                B[1] - B[2] - B[3] + B[6]\n                sage: phi.preimage(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n                sage: (phi^-1)(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n\n            Since :trac:`8678`, one can also define a triangular\n            morphism from a function::\n\n                sage: X = CombinatorialFreeModule(QQ, [0,1,2,3,4]); x = X.basis()\n                sage: from sage.modules.with_basis.morphism import TriangularModuleMorphismFromFunction\n                sage: def f(x): return x + X.term(0, sum(x.coefficients()))\n                sage: phi = X.module_morphism(function=f, codomain=X, triangular=\"upper\")\n                sage: phi(x[2] + 3*x[4])\n                4*B[0] + B[2] + 3*B[4]\n                sage: phi.preimage(_)\n                B[2] + 3*B[4]\n\n            For details and further optional arguments, see\n            :class:`sage.modules.with_basis.morphism.TriangularModuleMorphism`.\n\n            .. WARNING::\n\n                As a temporary measure, until multivariate morphisms\n                are implemented, the constructed morphism is in\n                ``Hom(codomain, domain, category)``. This is only\n                correct for unary functions.\n\n            .. TODO::\n\n               - Should codomain be ``self`` by default in the\n                 diagonal, triangular, and matrix cases?\n\n               - Support for diagonal morphisms between modules not\n                 sharing the same index set\n\n            TESTS::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, matrix=matrix(), codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(matrix=factorial, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: matrix (=factorial) should be a matrix\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=3, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: diagonal (=3) should be a function\n\n            ",
                    "args": [
                        "self",
                        "on_basis",
                        "matrix",
                        "function",
                        "diagonal",
                        "triangular",
                        "unitriangular"
                    ],
                    "argspec": [
                        [
                            "self",
                            "on_basis",
                            "matrix",
                            "function",
                            "diagonal",
                            "triangular",
                            "unitriangular"
                        ],
                        null,
                        "keywords",
                        [
                            null,
                            null,
                            null,
                            null,
                            null,
                            false
                        ]
                    ]
                },
                "monomial": {
                    "__doc__": "\n            Return the basis element indexed by ``i``.\n\n            INPUT:\n\n            - ``i`` -- an element of the index set\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])\n                sage: F.monomial('a')\n                B['a']\n\n            ``F.monomial`` is in fact (almost) a map::\n\n                sage: F.monomial\n                Term map from {'a', 'b', 'c'} to Free module generated by {'a', 'b', 'c'} over Rational Field\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "monomial_or_zero_if_none": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])\n                sage: F.monomial_or_zero_if_none('a')\n                B['a']\n                sage: F.monomial_or_zero_if_none(None)\n                0\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "submodule": {
                    "__doc__": "\n            The submodule spanned by a finite set of elements.\n\n            INPUT:\n\n            - ``gens`` -- a list or family of elements of ``self``\n\n            - ``check`` -- (default: ``True``) whether to verify that the\n               elements of ``gens`` are in ``self``\n\n            - ``already_echelonized`` -- (default: ``False``) whether\n               the elements of ``gens`` are already in (not necessarily\n               reduced) echelon form\n\n            - ``unitrangular`` -- (default: ``False``) whether\n              the lift morphism is unitrangular\n\n            If ``already_echelonized`` is ``False``, then the\n            generators are put in reduced echelon form using\n            :meth:`echelonize`, and reindexed by `0,1,...`.\n\n            .. WARNING::\n\n                At this point, this method only works for finite\n                dimensional submodules and if matrices can be\n                echelonized over the base ring.\n\n            If in addition ``unitriangular`` is ``True``, then\n            the generators are made such that the coefficients of\n            the pivots are 1, so that lifting map is unitriangular.\n\n            The basis of the submodule uses the same index set as the\n            generators, and the lifting map sends `y_i` to `gens[i]`.\n\n\n            .. SEEALSO::\n\n                 - :meth:`ModulesWithBasis.FiniteDimensional.ParentMethods.quotient_module`\n                 - :class:`sage.modules.with_basis.subquotient.SubmoduleWithBasis`\n\n            EXAMPLES:\n\n            We construct a submodule of the free `\\QQ`-module generated by\n            `x_0, x_1, x_2`. The submodule is spanned by `y_0 = x_0 - x_1` and\n            `y_1 - x_1 - x_2`, and its basis elements are indexed by `0` and `1`::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: gens = [x[0] - x[1], x[1] - x[2]]; gens\n                [x[0] - x[1], x[1] - x[2]]\n                sage: Y = X.submodule(gens, already_echelonized=True)\n                sage: Y.print_options(prefix='y'); Y\n                Free module generated by {0, 1} over Rational Field\n                sage: y = Y.basis()\n                sage: y[1]\n                y[1]\n                sage: y[1].lift()\n                x[1] - x[2]\n                sage: Y.retract(x[0]-x[2])\n                y[0] + y[1]\n                sage: Y.retract(x[0])\n                Traceback (most recent call last):\n                ...\n                ValueError: x[0] is not in the image\n\n            By using a family to specify a basis of the submodule, we obtain a\n            submodule whose index set coincides with the index set of the family::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: gens = Family({1 : x[0] - x[1], 3: x[1] - x[2]}); gens\n                Finite family {1: x[0] - x[1], 3: x[1] - x[2]}\n                sage: Y = X.submodule(gens, already_echelonized=True)\n                sage: Y.print_options(prefix='y'); Y\n                Free module generated by {1, 3} over Rational Field\n                sage: y = Y.basis()\n                sage: y[1]\n                y[1]\n                sage: y[1].lift()\n                x[0] - x[1]\n                sage: y[3].lift()\n                x[1] - x[2]\n                sage: Y.retract(x[0]-x[2])\n                y[1] + y[3]\n                sage: Y.retract(x[0])\n                Traceback (most recent call last):\n                ...\n                ValueError: x[0] is not in the image\n\n            It is not necessary that the generators of the submodule form\n            a basis (an explicit basis will be computed)::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: gens = [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]; gens\n                [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]\n                sage: Y = X.submodule(gens, already_echelonized=False)\n                sage: Y.print_options(prefix='y')\n                sage: Y\n                Free module generated by {0, 1} over Rational Field\n                sage: [b.lift() for b in Y.basis()]\n                [x[0] - x[2], x[1] - x[2]]\n\n            We now implement by hand the center of the algebra of the\n            symmetric group `S_3`::\n\n                sage: S3 = SymmetricGroup(3)\n                sage: S3A = S3.algebra(QQ)\n                sage: basis = S3A.annihilator_basis(S3A.algebra_generators(), S3A.bracket)\n                sage: basis\n                ((), (2,3) + (1,2) + (1,3), (1,2,3) + (1,3,2))\n                sage: center = S3A.submodule(basis,\n                ....:                        category=AlgebrasWithBasis(QQ).Subobjects(),\n                ....:                        already_echelonized=True)\n                sage: center\n                Free module generated by {0, 1, 2} over Rational Field\n                sage: center in Algebras\n                True\n                sage: center.print_options(prefix='c')\n                sage: c = center.basis()\n                sage: c[1].lift()\n                (2,3) + (1,2) + (1,3)\n                sage: c[0]^2\n                c[0]\n                sage: e = 1/6*(c[0]+c[1]+c[2])\n                sage: e.is_idempotent()\n                True\n\n            Of course, this center is best constructed using::\n\n                sage: center = S3A.center()\n\n            We can also automatically construct a basis such that\n            the lift morphism is (lower) unitriangular::\n\n                sage: R.<a,b> = QQ[]\n                sage: C = CombinatorialFreeModule(R, range(3), prefix='x')\n                sage: x = C.basis()\n                sage: gens = [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]\n                sage: Y = C.submodule(gens, unitriangular=True)\n                sage: Y.lift.matrix()\n                [ 1  0]\n                [ 0  1]\n                [-1 -1]\n\n            TESTS::\n\n                sage: TestSuite(Y).run()\n                sage: TestSuite(center).run()\n            ",
                    "args": [
                        "self",
                        "gens",
                        "check",
                        "already_echelonized",
                        "unitriangular",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "gens",
                            "check",
                            "already_echelonized",
                            "unitriangular",
                            "category"
                        ],
                        null,
                        null,
                        [
                            true,
                            false,
                            false,
                            null
                        ]
                    ]
                },
                "sum_of_terms": {
                    "__doc__": "\n            Construct a sum of terms of ``self``.\n\n            INPUT:\n\n            - ``terms`` -- a list (or iterable) of pairs ``(index, coeff)``\n\n            OUTPUT:\n\n            Sum of ``coeff * B[index]`` over all ``(index, coeff)`` in\n            ``terms``, where ``B`` is the basis of ``self``.\n\n            EXAMPLES::\n\n                sage: m = matrix([[0,1],[1,1]])\n                sage: J.<a,b,c> = JordanAlgebra(m)\n                sage: J.sum_of_terms([(0, 2), (2, -3)])\n                2 + (0, -3)\n            ",
                    "args": [
                        "self",
                        "terms"
                    ],
                    "argspec": [
                        [
                            "self",
                            "terms"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "tensor": {
                    "__doc__": "\n            Return the tensor product of the parents.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example(); A.rename(\"A\")\n                sage: A.tensor(A,A)\n                A # A # A\n                sage: A.rename(None)\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "parents",
                        null,
                        null
                    ]
                },
                "term": {
                    "__doc__": "\n            Construct a term in ``self``.\n\n            INPUT:\n\n            - ``index`` -- the index of a basis element\n            - ``coeff`` -- an element of the coefficient ring (default: one)\n\n            OUTPUT:\n\n            ``coeff * B[index]``, where ``B`` is the basis of ``self``.\n\n            EXAMPLES::\n\n                sage: m = matrix([[0,1],[1,1]])\n                sage: J.<a,b,c> = JordanAlgebra(m)\n                sage: J.term(1, -2)\n                0 + (-2, 0)\n\n            Design: should this do coercion on the coefficient ring?\n            ",
                    "args": [
                        "self",
                        "index",
                        "coeff"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index",
                            "coeff"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "__getitem__": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self``.\n\n            EXAMPLES::\n\n                sage: p = Partition([2,1])\n                sage: q = Partition([1,1,1])\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s(p)\n                sage: a._coefficient_fast([2,1])\n                Traceback (most recent call last):\n                ...\n                TypeError: unhashable type: 'list'\n\n            ::\n\n                sage: a._coefficient_fast(p)\n                1\n                sage: a._coefficient_fast(q)\n                0\n                sage: a[p]\n                1\n                sage: a[q]\n                0\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__len__": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: len(f)\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: len(z)\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficient": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self`` and raise an error\n            if ``m`` is not in the basis indexing set.\n\n            INPUT:\n\n            - ``m`` -- a basis index of the parent of ``self``\n\n            OUTPUT:\n\n            The ``B[m]``-coordinate of ``self`` with respect to the basis\n            ``B``. Here, ``B`` denotes the given basis of the parent of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: s = CombinatorialFreeModule(QQ, Partitions())\n                sage: z = s([4]) - 2*s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficient([4])\n                1\n                sage: z.coefficient([2,1])\n                -2\n                sage: z.coefficient(Partition([2,1]))\n                -2\n                sage: z.coefficient([1,2])\n                Traceback (most recent call last):\n                ...\n                AssertionError: [1, 2] should be an element of Partitions\n                sage: z.coefficient(Composition([2,1]))\n                Traceback (most recent call last):\n                ...\n                AssertionError: [2, 1] should be an element of Partitions\n\n            Test that ``coefficient`` also works for those parents that do\n            not yet have an element_class::\n\n                sage: G = DihedralGroup(3)\n                sage: F = CombinatorialFreeModule(QQ, G)\n                sage: hasattr(G, \"element_class\")\n                False\n                sage: g = G.an_element()\n                sage: (2*F.monomial(g)).coefficient(g)\n                2\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficients": {
                    "__doc__": "\n            Return a list of the (non-zero) coefficients appearing on\n            the basis elements in ``self`` (in an arbitrary order).\n\n            INPUT:\n\n            - ``sort`` -- (default: ``True``) to sort the coefficients\n              based upon the default ordering of the indexing set\n\n            .. SEEALSO::\n\n                :meth:`~sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis.ElementMethods.dense_coefficient_list`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.coefficients()\n                [1, -3]\n                sage: f = B['c'] - 3*B['a']\n                sage: f.coefficients()\n                [-3, 1]\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficients()\n                [1, 1, 1, 1]\n            ",
                    "args": [
                        "self",
                        "sort"
                    ],
                    "argspec": [
                        [
                            "self",
                            "sort"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "is_zero": {
                    "__doc__": "\n            Return ``True`` if and only if ``self == 0``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.is_zero()\n                False\n                sage: F.zero().is_zero()\n                True\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: s([2,1]).is_zero()\n                False\n                sage: s(0).is_zero()\n                True\n                sage: (s([2,1]) - s([2,1])).is_zero()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "leading_coefficient": {
                    "__doc__": "\n            Returns the leading coefficient of ``self``.\n\n            This is the coefficient of the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\")\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_coefficient()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_coefficient(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_coefficient()\n                -5\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_item": {
                    "__doc__": "\n            Return the pair ``(k, c)`` where\n\n            .. MATH::\n\n                c \\cdot (\\mbox{the basis element indexed by } k)\n\n            is the leading term of ``self``.\n\n            Here 'leading term' means that the corresponding basis element is\n            maximal.  Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be\n            provided.  This should return a negative value if ``x < y``, ``0``\n            if ``x == y`` and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_item()\n                (3, 4)\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_item(cmp=cmp)\n                (1, 3)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_item()\n                ([3], -5)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_monomial": {
                    "__doc__": "\n            Return the leading monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_monomial()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_monomial(cmp=cmp)\n                B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_monomial()\n                s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_support": {
                    "__doc__": "\n            Return the maximal element of the support of ``self``. Note\n            that this may not be the term which actually appears first when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_support()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_support(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_support()\n                [3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_term": {
                    "__doc__": "\n            Return the leading term of ``self``.\n\n            This is the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_term()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_term(cmp=cmp)\n                3*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_term()\n                -5*s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "length": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.length()\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.length()\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_coefficients": {
                    "__doc__": "\n            Mapping a function on coefficients.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the coefficient ring of the\n              free module\n\n            Return a new element of ``self.parent()`` obtained by applying the\n            function ``f`` to all of the coefficients of ``self``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.map_coefficients(lambda x: x+5)\n                6*B['a'] + 2*B['c']\n\n            Killed coefficients are handled properly::\n\n                sage: f.map_coefficients(lambda x: 0)\n                0\n                sage: list(f.map_coefficients(lambda x: 0))\n                []\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_coefficients(lambda x: x*2)\n                2*s[2, 1] + 4*s[3, 2]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_item": {
                    "__doc__": "\n            Mapping a function on items.\n\n            INPUT:\n\n            - ``f`` -- a function mapping pairs ``(index, coeff)`` to\n              other such pairs\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function `f` to all items ``(index, coeff)`` of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_item(lambda i, c: (-i, 2*c))\n                6*B[-1] + 4*B[0] + 4*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_item(lambda i, c: (1, 2*c))\n                14*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = lambda m,c: (m.conjugate(), 2*c)\n                sage: a = s([2,1]) + s([1,1,1])\n                sage: a.map_item(f)\n                2*s[2, 1] + 2*s[3]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function ``f`` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support(lambda i: -i)\n                3*B[-1] + 2*B[0] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support(lambda i: 1)\n                7*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_support(lambda x: x.conjugate())\n                s[2, 1] + 2*s[2, 2, 1]\n\n            TESTS::\n\n                sage: B.zero()      # This actually failed at some point!!! See #8890\n                0\n\n                sage: y = B.zero().map_support(lambda i: i/0); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support_skip_none": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Returns a new element of ``self.parent()`` obtained by\n            applying the function `f` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support_skip_none(lambda i: -i if i else None)\n                3*B[-1] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support_skip_none(lambda i: 1 if i else None)\n                5*B[1]\n\n            TESTS::\n\n                sage: y = x.map_support_skip_none(lambda i: None); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "monomial_coefficients": {
                    "__doc__": "\n            Return a dictionary whose keys are indices of basis elements\n            in the support of ``self`` and whose values are the\n            corresponding coefficients.\n\n            INPUT:\n\n            - ``copy`` -- (default: ``True``) if ``self`` is internally\n              represented by a dictionary ``d``, then make a copy of ``d``;\n              if ``False``, then this can cause undesired behavior by\n              mutating ``d``\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a']\n                1\n                sage: d['c']\n                3\n\n            TESTS:\n\n            We check that we make a copy of the coefficient dictionary::\n\n                sage: F = CombinatorialFreeModule(ZZ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a'] = 5\n                sage: f\n                B['a'] + 3*B['c']\n            ",
                    "args": [
                        "self",
                        "copy"
                    ],
                    "argspec": [
                        [
                            "self",
                            "copy"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "monomials": {
                    "__doc__": "\n            Return a list of the monomials of ``self`` (in an arbitrary\n            order).\n\n            The monomials of an element `a` are defined to be the basis\n            elements whose corresponding coefficients of `a` are\n            non-zero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.monomials()\n                [B['a'], B['c']]\n\n                sage: (F.zero()).monomials()\n                []\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support": {
                    "__doc__": "\n            Return a list of the objects indexing the basis of\n            ``self.parent()`` whose corresponding coefficients of\n            ``self`` are non-zero.\n\n            This method returns these objects in an arbitrary order.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: sorted(f.support())\n                ['a', 'c']\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: sorted(z.support())\n                [[1], [1, 1, 1], [2, 1], [4]]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support_of_term": {
                    "__doc__": "\n            Return the support of ``self``, where ``self`` is a monomial\n            (possibly with coefficient).\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3,4]); X.rename(\"X\")\n                sage: X.monomial(2).support_of_term()\n                2\n                sage: X.term(3, 2).support_of_term()\n                3\n\n            An exception is raised if ``self`` has more than one term::\n\n                sage: (X.monomial(2) + X.monomial(3)).support_of_term()\n                Traceback (most recent call last):\n                ...\n                ValueError: B[2] + B[3] is not a single term\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "tensor": {
                    "__doc__": "\n            Return the tensor product of its arguments, as an element of\n            the tensor product of the parents of those elements.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example()\n                sage: (a,b,c) = A.algebra_generators()\n                sage: a.tensor(b, c)\n                B[word: a] # B[word: b] # B[word: c]\n\n            FIXME: is this a policy that we want to enforce on all parents?\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "elements",
                        null,
                        null
                    ]
                },
                "terms": {
                    "__doc__": "\n            Return a list of the (non-zero) terms of ``self`` (in an\n            arbitrary order).\n\n            .. SEEALSO:: :meth:`monomials`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.terms()\n                [B['a'], 2*B['c']]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "trailing_coefficient": {
                    "__doc__": "\n            Return the trailing coefficient of ``self``.\n\n            This is the coefficient of the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_coefficient()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_coefficient(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_coefficient()\n                2\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_item": {
                    "__doc__": "\n            Returns the pair ``(c, k)`` where ``c*self.parent().monomial(k)``\n            is the trailing term of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_item()\n                (1, 3)\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_item(cmp=cmp)\n                (3, 1)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_item()\n                ([1], 2)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_monomial": {
                    "__doc__": "\n            Return the trailing monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_monomial()\n                B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_monomial(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_monomial()\n                s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_support": {
                    "__doc__": "\n            Return the minimal element of the support of ``self``. Note\n            that this may not be the term which actually appears last when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, `0` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.trailing_support()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_support(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_support()\n                [1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_term": {
                    "__doc__": "\n            Return the trailing term of ``self``.\n\n            This is the term whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_term()\n                3*B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_term(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_term()\n                2*s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "mmt.AdditiveMagmas.GAP",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.AdditiveUnital.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "mmt.AdditiveSemigroups.GAP",
            "mmt.AdditiveUnital.GAP",
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.Modules.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.AdditiveInverse",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces.WithBasis",
            "sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts",
            "sage.categories.vector_spaces.VectorSpaces.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.WithBasis.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas.CartesianProducts",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Unital.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "Distributive",
            "AdditiveUnital",
            "AdditiveAssociative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative",
            "sage.categories.commutative_additive_monoids.CommutativeAdditiveMonoids"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.AdditiveInverse"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.AdditiveInverse.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of (abstract) vector spaces over a given field\n\n    ??? with an embedding in an ambient vector space ???\n\n    EXAMPLES::\n\n        sage: VectorSpaces(QQ)\n        Category of vector spaces over Rational Field\n        sage: VectorSpaces(QQ).super_categories()\n        [Category of modules over Rational Field]\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of (abstract) vector spaces over a given field\n\n    ??? with an embedding in an ambient vector space ???\n\n    EXAMPLES::\n\n        sage: VectorSpaces(QQ)\n        Category of vector spaces over Rational Field\n        sage: VectorSpaces(QQ).super_categories()\n        [Category of modules over Rational Field]\n    ",
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "GAP",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "mmt.Magmas.GAP",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.Unital.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveAssociative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.CartesianProducts",
            "sage.categories.additive_semigroups.AdditiveSemigroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_semigroups.AdditiveSemigroups.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups.CartesianProducts",
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "base_ring": {
                    "__doc__": "\n                Return the base ring of this Cartesian product.\n\n                EXAMPLES::\n\n                    sage: E = CombinatorialFreeModule(ZZ, [1,2,3])\n                    sage: F = CombinatorialFreeModule(ZZ, [2,3,4])\n                    sage: C = cartesian_product([E, F]); C\n                    Free module generated by {1, 2, 3} over Integer Ring (+)\n                    Free module generated by {2, 3, 4} over Integer Ring\n                    sage: C.base_ring()\n                    Integer Ring\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas.Realizations",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Unital.Realizations",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "Distributive",
            "AdditiveUnital",
            "AdditiveAssociative",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital",
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.magmatic_algebras.MagmaticAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "algebra_generators": {
                    "__doc__": "\n            Return a family of generators of this algebra.\n\n            EXAMPLES::\n\n                sage: F = AlgebrasWithBasis(QQ).example(); F\n                An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n                sage: F.algebra_generators()\n                Family (B[word: a], B[word: b], B[word: c])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas.Algebras",
            "sage.categories.magmas.Magmas.Commutative"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Commutative.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of compact topological spaces.\n        ",
        "axioms": [
            "Compact"
        ],
        "element_class": {
            "__doc__": "\n        The category of compact topological spaces.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of compact topological spaces.\n        ",
            "methods": {}
        },
        "name": "sage.categories.topological_spaces.TopologicalSpaces.Compact",
        "parent_class": {
            "__doc__": "\n        The category of compact topological spaces.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.topological_spaces.TopologicalSpaces",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of compact topological spaces.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces.WithBasis",
            "sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts",
            "sage.categories.vector_spaces.VectorSpaces.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.WithBasis.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveAssociative",
            "AdditiveUnital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Homsets",
            "sage.categories.additive_monoids.AdditiveMonoids"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_monoids.AdditiveMonoids.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Homsets",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_monoids.AdditiveMonoids.Homsets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules",
            "sage.categories.homsets.HomsetsOf"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "base_ring": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.homsets.HomsetsOf",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modules.Modules.Homsets"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all homsets.\n\n    EXAMPLES::\n\n        sage: from sage.categories.homsets import Homsets\n        sage: Homsets()\n        Category of homsets\n\n    This is a subcategory of ``Sets()``::\n\n        sage: Homsets().super_categories()\n        [Category of sets]\n\n    By this, we assume that all homsets implemented in Sage are sets,\n    or equivalently that we only implement locally small categories.\n    See :wikipedia:`Category_(mathematics)`.\n\n    :trac:`17364`: every homset category shall be a subcategory of the\n    category of all homsets::\n\n        sage: Schemes().Homsets().is_subcategory(Homsets())\n        True\n        sage: AdditiveMagmas().Homsets().is_subcategory(Homsets())\n        True\n        sage: AdditiveMagmas().AdditiveUnital().Homsets().is_subcategory(Homsets())\n        True\n\n    This is tested in :meth:`HomsetsCategory._test_homsets_category`.\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of all homsets.\n\n    EXAMPLES::\n\n        sage: from sage.categories.homsets import Homsets\n        sage: Homsets()\n        Category of homsets\n\n    This is a subcategory of ``Sets()``::\n\n        sage: Homsets().super_categories()\n        [Category of sets]\n\n    By this, we assume that all homsets implemented in Sage are sets,\n    or equivalently that we only implement locally small categories.\n    See :wikipedia:`Category_(mathematics)`.\n\n    :trac:`17364`: every homset category shall be a subcategory of the\n    category of all homsets::\n\n        sage: Schemes().Homsets().is_subcategory(Homsets())\n        True\n        sage: AdditiveMagmas().Homsets().is_subcategory(Homsets())\n        True\n        sage: AdditiveMagmas().AdditiveUnital().Homsets().is_subcategory(Homsets())\n        True\n\n    This is tested in :meth:`HomsetsCategory._test_homsets_category`.\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of all homsets.\n\n    EXAMPLES::\n\n        sage: from sage.categories.homsets import Homsets\n        sage: Homsets()\n        Category of homsets\n\n    This is a subcategory of ``Sets()``::\n\n        sage: Homsets().super_categories()\n        [Category of sets]\n\n    By this, we assume that all homsets implemented in Sage are sets,\n    or equivalently that we only implement locally small categories.\n    See :wikipedia:`Category_(mathematics)`.\n\n    :trac:`17364`: every homset category shall be a subcategory of the\n    category of all homsets::\n\n        sage: Schemes().Homsets().is_subcategory(Homsets())\n        True\n        sage: AdditiveMagmas().Homsets().is_subcategory(Homsets())\n        True\n        sage: AdditiveMagmas().AdditiveUnital().Homsets().is_subcategory(Homsets())\n        True\n\n    This is tested in :meth:`HomsetsCategory._test_homsets_category`.\n    ",
            "methods": {}
        },
        "name": "sage.categories.homsets.Homsets",
        "parent_class": {
            "__doc__": "\n    The category of all homsets.\n\n    EXAMPLES::\n\n        sage: from sage.categories.homsets import Homsets\n        sage: Homsets()\n        Category of homsets\n\n    This is a subcategory of ``Sets()``::\n\n        sage: Homsets().super_categories()\n        [Category of sets]\n\n    By this, we assume that all homsets implemented in Sage are sets,\n    or equivalently that we only implement locally small categories.\n    See :wikipedia:`Category_(mathematics)`.\n\n    :trac:`17364`: every homset category shall be a subcategory of the\n    category of all homsets::\n\n        sage: Schemes().Homsets().is_subcategory(Homsets())\n        True\n        sage: AdditiveMagmas().Homsets().is_subcategory(Homsets())\n        True\n        sage: AdditiveMagmas().AdditiveUnital().Homsets().is_subcategory(Homsets())\n        True\n\n    This is tested in :meth:`HomsetsCategory._test_homsets_category`.\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.homsets.Homsets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of all homsets.\n\n    EXAMPLES::\n\n        sage: from sage.categories.homsets import Homsets\n        sage: Homsets()\n        Category of homsets\n\n    This is a subcategory of ``Sets()``::\n\n        sage: Homsets().super_categories()\n        [Category of sets]\n\n    By this, we assume that all homsets implemented in Sage are sets,\n    or equivalently that we only implement locally small categories.\n    See :wikipedia:`Category_(mathematics)`.\n\n    :trac:`17364`: every homset category shall be a subcategory of the\n    category of all homsets::\n\n        sage: Schemes().Homsets().is_subcategory(Homsets())\n        True\n        sage: AdditiveMagmas().Homsets().is_subcategory(Homsets())\n        True\n        sage: AdditiveMagmas().AdditiveUnital().Homsets().is_subcategory(Homsets())\n        True\n\n    This is tested in :meth:`HomsetsCategory._test_homsets_category`.\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras",
            "sage.categories.modules_with_basis.ModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_product_from_product_on_basis_multiply": {
                    "__doc__": "\n                Computes the product of two elements by extending\n                bilinearly the method :meth:`product_on_basis`.\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example(); A\n                    An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n                    sage: (a,b,c) = A.algebra_generators()\n                    sage: A._product_from_product_on_basis_multiply(a*b + 2*c, a - b)\n                    B[word: aba] - B[word: abb] + 2*B[word: ca] - 2*B[word: cb]\n\n                ",
                    "args": [
                        "self",
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "product_on_basis": {
                    "__doc__": "\n                The product of the algebra on the basis (optional).\n\n                INPUT:\n\n                - ``i``, ``j`` -- the indices of two elements of the\n                  basis of ``self``\n\n                Return the product of the two corresponding basis elements\n                indexed by ``i`` and ``j``.\n\n                If implemented, :meth:`product` is defined from\n                it by bilinearity.\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example()\n                    sage: Word = A.basis().keys()\n                    sage: A.product_on_basis(Word(\"abc\"),Word(\"cba\"))\n                    B[word: abccba]\n                ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveAssociative",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "mmt.AdditiveMagmas.GAP",
            "sage.categories.additive_semigroups.AdditiveSemigroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.AdditiveSemigroups.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of complex reflection groups or generalized Coxeter groups.\n\n    Finite Coxeter groups can be defined equivalently as groups\n    generated by reflections, or by presentations. Over the last\n    decades, the theory has been generalized in both directions,\n    leading to the study of (finite) complex reflection groups on the\n    one hand, and (finite) generalized Coxeter groups on the other\n    hand. Many of the features remain similar, yet, in the current\n    state of the art, there is no general theory covering both\n    directions.\n\n    This is reflected by the name of this category which is about\n    factoring out the common code, tests, and declarations.\n\n    A group in this category has:\n\n    - A distinguished finite set of generators `(s_i)_I`, called\n      *simple reflections*. The set `I` is called the *index set*. The\n      name \"reflection\" is somewhat of an abuse as they can have\n      higher order; still, they are all of finite order: `s_i^k=1` for\n      some `k`.\n\n    - A collection of *distinguished reflections* which are the\n      conjugates of the simple reflections. For complex reflection\n      groups, they are in one-to-one correspondence with the\n      reflection hyperplanes and share the same index set.\n\n    - A collection of *reflections* which are the conjugates of all\n      the non trivial powers of the simple reflections.\n\n    The usual notions of reduced words, length, irreducibility, etc\n    can be canonically defined from the above.\n\n    The following methods must be implemented:\n\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ParentMethods.index_set`\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ParentMethods.simple_reflection`\n\n    Optionally one can define analog methods for distinguished\n    reflections and reflections (see below).\n\n    At least one of the following methods must be implemented:\n\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods.apply_simple_reflection`\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods.apply_simple_reflection_left`\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods.apply_simple_reflection_right`\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods._mul_`\n\n    It's recommended to implement either `_mul` or both\n    `apply_simple_reflection_left` and `apply_simple_reflection_right`.\n\n    .. SEEALSO::\n\n        - :class:`complex_reflection_groups.ComplexReflectionGroups`\n        - :class:`generalized_coxeter_groups.GeneralizedCoxeterGroups`\n\n    EXAMPLES::\n\n        sage: from sage.categories.complex_reflection_or_generalized_coxeter_groups import ComplexReflectionOrGeneralizedCoxeterGroups\n        sage: C = ComplexReflectionOrGeneralizedCoxeterGroups(); C\n        Category of complex reflection or generalized coxeter groups\n        sage: C.super_categories()\n        [Category of finitely generated groups]\n\n        sage: C.required_methods()\n        {'element': {'optional': ['reflection_length'],\n                     'required': []},\n          'parent': {'optional': ['distinguished_reflection', 'hyperplane_index_set',\n                                  'irreducible_components',\n                                  'reflection', 'reflection_index_set'],\n                    'required':  ['__contains__', 'index_set']}}\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "apply_conjugation_by_simple_reflection": {
                    "__doc__": "\n            Conjugate ``self`` by the ``i``-th simple reflection.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3])\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.apply_conjugation_by_simple_reflection(1).reduced_word()\n                [3, 2]\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "apply_reflections": {
                    "__doc__": "\n            Return the result of the (left/right) multiplication of\n            ``self`` by ``word``.\n\n            INPUT:\n\n            - ``word`` -- a sequence of indices of reflections\n            - ``side`` -- (default: ``'right'``) indicates multiplying\n              from left or right\n            - ``word_type`` -- (optional, default: ``'all'``):\n              either ``'simple'``, ``'distinguished'``, or ``'all'``\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,3))          # optional - gap3\n                sage: W.one().apply_reflections([1])        # optional - gap3\n                (1,4)(2,3)(5,6)\n                sage: W.one().apply_reflections([2])        # optional - gap3\n                (1,3)(2,5)(4,6)\n                sage: W.one().apply_reflections([2,1])      # optional - gap3\n                (1,2,6)(3,4,5)\n\n\n                sage: W = CoxeterGroups().example()\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.apply_reflections([0,1], word_type='simple')\n                (2, 3, 1, 0)\n                sage: w\n                (1, 2, 3, 0)\n                sage: w.apply_reflections([0,1], side='left', word_type='simple')\n                (0, 1, 3, 2)\n\n\n                sage: W = ReflectionGroup((1,1,3))          # optional - gap3\n                sage: W.one().apply_reflections([1], word_type='distinguished')   # optional - gap3\n                (1,4)(2,3)(5,6)\n                sage: W.one().apply_reflections([2],   word_type='distinguished')   # optional - gap3\n                (1,3)(2,5)(4,6)\n                sage: W.one().apply_reflections([3],   word_type='distinguished')   # optional - gap3\n                (1,5)(2,4)(3,6)\n                sage: W.one().apply_reflections([2,1], word_type='distinguished')   # optional - gap3\n                (1,2,6)(3,4,5)\n\n                sage: W = ReflectionGroup((1,1,3), hyperplane_index_set=['A','B','C']); W   # optional - gap3\n                Irreducible real reflection group of rank 2 and type A2\n                sage: W.one().apply_reflections(['A'], word_type='distinguished')   # optional - gap3\n                (1,4)(2,3)(5,6)\n            ",
                    "args": [
                        "self",
                        "word",
                        "side",
                        "word_type"
                    ],
                    "argspec": [
                        [
                            "self",
                            "word",
                            "side",
                            "word_type"
                        ],
                        null,
                        null,
                        [
                            "right",
                            "all"
                        ]
                    ]
                },
                "apply_simple_reflection": {
                    "__doc__": "\n            Return ``self`` multiplied by the simple reflection ``s[i]``.\n\n            INPUT:\n\n            - ``i`` -- an element of the index set\n            - ``side`` -- (default: ``\"right\"``) ``\"left\"`` or ``\"right\"``\n\n            This default implementation simply calls\n            :meth:`apply_simple_reflection_left` or\n            :meth:`apply_simple_reflection_right`.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.apply_simple_reflection(0, side = \"left\")\n                (0, 2, 3, 1)\n                sage: w.apply_simple_reflection(1, side = \"left\")\n                (2, 1, 3, 0)\n                sage: w.apply_simple_reflection(2, side = \"left\")\n                (1, 3, 2, 0)\n\n                sage: w.apply_simple_reflection(0, side = \"right\")\n                (2, 1, 3, 0)\n                sage: w.apply_simple_reflection(1, side = \"right\")\n                (1, 3, 2, 0)\n                sage: w.apply_simple_reflection(2, side = \"right\")\n                (1, 2, 0, 3)\n\n            By default, ``side`` is ``\"right\"``::\n\n                sage: w.apply_simple_reflection(0)\n                (2, 1, 3, 0)\n\n            Some tests with a complex reflection group::\n\n                sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n                sage: W = ComplexReflectionGroups().example(); W\n                5-colored permutations of size 3\n                sage: w = W.an_element(); w\n                [[1, 0, 0], [3, 1, 2]]\n                sage: w.apply_simple_reflection(1, side=\"left\")\n                [[0, 1, 0], [1, 3, 2]]\n                sage: w.apply_simple_reflection(2, side=\"left\")\n                [[1, 0, 0], [3, 2, 1]]\n                sage: w.apply_simple_reflection(3, side=\"left\")\n                [[1, 0, 1], [3, 1, 2]]\n\n                sage: w.apply_simple_reflection(1, side=\"right\")\n                [[1, 0, 0], [3, 2, 1]]\n                sage: w.apply_simple_reflection(2, side=\"right\")\n                [[1, 0, 0], [2, 1, 3]]\n                sage: w.apply_simple_reflection(3, side=\"right\")\n                [[2, 0, 0], [3, 1, 2]]\n\n            TESTS::\n\n                sage: w.apply_simple_reflection_right.__module__\n                'sage.categories.complex_reflection_or_generalized_coxeter_groups'\n            ",
                    "args": [
                        "self",
                        "i",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "apply_simple_reflection_left": {
                    "__doc__": "\n            Return ``self`` multiplied by the simple reflection ``s[i]``\n            on the left.\n\n            This low level method is used intensively. Coxeter groups\n            are encouraged to override this straightforward\n            implementation whenever a faster approach exists.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.apply_simple_reflection_left(0)\n                (0, 2, 3, 1)\n                sage: w.apply_simple_reflection_left(1)\n                (2, 1, 3, 0)\n                sage: w.apply_simple_reflection_left(2)\n                (1, 3, 2, 0)\n\n            EXAMPLES::\n\n                sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n                sage: W = ComplexReflectionGroups().example()\n                sage: w = W.an_element(); w\n                [[1, 0, 0], [3, 1, 2]]\n                sage: w.apply_simple_reflection_left(1)\n                [[0, 1, 0], [1, 3, 2]]\n                sage: w.apply_simple_reflection_left(2)\n                [[1, 0, 0], [3, 2, 1]]\n                sage: w.apply_simple_reflection_left(3)\n                [[1, 0, 1], [3, 1, 2]]\n\n            TESTS::\n\n                sage: w.apply_simple_reflection_left.__module__\n                'sage.categories.complex_reflection_or_generalized_coxeter_groups'\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "apply_simple_reflection_right": {
                    "__doc__": "\n            Return ``self`` multiplied by the simple reflection ``s[i]``\n            on the right.\n\n            This low level method is used intensively. Coxeter groups\n            are encouraged to override this straightforward\n            implementation whenever a faster approach exists.\n\n            EXAMPLES::\n\n                sage: W=CoxeterGroups().example()\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.apply_simple_reflection_right(0)\n                (2, 1, 3, 0)\n                sage: w.apply_simple_reflection_right(1)\n                (1, 3, 2, 0)\n                sage: w.apply_simple_reflection_right(2)\n                (1, 2, 0, 3)\n\n                sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n                sage: W = ComplexReflectionGroups().example()\n                sage: w = W.an_element(); w\n                [[1, 0, 0], [3, 1, 2]]\n                sage: w.apply_simple_reflection_right(1)\n                [[1, 0, 0], [3, 2, 1]]\n                sage: w.apply_simple_reflection_right(2)\n                [[1, 0, 0], [2, 1, 3]]\n                sage: w.apply_simple_reflection_right(3)\n                [[2, 0, 0], [3, 1, 2]]\n\n            TESTS::\n\n                sage: w.apply_simple_reflection_right.__module__\n                'sage.categories.complex_reflection_or_generalized_coxeter_groups'\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "apply_simple_reflections": {
                    "__doc__": "\n            Return the result of the (left/right) multiplication of\n            ``self`` by ``word``.\n\n            INPUT:\n\n            - ``word`` -- a sequence of indices of simple reflections\n            - ``side`` -- (default: ``'right'``) indicates multiplying\n              from left or right\n\n            This is a specialized implementation of\n            :meth:`apply_reflections` for the simple reflections. The\n            rationale for its existence are:\n\n            - It can take advantage of ``apply_simple_reflection``,\n              which often is less expensive than computing a product.\n\n            - It reduced burden on implementations that would want to\n              provide an optimized version of this method.\n\n            EXAMPLES::\n\n               sage: W = CoxeterGroups().example()\n               sage: w = W.an_element(); w\n               (1, 2, 3, 0)\n               sage: w.apply_simple_reflections([0,1])\n               (2, 3, 1, 0)\n               sage: w\n               (1, 2, 3, 0)\n               sage: w.apply_simple_reflections([0,1],side='left')\n               (0, 1, 3, 2)\n            ",
                    "args": [
                        "self",
                        "word",
                        "side",
                        "type"
                    ],
                    "argspec": [
                        [
                            "self",
                            "word",
                            "side",
                            "type"
                        ],
                        null,
                        null,
                        [
                            "right",
                            "simple"
                        ]
                    ]
                },
                "inverse": {
                    "__doc__": "\n            Return the inverse of ``self``.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['B',7])\n                sage: w = W.an_element()\n                sage: u = w.inverse()\n                sage: u == ~w\n                True\n                sage: u * w == w * u\n                True\n                sage: u * w\n                [1 0 0 0 0 0 0]\n                [0 1 0 0 0 0 0]\n                [0 0 1 0 0 0 0]\n                [0 0 0 1 0 0 0]\n                [0 0 0 0 1 0 0]\n                [0 0 0 0 0 1 0]\n                [0 0 0 0 0 0 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_reflection": {
                    "__doc__": "\n            Return whether ``self`` is a reflection.\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,4))                      # optional - gap3\n                sage: [t.is_reflection() for t in W.reflections()]      # optional - gap3\n                [True, True, True, True, True, True]\n                sage: len([t for t in W.reflections() if t.is_reflection()])    # optional - gap3\n                6\n\n                sage: W = ReflectionGroup((2,1,3))                      # optional - gap3\n                sage: [t.is_reflection() for t in W.reflections()]      # optional - gap3\n                [True, True, True, True, True, True, True, True, True]\n                sage: len([t for t in W.reflections() if t.is_reflection()])    # optional - gap3\n                9\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reflection_length": {
                    "__doc__": "\n            Return the reflection length of ``self``.\n\n            This is the minimal length of a factorization of ``self``\n            into reflections.\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,2))                      # optional - gap3\n                sage: sorted([t.reflection_length() for t in W])        # optional - gap3\n                [0, 1]\n\n                sage: W = ReflectionGroup((2,1,2))                      # optional - gap3\n                sage: sorted([t.reflection_length() for t in W])        # optional - gap3\n                [0, 1, 1, 1, 1, 2, 2, 2]\n\n                sage: W = ReflectionGroup((3,1,2))                      # optional - gap3\n                sage: sorted([t.reflection_length() for t in W])        # optional - gap3\n                [0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n\n                sage: W = ReflectionGroup((2,2,2))                      # optional - gap3\n                sage: sorted([t.reflection_length() for t in W])        # optional - gap3\n                [0, 1, 1, 2]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.category.JoinCategory"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of complex reflection groups or generalized Coxeter groups.\n\n    Finite Coxeter groups can be defined equivalently as groups\n    generated by reflections, or by presentations. Over the last\n    decades, the theory has been generalized in both directions,\n    leading to the study of (finite) complex reflection groups on the\n    one hand, and (finite) generalized Coxeter groups on the other\n    hand. Many of the features remain similar, yet, in the current\n    state of the art, there is no general theory covering both\n    directions.\n\n    This is reflected by the name of this category which is about\n    factoring out the common code, tests, and declarations.\n\n    A group in this category has:\n\n    - A distinguished finite set of generators `(s_i)_I`, called\n      *simple reflections*. The set `I` is called the *index set*. The\n      name \"reflection\" is somewhat of an abuse as they can have\n      higher order; still, they are all of finite order: `s_i^k=1` for\n      some `k`.\n\n    - A collection of *distinguished reflections* which are the\n      conjugates of the simple reflections. For complex reflection\n      groups, they are in one-to-one correspondence with the\n      reflection hyperplanes and share the same index set.\n\n    - A collection of *reflections* which are the conjugates of all\n      the non trivial powers of the simple reflections.\n\n    The usual notions of reduced words, length, irreducibility, etc\n    can be canonically defined from the above.\n\n    The following methods must be implemented:\n\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ParentMethods.index_set`\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ParentMethods.simple_reflection`\n\n    Optionally one can define analog methods for distinguished\n    reflections and reflections (see below).\n\n    At least one of the following methods must be implemented:\n\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods.apply_simple_reflection`\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods.apply_simple_reflection_left`\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods.apply_simple_reflection_right`\n    - :meth:`ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods._mul_`\n\n    It's recommended to implement either `_mul` or both\n    `apply_simple_reflection_left` and `apply_simple_reflection_right`.\n\n    .. SEEALSO::\n\n        - :class:`complex_reflection_groups.ComplexReflectionGroups`\n        - :class:`generalized_coxeter_groups.GeneralizedCoxeterGroups`\n\n    EXAMPLES::\n\n        sage: from sage.categories.complex_reflection_or_generalized_coxeter_groups import ComplexReflectionOrGeneralizedCoxeterGroups\n        sage: C = ComplexReflectionOrGeneralizedCoxeterGroups(); C\n        Category of complex reflection or generalized coxeter groups\n        sage: C.super_categories()\n        [Category of finitely generated groups]\n\n        sage: C.required_methods()\n        {'element': {'optional': ['reflection_length'],\n                     'required': []},\n          'parent': {'optional': ['distinguished_reflection', 'hyperplane_index_set',\n                                  'irreducible_components',\n                                  'reflection', 'reflection_index_set'],\n                    'required':  ['__contains__', 'index_set']}}\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "distinguished_reflection": {
                    "__doc__": "\n            Return the `i`-th distinguished reflection of ``self``.\n\n            INPUT:\n\n            - ``i`` -- an element of the index set of the distinguished reflections.\n\n            .. SEEALSO::\n\n                - :meth:`distinguished_reflections`\n                - :meth:`hyperplane_index_set`\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,4), hyperplane_index_set=('a','b','c','d','e','f'))  # optional - gap3\n                sage: for i in W.hyperplane_index_set():                    # optional - gap3\n                ....:     print('%s %s'%(i, W.distinguished_reflection(i))) # optional - gap3\n                a (1,7)(2,4)(5,6)(8,10)(11,12)\n                b (1,4)(2,8)(3,5)(7,10)(9,11)\n                c (2,5)(3,9)(4,6)(8,11)(10,12)\n                d (1,8)(2,7)(3,6)(4,10)(9,12)\n                e (1,6)(2,9)(3,8)(5,11)(7,12)\n                f (1,11)(3,10)(4,9)(5,7)(6,12)\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "distinguished_reflections": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "from_reduced_word": {
                    "__doc__": "\n            Return an element of ``self`` from its (reduced) word.\n\n            INPUT:\n\n            - ``word`` -- a list (or iterable) of elements of the\n              index set of ``self`` (resp. of the distinguished\n              or of all reflections)\n            - ``word_type`` -- (optional, default: ``'simple'``):\n              either ``'simple'``, ``'distinguished'``, or ``'all'``\n\n            If ``word`` is `[i_1,i_2,\\ldots,i_k]`, then this returns\n            the corresponding product of simple reflections\n            `s_{i_1} s_{i_2} \\cdots s_{i_k}`.\n\n            If ``word_type`` is ``'distinguished'`` (resp. ``'all'``),\n            then the product of the distinguished reflections (resp. all\n            reflections) is returned.\n\n            .. NOTE::\n\n                The main use case is for constructing elements from\n                reduced words, hence the name of this method.\n                However, the input word need *not* be reduced.\n\n            .. SEEALSO::\n\n                - :meth:`index_set`\n                - :meth:`reflections_index_set`\n                - :meth:`hyperplane_index_set`\n                - :meth:`~ComplexReflectionOrGeneralizedCoxeterGroups.ElementMethods.apply_simple_reflections`\n                - :meth:`~CoxeterGroup.ElementMethods.reduced_word`\n                - :meth:`~CoxeterGroup.ParentMethods._test_reduced_word`\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: W\n                The symmetric group on {0, ..., 3}\n                sage: s = W.simple_reflections()\n                sage: W.from_reduced_word([0,2,0,1])\n                (0, 3, 1, 2)\n                sage: W.from_reduced_word((0,2,0,1))\n                (0, 3, 1, 2)\n                sage: s[0]*s[2]*s[0]*s[1]\n                (0, 3, 1, 2)\n\n            We now experiment with the the different values for\n            ``word_type`` for the colored symmetric group::\n\n                sage: W = ColoredPermutations(1,4)\n                sage: W.from_reduced_word([1,2,1,2,1,2])\n                [[0, 0, 0, 0], [1, 2, 3, 4]]\n\n                sage: W.from_reduced_word([1, 2, 3]).reduced_word()\n                [1, 2, 3]\n\n                sage: W = ReflectionGroup((1,1,4))           # optional - gap3\n                sage: W.from_reduced_word([1,2,3], word_type='all').reduced_word()  # optional - gap3\n                [1, 2, 3]\n\n                sage: W.from_reduced_word([1,2,3], word_type='all').reduced_word_in_reflections()   # optional - gap3\n                [1, 2, 3]\n\n                sage: W.from_reduced_word([1,2,3]).reduced_word_in_reflections()    # optional - gap3\n                [1, 2, 3]\n\n            TESTS::\n\n                sage: W=WeylGroup(['E',6])\n                sage: W.from_reduced_word([2,3,4,2])\n                [ 0  1  0  0  0  0  0  0]\n                [ 0  0 -1  0  0  0  0  0]\n                [-1  0  0  0  0  0  0  0]\n                [ 0  0  0  1  0  0  0  0]\n                [ 0  0  0  0  1  0  0  0]\n                [ 0  0  0  0  0  1  0  0]\n                [ 0  0  0  0  0  0  1  0]\n                [ 0  0  0  0  0  0  0  1]\n            ",
                    "args": [
                        "self",
                        "word",
                        "word_type"
                    ],
                    "argspec": [
                        [
                            "self",
                            "word",
                            "word_type"
                        ],
                        null,
                        null,
                        [
                            "simple"
                        ]
                    ]
                },
                "hyperplane_index_set": {
                    "__doc__": "\n            Return the index set of the distinguished reflections of ``self``.\n\n            This is also the index set of the reflection hyperplanes\n            of ``self``, hence the name. This name is slightly abusive\n            since the concept of reflection hyperplanes is not defined\n            for all generalized Coxeter groups. However for all\n            practical purposes this is only used for complex\n            reflection groups, and there this is the desirable name.\n\n            .. SEEALSO::\n\n                - :meth:`distinguished_reflection`\n                - :meth:`distinguished_reflections`\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,4))                      # optional - gap3\n                sage: W.hyperplane_index_set()                          # optional - gap3\n                (1, 2, 3, 4, 5, 6)\n                sage: W = ReflectionGroup((1,1,4), hyperplane_index_set=[1,3,'asdf',7,9,11])    # optional - gap3\n                sage: W.hyperplane_index_set()                          # optional - gap3\n                (1, 3, 'asdf', 7, 9, 11)\n                sage: W = ReflectionGroup((1,1,4), hyperplane_index_set=('a','b','c','d','e','f'))  # optional - gap3\n                sage: W.hyperplane_index_set()                          # optional - gap3\n                ('a', 'b', 'c', 'd', 'e', 'f')\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "index_set": {
                    "__doc__": "\n            Return the index set of (the simple reflections of)\n            ``self``, as a list (or iterable).\n\n            .. SEEALSO::\n\n                - :meth:`simple_reflection`\n                - :meth:`simple_reflections`\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().Finite().example(); W\n                The 5-th dihedral group of order 10\n                sage: W.index_set()\n                (1, 2)\n\n                sage: W = ColoredPermutations(1, 4)\n                sage: W.index_set()\n                (1, 2, 3)\n                sage: W = ReflectionGroup((1,1,4), index_set=[1,3,'asdf'])  # optional - gap3\n                sage: W.index_set()                                     # optional - gap3\n                (1, 3, 'asdf')\n                sage: W = ReflectionGroup((1,1,4), index_set=('a','b','c')) # optional - gap3\n                sage: W.index_set()                                     # optional - gap3\n                ('a', 'b', 'c')\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "irreducible_component_index_sets": {
                    "__doc__": "\n            Return a list containing the index sets of the irreducible components of\n            ``self`` as finite reflection groups.\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup([1,1,3], [3,1,3], 4); W       # optional - gap3\n                Reducible complex reflection group of rank 7 and type A2 x G(3,1,3) x ST4\n                sage: sorted(W.irreducible_component_index_sets())      # optional - gap3\n                [[1, 2], [3, 4, 5], [6, 7]]\n\n            ALGORITHM:\n\n                Take the connected components of the graph on the\n                index set with edges (i,j) where s[i] and s[j] don't\n                commute.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "irreducible_components": {
                    "__doc__": "\n            Return the irreducible components of ``self`` as finite\n            reflection groups.\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup([1,1,3], [3,1,3], 4)          # optional - gap3\n                sage: W.irreducible_components()                        # optional - gap3\n                [Irreducible real reflection group of rank 2 and type A2,\n                 Irreducible complex reflection group of rank 3 and type G(3,1,3),\n                 Irreducible complex reflection group of rank 2 and type ST4]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_irreducible": {
                    "__doc__": "\n            Return ``True`` if ``self`` is irreducible.\n\n            EXAMPLES::\n\n                sage: W = ColoredPermutations(1,3); W\n                1-colored permutations of size 3\n                sage: W.is_irreducible()\n                True\n\n                sage: W = ReflectionGroup((1,1,3),(2,1,3)); W           # optional - gap3\n                Reducible real reflection group of rank 5 and type A2 x B3\n                sage: W.is_irreducible()                                # optional - gap3\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_reducible": {
                    "__doc__": "\n            Return ``True`` if ``self`` is not irreducible.\n\n            EXAMPLES::\n\n                sage: W = ColoredPermutations(1,3); W\n                1-colored permutations of size 3\n                sage: W.is_reducible()\n                False\n\n                sage: W = ReflectionGroup((1,1,3), (2,1,3)); W          # optional - gap3\n                Reducible real reflection group of rank 5 and type A2 x B3\n                sage: W.is_reducible()                                  # optional - gap3\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "number_of_irreducible_components": {
                    "__doc__": "\n            Return the number of irreducible components of ``self``.\n\n            EXAMPLES::\n\n                sage: SymmetricGroup(3).number_of_irreducible_components()\n                1\n\n                sage: ColoredPermutations(1,3).number_of_irreducible_components()\n                1\n\n                sage: ReflectionGroup((1,1,3),(2,1,3)).number_of_irreducible_components()   # optional - gap3\n                2\n\n            TESTS::\n\n                sage: SymmetricGroup(3).number_of_irreducible_components.__module__\n                'sage.categories.complex_reflection_or_generalized_coxeter_groups'\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "number_of_simple_reflections": {
                    "__doc__": "\n            Return the number of simple reflections of ``self``.\n\n            EXAMPLES::\n\n                sage: W = ColoredPermutations(1,3)\n                sage: W.number_of_simple_reflections()\n                2\n                sage: W = ColoredPermutations(2,3)\n                sage: W.number_of_simple_reflections()\n                3\n                sage: W = ColoredPermutations(4,3)\n                sage: W.number_of_simple_reflections()\n                3\n                sage: W = ReflectionGroup((4,2,3))                      # optional - gap3\n                sage: W.number_of_simple_reflections()                  # optional - gap3\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reflection": {
                    "__doc__": "\n            Return the `i`-th reflection of ``self``.\n\n            For `i` in `1,\\dots,N`, this gives the `i`-th reflection of\n            ``self``.\n\n            .. SEEALSO::\n\n                - :meth:`reflections_index_set`\n                - :meth:`reflections`\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,4))                      # optional - gap3\n                sage: for i in W.reflection_index_set():                # optional - gap3\n                ....:     print('%s %s'%(i, W.reflection(i)))           # optional - gap3\n                1 (1,7)(2,4)(5,6)(8,10)(11,12)\n                2 (1,4)(2,8)(3,5)(7,10)(9,11)\n                3 (2,5)(3,9)(4,6)(8,11)(10,12)\n                4 (1,8)(2,7)(3,6)(4,10)(9,12)\n                5 (1,6)(2,9)(3,8)(5,11)(7,12)\n                6 (1,11)(3,10)(4,9)(5,7)(6,12)\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reflection_index_set": {
                    "__doc__": "\n            Return the index set of the reflections of ``self``.\n\n            .. SEEALSO::\n\n                - :meth:`reflection`\n                - :meth:`reflections`\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,4))                      # optional - gap3\n                sage: W.reflection_index_set()                          # optional - gap3\n                (1, 2, 3, 4, 5, 6)\n                sage: W = ReflectionGroup((1,1,4), reflection_index_set=[1,3,'asdf',7,9,11])    # optional - gap3\n                sage: W.reflection_index_set()                          # optional - gap3\n                (1, 3, 'asdf', 7, 9, 11)\n                sage: W = ReflectionGroup((1,1,4), reflection_index_set=('a','b','c','d','e','f'))  # optional - gap3\n                sage: W.reflection_index_set()                          # optional - gap3\n                ('a', 'b', 'c', 'd', 'e', 'f')\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reflections": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "simple_reflection": {
                    "__doc__": "\n            Return the `i`-th simple reflection `s_i` of ``self``.\n\n            INPUT:\n\n            - ``i`` -- an element from the index set\n\n            .. SEEALSO::\n\n                - :meth:`index_set`\n                - :meth:`simple_reflections`\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: W\n                The symmetric group on {0, ..., 3}\n                sage: W.simple_reflection(1)\n                (0, 2, 1, 3)\n                sage: s = W.simple_reflections()\n                sage: s[1]\n                (0, 2, 1, 3)\n\n                sage: W = ReflectionGroup((1,1,4), index_set=[1,3,'asdf'])  # optional - gap3\n                sage: for i in W.index_set():                           # optional - gap3\n                ....:     print('%s %s'%(i, W.simple_reflection(i)))    # optional - gap3\n                1 (1,7)(2,4)(5,6)(8,10)(11,12)\n                3 (1,4)(2,8)(3,5)(7,10)(9,11)\n                asdf (2,5)(3,9)(4,6)(8,11)(10,12)\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "simple_reflection_orders": {
                    "__doc__": "\n            Return the orders of the simple reflections.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['B',3])\n                sage: W.simple_reflection_orders()\n                [2, 2, 2]\n                sage: W = CoxeterGroup(['C',4])\n                sage: W.simple_reflection_orders()\n                [2, 2, 2, 2]\n                sage: SymmetricGroup(5).simple_reflection_orders()\n                [2, 2, 2, 2]\n                sage: C = ColoredPermutations(4, 3)\n                sage: C.simple_reflection_orders()\n                [2, 2, 4]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "simple_reflections": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "apply_conjugation_by_simple_reflection": {
                    "__doc__": "\n            Conjugate ``self`` by the ``i``-th simple reflection.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['A',3])\n                sage: w = W.from_reduced_word([3,1,2,1])\n                sage: w.apply_conjugation_by_simple_reflection(1).reduced_word()\n                [3, 2]\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "apply_reflections": {
                    "__doc__": "\n            Return the result of the (left/right) multiplication of\n            ``self`` by ``word``.\n\n            INPUT:\n\n            - ``word`` -- a sequence of indices of reflections\n            - ``side`` -- (default: ``'right'``) indicates multiplying\n              from left or right\n            - ``word_type`` -- (optional, default: ``'all'``):\n              either ``'simple'``, ``'distinguished'``, or ``'all'``\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,3))          # optional - gap3\n                sage: W.one().apply_reflections([1])        # optional - gap3\n                (1,4)(2,3)(5,6)\n                sage: W.one().apply_reflections([2])        # optional - gap3\n                (1,3)(2,5)(4,6)\n                sage: W.one().apply_reflections([2,1])      # optional - gap3\n                (1,2,6)(3,4,5)\n\n\n                sage: W = CoxeterGroups().example()\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.apply_reflections([0,1], word_type='simple')\n                (2, 3, 1, 0)\n                sage: w\n                (1, 2, 3, 0)\n                sage: w.apply_reflections([0,1], side='left', word_type='simple')\n                (0, 1, 3, 2)\n\n\n                sage: W = ReflectionGroup((1,1,3))          # optional - gap3\n                sage: W.one().apply_reflections([1], word_type='distinguished')   # optional - gap3\n                (1,4)(2,3)(5,6)\n                sage: W.one().apply_reflections([2],   word_type='distinguished')   # optional - gap3\n                (1,3)(2,5)(4,6)\n                sage: W.one().apply_reflections([3],   word_type='distinguished')   # optional - gap3\n                (1,5)(2,4)(3,6)\n                sage: W.one().apply_reflections([2,1], word_type='distinguished')   # optional - gap3\n                (1,2,6)(3,4,5)\n\n                sage: W = ReflectionGroup((1,1,3), hyperplane_index_set=['A','B','C']); W   # optional - gap3\n                Irreducible real reflection group of rank 2 and type A2\n                sage: W.one().apply_reflections(['A'], word_type='distinguished')   # optional - gap3\n                (1,4)(2,3)(5,6)\n            ",
                    "args": [
                        "self",
                        "word",
                        "side",
                        "word_type"
                    ],
                    "argspec": [
                        [
                            "self",
                            "word",
                            "side",
                            "word_type"
                        ],
                        null,
                        null,
                        [
                            "right",
                            "all"
                        ]
                    ]
                },
                "apply_simple_reflection": {
                    "__doc__": "\n            Return ``self`` multiplied by the simple reflection ``s[i]``.\n\n            INPUT:\n\n            - ``i`` -- an element of the index set\n            - ``side`` -- (default: ``\"right\"``) ``\"left\"`` or ``\"right\"``\n\n            This default implementation simply calls\n            :meth:`apply_simple_reflection_left` or\n            :meth:`apply_simple_reflection_right`.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.apply_simple_reflection(0, side = \"left\")\n                (0, 2, 3, 1)\n                sage: w.apply_simple_reflection(1, side = \"left\")\n                (2, 1, 3, 0)\n                sage: w.apply_simple_reflection(2, side = \"left\")\n                (1, 3, 2, 0)\n\n                sage: w.apply_simple_reflection(0, side = \"right\")\n                (2, 1, 3, 0)\n                sage: w.apply_simple_reflection(1, side = \"right\")\n                (1, 3, 2, 0)\n                sage: w.apply_simple_reflection(2, side = \"right\")\n                (1, 2, 0, 3)\n\n            By default, ``side`` is ``\"right\"``::\n\n                sage: w.apply_simple_reflection(0)\n                (2, 1, 3, 0)\n\n            Some tests with a complex reflection group::\n\n                sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n                sage: W = ComplexReflectionGroups().example(); W\n                5-colored permutations of size 3\n                sage: w = W.an_element(); w\n                [[1, 0, 0], [3, 1, 2]]\n                sage: w.apply_simple_reflection(1, side=\"left\")\n                [[0, 1, 0], [1, 3, 2]]\n                sage: w.apply_simple_reflection(2, side=\"left\")\n                [[1, 0, 0], [3, 2, 1]]\n                sage: w.apply_simple_reflection(3, side=\"left\")\n                [[1, 0, 1], [3, 1, 2]]\n\n                sage: w.apply_simple_reflection(1, side=\"right\")\n                [[1, 0, 0], [3, 2, 1]]\n                sage: w.apply_simple_reflection(2, side=\"right\")\n                [[1, 0, 0], [2, 1, 3]]\n                sage: w.apply_simple_reflection(3, side=\"right\")\n                [[2, 0, 0], [3, 1, 2]]\n\n            TESTS::\n\n                sage: w.apply_simple_reflection_right.__module__\n                'sage.categories.complex_reflection_or_generalized_coxeter_groups'\n            ",
                    "args": [
                        "self",
                        "i",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "right"
                        ]
                    ]
                },
                "apply_simple_reflection_left": {
                    "__doc__": "\n            Return ``self`` multiplied by the simple reflection ``s[i]``\n            on the left.\n\n            This low level method is used intensively. Coxeter groups\n            are encouraged to override this straightforward\n            implementation whenever a faster approach exists.\n\n            EXAMPLES::\n\n                sage: W = CoxeterGroups().example()\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.apply_simple_reflection_left(0)\n                (0, 2, 3, 1)\n                sage: w.apply_simple_reflection_left(1)\n                (2, 1, 3, 0)\n                sage: w.apply_simple_reflection_left(2)\n                (1, 3, 2, 0)\n\n            EXAMPLES::\n\n                sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n                sage: W = ComplexReflectionGroups().example()\n                sage: w = W.an_element(); w\n                [[1, 0, 0], [3, 1, 2]]\n                sage: w.apply_simple_reflection_left(1)\n                [[0, 1, 0], [1, 3, 2]]\n                sage: w.apply_simple_reflection_left(2)\n                [[1, 0, 0], [3, 2, 1]]\n                sage: w.apply_simple_reflection_left(3)\n                [[1, 0, 1], [3, 1, 2]]\n\n            TESTS::\n\n                sage: w.apply_simple_reflection_left.__module__\n                'sage.categories.complex_reflection_or_generalized_coxeter_groups'\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "apply_simple_reflection_right": {
                    "__doc__": "\n            Return ``self`` multiplied by the simple reflection ``s[i]``\n            on the right.\n\n            This low level method is used intensively. Coxeter groups\n            are encouraged to override this straightforward\n            implementation whenever a faster approach exists.\n\n            EXAMPLES::\n\n                sage: W=CoxeterGroups().example()\n                sage: w = W.an_element(); w\n                (1, 2, 3, 0)\n                sage: w.apply_simple_reflection_right(0)\n                (2, 1, 3, 0)\n                sage: w.apply_simple_reflection_right(1)\n                (1, 3, 2, 0)\n                sage: w.apply_simple_reflection_right(2)\n                (1, 2, 0, 3)\n\n                sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n                sage: W = ComplexReflectionGroups().example()\n                sage: w = W.an_element(); w\n                [[1, 0, 0], [3, 1, 2]]\n                sage: w.apply_simple_reflection_right(1)\n                [[1, 0, 0], [3, 2, 1]]\n                sage: w.apply_simple_reflection_right(2)\n                [[1, 0, 0], [2, 1, 3]]\n                sage: w.apply_simple_reflection_right(3)\n                [[2, 0, 0], [3, 1, 2]]\n\n            TESTS::\n\n                sage: w.apply_simple_reflection_right.__module__\n                'sage.categories.complex_reflection_or_generalized_coxeter_groups'\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "apply_simple_reflections": {
                    "__doc__": "\n            Return the result of the (left/right) multiplication of\n            ``self`` by ``word``.\n\n            INPUT:\n\n            - ``word`` -- a sequence of indices of simple reflections\n            - ``side`` -- (default: ``'right'``) indicates multiplying\n              from left or right\n\n            This is a specialized implementation of\n            :meth:`apply_reflections` for the simple reflections. The\n            rationale for its existence are:\n\n            - It can take advantage of ``apply_simple_reflection``,\n              which often is less expensive than computing a product.\n\n            - It reduced burden on implementations that would want to\n              provide an optimized version of this method.\n\n            EXAMPLES::\n\n               sage: W = CoxeterGroups().example()\n               sage: w = W.an_element(); w\n               (1, 2, 3, 0)\n               sage: w.apply_simple_reflections([0,1])\n               (2, 3, 1, 0)\n               sage: w\n               (1, 2, 3, 0)\n               sage: w.apply_simple_reflections([0,1],side='left')\n               (0, 1, 3, 2)\n            ",
                    "args": [
                        "self",
                        "word",
                        "side",
                        "type"
                    ],
                    "argspec": [
                        [
                            "self",
                            "word",
                            "side",
                            "type"
                        ],
                        null,
                        null,
                        [
                            "right",
                            "simple"
                        ]
                    ]
                },
                "inverse": {
                    "__doc__": "\n            Return the inverse of ``self``.\n\n            EXAMPLES::\n\n                sage: W = WeylGroup(['B',7])\n                sage: w = W.an_element()\n                sage: u = w.inverse()\n                sage: u == ~w\n                True\n                sage: u * w == w * u\n                True\n                sage: u * w\n                [1 0 0 0 0 0 0]\n                [0 1 0 0 0 0 0]\n                [0 0 1 0 0 0 0]\n                [0 0 0 1 0 0 0]\n                [0 0 0 0 1 0 0]\n                [0 0 0 0 0 1 0]\n                [0 0 0 0 0 0 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_reflection": {
                    "__doc__": "\n            Return whether ``self`` is a reflection.\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,4))                      # optional - gap3\n                sage: [t.is_reflection() for t in W.reflections()]      # optional - gap3\n                [True, True, True, True, True, True]\n                sage: len([t for t in W.reflections() if t.is_reflection()])    # optional - gap3\n                6\n\n                sage: W = ReflectionGroup((2,1,3))                      # optional - gap3\n                sage: [t.is_reflection() for t in W.reflections()]      # optional - gap3\n                [True, True, True, True, True, True, True, True, True]\n                sage: len([t for t in W.reflections() if t.is_reflection()])    # optional - gap3\n                9\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "reflection_length": {
                    "__doc__": "\n            Return the reflection length of ``self``.\n\n            This is the minimal length of a factorization of ``self``\n            into reflections.\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,2))                      # optional - gap3\n                sage: sorted([t.reflection_length() for t in W])        # optional - gap3\n                [0, 1]\n\n                sage: W = ReflectionGroup((2,1,2))                      # optional - gap3\n                sage: sorted([t.reflection_length() for t in W])        # optional - gap3\n                [0, 1, 1, 1, 1, 2, 2, 2]\n\n                sage: W = ReflectionGroup((3,1,2))                      # optional - gap3\n                sage: sorted([t.reflection_length() for t in W])        # optional - gap3\n                [0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n\n                sage: W = ReflectionGroup((2,2,2))                      # optional - gap3\n                sage: sorted([t.reflection_length() for t in W])        # optional - gap3\n                [0, 1, 1, 2]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "Connected",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.filtered_modules.FilteredModules.Connected",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.associative_algebras.AssociativeAlgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.Algebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_semigroups.AdditiveSemigroups.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of finite generalized Coxeter groups.\n        ",
        "axioms": [
            "Inverse",
            "Associative",
            "FinitelyGeneratedAsMagma",
            "Unital",
            "Finite",
            "WellGenerated"
        ],
        "element_class": {
            "__doc__": "\n        The category of finite generalized Coxeter groups.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_complex_reflection_groups.FiniteComplexReflectionGroups.WellGenerated",
            "sage.categories.generalized_coxeter_groups.GeneralizedCoxeterGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of finite generalized Coxeter groups.\n        ",
            "methods": {}
        },
        "name": "sage.categories.generalized_coxeter_groups.GeneralizedCoxeterGroups.Finite",
        "parent_class": {
            "__doc__": "\n        The category of finite generalized Coxeter groups.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of finite generalized Coxeter groups.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of `(R,S)`-bimodules\n\n    For `R` and `S` rings, a `(R,S)`-bimodule `X` is a left `R`-module\n    and right `S`-module such that the left and right actions commute:\n    `r*(x*s) = (r*x)*s`.\n\n    EXAMPLES::\n\n        sage: Bimodules(QQ, ZZ)\n        Category of bimodules over Rational Field on the left and Integer Ring on the right\n        sage: Bimodules(QQ, ZZ).super_categories()\n        [Category of left modules over Rational Field, Category of right modules over Integer Ring]\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of `(R,S)`-bimodules\n\n    For `R` and `S` rings, a `(R,S)`-bimodule `X` is a left `R`-module\n    and right `S`-module such that the left and right actions commute:\n    `r*(x*s) = (r*x)*s`.\n\n    EXAMPLES::\n\n        sage: Bimodules(QQ, ZZ)\n        Category of bimodules over Rational Field on the left and Integer Ring on the right\n        sage: Bimodules(QQ, ZZ).super_categories()\n        [Category of left modules over Rational Field, Category of right modules over Integer Ring]\n    ",
            "methods": {}
        },
        "name": "sage.categories.bimodules.Bimodules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Endset",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.homsets.Homsets.Endset",
            "sage.categories.modules.Modules.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.Homsets.Endset",
        "parent_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.homsets.HomsetsOf",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.modules.Modules.Homsets",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Endset",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.rings.Rings",
            "sage.categories.homsets.Homsets.Endset",
            "sage.categories.modular_abelian_varieties.ModularAbelianVarieties.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.modular_abelian_varieties.ModularAbelianVarieties.Homsets.Endset",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.modular_abelian_varieties.ModularAbelianVarieties.Homsets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveAssociative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.Homsets",
            "sage.categories.additive_semigroups.AdditiveSemigroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_semigroups.AdditiveSemigroups.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_semigroups.AdditiveSemigroups.Homsets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.Homsets",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of super modules.\n\n    An `R`-*super module* (where `R` is a ring) is an `R`-module `M` equipped\n    with a decomposition `M = M_0 \\oplus M_1` into two `R`-submodules\n    `M_0` and `M_1` (called the *even part* and the *odd part* of `M`,\n    respectively).\n\n    Thus, an `R`-super module automatically becomes a `\\ZZ / 2 \\ZZ`-graded\n    `R`-module, with `M_0` being the degree-`0` component and `M_1` being the\n    degree-`1` component.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Super()\n        Category of super modules over Integer Ring\n        sage: Modules(ZZ).Super().super_categories()\n        [Category of graded modules over Integer Ring]\n\n    The category of super modules defines the super structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Super().additional_structure()\n        Category of super modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Super()).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "is_even": {
                    "__doc__": "\n            Return if ``self`` is an even element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even()\n                False\n                sage: C.basis()[2,2].is_even()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_even_odd": {
                    "__doc__": "\n            Return ``0`` if ``self`` is an even element or ``1``\n            if an odd element.\n\n            .. NOTE::\n\n                The default implementation assumes that the even/odd is\n                determined by the parity of :meth:`degree`.\n\n                Overwrite this method if the even/odd behavior is desired\n                to be independent.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even_odd()\n                1\n                sage: C.basis()[2,2].is_even_odd()\n                0\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_odd": {
                    "__doc__": "\n            Return if ``self`` is an odd element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_odd()\n                True\n                sage: C.basis()[2,2].is_odd()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.graded_modules.GradedModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of super modules.\n\n    An `R`-*super module* (where `R` is a ring) is an `R`-module `M` equipped\n    with a decomposition `M = M_0 \\oplus M_1` into two `R`-submodules\n    `M_0` and `M_1` (called the *even part* and the *odd part* of `M`,\n    respectively).\n\n    Thus, an `R`-super module automatically becomes a `\\ZZ / 2 \\ZZ`-graded\n    `R`-module, with `M_0` being the degree-`0` component and `M_1` being the\n    degree-`1` component.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Super()\n        Category of super modules over Integer Ring\n        sage: Modules(ZZ).Super().super_categories()\n        [Category of graded modules over Integer Ring]\n\n    The category of super modules defines the super structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Super().additional_structure()\n        Category of super modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.super_modules.SuperModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "is_even": {
                    "__doc__": "\n            Return if ``self`` is an even element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even()\n                False\n                sage: C.basis()[2,2].is_even()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_even_odd": {
                    "__doc__": "\n            Return ``0`` if ``self`` is an even element or ``1``\n            if an odd element.\n\n            .. NOTE::\n\n                The default implementation assumes that the even/odd is\n                determined by the parity of :meth:`degree`.\n\n                Overwrite this method if the even/odd behavior is desired\n                to be independent.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even_odd()\n                1\n                sage: C.basis()[2,2].is_even_odd()\n                0\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_odd": {
                    "__doc__": "\n            Return if ``self`` is an odd element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_odd()\n                True\n                sage: C.basis()[2,2].is_odd()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.TensorProducts",
        "parent_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas.CartesianProducts",
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of super modules.\n\n    An `R`-*super module* (where `R` is a ring) is an `R`-module `M` equipped\n    with a decomposition `M = M_0 \\oplus M_1` into two `R`-submodules\n    `M_0` and `M_1` (called the *even part* and the *odd part* of `M`,\n    respectively).\n\n    Thus, an `R`-super module automatically becomes a `\\ZZ / 2 \\ZZ`-graded\n    `R`-module, with `M_0` being the degree-`0` component and `M_1` being the\n    degree-`1` component.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Super()\n        Category of super modules over Integer Ring\n        sage: Modules(ZZ).Super().super_categories()\n        [Category of graded modules over Integer Ring]\n\n    The category of super modules defines the super structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Super().additional_structure()\n        Category of super modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Super()).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "is_even": {
                    "__doc__": "\n            Return if ``self`` is an even element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even()\n                False\n                sage: C.basis()[2,2].is_even()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_even_odd": {
                    "__doc__": "\n            Return ``0`` if ``self`` is an even element or ``1``\n            if an odd element.\n\n            .. NOTE::\n\n                The default implementation assumes that the even/odd is\n                determined by the parity of :meth:`degree`.\n\n                Overwrite this method if the even/odd behavior is desired\n                to be independent.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even_odd()\n                1\n                sage: C.basis()[2,2].is_even_odd()\n                0\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_odd": {
                    "__doc__": "\n            Return if ``self`` is an odd element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_odd()\n                True\n                sage: C.basis()[2,2].is_odd()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.graded_modules.GradedModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of super modules.\n\n    An `R`-*super module* (where `R` is a ring) is an `R`-module `M` equipped\n    with a decomposition `M = M_0 \\oplus M_1` into two `R`-submodules\n    `M_0` and `M_1` (called the *even part* and the *odd part* of `M`,\n    respectively).\n\n    Thus, an `R`-super module automatically becomes a `\\ZZ / 2 \\ZZ`-graded\n    `R`-module, with `M_0` being the degree-`0` component and `M_1` being the\n    degree-`1` component.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Super()\n        Category of super modules over Integer Ring\n        sage: Modules(ZZ).Super().super_categories()\n        [Category of graded modules over Integer Ring]\n\n    The category of super modules defines the super structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Super().additional_structure()\n        Category of super modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.super_modules.SuperModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "is_even": {
                    "__doc__": "\n            Return if ``self`` is an even element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even()\n                False\n                sage: C.basis()[2,2].is_even()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_even_odd": {
                    "__doc__": "\n            Return ``0`` if ``self`` is an even element or ``1``\n            if an odd element.\n\n            .. NOTE::\n\n                The default implementation assumes that the even/odd is\n                determined by the parity of :meth:`degree`.\n\n                Overwrite this method if the even/odd behavior is desired\n                to be independent.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even_odd()\n                1\n                sage: C.basis()[2,2].is_even_odd()\n                0\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_odd": {
                    "__doc__": "\n            Return if ``self`` is an odd element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_odd()\n                True\n                sage: C.basis()[2,2].is_odd()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.homsets.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Homsets",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of super modules with a distinguished basis.\n\n    An `R`-*super module with a distinguished basis* is an\n    `R`-super module equipped with an `R`-module basis whose elements are\n    homogeneous.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "even_component": {
                    "__doc__": "\n            Return the even component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.even_component()\n                x*y + 4\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x + y\n                sage: a.even_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_super_homogeneous": {
                    "__doc__": "\n            Return whether this element is homogeneous, in the sense\n            of a super module (i.e., is even or odd).\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x + y\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + x - 3*y + 4\n                sage: a.is_super_homogeneous()\n                False\n\n            The exterior algebra has a `\\ZZ` grading, which induces the\n            `\\ZZ / 2\\ZZ` grading. However the definition of homogeneous\n            elements differs because of the different gradings::\n\n                sage: E.<x,y> = ExteriorAlgebra(QQ)\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a.is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "odd_component": {
                    "__doc__": "\n            Return the odd component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.odd_component()\n                x - 3*y\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x*y\n                sage: a.odd_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.super_modules.SuperModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of super modules with a distinguished basis.\n\n    An `R`-*super module with a distinguished basis* is an\n    `R`-super module equipped with an `R`-module basis whose elements are\n    homogeneous.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.super_modules_with_basis.SuperModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_even_odd_on_basis": {
                    "__doc__": "\n            Return the parity of the basis element indexed by ``m``.\n\n            OUTPUT:\n\n            ``0`` if ``m`` is for an even element or ``1`` if ``m``\n            is for an odd element.\n\n            .. NOTE::\n\n                The default implementation assumes that the even/odd is\n                determined by the parity of :meth:`degree`.\n\n                Overwrite this method if the even/odd behavior is desired\n                to be independent.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: C._even_odd_on_basis((0,))\n                1\n                sage: C._even_odd_on_basis((0,1))\n                0\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "even_component": {
                    "__doc__": "\n            Return the even component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.even_component()\n                x*y + 4\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x + y\n                sage: a.even_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_super_homogeneous": {
                    "__doc__": "\n            Return whether this element is homogeneous, in the sense\n            of a super module (i.e., is even or odd).\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x + y\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + x - 3*y + 4\n                sage: a.is_super_homogeneous()\n                False\n\n            The exterior algebra has a `\\ZZ` grading, which induces the\n            `\\ZZ / 2\\ZZ` grading. However the definition of homogeneous\n            elements differs because of the different gradings::\n\n                sage: E.<x,y> = ExteriorAlgebra(QQ)\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a.is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "odd_component": {
                    "__doc__": "\n            Return the odd component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.odd_component()\n                x - 3*y\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x*y\n                sage: a.odd_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.Algebras",
            "sage.categories.unital_algebras.UnitalAlgebras.WithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.Algebras",
            "sage.categories.magmas.Magmas.Commutative"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of connected topological spaces.\n        ",
        "axioms": [
            "Connected"
        ],
        "element_class": {
            "__doc__": "\n        The category of connected topological spaces.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.topological_spaces.TopologicalSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of connected topological spaces.\n        ",
            "methods": {}
        },
        "name": "sage.categories.topological_spaces.TopologicalSpaces.Connected",
        "parent_class": {
            "__doc__": "\n        The category of connected topological spaces.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.topological_spaces.TopologicalSpaces",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of connected topological spaces.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.graded_algebras.GradedAlgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "name": "sage.categories.category.JoinCategory",
        "parent_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.hopf_algebras.HopfAlgebras",
            "sage.categories.magmas.Magmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.right_modules.RightModules"
        ],
        "subcategory_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Inverse",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas.Unital.CartesianProducts",
            "sage.categories.magmas.Magmas.Unital.Inverse"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Unital.Inverse.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Commutative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas.CartesianProducts",
            "sage.categories.magmas.Magmas.Commutative"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Commutative.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_modules.FilteredModules",
        "parent_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade",
            "AdditiveUnital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets.WithRealizations"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.WithRealizations",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded modules.\n\n    We consider every graded module `M = \\bigoplus_i M_i` as a\n    filtered module under the (natural) filtration given by\n\n    .. MATH::\n\n        F_i = \\bigoplus_{j < i} M_j.\n\n    EXAMPLES::\n\n        sage: GradedModules(ZZ)\n        Category of graded modules over Integer Ring\n        sage: GradedModules(ZZ).super_categories()\n        [Category of filtered modules over Integer Ring]\n\n    The category of graded modules defines the graded structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Graded().additional_structure()\n        Category of graded modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(GradedModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded modules.\n\n    We consider every graded module `M = \\bigoplus_i M_i` as a\n    filtered module under the (natural) filtration given by\n\n    .. MATH::\n\n        F_i = \\bigoplus_{j < i} M_j.\n\n    EXAMPLES::\n\n        sage: GradedModules(ZZ)\n        Category of graded modules over Integer Ring\n        sage: GradedModules(ZZ).super_categories()\n        [Category of filtered modules over Integer Ring]\n\n    The category of graded modules defines the graded structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Graded().additional_structure()\n        Category of graded modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(GradedModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_modules.GradedModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas.Algebras",
            "sage.categories.unital_algebras.UnitalAlgebras.WithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas.Magmas.Unital.Algebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets.Algebras",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.sets_cat.Sets.WithRealizations",
            "sage.categories.metric_spaces.MetricSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.metric_spaces.MetricSpaces.WithRealizations",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.topological_spaces.TopologicalSpaces",
            "sage.categories.metric_spaces.MetricSpaces",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "mmt.Modules.GAP"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.WithBasis.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.homsets.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.homsets.HomsetsOf",
        "parent_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.homsets.HomsetsOf",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.homsets.Homsets"
        ],
        "subcategory_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules.CartesianProducts",
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.DualObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules with basis constructed by tensor product of\n        modules with basis.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of modules\n            with basis.\n            ",
            "methods": {
                "apply_multilinear_morphism": {
                    "__doc__": "\n                Return the result of applying the morphism induced by ``f``\n                to ``self``.\n\n                INPUT:\n\n                - ``f`` -- a multilinear morphism from the component\n                  modules of the parent tensor product to any module\n\n                - ``codomain`` -- the codomain of ``f`` (optional)\n\n                By the universal property of the tensor product, ``f``\n                induces a linear morphism from `self.parent()` to the\n                target module. Returns the result of applying that\n                morphism to ``self``.\n\n                The codomain is used for optimizations purposes\n                only. If it's not provided, it's recovered by calling\n                ``f`` on the zero input.\n\n                EXAMPLES:\n\n                We start with simple (admittedly not so interesting)\n                examples, with two modules `A` and `B`::\n\n                    sage: A = CombinatorialFreeModule(ZZ, [1,2], prefix=\"A\"); A.rename(\"A\")\n                    sage: B = CombinatorialFreeModule(ZZ, [3,4], prefix=\"B\"); B.rename(\"B\")\n\n                and `f` the bilinear morphism `(a,b) \\mapsto b \\otimes a`\n                from `A \\times B` to `B \\otimes A`::\n\n                    sage: def f(a,b):\n                    ....:     return tensor([b,a])\n\n                Now, calling applying `f` on `a \\otimes b` returns the same\n                as `f(a,b)`::\n\n                    sage: a = A.monomial(1) + 2 * A.monomial(2); a\n                    A[1] + 2*A[2]\n                    sage: b = B.monomial(3) - 2 * B.monomial(4); b\n                    B[3] - 2*B[4]\n                    sage: f(a,b)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n\n                `f` may be a bilinear morphism to any module over the\n                base ring of `A` and `B`. Here the codomain is `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients(), 0) * sum(b.coefficients(), 0)\n                    sage: f(a,b)\n                    -3\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    -3\n\n                Mind the `0` in the sums above; otherwise `f` would\n                not return `0` in `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients()) * sum(b.coefficients())\n                    sage: type(f(A.zero(), B.zero()))\n                    <type 'int'>\n\n                Which would be wrong and break this method::\n\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    Traceback (most recent call last):\n                    ...\n                    AttributeError: 'int' object has no attribute 'parent'\n\n                Here we consider an example where the codomain is a\n                module with basis with a different base ring::\n\n                    sage: C = CombinatorialFreeModule(QQ, [(1,3),(2,4)], prefix=\"C\"); C.rename(\"C\")\n                    sage: def f(a,b):\n                    ....:     return C.sum_of_terms( [((1,3), QQ(a[1]*b[3])), ((2,4), QQ(a[2]*b[4]))] )\n                    sage: f(a,b)\n                    C[(1, 3)] - 4*C[(2, 4)]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    C[(1, 3)] - 4*C[(2, 4)]\n\n                 We conclude with a real life application, where we\n                 check that the antipode of the Hopf algebra of\n                 Symmetric functions on the Schur basis satisfies its\n                 defining formula::\n\n                    sage: Sym = SymmetricFunctions(QQ)\n                    sage: s = Sym.schur()\n                    sage: def f(a,b): return a*b.antipode()\n                    sage: x = 4*s.an_element(); x\n                    8*s[] + 8*s[1] + 12*s[2]\n                    sage: x.coproduct().apply_multilinear_morphism(f)\n                    8*s[]\n                    sage: x.coproduct().apply_multilinear_morphism(f) == x.counit()\n                    True\n\n                We recover the constant term of `x`, as desired.\n\n                .. TODO::\n\n                    Extract a method to linearize a multilinear\n                    morphism, and delegate the work there.\n                ",
                    "args": [
                        "self",
                        "f",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "codomain"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.modules.Modules.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules with basis constructed by tensor product of\n        modules with basis.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts",
        "parent_class": {
            "__doc__": "\n            Implements operations on tensor products of modules with basis.\n            ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of modules\n            with basis.\n            ",
            "methods": {
                "apply_multilinear_morphism": {
                    "__doc__": "\n                Return the result of applying the morphism induced by ``f``\n                to ``self``.\n\n                INPUT:\n\n                - ``f`` -- a multilinear morphism from the component\n                  modules of the parent tensor product to any module\n\n                - ``codomain`` -- the codomain of ``f`` (optional)\n\n                By the universal property of the tensor product, ``f``\n                induces a linear morphism from `self.parent()` to the\n                target module. Returns the result of applying that\n                morphism to ``self``.\n\n                The codomain is used for optimizations purposes\n                only. If it's not provided, it's recovered by calling\n                ``f`` on the zero input.\n\n                EXAMPLES:\n\n                We start with simple (admittedly not so interesting)\n                examples, with two modules `A` and `B`::\n\n                    sage: A = CombinatorialFreeModule(ZZ, [1,2], prefix=\"A\"); A.rename(\"A\")\n                    sage: B = CombinatorialFreeModule(ZZ, [3,4], prefix=\"B\"); B.rename(\"B\")\n\n                and `f` the bilinear morphism `(a,b) \\mapsto b \\otimes a`\n                from `A \\times B` to `B \\otimes A`::\n\n                    sage: def f(a,b):\n                    ....:     return tensor([b,a])\n\n                Now, calling applying `f` on `a \\otimes b` returns the same\n                as `f(a,b)`::\n\n                    sage: a = A.monomial(1) + 2 * A.monomial(2); a\n                    A[1] + 2*A[2]\n                    sage: b = B.monomial(3) - 2 * B.monomial(4); b\n                    B[3] - 2*B[4]\n                    sage: f(a,b)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n\n                `f` may be a bilinear morphism to any module over the\n                base ring of `A` and `B`. Here the codomain is `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients(), 0) * sum(b.coefficients(), 0)\n                    sage: f(a,b)\n                    -3\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    -3\n\n                Mind the `0` in the sums above; otherwise `f` would\n                not return `0` in `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients()) * sum(b.coefficients())\n                    sage: type(f(A.zero(), B.zero()))\n                    <type 'int'>\n\n                Which would be wrong and break this method::\n\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    Traceback (most recent call last):\n                    ...\n                    AttributeError: 'int' object has no attribute 'parent'\n\n                Here we consider an example where the codomain is a\n                module with basis with a different base ring::\n\n                    sage: C = CombinatorialFreeModule(QQ, [(1,3),(2,4)], prefix=\"C\"); C.rename(\"C\")\n                    sage: def f(a,b):\n                    ....:     return C.sum_of_terms( [((1,3), QQ(a[1]*b[3])), ((2,4), QQ(a[2]*b[4]))] )\n                    sage: f(a,b)\n                    C[(1, 3)] - 4*C[(2, 4)]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    C[(1, 3)] - 4*C[(2, 4)]\n\n                 We conclude with a real life application, where we\n                 check that the antipode of the Hopf algebra of\n                 Symmetric functions on the Schur basis satisfies its\n                 defining formula::\n\n                    sage: Sym = SymmetricFunctions(QQ)\n                    sage: s = Sym.schur()\n                    sage: def f(a,b): return a*b.antipode()\n                    sage: x = 4*s.an_element(); x\n                    8*s[] + 8*s[1] + 12*s[2]\n                    sage: x.coproduct().apply_multilinear_morphism(f)\n                    8*s[]\n                    sage: x.coproduct().apply_multilinear_morphism(f) == x.counit()\n                    True\n\n                We recover the constant term of `x`, as desired.\n\n                .. TODO::\n\n                    Extract a method to linearize a multilinear\n                    morphism, and delegate the work there.\n                ",
                    "args": [
                        "self",
                        "f",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "codomain"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
        "axioms": [
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.groups.Groups",
            "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "name": "sage.categories.category.JoinCategory",
        "parent_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    A class for joins of several categories. Do not use directly;\n    see Category.join instead.\n\n    EXAMPLES::\n\n        sage: from sage.categories.category import JoinCategory\n        sage: J = JoinCategory((Groups(), CommutativeAdditiveMonoids())); J\n        Join of Category of groups and Category of commutative additive monoids\n        sage: J.super_categories()\n        [Category of groups, Category of commutative additive monoids]\n        sage: J.all_super_categories(proper=True)\n        [Category of groups, ..., Category of magmas,\n         Category of commutative additive monoids, ..., Category of additive magmas,\n         Category of sets, Category of sets with partial maps, Category of objects]\n\n    By :trac:`11935`, join categories and categories over base rings\n    inherit from :class:`CategoryWithParameters`. This allows for\n    sharing parent and element classes between similar categories. For\n    example, since group algebras belong to a join category and since\n    the underlying implementation is the same for all finite fields,\n    we have::\n\n        sage: G = SymmetricGroup(10)\n        sage: A3 = G.algebra(GF(3))\n        sage: A5 = G.algebra(GF(5))\n        sage: type(A3.category())\n        <class 'sage.categories.category.JoinCategory_with_category'>\n        sage: type(A3) is type(A5)\n        True\n\n    .. automethod:: _repr_object_names\n    .. automethod:: _repr_\n    .. automethod:: _without_axioms\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded modules with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "degree_negation": {
                    "__doc__": "\n            Return the image of ``self`` under the degree negation\n            automorphism of the graded module to which ``self`` belongs.\n\n            The degree negation is the module automorphism which scales\n            every homogeneous element of degree `k` by `(-1)^k` (for all\n            `k`). This assumes that the module to which ``self`` belongs\n            (that is, the module ``self.parent()``) is `\\ZZ`-graded.\n\n            EXAMPLES::\n\n                sage: E.<a,b> = ExteriorAlgebra(QQ)\n                sage: ((1 + a) * (1 + b)).degree_negation()\n                a^b - a - b + 1\n                sage: E.zero().degree_negation()\n                0\n\n                sage: P = GradedModulesWithBasis(ZZ).example(); P\n                An example of a graded module with basis: the free module on partitions over Integer Ring\n                sage: pbp = lambda x: P.basis()[Partition(list(x))]\n                sage: p = pbp([3,1]) - 2 * pbp([2]) + 4 * pbp([1])\n                sage: p.degree_negation()\n                -4*P[1] - 2*P[2] + P[3, 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis",
            "sage.categories.graded_modules.GradedModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded modules with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_modules_with_basis.GradedModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "degree_negation": {
                    "__doc__": "\n            Return the image of ``element`` under the degree negation\n            automorphism of the graded module ``self``.\n\n            The degree negation is the module automorphism which scales\n            every homogeneous element of degree `k` by `(-1)^k` (for all\n            `k`). This assumes that the module ``self`` is `\\ZZ`-graded.\n\n            INPUT:\n\n            - ``element`` -- element of the module ``self``\n\n            EXAMPLES::\n\n                sage: E.<a,b> = ExteriorAlgebra(QQ)\n                sage: E.degree_negation((1 + a) * (1 + b))\n                a^b - a - b + 1\n                sage: E.degree_negation(E.zero())\n                0\n\n                sage: P = GradedModulesWithBasis(ZZ).example(); P\n                An example of a graded module with basis: the free module on partitions over Integer Ring\n                sage: pbp = lambda x: P.basis()[Partition(list(x))]\n                sage: p = pbp([3,1]) - 2 * pbp([2]) + 4 * pbp([1])\n                sage: P.degree_negation(p)\n                -4*P[1] - 2*P[2] + P[3, 1]\n            ",
                    "args": [
                        "self",
                        "element"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "degree_negation": {
                    "__doc__": "\n            Return the image of ``self`` under the degree negation\n            automorphism of the graded module to which ``self`` belongs.\n\n            The degree negation is the module automorphism which scales\n            every homogeneous element of degree `k` by `(-1)^k` (for all\n            `k`). This assumes that the module to which ``self`` belongs\n            (that is, the module ``self.parent()``) is `\\ZZ`-graded.\n\n            EXAMPLES::\n\n                sage: E.<a,b> = ExteriorAlgebra(QQ)\n                sage: ((1 + a) * (1 + b)).degree_negation()\n                a^b - a - b + 1\n                sage: E.zero().degree_negation()\n                0\n\n                sage: P = GradedModulesWithBasis(ZZ).example(); P\n                An example of a graded module with basis: the free module on partitions over Integer Ring\n                sage: pbp = lambda x: P.basis()[Partition(list(x))]\n                sage: p = pbp([3,1]) - 2 * pbp([2]) + 4 * pbp([1])\n                sage: p.degree_negation()\n                -4*P[1] - 2*P[2] + P[3, 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Endset",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.homsets.Homsets.Endset",
            "sage.categories.modules.Modules.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.Homsets.Endset",
        "parent_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.homsets.HomsetsOf",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modules.Modules.Homsets"
        ],
        "subcategory_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas",
            "sage.categories.magmas.Magmas.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of all modules over a base ring `R`.\n\n    An `R`-module `M` is a left and right `R`-module over a\n    commutative ring `R` such that:\n\n    .. MATH::\n\n        r*(x*s) = (r*x)*s \\qquad  \\forall r,s \\in R \\text{ and } x \\in M\n\n    INPUT:\n\n    - ``base_ring`` -- a ring `R` or subcategory of ``Rings()``\n    - ``dispatch`` -- a boolean (for internal use; default: ``True``)\n\n    When the base ring is a field, the category of vector spaces is\n    returned instead (unless ``dispatch == False``).\n\n    .. WARNING::\n\n        Outside of the context of symmetric modules over a commutative\n        ring, the specifications of this category are fuzzy and not\n        yet set in stone (see below). The code in this category and\n        its subcategories is therefore prone to bugs or arbitrary\n        limitations in this case.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ)\n        Category of modules over Integer Ring\n        sage: Modules(QQ)\n        Category of vector spaces over Rational Field\n\n        sage: Modules(Rings())\n        Category of modules over rings\n        sage: Modules(FiniteFields())\n        Category of vector spaces over finite fields\n\n        sage: Modules(Integers(9))\n        Category of modules over Ring of integers modulo 9\n\n        sage: Modules(Integers(9)).super_categories()\n        [Category of bimodules over Ring of integers modulo 9 on the left and Ring of integers modulo 9 on the right]\n\n        sage: Modules(ZZ).super_categories()\n        [Category of bimodules over Integer Ring on the left and Integer Ring on the right]\n\n        sage: Modules == RingModules\n        True\n\n        sage: Modules(ZZ['x']).is_abelian()   # see #6081\n        True\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ)).run()\n\n    .. TODO::\n\n        - Clarify the distinction, if any, with ``BiModules(R, R)``.\n          In particular, if `R` is a commutative ring (e.g. a field),\n          some pieces of the code possibly assume that `M` is a\n          *symmetric `R`-`R`-bimodule*:\n\n          .. MATH::\n\n              r*x = x*r \\qquad  \\forall r \\in R \\text{ and } x \\in M\n\n        - Make sure that non symmetric modules are properly supported\n          by all the code, and advertise it.\n\n        - Make sure that non commutative rings are properly supported\n          by all the code, and advertise it.\n\n        - Add support for base semirings.\n\n        - Implement a ``FreeModules(R)`` category, when so prompted by a\n          concrete use case: e.g.  modeling a free module with several\n          bases (using :meth:`Sets.SubcategoryMethods.Realizations`)\n          or with an atlas of local maps (see e.g. :trac:`15916`).\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "__mul__": {
                    "__doc__": "Modules__mul__(Element left, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 86)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``left`` -- an element of a :class:`module <Modules>`\n    - ``right`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the right\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: x * int(2)\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__rmul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a\n    Cython method in :mod:`sage.categories.magmas_cython`::\n\n        sage: x.__mul__.im_func is Modules.ElementMethods.__mul__.im_func\n        True\n        sage: x.__mul__.im_func is sage.categories.coercion_methods.Modules__mul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__rmul__": {
                    "__doc__": "Modules__rmul__(Element right, left)\nFile: sage/categories/coercion_methods.pyx (starting at line 122)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``right`` -- an element of a :class:`module <Modules>`\n    - ``left`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the left\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: int(2) * x\n        2*B['a']\n        sage: x.__rmul__(int(2))\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__mul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a Cython\n    method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__rmul__.im_func is Modules.ElementMethods.__rmul__.im_func\n        True\n        sage: x.__rmul__.im_func is sage.categories.coercion_methods.Modules__rmul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "right",
                        "left"
                    ],
                    "argspec": [
                        [
                            "right",
                            "left"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.bimodules.Bimodules"
        ],
        "mmt": "Modules",
        "morphism_class": {
            "__doc__": "\n    The category of all modules over a base ring `R`.\n\n    An `R`-module `M` is a left and right `R`-module over a\n    commutative ring `R` such that:\n\n    .. MATH::\n\n        r*(x*s) = (r*x)*s \\qquad  \\forall r,s \\in R \\text{ and } x \\in M\n\n    INPUT:\n\n    - ``base_ring`` -- a ring `R` or subcategory of ``Rings()``\n    - ``dispatch`` -- a boolean (for internal use; default: ``True``)\n\n    When the base ring is a field, the category of vector spaces is\n    returned instead (unless ``dispatch == False``).\n\n    .. WARNING::\n\n        Outside of the context of symmetric modules over a commutative\n        ring, the specifications of this category are fuzzy and not\n        yet set in stone (see below). The code in this category and\n        its subcategories is therefore prone to bugs or arbitrary\n        limitations in this case.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ)\n        Category of modules over Integer Ring\n        sage: Modules(QQ)\n        Category of vector spaces over Rational Field\n\n        sage: Modules(Rings())\n        Category of modules over rings\n        sage: Modules(FiniteFields())\n        Category of vector spaces over finite fields\n\n        sage: Modules(Integers(9))\n        Category of modules over Ring of integers modulo 9\n\n        sage: Modules(Integers(9)).super_categories()\n        [Category of bimodules over Ring of integers modulo 9 on the left and Ring of integers modulo 9 on the right]\n\n        sage: Modules(ZZ).super_categories()\n        [Category of bimodules over Integer Ring on the left and Integer Ring on the right]\n\n        sage: Modules == RingModules\n        True\n\n        sage: Modules(ZZ['x']).is_abelian()   # see #6081\n        True\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ)).run()\n\n    .. TODO::\n\n        - Clarify the distinction, if any, with ``BiModules(R, R)``.\n          In particular, if `R` is a commutative ring (e.g. a field),\n          some pieces of the code possibly assume that `M` is a\n          *symmetric `R`-`R`-bimodule*:\n\n          .. MATH::\n\n              r*x = x*r \\qquad  \\forall r \\in R \\text{ and } x \\in M\n\n        - Make sure that non symmetric modules are properly supported\n          by all the code, and advertise it.\n\n        - Make sure that non commutative rings are properly supported\n          by all the code, and advertise it.\n\n        - Add support for base semirings.\n\n        - Implement a ``FreeModules(R)`` category, when so prompted by a\n          concrete use case: e.g.  modeling a free module with several\n          bases (using :meth:`Sets.SubcategoryMethods.Realizations`)\n          or with an atlas of local maps (see e.g. :trac:`15916`).\n    ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "tensor_square": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "__mul__": {
                    "__doc__": "Modules__mul__(Element left, right)\nFile: sage/categories/coercion_methods.pyx (starting at line 86)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``left`` -- an element of a :class:`module <Modules>`\n    - ``right`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the right\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: x * int(2)\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__rmul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a\n    Cython method in :mod:`sage.categories.magmas_cython`::\n\n        sage: x.__mul__.im_func is Modules.ElementMethods.__mul__.im_func\n        True\n        sage: x.__mul__.im_func is sage.categories.coercion_methods.Modules__mul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__rmul__": {
                    "__doc__": "Modules__rmul__(Element right, left)\nFile: sage/categories/coercion_methods.pyx (starting at line 122)\n\n    Return the product of ``left`` and ``right``.\n\n    INPUT:\n\n    - ``right`` -- an element of a :class:`module <Modules>`\n    - ``left`` -- any object\n\n    EXAMPLES:\n\n    This is used when multiplying an element of a module on the left\n    by something, typically a coefficient::\n\n        sage: F = CombinatorialFreeModule(QQ, [\"a\", \"b\"])\n        sage: x = F.monomial(\"a\")\n        sage: int(2) * x\n        2*B['a']\n        sage: x.__rmul__(int(2))\n        2*B['a']\n\n    .. SEEALSO:: :meth:`Modules.ElementMethods.__mul__`\n\n    This is :meth:`Modules.ElementMethods.__rmul__`, implemented as a Cython\n    method in :mod:`sage.categories.coercion_methods`::\n\n        sage: x.__rmul__.im_func is Modules.ElementMethods.__rmul__.im_func\n        True\n        sage: x.__rmul__.im_func is sage.categories.coercion_methods.Modules__rmul__\n        True\n\n    .. TODO::\n\n        Make a better unit test once ``Modules().example()`` is implemented.\n    ",
                    "args": [
                        "right",
                        "left"
                    ],
                    "argspec": [
                        [
                            "right",
                            "left"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Irreducible",
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups.Irreducible",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "Connected",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.filtered_modules.FilteredModules.Connected",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "Distributive",
            "AdditiveAssociative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative",
            "sage.categories.commutative_additive_semigroups.CommutativeAdditiveSemigroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Inverse",
            "WellGenerated",
            "FinitelyGeneratedAsMagma",
            "Unital",
            "Finite",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_complex_reflection_groups.FiniteComplexReflectionGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.finite_complex_reflection_groups.FiniteComplexReflectionGroups.WellGenerated",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_well_generated": {
                    "__doc__": "\n                Check if ``self`` is well-generated.\n\n                EXAMPLES::\n\n                    sage: W = ReflectionGroup((3,1,2))     # optional - gap3\n                    sage: W._test_well_generated()         # optional - gap3\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "coxeter_element": {
                    "__doc__": "CachedMethodCallerNoArgs(inst, f, cache=None, name=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2099)\n\n    Utility class that is used by :class:`CachedMethod` to bind a\n    cached method to an instance, in the case of a method that does\n    not accept any arguments except ``self``.\n\n    .. NOTE::\n\n        The return value ``None`` would not be cached. So, if you have\n        a method that does not accept arguments and may return ``None``\n        after a lengthy computation, then ``@cached_method`` should not\n        be used.\n\n    EXAMPLE::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: I.gens\n        Cached version of <function gens at 0x...>\n        sage: type(I.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n        sage: I.gens is I.gens\n        True\n        sage: I.gens() is I.gens()\n        True\n\n    AUTHOR:\n\n    - Simon King (2011-04)\n    ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coxeter_elements": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "standard_coxeter_elements": {
                    "__doc__": "CachedMethodCallerNoArgs(inst, f, cache=None, name=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2099)\n\n    Utility class that is used by :class:`CachedMethod` to bind a\n    cached method to an instance, in the case of a method that does\n    not accept any arguments except ``self``.\n\n    .. NOTE::\n\n        The return value ``None`` would not be cached. So, if you have\n        a method that does not accept arguments and may return ``None``\n        after a lengthy computation, then ``@cached_method`` should not\n        be used.\n\n    EXAMPLE::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: I.gens\n        Cached version of <function gens at 0x...>\n        sage: type(I.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n        sage: I.gens is I.gens\n        True\n        sage: I.gens() is I.gens()\n        True\n\n    AUTHOR:\n\n    - Simon King (2011-04)\n    ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of sets `(S,+,*)` with `*` distributing on `+`.\n\n    This is similar to a ring, but `+` and `*` are only required to be\n    (additive) magmas.\n\n    EXAMPLES::\n\n        sage: from sage.categories.distributive_magmas_and_additive_magmas import DistributiveMagmasAndAdditiveMagmas\n        sage: C = DistributiveMagmasAndAdditiveMagmas(); C\n        Category of distributive magmas and additive magmas\n        sage: C.super_categories()\n        [Category of magmas and additive magmas]\n\n    TESTS::\n\n        sage: from sage.categories.magmas_and_additive_magmas import MagmasAndAdditiveMagmas\n        sage: C is MagmasAndAdditiveMagmas().Distributive()\n        True\n        sage: C is (Magmas() & AdditiveMagmas()).Distributive()\n        True\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "Distributive"
        ],
        "element_class": {
            "__doc__": "\n    The category of sets `(S,+,*)` with `*` distributing on `+`.\n\n    This is similar to a ring, but `+` and `*` are only required to be\n    (additive) magmas.\n\n    EXAMPLES::\n\n        sage: from sage.categories.distributive_magmas_and_additive_magmas import DistributiveMagmasAndAdditiveMagmas\n        sage: C = DistributiveMagmasAndAdditiveMagmas(); C\n        Category of distributive magmas and additive magmas\n        sage: C.super_categories()\n        [Category of magmas and additive magmas]\n\n    TESTS::\n\n        sage: from sage.categories.magmas_and_additive_magmas import MagmasAndAdditiveMagmas\n        sage: C is MagmasAndAdditiveMagmas().Distributive()\n        True\n        sage: C is (Magmas() & AdditiveMagmas()).Distributive()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of sets `(S,+,*)` with `*` distributing on `+`.\n\n    This is similar to a ring, but `+` and `*` are only required to be\n    (additive) magmas.\n\n    EXAMPLES::\n\n        sage: from sage.categories.distributive_magmas_and_additive_magmas import DistributiveMagmasAndAdditiveMagmas\n        sage: C = DistributiveMagmasAndAdditiveMagmas(); C\n        Category of distributive magmas and additive magmas\n        sage: C.super_categories()\n        [Category of magmas and additive magmas]\n\n    TESTS::\n\n        sage: from sage.categories.magmas_and_additive_magmas import MagmasAndAdditiveMagmas\n        sage: C is MagmasAndAdditiveMagmas().Distributive()\n        True\n        sage: C is (Magmas() & AdditiveMagmas()).Distributive()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_distributivity": {
                    "__doc__": "\n            Test the distributivity of `*` on `+` on (not necessarily\n            all) elements of this set.\n\n            INPUT:\n\n            - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n            EXAMPLES:\n\n            By default, this method runs the tests only on the\n            elements returned by ``self.some_elements()``::\n\n                sage: NN.some_elements()\n                [0, 1, 3, 42]\n                sage: NN._test_distributivity()\n\n            However, the elements tested can be customized with the\n            ``elements`` keyword argument::\n\n                sage: CC._test_distributivity(elements=[CC(0),CC(1),CC(3),CC(I)])\n\n            See the documentation for :class:`TestSuite` for more information.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of sets `(S,+,*)` with `*` distributing on `+`.\n\n    This is similar to a ring, but `+` and `*` are only required to be\n    (additive) magmas.\n\n    EXAMPLES::\n\n        sage: from sage.categories.distributive_magmas_and_additive_magmas import DistributiveMagmasAndAdditiveMagmas\n        sage: C = DistributiveMagmasAndAdditiveMagmas(); C\n        Category of distributive magmas and additive magmas\n        sage: C.super_categories()\n        [Category of magmas and additive magmas]\n\n    TESTS::\n\n        sage: from sage.categories.magmas_and_additive_magmas import MagmasAndAdditiveMagmas\n        sage: C is MagmasAndAdditiveMagmas().Distributive()\n        True\n        sage: C is (Magmas() & AdditiveMagmas()).Distributive()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite dimensional modules with a distinguished basis\n\n    EXAMPLES::\n\n      sage: C = FiniteDimensionalModulesWithBasis(ZZ); C\n      Category of finite dimensional modules with basis over Integer Ring\n      sage: sorted(C.super_categories(), key=str)\n      [Category of finite dimensional modules over Integer Ring,\n       Category of modules with basis over Integer Ring]\n      sage: C is Modules(ZZ).WithBasis().FiniteDimensional()\n      True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "FiniteDimensional"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "dense_coefficient_list": {
                    "__doc__": "\n            Return a list of *all* coefficients of ``self``.\n\n            By default, this list is ordered in the same way as the\n            indexing set of the basis of the parent of ``self``.\n\n            INPUT:\n\n            - ``order`` -- (optional) an ordering of the basis indexing set\n\n            EXAMPLES::\n\n                sage: v = vector([0, -1, -3])\n                sage: v.dense_coefficient_list()\n                [0, -1, -3]\n                sage: v.dense_coefficient_list([2,1,0])\n                [-3, -1, 0]\n                sage: sorted(v.coefficients())\n                [-3, -1]\n            ",
                    "args": [
                        "self",
                        "order"
                    ],
                    "argspec": [
                        [
                            "self",
                            "order"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "gap": "IsFiniteDimensional",
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.modules.Modules.FiniteDimensional"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {
                "image": {
                    "__doc__": "\n            Return the image of ``self`` as a submodule of the codomain.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: f.image()\n                Free module generated by {0, 1, 2} over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "image_basis": {
                    "__doc__": "\n            Return a basis for the image of ``self`` in echelon form.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: f.image_basis()\n                ([1, 2, 3], [2, 3, 1], [3, 1, 2])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "kernel": {
                    "__doc__": "\n            Return the kernel of ``self`` as a submodule of the domain.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: K = f.kernel()\n                sage: K\n                Free module generated by {0, 1, 2} over Rational Field\n                sage: K.ambient()\n                Symmetric group algebra of order 3 over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "kernel_basis": {
                    "__doc__": "\n            Return a basis of the kernel of ``self`` in echelon form.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: f.kernel_basis()\n                ([1, 2, 3] - [3, 2, 1], [1, 3, 2] - [3, 2, 1], [2, 1, 3] - [3, 2, 1])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "matrix": {
                    "__doc__": "\n            Return the matrix of this morphism in the distinguished\n            bases of the domain and codomain.\n\n            INPUT:\n\n            - ``base_ring`` -- a ring (default: ``None``, meaning the\n              base ring of the codomain)\n\n            - ``side`` -- \"left\" or \"right\" (default: \"left\")\n\n            If ``side`` is \"left\", this morphism is considered as\n            acting on the left; i.e. each column of the matrix\n            represents the image of an element of the basis of the\n            domain.\n\n            The order of the rows and columns matches with the order\n            in which the bases are enumerated.\n\n            .. SEEALSO:: :func:`Modules.WithBasis.ParentMethods.module_morphism`\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2]); x = X.basis()\n                sage: Y = CombinatorialFreeModule(ZZ, [3,4]); y = Y.basis()\n                sage: phi = X.module_morphism(on_basis = {1: y[3] + 3*y[4], 2: 2*y[3] + 5*y[4]}.__getitem__,\n                ...                           codomain = Y)\n                sage: phi.matrix()\n                [1 2]\n                [3 5]\n                sage: phi.matrix(side=\"right\")\n                [1 3]\n                [2 5]\n\n                sage: phi.matrix().parent()\n                Full MatrixSpace of 2 by 2 dense matrices over Integer Ring\n                sage: phi.matrix(QQ).parent()\n                Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n\n            The resulting matrix is immutable::\n\n                sage: phi.matrix().is_mutable()\n                False\n\n            The zero morphism has a zero matrix::\n\n                sage: Hom(X,Y).zero().matrix()\n                [0 0]\n                [0 0]\n\n            .. TODO::\n\n                Add support for morphisms where the codomain has a\n                different base ring than the domain::\n\n                    sage: Y = CombinatorialFreeModule(QQ, [3,4]); y = Y.basis()\n                    sage: phi = X.module_morphism(on_basis = {1: y[3] + 3*y[4], 2: 2*y[3] + 5/2*y[4]}.__getitem__,\n                    ...                           codomain = Y)\n                    sage: phi.matrix().parent()          # todo: not implemented\n                    Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n\n                This currently does not work because, in this case,\n                the morphism is just in the category of commutative\n                additive groups (i.e. the intersection of the\n                categories of modules over `\\ZZ` and over `\\QQ`)::\n\n                    sage: phi.parent().homset_category()\n                    Category of commutative additive semigroups\n                    sage: phi.parent().homset_category() # todo: not implemented\n                    Category of finite dimensional modules with basis over Integer Ring\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "left"
                        ]
                    ]
                }
            }
        },
        "name": "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "annihilator": {
                    "__doc__": "\n            Return the annihilator of a finite set.\n\n            INPUT:\n\n            - ``S`` -- a finite set\n\n            - ``action`` -- a function (default: :obj:`operator.mul`)\n\n            - ``side`` -- 'left' or 'right' (default: 'right')\n\n            - ``category`` -- a category\n\n            Assumptions:\n\n            - ``action`` takes elements of ``self`` as first argument\n              and elements of ``S`` as second argument;\n\n            - The codomain is any vector space, and ``action`` is\n              linear on its first argument; typically it is bilinear;\n\n            - If ``side`` is 'left', this is reversed.\n\n            OUTPUT:\n\n            The subspace of the elements `x` of ``self`` such that\n            ``action(x,s) = 0`` for all `s\\in S`. If ``side`` is\n            'left' replace the above equation by ``action(s,x) = 0``.\n\n            If ``self`` is a ring, ``action`` an action of ``self`` on\n            a module `M` and `S` is a subset of `M`, we recover the\n            :Wikipedia:`Annihilator_%28ring_theory%29`. Similarly this\n            can be used to compute torsion or orthogonals.\n\n            .. SEEALSO:: :meth:`annihilator_basis` for lots of examples.\n\n            EXAMPLES::\n\n                sage: F = FiniteDimensionalAlgebrasWithBasis(QQ).example(); F\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: x,y,a,b = F.basis()\n                sage: A = F.annihilator([a + 3*b + 2*y]); A\n                Free module generated by {0} over Rational Field\n                sage: [b.lift() for b in A.basis()]\n                [-1/2*a - 3/2*b + x]\n\n            The category can be used to specify other properties of\n            this subspace, like that this is a subalgebra::\n\n                sage: center = F.annihilator(F.basis(), F.bracket,\n                ....:                        category=Algebras(QQ).Subobjects())\n                sage: (e,) = center.basis()\n                sage: e.lift()\n                x + y\n                sage: e * e == e\n                True\n\n            Taking annihilator is order reversing for inclusion::\n\n                sage: A   = F.annihilator([]);    A  .rename(\"A\")\n                sage: Ax  = F.annihilator([x]);   Ax .rename(\"Ax\")\n                sage: Ay  = F.annihilator([y]);   Ay .rename(\"Ay\")\n                sage: Axy = F.annihilator([x,y]); Axy.rename(\"Axy\")\n                sage: P = Poset(([A, Ax, Ay, Axy], attrcall(\"is_submodule\")))\n                sage: sorted(P.cover_relations(), key=str)\n                [[Ax, A], [Axy, Ax], [Axy, Ay], [Ay, A]]\n            ",
                    "args": [
                        "self",
                        "S",
                        "action",
                        "side",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S",
                            "action",
                            "side",
                            "category"
                        ],
                        null,
                        null,
                        [
                            "<built-in function mul>",
                            "right",
                            null
                        ]
                    ]
                },
                "annihilator_basis": {
                    "__doc__": "\n            Return a basis of the annihilator of a finite set of elements.\n\n            INPUT:\n\n            - ``S`` -- a finite set of objects\n\n            - ``action`` -- a function (default: :obj:`operator.mul`)\n\n            - ``side`` -- 'left' or 'right' (default: 'right'):\n              on which side of ``self`` the elements of `S` acts.\n\n            See :meth:`annihilator` for the assumptions and definition\n            of the annihilator.\n\n            EXAMPLES:\n\n            By default, the action is the standard `*` operation. So\n            our first example is about an algebra::\n\n                sage: F = FiniteDimensionalAlgebrasWithBasis(QQ).example(); F\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: x,y,a,b = F.basis()\n\n            In this algebra, multiplication on the right by `x`\n            annihilates all basis elements but `x`::\n\n                sage: x*x, y*x, a*x, b*x\n                (x, 0, 0, 0)\n\n            So the annihilator is the subspace spanned by `y`, `a`, and `b`::\n\n                sage: F.annihilator_basis([x])\n                (y, a, b)\n\n            The same holds for `a` and `b`::\n\n                sage: x*a, y*a, a*a, b*a\n                (a, 0, 0, 0)\n                sage: F.annihilator_basis([a])\n                (y, a, b)\n\n            On the other hand, `y` annihilates only `x`::\n\n                sage: F.annihilator_basis([y])\n                (x,)\n\n            Here is a non trivial annihilator::\n\n                sage: F.annihilator_basis([a + 3*b + 2*y])\n                (-1/2*a - 3/2*b + x,)\n\n            Let's check it::\n\n                sage: (-1/2*a - 3/2*b + x) * (a + 3*b + 2*y)\n                0\n\n            Doing the same calculations on the left exchanges the\n            roles of `x` and `y`::\n\n                sage: F.annihilator_basis([y], side=\"left\")\n                (x, a, b)\n                sage: F.annihilator_basis([a], side=\"left\")\n                (x, a, b)\n                sage: F.annihilator_basis([b], side=\"left\")\n                (x, a, b)\n                sage: F.annihilator_basis([x], side=\"left\")\n                (y,)\n                sage: F.annihilator_basis([a+3*b+2*x], side=\"left\")\n                (-1/2*a - 3/2*b + y,)\n\n            By specifying an inner product, this method can be used to\n            compute the orthogonal of a subspace::\n\n                sage: x,y,a,b = F.basis()\n                sage: def scalar(u,v): return vector([sum(u[i]*v[i] for i in F.basis().keys())])\n                sage: F.annihilator_basis([x+y, a+b], scalar)\n                (x - y, a - b)\n\n            By specifying the standard Lie bracket as action, one can\n            compute the commutator of a subspace of `F`::\n\n                sage: F.annihilator_basis([a+b], action=F.bracket)\n                (x + y, a, b)\n\n            In particular one can compute a basis of the center of the\n            algebra. In our example, it is reduced to the identity::\n\n                sage: F.annihilator_basis(F.algebra_generators(), action=F.bracket)\n                (x + y,)\n\n            But see also\n            :meth:`FiniteDimensionalAlgebrasWithBasis.ParentMethods.center_basis`.\n            ",
                    "args": [
                        "self",
                        "S",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "<built-in function mul>",
                            "right"
                        ]
                    ]
                },
                "dimension": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method dimension at 0x7fe375ebb758>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "sage",
                    "gap_name": "Dimension",
                    "mmt_name": null
                },
                "quotient_module": {
                    "__doc__": "\n            Construct the quotient module ``self``/``submodule``.\n\n            INPUT:\n\n            - ``submodule`` -- a submodule with basis of ``self``, or\n              something that can be turned into one via\n              ``self.submodule(submodule)``.\n\n            - ``check``, ``already_echelonized`` -- passed down to\n              :meth:`ModulesWithBasis.ParentMethods.submodule`.\n\n            .. WARNING::\n\n                At this point, this only supports quotients by free\n                submodules admitting a basis in unitriangular echelon\n                form. In this case, the quotient is also a free\n                module, with a basis consisting of the retract of a\n                subset of the basis of ``self``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: Y = X.quotient_module([x[0]-x[1], x[1]-x[2]], already_echelonized=True)\n                sage: Y.print_options(prefix='y'); Y\n                Free module generated by {2} over Rational Field\n                sage: y = Y.basis()\n                sage: y[2]\n                y[2]\n                sage: y[2].lift()\n                x[2]\n                sage: Y.retract(x[0]+2*x[1])\n                3*y[2]\n\n                sage: R.<a,b> = QQ[]\n                sage: C = CombinatorialFreeModule(R, range(3), prefix='x')\n                sage: x = C.basis()\n                sage: gens = [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]\n                sage: Y = X.quotient_module(gens)\n\n            .. SEEALSO::\n\n                 - :meth:`Modules.WithBasis.ParentMethods.submodule`\n                 - :meth:`Rings.ParentMethods.quotient`\n                 - :class:`sage.modules.with_basis.subquotient.QuotientModuleWithBasis`\n            ",
                    "args": [
                        "self",
                        "submodule",
                        "check",
                        "already_echelonized",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "submodule",
                            "check",
                            "already_echelonized",
                            "category"
                        ],
                        null,
                        null,
                        [
                            true,
                            false,
                            null
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "dense_coefficient_list": {
                    "__doc__": "\n            Return a list of *all* coefficients of ``self``.\n\n            By default, this list is ordered in the same way as the\n            indexing set of the basis of the parent of ``self``.\n\n            INPUT:\n\n            - ``order`` -- (optional) an ordering of the basis indexing set\n\n            EXAMPLES::\n\n                sage: v = vector([0, -1, -3])\n                sage: v.dense_coefficient_list()\n                [0, -1, -3]\n                sage: v.dense_coefficient_list([2,1,0])\n                [-3, -1, 0]\n                sage: sorted(v.coefficients())\n                [-3, -1]\n            ",
                    "args": [
                        "self",
                        "order"
                    ],
                    "argspec": [
                        [
                            "self",
                            "order"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "__call_on_basis__": {
                    "__doc__": "\n                Construct a morphism in this homset from a function defined\n                on the basis.\n\n                INPUT:\n\n                - ``on_basis`` -- a function from the indices of the\n                  basis of the domain of ``self`` to the codomain of\n                  ``self``\n\n                This method simply delegates the work to\n                :meth:`ModulesWithBasis.ParentMethods.module_morphism`. It\n                is used by :meth:`Homset.__call__` to handle the\n                ``on_basis`` argument, and will disapear as soon as\n                the logic will be generalized.\n\n                EXAMPLES::\n\n                    sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                    sage: H = Hom(X, Y)\n                    sage: x = X.basis()\n\n                    sage: phi = H(on_basis = lambda i: Y.monomial(i) + 2*Y.monomial(i+1)) # indirect doctest\n                    sage: phi\n                    Generic morphism:\n                    From: X\n                    To:   Y\n                    sage: phi(x[1] + x[3])\n                    B[1] + 2*B[2] + B[3] + 2*B[4]\n\n                Diagonal functions can be constructed using the ``diagonal`` option::\n\n                    sage: X = CombinatorialFreeModule(QQ, [1,2,3,4]); X.rename(\"X\")\n                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4], key=\"Y\"); Y.rename(\"Y\")\n                    sage: H = Hom(X, Y)\n                    sage: x = X.basis()\n                    sage: phi = H(diagonal = lambda x: x^2)\n                    sage: phi(x[1] + x[2] + x[3])\n                    B[1] + 4*B[2] + 9*B[3]\n\n                TESTS::\n\n                As for usual homsets, the argument can be a Python function::\n\n                    sage: phi = H(lambda x: Y.zero())\n                    sage: phi\n                    Generic morphism:\n                      From: X\n                      To:   Y\n                    sage: phi(x[1] + x[3])\n                    0\n\n               We check that the homset category is properly set up::\n\n                    sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                    sage: H = Hom(X, Y)\n                    sage: H.zero().category_for()\n                    Category of finite dimensional vector spaces with basis over Rational Field\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.homsets.HomsetsOf",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.modules_with_basis.ModulesWithBasis.Homsets",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modules.Modules.Homsets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of left modules\n    left modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with left multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: LeftModules(ZZ)\n        Category of left modules over Integer Ring\n        sage: LeftModules(ZZ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(LeftModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of left modules\n    left modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with left multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: LeftModules(ZZ)\n        Category of left modules over Integer Ring\n        sage: LeftModules(ZZ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(LeftModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.left_modules.LeftModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of super modules with a distinguished basis.\n\n    An `R`-*super module with a distinguished basis* is an\n    `R`-super module equipped with an `R`-module basis whose elements are\n    homogeneous.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "even_component": {
                    "__doc__": "\n            Return the even component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.even_component()\n                x*y + 4\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x + y\n                sage: a.even_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_super_homogeneous": {
                    "__doc__": "\n            Return whether this element is homogeneous, in the sense\n            of a super module (i.e., is even or odd).\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x + y\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + x - 3*y + 4\n                sage: a.is_super_homogeneous()\n                False\n\n            The exterior algebra has a `\\ZZ` grading, which induces the\n            `\\ZZ / 2\\ZZ` grading. However the definition of homogeneous\n            elements differs because of the different gradings::\n\n                sage: E.<x,y> = ExteriorAlgebra(QQ)\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a.is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "odd_component": {
                    "__doc__": "\n            Return the odd component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.odd_component()\n                x - 3*y\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x*y\n                sage: a.odd_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.super_modules.SuperModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of super modules with a distinguished basis.\n\n    An `R`-*super module with a distinguished basis* is an\n    `R`-super module equipped with an `R`-module basis whose elements are\n    homogeneous.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.super_modules_with_basis.SuperModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_even_odd_on_basis": {
                    "__doc__": "\n            Return the parity of the basis element indexed by ``m``.\n\n            OUTPUT:\n\n            ``0`` if ``m`` is for an even element or ``1`` if ``m``\n            is for an odd element.\n\n            .. NOTE::\n\n                The default implementation assumes that the even/odd is\n                determined by the parity of :meth:`degree`.\n\n                Overwrite this method if the even/odd behavior is desired\n                to be independent.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: C._even_odd_on_basis((0,))\n                1\n                sage: C._even_odd_on_basis((0,1))\n                0\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "even_component": {
                    "__doc__": "\n            Return the even component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.even_component()\n                x*y + 4\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x + y\n                sage: a.even_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_super_homogeneous": {
                    "__doc__": "\n            Return whether this element is homogeneous, in the sense\n            of a super module (i.e., is even or odd).\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x + y\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + x - 3*y + 4\n                sage: a.is_super_homogeneous()\n                False\n\n            The exterior algebra has a `\\ZZ` grading, which induces the\n            `\\ZZ / 2\\ZZ` grading. However the definition of homogeneous\n            elements differs because of the different gradings::\n\n                sage: E.<x,y> = ExteriorAlgebra(QQ)\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a.is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "odd_component": {
                    "__doc__": "\n            Return the odd component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.odd_component()\n                x - 3*y\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x*y\n                sage: a.odd_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of right modules\n    right modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with right multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: RightModules(QQ)\n        Category of right modules over Rational Field\n        sage: RightModules(QQ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(RightModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of right modules\n    right modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with right multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: RightModules(QQ)\n        Category of right modules over Rational Field\n        sage: RightModules(QQ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(RightModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.right_modules.RightModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered modules with a distinguished basis.\n\n    A *filtered module with basis* over a ring `R` means\n    (for the purpose of this code) a filtered `R`-module `M`\n    with filtration `(F_i)_{i \\in I}` (typically `I = \\NN`)\n    endowed with a basis `(b_j)_{j \\in J}` of `M` and a partition\n    `J = \\bigsqcup_{i \\in I} J_i` of the set `J` (it is allowed\n    that some `J_i` are empty) such that for every `n \\in I`,\n    the subfamily `(b_j)_{j \\in U_n}`, where\n    `U_n = \\bigcup_{i \\leq n} J_i`, is a basis of the\n    `R`-submodule `F_n`.\n\n    For every `i \\in I`, the `R`-submodule of `M` spanned by\n    `(b_j)_{j \\in J_i}` is called the `i`-*th graded component*\n    (aka the `i`-*th homogeneous component*) of the filtered\n    module with basis `M`; the elements of this submodule are\n    referred to as *homogeneous elements of degree* `i`.\n    The `R`-module `M` is the direct sum of its `i`-th graded\n    components over all `i \\in I`, and thus becomes a graded\n    `R`-module with basis.\n    Conversely, any graded `R`-module with basis canonically\n    becomes a filtered `R`-module with basis (by defining\n    `F_n = \\bigoplus_{i \\leq n} G_i` where `G_i` is the `i`-th\n    graded component, and defining `J_i` as the indexing set\n    of the basis of the `i`-th graded component). Hence, the\n    notion of a filtered `R`-module with basis is equivalent\n    to the notion of a graded `R`-module with basis.\n\n    However, the *category* of filtered `R`-modules with basis is not\n    the category of graded `R`-modules with basis. Indeed, the *morphisms*\n    of filtered `R`-modules with basis are defined to be morphisms of\n    `R`-modules which send each `F_n` of the domain to the corresponding\n    `F_n` of the target; in contrast, the morphisms of graded `R`-modules\n    with basis must preserve each homogeneous component. Also,\n    the notion of a filtered algebra with basis differs from\n    that of a graded algebra with basis.\n\n    .. NOTE::\n\n        Currently, to make use of the functionality of this class,\n        an instance of ``FilteredModulesWithBasis`` should fulfill\n        the contract of a :class:`CombinatorialFreeModule` (most\n        likely by inheriting from it). It should also have the\n        indexing set `J` encoded as its ``_indices`` attribute,\n        and ``_indices.subset(size=i)`` should yield the subset\n        `J_i` (as an iterable). If the latter conditions are not\n        satisfied, then :meth:`basis` must be overridden.\n\n    .. NOTE::\n\n        One should implement a ``degree_on_basis`` method in the parent\n        class in order to fully utilize the methods of this category.\n        This might become a required abstract method in the future.\n\n    EXAMPLES::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered(); C\n        Category of filtered modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules over Integer Ring,\n         Category of modules with basis over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Filtered()\n        True\n\n    TESTS::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered()\n        sage: TestSuite(C).run()\n        sage: C = ModulesWithBasis(QQ).Filtered()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "degree_on_basis": {
                    "__doc__": "\n            Return the degree of the basis element indexed by ``m``\n            in ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(QQ).example()\n                sage: A.degree_on_basis(Partition((2,1)))\n                3\n                sage: A.degree_on_basis(Partition((4,2,1,1,1,1)))\n                10\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component": {
                    "__doc__": "\n            Return the homogeneous component of degree ``n`` of the\n            element ``self``.\n\n            Let `m` be an element of a filtered `R`-module `M` with\n            basis. Then, `m` can be uniquely written in the form\n            `m = \\sum_{i \\in I} m_i`, where each `m_i` is a\n            homogeneous element of degree `i`. For `n \\in I`, we\n            define the homogeneous component of degree `n` of the\n            element `m` to be `m_n`.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.homogeneous_component(-1)\n                0\n                sage: g.homogeneous_component(0)\n                1\n                sage: g.homogeneous_component(2)\n                -2*U['x']*U['y']\n                sage: g.homogeneous_component(5)\n                0\n                sage: g.homogeneous_component(7)\n                U['x']^2*U['y']^2*U['z']^3\n                sage: g.homogeneous_component(8)\n                0\n\n            TESTS:\n\n            Check that this really returns ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.homogeneous_component(3).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_homogeneous": {
                    "__doc__": "\n            Return whether the element ``self`` is homogeneous.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x=A(Partition((3,2,1)))\n                sage: y=A(Partition((4,4,1)))\n                sage: z=A(Partition((2,2,2)))\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x - y).is_homogeneous()\n                False\n                sage: (x+2*z).is_homogeneous()\n                True\n\n            Here is an example with a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x^3 - y^2).is_homogeneous()\n                True\n                sage: ((x + y)^2).is_homogeneous()\n                False\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis, or at least on a definition of homogeneous\n            components)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).is_homogeneous()\n                True\n                sage: (y*x).is_homogeneous()\n                False\n                sage: A.one().is_homogeneous()\n                True\n                sage: A.zero().is_homogeneous()\n                True\n                sage: (A.one()+x).is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "maximal_degree": {
                    "__doc__": "\n            The maximum of the degrees of the homogeneous components\n            of ``self``.\n\n            This is also the smallest `i` such that ``self`` belongs\n            to `F_i`. Hence, it does not depend on the basis of the\n            parent of ``self``.\n\n            .. SEEALSO:: :meth:`homogeneous_degree`\n\n            EXAMPLES:\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.maximal_degree()\n                6\n                sage: (x + 2*z).maximal_degree()\n                6\n                sage: (y - x).maximal_degree()\n                9\n                sage: (3*z).maximal_degree()\n                6\n\n            Now, we test this on a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.maximal_degree()\n                2\n                sage: (x^3 + 4*y^2).maximal_degree()\n                6\n                sage: ((1 + x)^3).maximal_degree()\n                6\n\n            Let us now test a filtered algebra::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).maximal_degree()\n                2\n                sage: (y*x).maximal_degree()\n                2\n                sage: A.one().maximal_degree()\n                0\n                sage: A.zero().maximal_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n                sage: (A.one()+x).maximal_degree()\n                1\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "truncate": {
                    "__doc__": "\n            Return the sum of the homogeneous components of degree\n            strictly less than ``n`` of ``self``.\n\n            See :meth:`homogeneous_component` for the notion of a\n            homogeneous component.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(-1)\n                0\n                sage: g.truncate(0)\n                0\n                sage: g.truncate(2)\n                2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(3)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(5)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(7)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(8)\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.truncate(0).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered modules with a distinguished basis.\n\n    A *filtered module with basis* over a ring `R` means\n    (for the purpose of this code) a filtered `R`-module `M`\n    with filtration `(F_i)_{i \\in I}` (typically `I = \\NN`)\n    endowed with a basis `(b_j)_{j \\in J}` of `M` and a partition\n    `J = \\bigsqcup_{i \\in I} J_i` of the set `J` (it is allowed\n    that some `J_i` are empty) such that for every `n \\in I`,\n    the subfamily `(b_j)_{j \\in U_n}`, where\n    `U_n = \\bigcup_{i \\leq n} J_i`, is a basis of the\n    `R`-submodule `F_n`.\n\n    For every `i \\in I`, the `R`-submodule of `M` spanned by\n    `(b_j)_{j \\in J_i}` is called the `i`-*th graded component*\n    (aka the `i`-*th homogeneous component*) of the filtered\n    module with basis `M`; the elements of this submodule are\n    referred to as *homogeneous elements of degree* `i`.\n    The `R`-module `M` is the direct sum of its `i`-th graded\n    components over all `i \\in I`, and thus becomes a graded\n    `R`-module with basis.\n    Conversely, any graded `R`-module with basis canonically\n    becomes a filtered `R`-module with basis (by defining\n    `F_n = \\bigoplus_{i \\leq n} G_i` where `G_i` is the `i`-th\n    graded component, and defining `J_i` as the indexing set\n    of the basis of the `i`-th graded component). Hence, the\n    notion of a filtered `R`-module with basis is equivalent\n    to the notion of a graded `R`-module with basis.\n\n    However, the *category* of filtered `R`-modules with basis is not\n    the category of graded `R`-modules with basis. Indeed, the *morphisms*\n    of filtered `R`-modules with basis are defined to be morphisms of\n    `R`-modules which send each `F_n` of the domain to the corresponding\n    `F_n` of the target; in contrast, the morphisms of graded `R`-modules\n    with basis must preserve each homogeneous component. Also,\n    the notion of a filtered algebra with basis differs from\n    that of a graded algebra with basis.\n\n    .. NOTE::\n\n        Currently, to make use of the functionality of this class,\n        an instance of ``FilteredModulesWithBasis`` should fulfill\n        the contract of a :class:`CombinatorialFreeModule` (most\n        likely by inheriting from it). It should also have the\n        indexing set `J` encoded as its ``_indices`` attribute,\n        and ``_indices.subset(size=i)`` should yield the subset\n        `J_i` (as an iterable). If the latter conditions are not\n        satisfied, then :meth:`basis` must be overridden.\n\n    .. NOTE::\n\n        One should implement a ``degree_on_basis`` method in the parent\n        class in order to fully utilize the methods of this category.\n        This might become a required abstract method in the future.\n\n    EXAMPLES::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered(); C\n        Category of filtered modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules over Integer Ring,\n         Category of modules with basis over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Filtered()\n        True\n\n    TESTS::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered()\n        sage: TestSuite(C).run()\n        sage: C = ModulesWithBasis(QQ).Filtered()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "from_graded_conversion": {
                    "__doc__": "\n            Return the inverse of the canonical `R`-module isomorphism\n            `A \\to \\operatorname{gr} A` induced by the basis of `A`\n            (where `A = ` ``self``). This inverse is an isomorphism\n            `\\operatorname{gr} A \\to A`.\n\n            This is an isomorphism of `R`-modules. See\n            the class documentation :class:`AssociatedGradedAlgebra`.\n\n            .. SEEALSO::\n\n                :meth:`to_graded_conversion`\n\n            EXAMPLES::\n\n                sage: A = Modules(QQ).WithBasis().Filtered().example()\n                sage: p = -2 * A.an_element(); p\n                -4*P[] - 4*P[1] - 6*P[2]\n                sage: q = A.to_graded_conversion()(p); q\n                -4*Bbar[[]] - 4*Bbar[[1]] - 6*Bbar[[2]]\n                sage: A.from_graded_conversion()(q) == p\n                True\n                sage: q.parent() is A.graded_algebra()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "graded_algebra": {
                    "__doc__": "\n            Return the associated graded module to ``self``.\n\n            See :class:`~sage.algebras.associated_graded.AssociatedGradedAlgebra`\n            for the definition and the properties of this.\n\n            If the filtered module ``self`` with basis is called `A`,\n            then this method returns `\\operatorname{gr} A`. The method\n            :meth:`to_graded_conversion` returns the canonical\n            `R`-module isomorphism `A \\to \\operatorname{gr} A` induced\n            by the basis of `A`, and the method\n            :meth:`from_graded_conversion` returns the inverse of this\n            isomorphism. The method :meth:`projection` projects\n            elements of `A` onto `\\operatorname{gr} A` according to\n            their place in the filtration on `A`.\n\n            .. WARNING::\n\n                When not overridden, this method returns the default\n                implementation of an associated graded module --\n                namely, ``AssociatedGradedAlgebra(self)``, where\n                ``AssociatedGradedAlgebra`` is\n                :class:`~sage.algebras.associated_graded.AssociatedGradedAlgebra`.\n                But some instances of :class:`FilteredModulesWithBasis`\n                override this method, as the associated graded module\n                often is (isomorphic) to a simpler object (for instance,\n                the associated graded module of a graded module can be\n                identified with the graded module itself). Generic code\n                that uses associated graded modules (such as the code\n                of the :meth:`induced_graded_map` method below) should\n                make sure to only communicate with them via the\n                :meth:`to_graded_conversion`,\n                :meth:`from_graded_conversion` and\n                :meth:`projection` methods (in particular,\n                do not expect there to be a conversion from ``self``\n                to ``self.graded_algebra()``; this currently does not\n                work for Clifford algebras). Similarly, when\n                overriding :meth:`graded_algebra`, make sure to\n                accordingly redefine these three methods, unless their\n                definitions below still apply to your case (this will\n                happen whenever the basis of your :meth:`graded_algebra`\n                has the same indexing set as ``self``, and the partition\n                of this indexing set according to degree is the same as\n                for ``self``).\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: A.graded_algebra()\n                Graded Module of An example of a filtered module with basis:\n                 the free module on partitions over Integer Ring\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component": {
                    "__doc__": "\n            Return the ``d``-th homogeneous component of ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(ZZ).example()\n                sage: A.homogeneous_component(4)\n                Degree 4 homogeneous component of An example of a graded module\n                 with basis: the free module on partitions over Integer Ring\n            ",
                    "args": [
                        "self",
                        "d"
                    ],
                    "argspec": [
                        [
                            "self",
                            "d"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component_basis": {
                    "__doc__": "\n            Return a basis for the ``d``-th homogeneous component of ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(ZZ).example()\n                sage: A.homogeneous_component_basis(4)\n                Lazy family (Term map from Partitions to An example of a graded module with basis:\n                             the free module on partitions over Integer Ring(i))_{i in Partitions of the integer 4}\n\n                sage: cat = GradedModulesWithBasis(ZZ)\n                sage: C = CombinatorialFreeModule(ZZ, ['a', 'b'], category=cat)\n                sage: C.degree_on_basis = lambda x: 1 if x == 'a' else 2\n                sage: C.homogeneous_component_basis(1)\n                Finite family {'a': B['a']}\n                sage: C.homogeneous_component_basis(2)\n                Finite family {'b': B['b']}\n            ",
                    "args": [
                        "self",
                        "d"
                    ],
                    "argspec": [
                        [
                            "self",
                            "d"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "induced_graded_map": {
                    "__doc__": "\n            Return the graded linear map between the associated graded\n            modules of ``self`` and ``other`` canonically induced by\n            the filtration-preserving map ``f : self -> other``.\n\n            Let `A` and `B` be two filtered modules with basis, and let\n            `(F_i)_{i \\in I}` and `(G_i)_{i \\in I}` be their\n            filtrations. Let `f : A \\to B` be a linear map which\n            preserves the filtration (i.e., satisfies `f(F_i) \\subseteq\n            G_i` for all `i \\in I`). Then, there is a canonically\n            defined graded linear map\n            `\\operatorname{gr} f : \\operatorname{gr} A \\to\n            \\operatorname{gr} B` which satisfies\n\n            .. MATH::\n\n                (\\operatorname{gr} f) (p_i(a)) = p_i(f(a))\n                \\qquad \\text{for all } i \\in I \\text{ and } a \\in F_i ,\n\n            where the `p_i` on the left hand side is the canonical\n            projection from `F_i` onto the `i`-th graded component\n            of `\\operatorname{gr} A`, while the `p_i` on the right\n            hand side is the canonical projection from `G_i` onto\n            the `i`-th graded component of `\\operatorname{gr} B`.\n\n            INPUT:\n\n            - ``other`` -- a filtered algebra with basis\n\n            - ``f`` -- a filtration-preserving linear map from ``self``\n              to ``other`` (can be given as a morphism or as a function)\n\n            OUTPUT:\n\n            The graded linear map `\\operatorname{gr} f`.\n\n            EXAMPLES:\n\n            **Example 1.**\n\n            We start with the free `\\QQ`-module with basis the set of all\n            partitions::\n\n                sage: A = Modules(QQ).WithBasis().Filtered().example(); A\n                An example of a filtered module with basis: the free module\n                 on partitions over Rational Field\n                sage: M = A.indices(); M\n                Partitions\n                sage: p1, p2, p21, p321 = [A.basis()[Partition(i)] for i in [[1], [2], [2,1], [3,2,1]]]\n\n            Let us define a map from ``A`` to itself which acts on the\n            basis by sending every partition `\\lambda` to the sum of\n            the conjugates of all partitions `\\mu` for which\n            `\\lambda / \\mu` is a horizontal strip::\n\n                sage: def map_on_basis(lam):\n                ....:     return A.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = A.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=A)\n                sage: f(p1)\n                P[] + P[1]\n                sage: f(p2)\n                P[] + P[1] + P[1, 1]\n                sage: f(p21)\n                P[1] + P[1, 1] + P[2] + P[2, 1]\n                sage: f(p21 - p1)\n                -P[] + P[1, 1] + P[2] + P[2, 1]\n                sage: f(p321)\n                P[2, 1] + P[2, 1, 1] + P[2, 2] + P[2, 2, 1]\n                 + P[3, 1] + P[3, 1, 1] + P[3, 2] + P[3, 2, 1]\n\n            We now compute `\\operatorname{gr} f` ::\n\n                sage: grA = A.graded_algebra(); grA\n                Graded Module of An example of a filtered module with basis:\n                 the free module on partitions over Rational Field\n                sage: pp1, pp2, pp21, pp321 = [A.to_graded_conversion()(i) for i in [p1, p2, p21, p321]]\n                sage: pp2 + 4 * pp21\n                Bbar[[2]] + 4*Bbar[[2, 1]]\n                sage: grf = A.induced_graded_map(A, f); grf\n                Generic endomorphism of Graded Module of An example of a\n                 filtered module with basis:\n                 the free module on partitions over Rational Field\n                sage: grf(pp1)\n                Bbar[[1]]\n                sage: grf(pp2 + 4 * pp21)\n                Bbar[[1, 1]] + 4*Bbar[[2, 1]]\n\n            **Example 2.**\n\n            We shall now construct `\\operatorname{gr} f` for a\n            different map `f` out of the same ``A``; the new map\n            `f` will lead into a graded algebra already, namely into\n            the algebra of symmetric functions::\n\n                sage: h = SymmetricFunctions(QQ).h()\n                sage: def map_on_basis(lam):  # redefining map_on_basis\n                ....:     return h.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = A.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=h)  # redefining f\n                sage: f(p1)\n                h[] + h[1]\n                sage: f(p2)\n                h[] + h[1] + h[1, 1]\n                sage: f(A.zero())\n                0\n                sage: f(p2 - 3*p1)\n                -2*h[] - 2*h[1] + h[1, 1]\n\n            The algebra ``h`` of symmetric functions in the `h`-basis\n            is already graded, so its associated graded algebra is\n            implemented as itself::\n\n                sage: grh = h.graded_algebra(); grh is h\n                True\n                sage: grf = A.induced_graded_map(h, f); grf\n                Generic morphism:\n                  From: Graded Module of An example of a filtered\n                   module with basis: the free module on partitions\n                   over Rational Field\n                  To:   Symmetric Functions over Rational Field\n                   in the homogeneous basis\n                sage: grf(pp1)\n                h[1]\n                sage: grf(pp2)\n                h[1, 1]\n                sage: grf(pp321)\n                h[3, 2, 1]\n                sage: grf(pp2 - 3*pp1)\n                -3*h[1] + h[1, 1]\n                sage: grf(pp21)\n                h[2, 1]\n                sage: grf(grA.zero())\n                0\n\n            **Example 3.**\n\n            After having had a graded module as the codomain, let us try to\n            have one as the domain instead. Our new ``f`` will go from ``h``\n            to ``A``::\n\n                sage: def map_on_basis(lam):  # redefining map_on_basis\n                ....:     return A.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = h.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=A)  # redefining f\n                sage: f(h[1])\n                P[] + P[1]\n                sage: f(h[2])\n                P[] + P[1] + P[1, 1]\n                sage: f(h[1, 1])\n                P[1] + P[2]\n                sage: f(h[2, 2])\n                P[1, 1] + P[2, 1] + P[2, 2]\n                sage: f(h[3, 2, 1])\n                P[2, 1] + P[2, 1, 1] + P[2, 2] + P[2, 2, 1]\n                 + P[3, 1] + P[3, 1, 1] + P[3, 2] + P[3, 2, 1]\n                sage: f(h.one())\n                P[]\n                sage: grf = h.induced_graded_map(A, f); grf\n                Generic morphism:\n                  From: Symmetric Functions over Rational Field\n                   in the homogeneous basis\n                  To:   Graded Module of An example of a filtered\n                   module with basis: the free module on partitions\n                   over Rational Field\n                sage: grf(h[1])\n                Bbar[[1]]\n                sage: grf(h[2])\n                Bbar[[1, 1]]\n                sage: grf(h[1, 1])\n                Bbar[[2]]\n                sage: grf(h[2, 2])\n                Bbar[[2, 2]]\n                sage: grf(h[3, 2, 1])\n                Bbar[[3, 2, 1]]\n                sage: grf(h.one())\n                Bbar[[]]\n\n            **Example 4.**\n\n            The construct `\\operatorname{gr} f` also makes sense when `f`\n            is a filtration-preserving map between graded modules. ::\n\n                sage: def map_on_basis(lam):  # redefining map_on_basis\n                ....:     return h.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = h.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=h)  # redefining f\n                sage: f(h[1])\n                h[] + h[1]\n                sage: f(h[2])\n                h[] + h[1] + h[1, 1]\n                sage: f(h[1, 1])\n                h[1] + h[2]\n                sage: f(h[2, 1])\n                h[1] + h[1, 1] + h[2] + h[2, 1]\n                sage: f(h.one())\n                h[]\n                sage: grf = h.induced_graded_map(h, f); grf\n                Generic endomorphism of Symmetric Functions over Rational\n                 Field in the homogeneous basis\n                sage: grf(h[1])\n                h[1]\n                sage: grf(h[2])\n                h[1, 1]\n                sage: grf(h[1, 1])\n                h[2]\n                sage: grf(h[2, 1])\n                h[2, 1]\n                sage: grf(h.one())\n                h[]\n            ",
                    "args": [
                        "self",
                        "other",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "projection": {
                    "__doc__": "\n            Return the `i`-th projection `p_i : F_i \\to G_i` (in the\n            notations of the class documentation\n            :class:`AssociatedGradedAlgebra`, where `A = ` ``self``).\n\n            This method actually does not return the map `p_i` itself,\n            but an extension of `p_i` to the whole `R`-module `A`.\n            This extension is the composition of the `R`-module\n            isomorphism `A \\to \\operatorname{gr} A` with the canonical\n            projection of the graded `R`-module `\\operatorname{gr} A`\n            onto its `i`-th graded component `G_i`. The codomain of\n            this map is `\\operatorname{gr} A`, although its actual\n            image is `G_i`. The map `p_i` is obtained from this map\n            by restricting its domain to `F_i` and its image to `G_i`.\n\n            EXAMPLES::\n\n                sage: A = Modules(ZZ).WithBasis().Filtered().example()\n                sage: p = -2 * A.an_element(); p\n                -4*P[] - 4*P[1] - 6*P[2]\n                sage: q = A.projection(2)(p); q\n                -6*Bbar[[2]]\n                sage: q.parent() is A.graded_algebra()\n                True\n                sage: A.projection(3)(p)\n                0\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "to_graded_conversion": {
                    "__doc__": "\n            Return the canonical `R`-module isomorphism\n            `A \\to \\operatorname{gr} A` induced by the basis of `A`\n            (where `A = ` ``self``).\n\n            This is an isomorphism of `R`-modules. See\n            the class documentation :class:`AssociatedGradedAlgebra`.\n\n            .. SEEALSO::\n\n                :meth:`from_graded_conversion`\n\n            EXAMPLES::\n\n                sage: A = Modules(QQ).WithBasis().Filtered().example()\n                sage: p = -2 * A.an_element(); p\n                -4*P[] - 4*P[1] - 6*P[2]\n                sage: q = A.to_graded_conversion()(p); q\n                -4*Bbar[[]] - 4*Bbar[[1]] - 6*Bbar[[2]]\n                sage: q.parent() is A.graded_algebra()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "degree_on_basis": {
                    "__doc__": "\n            Return the degree of the basis element indexed by ``m``\n            in ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(QQ).example()\n                sage: A.degree_on_basis(Partition((2,1)))\n                3\n                sage: A.degree_on_basis(Partition((4,2,1,1,1,1)))\n                10\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component": {
                    "__doc__": "\n            Return the homogeneous component of degree ``n`` of the\n            element ``self``.\n\n            Let `m` be an element of a filtered `R`-module `M` with\n            basis. Then, `m` can be uniquely written in the form\n            `m = \\sum_{i \\in I} m_i`, where each `m_i` is a\n            homogeneous element of degree `i`. For `n \\in I`, we\n            define the homogeneous component of degree `n` of the\n            element `m` to be `m_n`.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.homogeneous_component(-1)\n                0\n                sage: g.homogeneous_component(0)\n                1\n                sage: g.homogeneous_component(2)\n                -2*U['x']*U['y']\n                sage: g.homogeneous_component(5)\n                0\n                sage: g.homogeneous_component(7)\n                U['x']^2*U['y']^2*U['z']^3\n                sage: g.homogeneous_component(8)\n                0\n\n            TESTS:\n\n            Check that this really returns ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.homogeneous_component(3).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_homogeneous": {
                    "__doc__": "\n            Return whether the element ``self`` is homogeneous.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x=A(Partition((3,2,1)))\n                sage: y=A(Partition((4,4,1)))\n                sage: z=A(Partition((2,2,2)))\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x - y).is_homogeneous()\n                False\n                sage: (x+2*z).is_homogeneous()\n                True\n\n            Here is an example with a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x^3 - y^2).is_homogeneous()\n                True\n                sage: ((x + y)^2).is_homogeneous()\n                False\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis, or at least on a definition of homogeneous\n            components)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).is_homogeneous()\n                True\n                sage: (y*x).is_homogeneous()\n                False\n                sage: A.one().is_homogeneous()\n                True\n                sage: A.zero().is_homogeneous()\n                True\n                sage: (A.one()+x).is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "maximal_degree": {
                    "__doc__": "\n            The maximum of the degrees of the homogeneous components\n            of ``self``.\n\n            This is also the smallest `i` such that ``self`` belongs\n            to `F_i`. Hence, it does not depend on the basis of the\n            parent of ``self``.\n\n            .. SEEALSO:: :meth:`homogeneous_degree`\n\n            EXAMPLES:\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.maximal_degree()\n                6\n                sage: (x + 2*z).maximal_degree()\n                6\n                sage: (y - x).maximal_degree()\n                9\n                sage: (3*z).maximal_degree()\n                6\n\n            Now, we test this on a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.maximal_degree()\n                2\n                sage: (x^3 + 4*y^2).maximal_degree()\n                6\n                sage: ((1 + x)^3).maximal_degree()\n                6\n\n            Let us now test a filtered algebra::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).maximal_degree()\n                2\n                sage: (y*x).maximal_degree()\n                2\n                sage: A.one().maximal_degree()\n                0\n                sage: A.zero().maximal_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n                sage: (A.one()+x).maximal_degree()\n                1\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "truncate": {
                    "__doc__": "\n            Return the sum of the homogeneous components of degree\n            strictly less than ``n`` of ``self``.\n\n            See :meth:`homogeneous_component` for the notion of a\n            homogeneous component.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(-1)\n                0\n                sage: g.truncate(0)\n                0\n                sage: g.truncate(2)\n                2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(3)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(5)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(7)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(8)\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.truncate(0).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.DualObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.modules.Modules.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of all endomorphism sets.\n\n        This category serves too purposes: making sure that the\n        ``Endset`` axiom is implemented in the category where it's\n        defined, namely ``Homsets``, and specifying that ``Endsets``\n        are monoids.\n\n        EXAMPLES::\n\n            sage: from sage.categories.homsets import Homsets\n            sage: Homsets().Endset()\n            Category of endsets\n        ",
        "axioms": [
            "Endset",
            "Associative",
            "Unital"
        ],
        "element_class": {
            "__doc__": "\n        The category of all endomorphism sets.\n\n        This category serves too purposes: making sure that the\n        ``Endset`` axiom is implemented in the category where it's\n        defined, namely ``Homsets``, and specifying that ``Endsets``\n        are monoids.\n\n        EXAMPLES::\n\n            sage: from sage.categories.homsets import Homsets\n            sage: Homsets().Endset()\n            Category of endsets\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.monoids.Monoids",
            "sage.categories.homsets.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of all endomorphism sets.\n\n        This category serves too purposes: making sure that the\n        ``Endset`` axiom is implemented in the category where it's\n        defined, namely ``Homsets``, and specifying that ``Endsets``\n        are monoids.\n\n        EXAMPLES::\n\n            sage: from sage.categories.homsets import Homsets\n            sage: Homsets().Endset()\n            Category of endsets\n        ",
            "methods": {}
        },
        "name": "sage.categories.homsets.Homsets.Endset",
        "parent_class": {
            "__doc__": "\n        The category of all endomorphism sets.\n\n        This category serves too purposes: making sure that the\n        ``Endset`` axiom is implemented in the category where it's\n        defined, namely ``Homsets``, and specifying that ``Endsets``\n        are monoids.\n\n        EXAMPLES::\n\n            sage: from sage.categories.homsets import Homsets\n            sage: Homsets().Endset()\n            Category of endsets\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.homsets.Homsets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of all endomorphism sets.\n\n        This category serves too purposes: making sure that the\n        ``Endset`` axiom is implemented in the category where it's\n        defined, namely ``Homsets``, and specifying that ``Endsets``\n        are monoids.\n\n        EXAMPLES::\n\n            sage: from sage.categories.homsets import Homsets\n            sage: Homsets().Endset()\n            Category of endsets\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.WithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "FiniteDimensional",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "mmt.WithBasis.GAP",
            "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.FiniteDimensional.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups.CartesianProducts",
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "base_ring": {
                    "__doc__": "\n                Return the base ring of this Cartesian product.\n\n                EXAMPLES::\n\n                    sage: E = CombinatorialFreeModule(ZZ, [1,2,3])\n                    sage: F = CombinatorialFreeModule(ZZ, [2,3,4])\n                    sage: C = cartesian_product([E, F]); C\n                    Free module generated by {1, 2, 3} over Integer Ring (+)\n                    Free module generated by {2, 3, 4} over Integer Ring\n                    sage: C.base_ring()\n                    Integer Ring\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of modules constructed as Cartesian products of modules\n\n        This construction gives the direct product of modules. The\n        implementation is based on the following resources:\n\n        - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n        - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n            The category of finite irreducible well-generated\n            finite complex reflection groups.\n            ",
        "axioms": [
            "Inverse",
            "Associative",
            "FinitelyGeneratedAsMagma",
            "Unital",
            "Irreducible",
            "Finite",
            "WellGenerated"
        ],
        "element_class": {
            "__doc__": "\n            The category of finite irreducible well-generated\n            finite complex reflection groups.\n            ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_complex_reflection_groups.FiniteComplexReflectionGroups.Irreducible",
            "sage.categories.finite_complex_reflection_groups.FiniteComplexReflectionGroups.WellGenerated"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n            The category of finite irreducible well-generated\n            finite complex reflection groups.\n            ",
            "methods": {}
        },
        "name": "sage.categories.finite_complex_reflection_groups.FiniteComplexReflectionGroups.WellGenerated.Irreducible",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "catalan_number": {
                    "__doc__": "\n                    Return the Catalan number associated to ``self``.\n\n                    It is defined by\n\n                    .. MATH::\n\n                        \\prod_{i = 1}^n \\frac{d_i + h}{d_i},\n\n                    where `d_1, \\ldots, d_n` are the degrees and where\n                    `h` is the Coxeter number.\n                    See [Arm2006]_ for further information.\n\n                    INPUT:\n\n                    - ``positive`` -- optional boolean (default ``False``)\n                      if ``True``, return instead the positive Catalan\n                      number\n                    - ``polynomial`` -- optional boolean (default ``False``)\n                      if ``True``, return instead the `q`-analogue as a\n                      polynomial in `q`\n\n                    .. NOTE::\n\n                        - For the symmetric group `S_n`, it reduces to the\n                          Catalan number `\\frac{1}{n+1} \\binom{2n}{n}`.\n                        - The Catalan numbers for `G(r,1,n)` all coincide\n                          for `r > 1`.\n\n                    EXAMPLES::\n\n                        sage: [ColoredPermutations(1,n).catalan_number() for n in [3,4,5]]\n                        [5, 14, 42]\n\n                        sage: [ColoredPermutations(2,n).catalan_number() for n in [3,4,5]]\n                        [20, 70, 252]\n\n                        sage: [ReflectionGroup((2,2,n)).catalan_number() for n in [3,4,5]]  # optional - gap3\n                        [14, 50, 182]\n\n                    TESTS::\n\n                        sage: W = ColoredPermutations(3,6)\n                        sage: W.catalan_number(positive=True)\n                        462\n                        sage: W = ColoredPermutations(2,2)\n                        sage: W.catalan_number(polynomial=True)\n                        q^8 + q^6 + 2*q^4 + q^2 + 1\n                    ",
                    "args": [
                        "self",
                        "positive",
                        "polynomial"
                    ],
                    "argspec": [
                        [
                            "self",
                            "positive",
                            "polynomial"
                        ],
                        null,
                        null,
                        [
                            false,
                            false
                        ]
                    ]
                },
                "fuss_catalan_number": {
                    "__doc__": "\n                    Return the ``m``-th Fuss-Catalan number\n                    associated to ``self``.\n\n                    This is defined by\n\n                    .. MATH::\n\n                        \\prod_{i = 1}^n \\frac{d_i + mh}{d_i},\n\n                    where `d_1, \\ldots, d_n` are the degrees and\n                    `h` is the Coxeter number.\n\n                    INPUT:\n\n                    - ``positive`` -- optional boolean (default ``False``)\n                      if ``True``, return instead the positive Fuss-Catalan\n                      number\n                    - ``polynomial`` -- optional boolean (default ``False``)\n                      if ``True``, return instead the `q`-analogue as a\n                      polynomial in `q`\n\n                    See [Arm2006]_ for further information.\n\n                    .. NOTE::\n\n                        - For the symmetric group `S_n`, it reduces to the\n                          Fuss-Catalan number `\\frac{1}{mn+1}\\binom{(m+1)n}{n}`.\n                        - The Fuss-Catalan numbers for `G(r, 1, n)` all\n                          coincide for `r > 1`.\n\n                    REFERENCES:\n\n                    .. [Arm2006] D. Armstrong. *Generalized noncrossing\n                       partitions and combinatorics of Coxeter groups*.\n                       Mem. Amer. Math. Soc., 2006.\n\n                    EXAMPLES::\n\n                        sage: W = ColoredPermutations(1,3)\n                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]\n                        [5, 12, 22]\n\n                        sage: W = ColoredPermutations(1,4)\n                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]\n                        [14, 55, 140]\n\n                        sage: W = ColoredPermutations(1,5)\n                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]\n                        [42, 273, 969]\n\n                        sage: W = ColoredPermutations(2,2)\n                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]\n                        [6, 15, 28]\n\n                        sage: W = ColoredPermutations(2,3)\n                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]\n                        [20, 84, 220]\n\n                        sage: W = ColoredPermutations(2,4)\n                        sage: [W.fuss_catalan_number(i) for i in [1,2,3]]\n                        [70, 495, 1820]\n\n                    TESTS::\n\n                        sage: W = ColoredPermutations(2,4)\n                        sage: W.fuss_catalan_number(2,positive=True)\n                        330\n                        sage: W = ColoredPermutations(2,2)\n                        sage: W.fuss_catalan_number(2,polynomial=True)\n                        q^16 + q^14 + 2*q^12 + 2*q^10 + 3*q^8 + 2*q^6 +\n                        2*q^4 + q^2 + 1\n                    ",
                    "args": [
                        "self",
                        "m",
                        "positive",
                        "polynomial"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m",
                            "positive",
                            "polynomial"
                        ],
                        null,
                        null,
                        [
                            false,
                            false
                        ]
                    ]
                },
                "number_of_reflections_of_full_support": {
                    "__doc__": "\n                    Return the number of reflections with full\n                    support.\n\n                    EXAMPLES::\n\n                        sage: W = ColoredPermutations(1,4)\n                        sage: W.number_of_reflections_of_full_support()\n                        1\n\n                        sage: W = ColoredPermutations(3,3)\n                        sage: W.number_of_reflections_of_full_support()\n                        3\n                    ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "rational_catalan_number": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": "\n            The category of finite irreducible well-generated\n            finite complex reflection groups.\n            ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_modules.FilteredModules",
        "parent_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of filtered modules over a given ring `R`.\n\n    A *filtered module* over a ring `R` with a totally ordered\n    indexing set `I` (typically `I = \\NN`) is an `R`-module `M` equipped\n    with a family `(F_i)_{i \\in I}` of `R`-submodules satisfying\n    `F_i \\subseteq F_j` for all `i,j \\in I` having `i \\leq j`, and\n    `M = \\bigcup_{i \\in I} F_i`. This family is called a *filtration*\n    of the given module `M`.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Filtered()\n        Category of filtered modules over Integer Ring\n        sage: Modules(ZZ).Filtered().super_categories()\n        [Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtration_(mathematics)`\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces",
            "sage.categories.homsets.HomsetsOf"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "base_ring": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.homsets.HomsetsOf",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modules.Modules.Homsets"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of homomorphism sets `\\hom(X,Y)` for `X`, `Y` modules.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of modules with a distinguished basis.\n\n    The elements are represented by expanding them in the distinguished basis.\n    The morphisms are not required to respect the distinguished basis.\n\n    EXAMPLES::\n\n        sage: ModulesWithBasis(ZZ)\n        Category of modules with basis over Integer Ring\n        sage: ModulesWithBasis(ZZ).super_categories()\n        [Category of modules over Integer Ring]\n\n    If the base ring is actually a field, this constructs instead the\n    category of vector spaces with basis::\n\n        sage: ModulesWithBasis(QQ)\n        Category of vector spaces with basis over Rational Field\n\n        sage: ModulesWithBasis(QQ).super_categories()\n        [Category of modules with basis over Rational Field,\n         Category of vector spaces over Rational Field]\n\n    Let `X` and `Y` be two modules with basis. We can build `Hom(X,Y)`::\n\n        sage: X = CombinatorialFreeModule(QQ, [1,2]); X.__custom_name = \"X\"\n        sage: Y = CombinatorialFreeModule(QQ, [3,4]); Y.__custom_name = \"Y\"\n        sage: H = Hom(X, Y); H\n        Set of Morphisms from X to Y in Category of finite dimensional vector spaces with basis over Rational Field\n\n    The simplest morphism is the zero map::\n\n        sage: H.zero()         # todo: move this test into module once we have an example\n        Generic morphism:\n          From: X\n          To:   Y\n\n    which we can apply to elements of `X`::\n\n        sage: x = X.monomial(1) + 3 * X.monomial(2)\n        sage: H.zero()(x)\n        0\n\n    EXAMPLES:\n\n    We now construct a more interesting morphism by extending a\n    function by linearity::\n\n        sage: phi = H(on_basis = lambda i: Y.monomial(i+2)); phi\n        Generic morphism:\n          From: X\n          To:   Y\n        sage: phi(x)\n        B[3] + 3*B[4]\n\n    We can retrieve the function acting on indices of the basis::\n\n        sage: f = phi.on_basis()\n        sage: f(1), f(2)\n        (B[3], B[4])\n\n    `Hom(X,Y)` has a natural module structure (except for the zero,\n    the operations are not yet implemented though). However since the\n    dimension is not necessarily finite, it is not a module with\n    basis; but see :class:`FiniteDimensionalModulesWithBasis` and\n    :class:`GradedModulesWithBasis`::\n\n        sage: H in ModulesWithBasis(QQ), H in Modules(QQ)\n        (False, True)\n\n    Some more playing around with categories and higher order homsets::\n\n        sage: H.category()\n        Category of homsets of modules with basis over Rational Field\n        sage: Hom(H, H).category()\n        Category of endsets of homsets of modules with basis over Rational Field\n\n    .. TODO:: ``End(X)`` is an algebra.\n\n    .. NOTE::\n\n        This category currently requires an implementation of an\n        element method ``support``. Once :trac:`18066` is merged, an\n        implementation of an ``items`` method will be required.\n\n    TESTS::\n\n        sage: f = H.zero().on_basis()\n        sage: f(1)\n        0\n        sage: f(2)\n        0\n\n        sage: TestSuite(ModulesWithBasis(ZZ)).run()\n\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "__getitem__": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self``.\n\n            EXAMPLES::\n\n                sage: p = Partition([2,1])\n                sage: q = Partition([1,1,1])\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s(p)\n                sage: a._coefficient_fast([2,1])\n                Traceback (most recent call last):\n                ...\n                TypeError: unhashable type: 'list'\n\n            ::\n\n                sage: a._coefficient_fast(p)\n                1\n                sage: a._coefficient_fast(q)\n                0\n                sage: a[p]\n                1\n                sage: a[q]\n                0\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__len__": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: len(f)\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: len(z)\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficient": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self`` and raise an error\n            if ``m`` is not in the basis indexing set.\n\n            INPUT:\n\n            - ``m`` -- a basis index of the parent of ``self``\n\n            OUTPUT:\n\n            The ``B[m]``-coordinate of ``self`` with respect to the basis\n            ``B``. Here, ``B`` denotes the given basis of the parent of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: s = CombinatorialFreeModule(QQ, Partitions())\n                sage: z = s([4]) - 2*s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficient([4])\n                1\n                sage: z.coefficient([2,1])\n                -2\n                sage: z.coefficient(Partition([2,1]))\n                -2\n                sage: z.coefficient([1,2])\n                Traceback (most recent call last):\n                ...\n                AssertionError: [1, 2] should be an element of Partitions\n                sage: z.coefficient(Composition([2,1]))\n                Traceback (most recent call last):\n                ...\n                AssertionError: [2, 1] should be an element of Partitions\n\n            Test that ``coefficient`` also works for those parents that do\n            not yet have an element_class::\n\n                sage: G = DihedralGroup(3)\n                sage: F = CombinatorialFreeModule(QQ, G)\n                sage: hasattr(G, \"element_class\")\n                False\n                sage: g = G.an_element()\n                sage: (2*F.monomial(g)).coefficient(g)\n                2\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficients": {
                    "__doc__": "\n            Return a list of the (non-zero) coefficients appearing on\n            the basis elements in ``self`` (in an arbitrary order).\n\n            INPUT:\n\n            - ``sort`` -- (default: ``True``) to sort the coefficients\n              based upon the default ordering of the indexing set\n\n            .. SEEALSO::\n\n                :meth:`~sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis.ElementMethods.dense_coefficient_list`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.coefficients()\n                [1, -3]\n                sage: f = B['c'] - 3*B['a']\n                sage: f.coefficients()\n                [-3, 1]\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficients()\n                [1, 1, 1, 1]\n            ",
                    "args": [
                        "self",
                        "sort"
                    ],
                    "argspec": [
                        [
                            "self",
                            "sort"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "is_zero": {
                    "__doc__": "\n            Return ``True`` if and only if ``self == 0``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.is_zero()\n                False\n                sage: F.zero().is_zero()\n                True\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: s([2,1]).is_zero()\n                False\n                sage: s(0).is_zero()\n                True\n                sage: (s([2,1]) - s([2,1])).is_zero()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "leading_coefficient": {
                    "__doc__": "\n            Returns the leading coefficient of ``self``.\n\n            This is the coefficient of the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\")\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_coefficient()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_coefficient(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_coefficient()\n                -5\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_item": {
                    "__doc__": "\n            Return the pair ``(k, c)`` where\n\n            .. MATH::\n\n                c \\cdot (\\mbox{the basis element indexed by } k)\n\n            is the leading term of ``self``.\n\n            Here 'leading term' means that the corresponding basis element is\n            maximal.  Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be\n            provided.  This should return a negative value if ``x < y``, ``0``\n            if ``x == y`` and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_item()\n                (3, 4)\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_item(cmp=cmp)\n                (1, 3)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_item()\n                ([3], -5)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_monomial": {
                    "__doc__": "\n            Return the leading monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_monomial()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_monomial(cmp=cmp)\n                B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_monomial()\n                s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_support": {
                    "__doc__": "\n            Return the maximal element of the support of ``self``. Note\n            that this may not be the term which actually appears first when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_support()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_support(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_support()\n                [3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_term": {
                    "__doc__": "\n            Return the leading term of ``self``.\n\n            This is the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_term()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_term(cmp=cmp)\n                3*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_term()\n                -5*s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "length": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.length()\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.length()\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_coefficients": {
                    "__doc__": "\n            Mapping a function on coefficients.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the coefficient ring of the\n              free module\n\n            Return a new element of ``self.parent()`` obtained by applying the\n            function ``f`` to all of the coefficients of ``self``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.map_coefficients(lambda x: x+5)\n                6*B['a'] + 2*B['c']\n\n            Killed coefficients are handled properly::\n\n                sage: f.map_coefficients(lambda x: 0)\n                0\n                sage: list(f.map_coefficients(lambda x: 0))\n                []\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_coefficients(lambda x: x*2)\n                2*s[2, 1] + 4*s[3, 2]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_item": {
                    "__doc__": "\n            Mapping a function on items.\n\n            INPUT:\n\n            - ``f`` -- a function mapping pairs ``(index, coeff)`` to\n              other such pairs\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function `f` to all items ``(index, coeff)`` of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_item(lambda i, c: (-i, 2*c))\n                6*B[-1] + 4*B[0] + 4*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_item(lambda i, c: (1, 2*c))\n                14*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = lambda m,c: (m.conjugate(), 2*c)\n                sage: a = s([2,1]) + s([1,1,1])\n                sage: a.map_item(f)\n                2*s[2, 1] + 2*s[3]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function ``f`` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support(lambda i: -i)\n                3*B[-1] + 2*B[0] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support(lambda i: 1)\n                7*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_support(lambda x: x.conjugate())\n                s[2, 1] + 2*s[2, 2, 1]\n\n            TESTS::\n\n                sage: B.zero()      # This actually failed at some point!!! See #8890\n                0\n\n                sage: y = B.zero().map_support(lambda i: i/0); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support_skip_none": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Returns a new element of ``self.parent()`` obtained by\n            applying the function `f` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support_skip_none(lambda i: -i if i else None)\n                3*B[-1] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support_skip_none(lambda i: 1 if i else None)\n                5*B[1]\n\n            TESTS::\n\n                sage: y = x.map_support_skip_none(lambda i: None); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "monomial_coefficients": {
                    "__doc__": "\n            Return a dictionary whose keys are indices of basis elements\n            in the support of ``self`` and whose values are the\n            corresponding coefficients.\n\n            INPUT:\n\n            - ``copy`` -- (default: ``True``) if ``self`` is internally\n              represented by a dictionary ``d``, then make a copy of ``d``;\n              if ``False``, then this can cause undesired behavior by\n              mutating ``d``\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a']\n                1\n                sage: d['c']\n                3\n\n            TESTS:\n\n            We check that we make a copy of the coefficient dictionary::\n\n                sage: F = CombinatorialFreeModule(ZZ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a'] = 5\n                sage: f\n                B['a'] + 3*B['c']\n            ",
                    "args": [
                        "self",
                        "copy"
                    ],
                    "argspec": [
                        [
                            "self",
                            "copy"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "monomials": {
                    "__doc__": "\n            Return a list of the monomials of ``self`` (in an arbitrary\n            order).\n\n            The monomials of an element `a` are defined to be the basis\n            elements whose corresponding coefficients of `a` are\n            non-zero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.monomials()\n                [B['a'], B['c']]\n\n                sage: (F.zero()).monomials()\n                []\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support": {
                    "__doc__": "\n            Return a list of the objects indexing the basis of\n            ``self.parent()`` whose corresponding coefficients of\n            ``self`` are non-zero.\n\n            This method returns these objects in an arbitrary order.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: sorted(f.support())\n                ['a', 'c']\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: sorted(z.support())\n                [[1], [1, 1, 1], [2, 1], [4]]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support_of_term": {
                    "__doc__": "\n            Return the support of ``self``, where ``self`` is a monomial\n            (possibly with coefficient).\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3,4]); X.rename(\"X\")\n                sage: X.monomial(2).support_of_term()\n                2\n                sage: X.term(3, 2).support_of_term()\n                3\n\n            An exception is raised if ``self`` has more than one term::\n\n                sage: (X.monomial(2) + X.monomial(3)).support_of_term()\n                Traceback (most recent call last):\n                ...\n                ValueError: B[2] + B[3] is not a single term\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "tensor": {
                    "__doc__": "\n            Return the tensor product of its arguments, as an element of\n            the tensor product of the parents of those elements.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example()\n                sage: (a,b,c) = A.algebra_generators()\n                sage: a.tensor(b, c)\n                B[word: a] # B[word: b] # B[word: c]\n\n            FIXME: is this a policy that we want to enforce on all parents?\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "elements",
                        null,
                        null
                    ]
                },
                "terms": {
                    "__doc__": "\n            Return a list of the (non-zero) terms of ``self`` (in an\n            arbitrary order).\n\n            .. SEEALSO:: :meth:`monomials`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.terms()\n                [B['a'], 2*B['c']]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "trailing_coefficient": {
                    "__doc__": "\n            Return the trailing coefficient of ``self``.\n\n            This is the coefficient of the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_coefficient()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_coefficient(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_coefficient()\n                2\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_item": {
                    "__doc__": "\n            Returns the pair ``(c, k)`` where ``c*self.parent().monomial(k)``\n            is the trailing term of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_item()\n                (1, 3)\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_item(cmp=cmp)\n                (3, 1)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_item()\n                ([1], 2)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_monomial": {
                    "__doc__": "\n            Return the trailing monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_monomial()\n                B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_monomial(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_monomial()\n                s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_support": {
                    "__doc__": "\n            Return the minimal element of the support of ``self``. Note\n            that this may not be the term which actually appears last when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, `0` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.trailing_support()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_support(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_support()\n                [1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_term": {
                    "__doc__": "\n            Return the trailing term of ``self``.\n\n            This is the term whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_term()\n                3*B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_term(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_term()\n                2*s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {
                "_on_basis": {
                    "__doc__": "\n            Return the image of ``self`` on the basis element indexed by ``i``.\n\n            INPUT:\n\n            - ``i`` -- the index of an element of the basis of the domain of ``self``\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3]); X.rename(\"X\")\n                sage: phi = End(X)(lambda x: 2*x)\n                sage: phi._on_basis(3)\n                2*B[3]\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "on_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_apply_module_endomorphism": {
                    "__doc__": "\n            This takes in a function ``on_basis`` from the basis indices\n            to the elements of ``self``, and applies it linearly to ``x``.\n\n            EXAMPLES::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = lambda part: 2*s(part.conjugate())\n                sage: s._apply_module_endomorphism( s([2,1]) + s([1,1,1]), f)\n                2*s[2, 1] + 2*s[3]\n            ",
                    "args": [
                        "self",
                        "x",
                        "on_basis"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "on_basis"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_apply_module_morphism": {
                    "__doc__": "\n            Return the image of ``x`` under the module morphism defined by\n            extending :func:`on_basis` by linearity.\n\n            INPUT:\n\n            - ``x`` -- a element of ``self``\n\n            - ``on_basis`` -- a function that takes in an object indexing\n              a basis element and returns an element of the codomain\n\n            - ``codomain`` -- (optional) the codomain of the morphism (by\n              default, it is computed using :func:`on_basis`)\n\n            If ``codomain`` is not specified, then the function tries to\n            compute the codomain of the module morphism by finding the image\n            of one of the elements in the support; hence :func:`on_basis`\n            should return an element whose parent is the codomain.\n\n            EXAMPLES::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([3]) + s([2,1]) + s([1,1,1])\n                sage: b = 2*a\n                sage: f = lambda part: Integer( len(part) )\n                sage: s._apply_module_morphism(a, f) #1+2+3\n                6\n                sage: s._apply_module_morphism(b, f) #2*(1+2+3)\n                12\n                sage: s._apply_module_morphism(s(0), f)\n                0\n                sage: s._apply_module_morphism(s(1), f)\n                0\n                sage: s._apply_module_morphism(s(1), lambda part: len(part), ZZ)\n                0\n                sage: s._apply_module_morphism(s(1), lambda part: len(part))\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain could not be determined\n            ",
                    "args": [
                        "self",
                        "x",
                        "on_basis",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x",
                            "on_basis",
                            "codomain"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "_module_morphism": {
                    "__doc__": "\n            Construct a module morphism from ``self`` to ``codomain``.\n\n            Let ``self`` be a module `X` with a basis indexed by `I`.\n            This constructs a morphism `f: X \\to Y` by linearity from\n            a map `I \\to Y` which is to be its restriction to the\n            basis `(x_i)_{i \\in I}` of `X`. Some variants are possible\n            too.\n\n            INPUT:\n\n            - ``self`` -- a parent `X` in ``ModulesWithBasis(R)`` with\n              basis `x=(x_i)_{i\\in I}`.\n\n            Exactly one of the four following options must be\n            specified in order to define the morphism:\n\n            - ``on_basis`` -- a function `f` from `I` to `Y`\n            - ``diagonal`` -- a function `d` from `I` to `R`\n            - ``function`` -- a function `f` from `X` to `Y`\n            - ``matrix``   -- a matrix of size `\\dim Y \\times \\dim X`\n              (if the keyword ``side`` is set to ``'left'``) or\n              `\\dim Y \\times \\dim X` (if this keyword is ``'right'``)\n\n            Further options include:\n\n            - ``codomain`` -- the codomain `Y` of the morphism (default:\n              ``f.codomain()`` if it's defined; otherwise it must be specified)\n\n            - ``category`` -- a category or ``None`` (default: `None``)\n\n            - ``zero`` -- the zero of the codomain (default: ``codomain.zero()``);\n              can be used (with care) to define affine maps.\n              Only meaningful with ``on_basis``.\n\n            - ``position`` -- a non-negative integer specifying which\n              positional argument in used as the input of the function `f`\n              (default: 0); this is currently only used with ``on_basis``.\n\n            - ``triangular`` --  (default: ``None``) ``\"upper\"`` or\n              ``\"lower\"`` or ``None``:\n\n              * ``\"upper\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.leading_support`\n                of the image of the basis vector `x_i` is `i`, or\n\n              * ``\"lower\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.trailing_support`\n                of the image of the basis vector `x_i` is `i`.\n\n            - ``unitriangular`` -- (default: ``False``) a boolean.\n              Only meaningful for a triangular morphism.\n              As a shorthand, one may use ``unitriangular=\"lower\"``\n              for ``triangular=\"lower\", unitriangular=True``.\n\n            - ``side`` -- \"left\" or \"right\" (default: \"left\")\n              Only meaningful for a morphism built from a matrix.\n\n            EXAMPLES:\n\n            With the ``on_basis`` option, this returns a function `g`\n            obtained by extending `f` by linearity on the\n            ``position``-th positional argument. For example, for\n            ``position == 1`` and a ternary function `f`, one has:\n\n            .. MATH::\n\n                g\\left( a,\\ \\sum_i \\lambda_i x_i,\\ c \\right)\n                = \\sum_i \\lambda_i f(a, i, c).\n\n            ::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1), codomain = Y)\n                sage: x = X.basis(); y = Y.basis()\n                sage: phi(x[1] + x[3])\n                B[1] + 2*B[2] + B[3] + 2*B[4]\n\n                sage: phi\n                Generic morphism:\n                From: X\n                To:   Y\n\n            By default, the category is the first of\n            ``Modules(R).WithBasis().FiniteDimensional()``,\n            ``Modules(R).WithBasis()``, ``Modules(R)``, and\n            ``CommutativeAdditiveMonoids()`` that contains both the\n            domain and the codomain::\n\n                sage: phi.category_for()\n                Category of finite dimensional vector spaces with basis over Rational Field\n\n            With the ``zero`` argument, one can define affine morphisms::\n\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1),\n                ....:                         codomain = Y, zero = 10*y[1])\n                sage: phi(x[1] + x[3])\n                11*B[1] + 2*B[2] + B[3] + 2*B[4]\n\n            In this special case, the default category is ``Sets()``::\n\n                sage: phi.category_for()\n                Category of sets\n\n            One can construct morphisms with the base ring as codomain::\n\n                sage: X = CombinatorialFreeModule(ZZ,[1,-1])\n                sage: phi = X.module_morphism( on_basis=lambda i: i, codomain=ZZ )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (ZZ is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n            Or more generaly any ring admitting a coercion map from\n            the base ring::\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=RR )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1.00000000000000\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (RR is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                3\n\n                sage: phi = Y.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Ring of integers modulo 4) should be a module over the base ring of the domain(=Y)\n\n            On can also define module morphisms between free modules\n            over different base rings; here we implement the natural\n            map from `X = \\RR^2` to `Y = \\CC`::\n\n                sage: X = CombinatorialFreeModule(RR,['x','y'])\n                sage: Y = CombinatorialFreeModule(CC,['z'])\n                sage: x = X.monomial('x')\n                sage: y = X.monomial('y')\n                sage: z = Y.monomial('z')\n                sage: def on_basis( a ):\n                ....:     if a == 'x':\n                ....:         return CC(1) * z\n                ....:     elif a == 'y':\n                ....:         return CC(I) * z\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: v = 3 * x + 2 * y; v\n                3.00000000000000*B['x'] + 2.00000000000000*B['y']\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (CC is currently not in Modules(RR)!)\n                Category of vector spaces over Real Field with 53 bits of precision\n\n                sage: Y = CombinatorialFreeModule(CC['q'],['z'])\n                sage: z = Y.monomial('z')\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n\n            Of course, there should be a coercion between the\n            respective base rings of the domain and the codomain for\n            this to be meaningful::\n\n                sage: Y = CombinatorialFreeModule(QQ,['z'])\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'z'} over Rational Field)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n\n                sage: Y = CombinatorialFreeModule(RR['q'],['z'])\n                sage: phi = Y.module_morphism( on_basis=on_basis, codomain=X )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'z'} over Univariate Polynomial Ring in q over Real Field with 53 bits of precision)\n\n\n            With the ``diagonal=d`` argument, this constructs the\n            module morphism `g` such that\n\n            .. MATH::\n\n                `g(x_i) = d(i) y_i`.\n\n            This assumes that the respective bases `x` and `y` of `X`\n            and `Y` have the same index set `I`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, codomain=X)\n                sage: x = X.basis()\n                sage: phi(x[1]), phi(x[2]), phi(x[3])\n                (B[1], 2*B[2], 6*B[3])\n\n            See also: :class:`sage.modules.with_basis.morphism.DiagonalModuleMorphism`.\n\n            With the ``matrix=m`` argument, this constructs the module\n            morphism whose matrix in the distinguished basis of `X`\n            and `Y` is `m`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(ZZ, [3,4]); Y.rename(\"Y\"); y = Y.basis()\n                sage: m = matrix([[0,1,2],[3,5,0]])\n                sage: phi = X.module_morphism(matrix=m, codomain=Y)\n                sage: phi(x[1])\n                3*B[4]\n                sage: phi(x[2])\n                B[3] + 5*B[4]\n\n\n            See also: :class:`sage.modules.with_basis.morphism.ModuleMorphismFromMatrix`.\n\n            With ``triangular=\"upper\"``, the constructed module morphism is\n            assumed to be upper triangular; that is its matrix in the\n            distinguished basis of `X` and `Y` would be upper triangular with\n            invertible elements on its diagonal. This is used to compute\n            preimages and to invert the morphism::\n\n                sage: I = range(1,200)\n                sage: X = CombinatorialFreeModule(QQ, I); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(QQ, I); Y.rename(\"Y\"); y = Y.basis()\n                sage: f = Y.sum_of_monomials * divisors\n                sage: phi = X.module_morphism(f, triangular=\"upper\", codomain = Y)\n                sage: phi(x[2])\n                B[1] + B[2]\n                sage: phi(x[6])\n                B[1] + B[2] + B[3] + B[6]\n                sage: phi(x[30])\n                B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]\n                sage: phi.preimage(y[2])\n                -B[1] + B[2]\n                sage: phi.preimage(y[6])\n                B[1] - B[2] - B[3] + B[6]\n                sage: phi.preimage(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n                sage: (phi^-1)(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n\n            Since :trac:`8678`, one can also define a triangular\n            morphism from a function::\n\n                sage: X = CombinatorialFreeModule(QQ, [0,1,2,3,4]); x = X.basis()\n                sage: from sage.modules.with_basis.morphism import TriangularModuleMorphismFromFunction\n                sage: def f(x): return x + X.term(0, sum(x.coefficients()))\n                sage: phi = X.module_morphism(function=f, codomain=X, triangular=\"upper\")\n                sage: phi(x[2] + 3*x[4])\n                4*B[0] + B[2] + 3*B[4]\n                sage: phi.preimage(_)\n                B[2] + 3*B[4]\n\n            For details and further optional arguments, see\n            :class:`sage.modules.with_basis.morphism.TriangularModuleMorphism`.\n\n            .. WARNING::\n\n                As a temporary measure, until multivariate morphisms\n                are implemented, the constructed morphism is in\n                ``Hom(codomain, domain, category)``. This is only\n                correct for unary functions.\n\n            .. TODO::\n\n               - Should codomain be ``self`` by default in the\n                 diagonal, triangular, and matrix cases?\n\n               - Support for diagonal morphisms between modules not\n                 sharing the same index set\n\n            TESTS::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, matrix=matrix(), codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(matrix=factorial, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: matrix (=factorial) should be a matrix\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=3, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: diagonal (=3) should be a function\n\n            ",
                    "args": [
                        "self",
                        "on_basis",
                        "matrix",
                        "function",
                        "diagonal",
                        "triangular",
                        "unitriangular"
                    ],
                    "argspec": [
                        [
                            "self",
                            "on_basis",
                            "matrix",
                            "function",
                            "diagonal",
                            "triangular",
                            "unitriangular"
                        ],
                        null,
                        "keywords",
                        [
                            null,
                            null,
                            null,
                            null,
                            null,
                            false
                        ]
                    ]
                },
                "_repr_": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: class FooBar(CombinatorialFreeModule): pass\n                sage: C = FooBar(QQ, (1,2,3)); C # indirect doctest\n                Free module generated by {1, 2, 3} over Rational Field\n\n                sage: C._name = \"foobar\"; C\n                foobar over Rational Field\n\n                sage: C.rename(\"barfoo\"); C\n                barfoo\n\n                sage: class FooBar(Parent):\n                ....:     def basis(self): return Family({1:\"foo\", 2:\"bar\"})\n                ....:     def base_ring(self): return QQ\n                sage: FooBar(category = ModulesWithBasis(QQ))\n                Free module generated by [1, 2] over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "_sum_of_monomials": {
                    "__doc__": "\n            TESTS::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])\n                sage: F._sum_of_monomials(['a', 'b'])\n                B['a'] + B['b']\n            ",
                    "args": [
                        "self",
                        "indices"
                    ],
                    "argspec": [
                        [
                            "self",
                            "indices"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "echelon_form": {
                    "__doc__": "\n            Return a basis in echelon form of the subspace spanned by\n            a finite set of elements.\n\n            INPUT:\n\n            - ``elements`` -- a list or finite iterable of elements of ``self``\n            - ``row_reduced`` -- (default: ``False``) whether to compute the\n              basis for the row reduced echelon form\n\n            OUTPUT:\n\n            A list of elements of ``self`` whose expressions as\n            vectors form a matrix in echelon form. If ``base_ring`` is\n            specified, then the calculation is achieved in this base\n            ring.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: V = X.echelon_form([x[0]-x[1], x[0]-x[2],x[1]-x[2]]); V\n                [x[0] - x[2], x[1] - x[2]]\n                sage: matrix(map(vector, V))\n                [ 1  0 -1]\n                [ 0  1 -1]\n\n            ::\n\n                sage: F = CombinatorialFreeModule(ZZ, [1,2,3,4])\n                sage: B = F.basis()\n                sage: elements = [B[1]-17*B[2]+6*B[3], B[1]-17*B[2]+B[4]]\n                sage: F.echelon_form(elements)\n                [B[1] - 17*B[2] + B[4], 6*B[3] - B[4]]\n\n            ::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: a,b,c = F.basis()\n                sage: F.echelon_form([8*a+b+10*c, -3*a+b-c, a-b-c])\n                [B['a'] + B['c'], B['b'] + 2*B['c']]\n\n            ::\n\n                sage: R.<x,y> = QQ[]\n                sage: C = CombinatorialFreeModule(R, range(3), prefix='x')\n                sage: x = C.basis()\n                sage: C.echelon_form([x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]])\n                [x[0] - x[2], x[1] - x[2]]\n            ",
                    "args": [
                        "self",
                        "elements",
                        "row_reduced"
                    ],
                    "argspec": [
                        [
                            "self",
                            "elements",
                            "row_reduced"
                        ],
                        null,
                        null,
                        [
                            false
                        ]
                    ]
                },
                "linear_combination": {
                    "__doc__": "\n            Return the linear combination `\\lambda_1 v_1 + \\cdots +\n            \\lambda_k v_k` (resp.  the linear combination `v_1 \\lambda_1 +\n            \\cdots + v_k \\lambda_k`) where ``iter_of_elements_coeff`` iterates\n            through the sequence `((\\lambda_1, v_1), ..., (\\lambda_k, v_k))`.\n\n            INPUT:\n\n            - ``iter_of_elements_coeff`` -- iterator of pairs\n              ``(element, coeff)`` with ``element`` in ``self`` and\n              ``coeff`` in ``self.base_ring()``\n\n            - ``factor_on_left`` -- (optional) if ``True``, the coefficients\n              are multiplied from the left; if ``False``, the coefficients\n              are multiplied from the right\n\n            EXAMPLES::\n\n                sage: m = matrix([[0,1],[1,1]])\n                sage: J.<a,b,c> = JordanAlgebra(m)\n                sage: J.linear_combination(((a+b, 1), (-2*b + c, -1)))\n                1 + (3, -1)\n            ",
                    "args": [
                        "self",
                        "iter_of_elements_coeff",
                        "factor_on_left"
                    ],
                    "argspec": [
                        [
                            "self",
                            "iter_of_elements_coeff",
                            "factor_on_left"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "module_morphism": {
                    "__doc__": "\n            Construct a module morphism from ``self`` to ``codomain``.\n\n            Let ``self`` be a module `X` with a basis indexed by `I`.\n            This constructs a morphism `f: X \\to Y` by linearity from\n            a map `I \\to Y` which is to be its restriction to the\n            basis `(x_i)_{i \\in I}` of `X`. Some variants are possible\n            too.\n\n            INPUT:\n\n            - ``self`` -- a parent `X` in ``ModulesWithBasis(R)`` with\n              basis `x=(x_i)_{i\\in I}`.\n\n            Exactly one of the four following options must be\n            specified in order to define the morphism:\n\n            - ``on_basis`` -- a function `f` from `I` to `Y`\n            - ``diagonal`` -- a function `d` from `I` to `R`\n            - ``function`` -- a function `f` from `X` to `Y`\n            - ``matrix``   -- a matrix of size `\\dim Y \\times \\dim X`\n              (if the keyword ``side`` is set to ``'left'``) or\n              `\\dim Y \\times \\dim X` (if this keyword is ``'right'``)\n\n            Further options include:\n\n            - ``codomain`` -- the codomain `Y` of the morphism (default:\n              ``f.codomain()`` if it's defined; otherwise it must be specified)\n\n            - ``category`` -- a category or ``None`` (default: `None``)\n\n            - ``zero`` -- the zero of the codomain (default: ``codomain.zero()``);\n              can be used (with care) to define affine maps.\n              Only meaningful with ``on_basis``.\n\n            - ``position`` -- a non-negative integer specifying which\n              positional argument in used as the input of the function `f`\n              (default: 0); this is currently only used with ``on_basis``.\n\n            - ``triangular`` --  (default: ``None``) ``\"upper\"`` or\n              ``\"lower\"`` or ``None``:\n\n              * ``\"upper\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.leading_support`\n                of the image of the basis vector `x_i` is `i`, or\n\n              * ``\"lower\"`` - if the\n                :meth:`~ModulesWithBasis.ElementMethods.trailing_support`\n                of the image of the basis vector `x_i` is `i`.\n\n            - ``unitriangular`` -- (default: ``False``) a boolean.\n              Only meaningful for a triangular morphism.\n              As a shorthand, one may use ``unitriangular=\"lower\"``\n              for ``triangular=\"lower\", unitriangular=True``.\n\n            - ``side`` -- \"left\" or \"right\" (default: \"left\")\n              Only meaningful for a morphism built from a matrix.\n\n            EXAMPLES:\n\n            With the ``on_basis`` option, this returns a function `g`\n            obtained by extending `f` by linearity on the\n            ``position``-th positional argument. For example, for\n            ``position == 1`` and a ternary function `f`, one has:\n\n            .. MATH::\n\n                g\\left( a,\\ \\sum_i \\lambda_i x_i,\\ c \\right)\n                = \\sum_i \\lambda_i f(a, i, c).\n\n            ::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1), codomain = Y)\n                sage: x = X.basis(); y = Y.basis()\n                sage: phi(x[1] + x[3])\n                B[1] + 2*B[2] + B[3] + 2*B[4]\n\n                sage: phi\n                Generic morphism:\n                From: X\n                To:   Y\n\n            By default, the category is the first of\n            ``Modules(R).WithBasis().FiniteDimensional()``,\n            ``Modules(R).WithBasis()``, ``Modules(R)``, and\n            ``CommutativeAdditiveMonoids()`` that contains both the\n            domain and the codomain::\n\n                sage: phi.category_for()\n                Category of finite dimensional vector spaces with basis over Rational Field\n\n            With the ``zero`` argument, one can define affine morphisms::\n\n                sage: phi = X.module_morphism(lambda i: Y.monomial(i) + 2*Y.monomial(i+1),\n                ....:                         codomain = Y, zero = 10*y[1])\n                sage: phi(x[1] + x[3])\n                11*B[1] + 2*B[2] + B[3] + 2*B[4]\n\n            In this special case, the default category is ``Sets()``::\n\n                sage: phi.category_for()\n                Category of sets\n\n            One can construct morphisms with the base ring as codomain::\n\n                sage: X = CombinatorialFreeModule(ZZ,[1,-1])\n                sage: phi = X.module_morphism( on_basis=lambda i: i, codomain=ZZ )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (ZZ is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n            Or more generaly any ring admitting a coercion map from\n            the base ring::\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=RR )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                -1.00000000000000\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (RR is currently not in Modules(ZZ))\n                Category of modules over Integer Ring\n\n                sage: phi = X.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                sage: phi( 2 * X.monomial(1) + 3 * X.monomial(-1) )\n                3\n\n                sage: phi = Y.module_morphism(on_basis=lambda i: i, codomain=Zmod(4) )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Ring of integers modulo 4) should be a module over the base ring of the domain(=Y)\n\n            On can also define module morphisms between free modules\n            over different base rings; here we implement the natural\n            map from `X = \\RR^2` to `Y = \\CC`::\n\n                sage: X = CombinatorialFreeModule(RR,['x','y'])\n                sage: Y = CombinatorialFreeModule(CC,['z'])\n                sage: x = X.monomial('x')\n                sage: y = X.monomial('y')\n                sage: z = Y.monomial('z')\n                sage: def on_basis( a ):\n                ....:     if a == 'x':\n                ....:         return CC(1) * z\n                ....:     elif a == 'y':\n                ....:         return CC(I) * z\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: v = 3 * x + 2 * y; v\n                3.00000000000000*B['x'] + 2.00000000000000*B['y']\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n                sage: phi.category_for()\n                Category of commutative additive semigroups\n                sage: phi.category_for() # todo: not implemented (CC is currently not in Modules(RR)!)\n                Category of vector spaces over Real Field with 53 bits of precision\n\n                sage: Y = CombinatorialFreeModule(CC['q'],['z'])\n                sage: z = Y.monomial('z')\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                sage: phi(v)\n                (3.00000000000000+2.00000000000000*I)*B['z']\n\n            Of course, there should be a coercion between the\n            respective base rings of the domain and the codomain for\n            this to be meaningful::\n\n                sage: Y = CombinatorialFreeModule(QQ,['z'])\n                sage: phi = X.module_morphism( on_basis=on_basis, codomain=Y )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'z'} over Rational Field)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n\n                sage: Y = CombinatorialFreeModule(RR['q'],['z'])\n                sage: phi = Y.module_morphism( on_basis=on_basis, codomain=X )\n                Traceback (most recent call last):\n                ...\n                ValueError: codomain(=Free module generated by {'x', 'y'} over Real Field with 53 bits of precision)\n                 should be a module over the base ring of the\n                 domain(=Free module generated by {'z'} over Univariate Polynomial Ring in q over Real Field with 53 bits of precision)\n\n\n            With the ``diagonal=d`` argument, this constructs the\n            module morphism `g` such that\n\n            .. MATH::\n\n                `g(x_i) = d(i) y_i`.\n\n            This assumes that the respective bases `x` and `y` of `X`\n            and `Y` have the same index set `I`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, codomain=X)\n                sage: x = X.basis()\n                sage: phi(x[1]), phi(x[2]), phi(x[3])\n                (B[1], 2*B[2], 6*B[3])\n\n            See also: :class:`sage.modules.with_basis.morphism.DiagonalModuleMorphism`.\n\n            With the ``matrix=m`` argument, this constructs the module\n            morphism whose matrix in the distinguished basis of `X`\n            and `Y` is `m`::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(ZZ, [3,4]); Y.rename(\"Y\"); y = Y.basis()\n                sage: m = matrix([[0,1,2],[3,5,0]])\n                sage: phi = X.module_morphism(matrix=m, codomain=Y)\n                sage: phi(x[1])\n                3*B[4]\n                sage: phi(x[2])\n                B[3] + 5*B[4]\n\n\n            See also: :class:`sage.modules.with_basis.morphism.ModuleMorphismFromMatrix`.\n\n            With ``triangular=\"upper\"``, the constructed module morphism is\n            assumed to be upper triangular; that is its matrix in the\n            distinguished basis of `X` and `Y` would be upper triangular with\n            invertible elements on its diagonal. This is used to compute\n            preimages and to invert the morphism::\n\n                sage: I = range(1,200)\n                sage: X = CombinatorialFreeModule(QQ, I); X.rename(\"X\"); x = X.basis()\n                sage: Y = CombinatorialFreeModule(QQ, I); Y.rename(\"Y\"); y = Y.basis()\n                sage: f = Y.sum_of_monomials * divisors\n                sage: phi = X.module_morphism(f, triangular=\"upper\", codomain = Y)\n                sage: phi(x[2])\n                B[1] + B[2]\n                sage: phi(x[6])\n                B[1] + B[2] + B[3] + B[6]\n                sage: phi(x[30])\n                B[1] + B[2] + B[3] + B[5] + B[6] + B[10] + B[15] + B[30]\n                sage: phi.preimage(y[2])\n                -B[1] + B[2]\n                sage: phi.preimage(y[6])\n                B[1] - B[2] - B[3] + B[6]\n                sage: phi.preimage(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n                sage: (phi^-1)(y[30])\n                -B[1] + B[2] + B[3] + B[5] - B[6] - B[10] - B[15] + B[30]\n\n            Since :trac:`8678`, one can also define a triangular\n            morphism from a function::\n\n                sage: X = CombinatorialFreeModule(QQ, [0,1,2,3,4]); x = X.basis()\n                sage: from sage.modules.with_basis.morphism import TriangularModuleMorphismFromFunction\n                sage: def f(x): return x + X.term(0, sum(x.coefficients()))\n                sage: phi = X.module_morphism(function=f, codomain=X, triangular=\"upper\")\n                sage: phi(x[2] + 3*x[4])\n                4*B[0] + B[2] + 3*B[4]\n                sage: phi.preimage(_)\n                B[2] + 3*B[4]\n\n            For details and further optional arguments, see\n            :class:`sage.modules.with_basis.morphism.TriangularModuleMorphism`.\n\n            .. WARNING::\n\n                As a temporary measure, until multivariate morphisms\n                are implemented, the constructed morphism is in\n                ``Hom(codomain, domain, category)``. This is only\n                correct for unary functions.\n\n            .. TODO::\n\n               - Should codomain be ``self`` by default in the\n                 diagonal, triangular, and matrix cases?\n\n               - Support for diagonal morphisms between modules not\n                 sharing the same index set\n\n            TESTS::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=factorial, matrix=matrix(), codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: module_morphism() takes exactly one option\n                out of `matrix`, `on_basis`, `function`, `diagonal`\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(matrix=factorial, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: matrix (=factorial) should be a matrix\n\n            ::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2,3]); X.rename(\"X\")\n                sage: phi = X.module_morphism(diagonal=3, codomain=X)\n                Traceback (most recent call last):\n                ...\n                ValueError: diagonal (=3) should be a function\n\n            ",
                    "args": [
                        "self",
                        "on_basis",
                        "matrix",
                        "function",
                        "diagonal",
                        "triangular",
                        "unitriangular"
                    ],
                    "argspec": [
                        [
                            "self",
                            "on_basis",
                            "matrix",
                            "function",
                            "diagonal",
                            "triangular",
                            "unitriangular"
                        ],
                        null,
                        "keywords",
                        [
                            null,
                            null,
                            null,
                            null,
                            null,
                            false
                        ]
                    ]
                },
                "monomial": {
                    "__doc__": "\n            Return the basis element indexed by ``i``.\n\n            INPUT:\n\n            - ``i`` -- an element of the index set\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])\n                sage: F.monomial('a')\n                B['a']\n\n            ``F.monomial`` is in fact (almost) a map::\n\n                sage: F.monomial\n                Term map from {'a', 'b', 'c'} to Free module generated by {'a', 'b', 'c'} over Rational Field\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "monomial_or_zero_if_none": {
                    "__doc__": "\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a', 'b', 'c'])\n                sage: F.monomial_or_zero_if_none('a')\n                B['a']\n                sage: F.monomial_or_zero_if_none(None)\n                0\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "submodule": {
                    "__doc__": "\n            The submodule spanned by a finite set of elements.\n\n            INPUT:\n\n            - ``gens`` -- a list or family of elements of ``self``\n\n            - ``check`` -- (default: ``True``) whether to verify that the\n               elements of ``gens`` are in ``self``\n\n            - ``already_echelonized`` -- (default: ``False``) whether\n               the elements of ``gens`` are already in (not necessarily\n               reduced) echelon form\n\n            - ``unitrangular`` -- (default: ``False``) whether\n              the lift morphism is unitrangular\n\n            If ``already_echelonized`` is ``False``, then the\n            generators are put in reduced echelon form using\n            :meth:`echelonize`, and reindexed by `0,1,...`.\n\n            .. WARNING::\n\n                At this point, this method only works for finite\n                dimensional submodules and if matrices can be\n                echelonized over the base ring.\n\n            If in addition ``unitriangular`` is ``True``, then\n            the generators are made such that the coefficients of\n            the pivots are 1, so that lifting map is unitriangular.\n\n            The basis of the submodule uses the same index set as the\n            generators, and the lifting map sends `y_i` to `gens[i]`.\n\n\n            .. SEEALSO::\n\n                 - :meth:`ModulesWithBasis.FiniteDimensional.ParentMethods.quotient_module`\n                 - :class:`sage.modules.with_basis.subquotient.SubmoduleWithBasis`\n\n            EXAMPLES:\n\n            We construct a submodule of the free `\\QQ`-module generated by\n            `x_0, x_1, x_2`. The submodule is spanned by `y_0 = x_0 - x_1` and\n            `y_1 - x_1 - x_2`, and its basis elements are indexed by `0` and `1`::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: gens = [x[0] - x[1], x[1] - x[2]]; gens\n                [x[0] - x[1], x[1] - x[2]]\n                sage: Y = X.submodule(gens, already_echelonized=True)\n                sage: Y.print_options(prefix='y'); Y\n                Free module generated by {0, 1} over Rational Field\n                sage: y = Y.basis()\n                sage: y[1]\n                y[1]\n                sage: y[1].lift()\n                x[1] - x[2]\n                sage: Y.retract(x[0]-x[2])\n                y[0] + y[1]\n                sage: Y.retract(x[0])\n                Traceback (most recent call last):\n                ...\n                ValueError: x[0] is not in the image\n\n            By using a family to specify a basis of the submodule, we obtain a\n            submodule whose index set coincides with the index set of the family::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: gens = Family({1 : x[0] - x[1], 3: x[1] - x[2]}); gens\n                Finite family {1: x[0] - x[1], 3: x[1] - x[2]}\n                sage: Y = X.submodule(gens, already_echelonized=True)\n                sage: Y.print_options(prefix='y'); Y\n                Free module generated by {1, 3} over Rational Field\n                sage: y = Y.basis()\n                sage: y[1]\n                y[1]\n                sage: y[1].lift()\n                x[0] - x[1]\n                sage: y[3].lift()\n                x[1] - x[2]\n                sage: Y.retract(x[0]-x[2])\n                y[1] + y[3]\n                sage: Y.retract(x[0])\n                Traceback (most recent call last):\n                ...\n                ValueError: x[0] is not in the image\n\n            It is not necessary that the generators of the submodule form\n            a basis (an explicit basis will be computed)::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: gens = [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]; gens\n                [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]\n                sage: Y = X.submodule(gens, already_echelonized=False)\n                sage: Y.print_options(prefix='y')\n                sage: Y\n                Free module generated by {0, 1} over Rational Field\n                sage: [b.lift() for b in Y.basis()]\n                [x[0] - x[2], x[1] - x[2]]\n\n            We now implement by hand the center of the algebra of the\n            symmetric group `S_3`::\n\n                sage: S3 = SymmetricGroup(3)\n                sage: S3A = S3.algebra(QQ)\n                sage: basis = S3A.annihilator_basis(S3A.algebra_generators(), S3A.bracket)\n                sage: basis\n                ((), (2,3) + (1,2) + (1,3), (1,2,3) + (1,3,2))\n                sage: center = S3A.submodule(basis,\n                ....:                        category=AlgebrasWithBasis(QQ).Subobjects(),\n                ....:                        already_echelonized=True)\n                sage: center\n                Free module generated by {0, 1, 2} over Rational Field\n                sage: center in Algebras\n                True\n                sage: center.print_options(prefix='c')\n                sage: c = center.basis()\n                sage: c[1].lift()\n                (2,3) + (1,2) + (1,3)\n                sage: c[0]^2\n                c[0]\n                sage: e = 1/6*(c[0]+c[1]+c[2])\n                sage: e.is_idempotent()\n                True\n\n            Of course, this center is best constructed using::\n\n                sage: center = S3A.center()\n\n            We can also automatically construct a basis such that\n            the lift morphism is (lower) unitriangular::\n\n                sage: R.<a,b> = QQ[]\n                sage: C = CombinatorialFreeModule(R, range(3), prefix='x')\n                sage: x = C.basis()\n                sage: gens = [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]\n                sage: Y = C.submodule(gens, unitriangular=True)\n                sage: Y.lift.matrix()\n                [ 1  0]\n                [ 0  1]\n                [-1 -1]\n\n            TESTS::\n\n                sage: TestSuite(Y).run()\n                sage: TestSuite(center).run()\n            ",
                    "args": [
                        "self",
                        "gens",
                        "check",
                        "already_echelonized",
                        "unitriangular",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "gens",
                            "check",
                            "already_echelonized",
                            "unitriangular",
                            "category"
                        ],
                        null,
                        null,
                        [
                            true,
                            false,
                            false,
                            null
                        ]
                    ]
                },
                "sum_of_terms": {
                    "__doc__": "\n            Construct a sum of terms of ``self``.\n\n            INPUT:\n\n            - ``terms`` -- a list (or iterable) of pairs ``(index, coeff)``\n\n            OUTPUT:\n\n            Sum of ``coeff * B[index]`` over all ``(index, coeff)`` in\n            ``terms``, where ``B`` is the basis of ``self``.\n\n            EXAMPLES::\n\n                sage: m = matrix([[0,1],[1,1]])\n                sage: J.<a,b,c> = JordanAlgebra(m)\n                sage: J.sum_of_terms([(0, 2), (2, -3)])\n                2 + (0, -3)\n            ",
                    "args": [
                        "self",
                        "terms"
                    ],
                    "argspec": [
                        [
                            "self",
                            "terms"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "tensor": {
                    "__doc__": "\n            Return the tensor product of the parents.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example(); A.rename(\"A\")\n                sage: A.tensor(A,A)\n                A # A # A\n                sage: A.rename(None)\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "parents",
                        null,
                        null
                    ]
                },
                "term": {
                    "__doc__": "\n            Construct a term in ``self``.\n\n            INPUT:\n\n            - ``index`` -- the index of a basis element\n            - ``coeff`` -- an element of the coefficient ring (default: one)\n\n            OUTPUT:\n\n            ``coeff * B[index]``, where ``B`` is the basis of ``self``.\n\n            EXAMPLES::\n\n                sage: m = matrix([[0,1],[1,1]])\n                sage: J.<a,b,c> = JordanAlgebra(m)\n                sage: J.term(1, -2)\n                0 + (-2, 0)\n\n            Design: should this do coercion on the coefficient ring?\n            ",
                    "args": [
                        "self",
                        "index",
                        "coeff"
                    ],
                    "argspec": [
                        [
                            "self",
                            "index",
                            "coeff"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "__getitem__": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self``.\n\n            EXAMPLES::\n\n                sage: p = Partition([2,1])\n                sage: q = Partition([1,1,1])\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s(p)\n                sage: a._coefficient_fast([2,1])\n                Traceback (most recent call last):\n                ...\n                TypeError: unhashable type: 'list'\n\n            ::\n\n                sage: a._coefficient_fast(p)\n                1\n                sage: a._coefficient_fast(q)\n                0\n                sage: a[p]\n                1\n                sage: a[q]\n                0\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "__len__": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: len(f)\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: len(z)\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficient": {
                    "__doc__": "\n            Return the coefficient of ``m`` in ``self`` and raise an error\n            if ``m`` is not in the basis indexing set.\n\n            INPUT:\n\n            - ``m`` -- a basis index of the parent of ``self``\n\n            OUTPUT:\n\n            The ``B[m]``-coordinate of ``self`` with respect to the basis\n            ``B``. Here, ``B`` denotes the given basis of the parent of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: s = CombinatorialFreeModule(QQ, Partitions())\n                sage: z = s([4]) - 2*s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficient([4])\n                1\n                sage: z.coefficient([2,1])\n                -2\n                sage: z.coefficient(Partition([2,1]))\n                -2\n                sage: z.coefficient([1,2])\n                Traceback (most recent call last):\n                ...\n                AssertionError: [1, 2] should be an element of Partitions\n                sage: z.coefficient(Composition([2,1]))\n                Traceback (most recent call last):\n                ...\n                AssertionError: [2, 1] should be an element of Partitions\n\n            Test that ``coefficient`` also works for those parents that do\n            not yet have an element_class::\n\n                sage: G = DihedralGroup(3)\n                sage: F = CombinatorialFreeModule(QQ, G)\n                sage: hasattr(G, \"element_class\")\n                False\n                sage: g = G.an_element()\n                sage: (2*F.monomial(g)).coefficient(g)\n                2\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "coefficients": {
                    "__doc__": "\n            Return a list of the (non-zero) coefficients appearing on\n            the basis elements in ``self`` (in an arbitrary order).\n\n            INPUT:\n\n            - ``sort`` -- (default: ``True``) to sort the coefficients\n              based upon the default ordering of the indexing set\n\n            .. SEEALSO::\n\n                :meth:`~sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis.ElementMethods.dense_coefficient_list`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.coefficients()\n                [1, -3]\n                sage: f = B['c'] - 3*B['a']\n                sage: f.coefficients()\n                [-3, 1]\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.coefficients()\n                [1, 1, 1, 1]\n            ",
                    "args": [
                        "self",
                        "sort"
                    ],
                    "argspec": [
                        [
                            "self",
                            "sort"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "is_zero": {
                    "__doc__": "\n            Return ``True`` if and only if ``self == 0``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.is_zero()\n                False\n                sage: F.zero().is_zero()\n                True\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: s([2,1]).is_zero()\n                False\n                sage: s(0).is_zero()\n                True\n                sage: (s([2,1]) - s([2,1])).is_zero()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "leading_coefficient": {
                    "__doc__": "\n            Returns the leading coefficient of ``self``.\n\n            This is the coefficient of the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\")\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_coefficient()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_coefficient(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_coefficient()\n                -5\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_item": {
                    "__doc__": "\n            Return the pair ``(k, c)`` where\n\n            .. MATH::\n\n                c \\cdot (\\mbox{the basis element indexed by } k)\n\n            is the leading term of ``self``.\n\n            Here 'leading term' means that the corresponding basis element is\n            maximal.  Note that this may not be the term which actually appears\n            first when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be\n            provided.  This should return a negative value if ``x < y``, ``0``\n            if ``x == y`` and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_item()\n                (3, 4)\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_item(cmp=cmp)\n                (1, 3)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_item()\n                ([3], -5)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_monomial": {
                    "__doc__": "\n            Return the leading monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_monomial()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_monomial(cmp=cmp)\n                B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_monomial()\n                s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_support": {
                    "__doc__": "\n            Return the maximal element of the support of ``self``. Note\n            that this may not be the term which actually appears first when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, ``0`` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.leading_support()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_support(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_support()\n                [3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "leading_term": {
                    "__doc__": "\n            Return the leading term of ``self``.\n\n            This is the term whose corresponding basis element is\n            maximal. Note that this may not be the term which actually appears\n            first when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.leading_term()\n                B[3]\n                sage: def cmp(x,y): return y-x\n                sage: x.leading_term(cmp=cmp)\n                3*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.leading_term()\n                -5*s[3]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "length": {
                    "__doc__": "\n            Return the number of basis elements whose coefficients in\n            ``self`` are nonzero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.length()\n                2\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: z.length()\n                4\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_coefficients": {
                    "__doc__": "\n            Mapping a function on coefficients.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the coefficient ring of the\n              free module\n\n            Return a new element of ``self.parent()`` obtained by applying the\n            function ``f`` to all of the coefficients of ``self``.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: f.map_coefficients(lambda x: x+5)\n                6*B['a'] + 2*B['c']\n\n            Killed coefficients are handled properly::\n\n                sage: f.map_coefficients(lambda x: 0)\n                0\n                sage: list(f.map_coefficients(lambda x: 0))\n                []\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_coefficients(lambda x: x*2)\n                2*s[2, 1] + 4*s[3, 2]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_item": {
                    "__doc__": "\n            Mapping a function on items.\n\n            INPUT:\n\n            - ``f`` -- a function mapping pairs ``(index, coeff)`` to\n              other such pairs\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function `f` to all items ``(index, coeff)`` of\n            ``self``.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_item(lambda i, c: (-i, 2*c))\n                6*B[-1] + 4*B[0] + 4*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_item(lambda i, c: (1, 2*c))\n                14*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = lambda m,c: (m.conjugate(), 2*c)\n                sage: a = s([2,1]) + s([1,1,1])\n                sage: a.map_item(f)\n                2*s[2, 1] + 2*s[3]\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Return a new element of ``self.parent()`` obtained by\n            applying the function ``f`` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support(lambda i: -i)\n                3*B[-1] + 2*B[0] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support(lambda i: 1)\n                7*B[1]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2,1])+2*s([3,2])\n                sage: a.map_support(lambda x: x.conjugate())\n                s[2, 1] + 2*s[2, 2, 1]\n\n            TESTS::\n\n                sage: B.zero()      # This actually failed at some point!!! See #8890\n                0\n\n                sage: y = B.zero().map_support(lambda i: i/0); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "map_support_skip_none": {
                    "__doc__": "\n            Mapping a function on the support.\n\n            INPUT:\n\n            - ``f`` -- an endofunction on the indices of the free module\n\n            Returns a new element of ``self.parent()`` obtained by\n            applying the function `f` to all of the objects indexing\n            the basis elements.\n\n            EXAMPLES::\n\n                sage: B = CombinatorialFreeModule(ZZ, [-1, 0, 1])\n                sage: x = B.an_element(); x\n                2*B[-1] + 2*B[0] + 3*B[1]\n                sage: x.map_support_skip_none(lambda i: -i if i else None)\n                3*B[-1] + 2*B[1]\n\n            ``f`` needs not be injective::\n\n                sage: x.map_support_skip_none(lambda i: 1 if i else None)\n                5*B[1]\n\n            TESTS::\n\n                sage: y = x.map_support_skip_none(lambda i: None); y\n                0\n                sage: y.parent() is B\n                True\n            ",
                    "args": [
                        "self",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "monomial_coefficients": {
                    "__doc__": "\n            Return a dictionary whose keys are indices of basis elements\n            in the support of ``self`` and whose values are the\n            corresponding coefficients.\n\n            INPUT:\n\n            - ``copy`` -- (default: ``True``) if ``self`` is internally\n              represented by a dictionary ``d``, then make a copy of ``d``;\n              if ``False``, then this can cause undesired behavior by\n              mutating ``d``\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a']\n                1\n                sage: d['c']\n                3\n\n            TESTS:\n\n            We check that we make a copy of the coefficient dictionary::\n\n                sage: F = CombinatorialFreeModule(ZZ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 3*B['c']\n                sage: d = f.monomial_coefficients()\n                sage: d['a'] = 5\n                sage: f\n                B['a'] + 3*B['c']\n            ",
                    "args": [
                        "self",
                        "copy"
                    ],
                    "argspec": [
                        [
                            "self",
                            "copy"
                        ],
                        null,
                        null,
                        [
                            true
                        ]
                    ]
                },
                "monomials": {
                    "__doc__": "\n            Return a list of the monomials of ``self`` (in an arbitrary\n            order).\n\n            The monomials of an element `a` are defined to be the basis\n            elements whose corresponding coefficients of `a` are\n            non-zero.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.monomials()\n                [B['a'], B['c']]\n\n                sage: (F.zero()).monomials()\n                []\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support": {
                    "__doc__": "\n            Return a list of the objects indexing the basis of\n            ``self.parent()`` whose corresponding coefficients of\n            ``self`` are non-zero.\n\n            This method returns these objects in an arbitrary order.\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] - 3*B['c']\n                sage: sorted(f.support())\n                ['a', 'c']\n\n            ::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: z = s([4]) + s([2,1]) + s([1,1,1]) + s([1])\n                sage: sorted(z.support())\n                [[1], [1, 1, 1], [2, 1], [4]]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "support_of_term": {
                    "__doc__": "\n            Return the support of ``self``, where ``self`` is a monomial\n            (possibly with coefficient).\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1,2,3,4]); X.rename(\"X\")\n                sage: X.monomial(2).support_of_term()\n                2\n                sage: X.term(3, 2).support_of_term()\n                3\n\n            An exception is raised if ``self`` has more than one term::\n\n                sage: (X.monomial(2) + X.monomial(3)).support_of_term()\n                Traceback (most recent call last):\n                ...\n                ValueError: B[2] + B[3] is not a single term\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "tensor": {
                    "__doc__": "\n            Return the tensor product of its arguments, as an element of\n            the tensor product of the parents of those elements.\n\n            EXAMPLES::\n\n                sage: C = AlgebrasWithBasis(QQ)\n                sage: A = C.example()\n                sage: (a,b,c) = A.algebra_generators()\n                sage: a.tensor(b, c)\n                B[word: a] # B[word: b] # B[word: c]\n\n            FIXME: is this a policy that we want to enforce on all parents?\n            ",
                    "args": [],
                    "argspec": [
                        [],
                        "elements",
                        null,
                        null
                    ]
                },
                "terms": {
                    "__doc__": "\n            Return a list of the (non-zero) terms of ``self`` (in an\n            arbitrary order).\n\n            .. SEEALSO:: :meth:`monomials`\n\n            EXAMPLES::\n\n                sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])\n                sage: B = F.basis()\n                sage: f = B['a'] + 2*B['c']\n                sage: f.terms()\n                [B['a'], 2*B['c']]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "trailing_coefficient": {
                    "__doc__": "\n            Return the trailing coefficient of ``self``.\n\n            This is the coefficient of the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_coefficient()\n                3\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_coefficient(cmp=cmp)\n                1\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_coefficient()\n                2\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_item": {
                    "__doc__": "\n            Returns the pair ``(c, k)`` where ``c*self.parent().monomial(k)``\n            is the trailing term of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed.  If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_item()\n                (1, 3)\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_item(cmp=cmp)\n                (3, 1)\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_item()\n                ([1], 2)\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_monomial": {
                    "__doc__": "\n            Return the trailing monomial of ``self``.\n\n            This is the monomial whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_monomial()\n                B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_monomial(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_monomial()\n                s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_support": {
                    "__doc__": "\n            Return the minimal element of the support of ``self``. Note\n            that this may not be the term which actually appears last when\n            ``self`` is printed.\n\n            If the default ordering of the basis elements is not what is\n            desired, a comparison function, ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, `0` if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + 4*X.monomial(3)\n                sage: x.trailing_support()\n                1\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_support(cmp=cmp)\n                3\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_support()\n                [1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                },
                "trailing_term": {
                    "__doc__": "\n            Return the trailing term of ``self``.\n\n            This is the term whose corresponding basis element is\n            minimal. Note that this may not be the term which actually appears\n            last when ``self`` is printed. If the default term ordering is not\n            what is desired, a comparison function ``cmp(x,y)``, can be provided.\n            This should return a negative value if ``x < y``, 0 if ``x == y``\n            and a positive value if ``x > y``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, [1, 2, 3]); X.rename(\"X\"); x = X.basis()\n                sage: x = 3*X.monomial(1) + 2*X.monomial(2) + X.monomial(3)\n                sage: x.trailing_term()\n                3*B[1]\n                sage: def cmp(x,y): return y-x\n                sage: x.trailing_term(cmp=cmp)\n                B[3]\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: f = 2*s[1] + 3*s[2,1] - 5*s[3]\n                sage: f.trailing_term()\n                2*s[1]\n            ",
                    "args": [
                        "self",
                        "cmp"
                    ],
                    "argspec": [
                        [
                            "self",
                            "cmp"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of `(R,S)`-bimodules\n\n    For `R` and `S` rings, a `(R,S)`-bimodule `X` is a left `R`-module\n    and right `S`-module such that the left and right actions commute:\n    `r*(x*s) = (r*x)*s`.\n\n    EXAMPLES::\n\n        sage: Bimodules(QQ, ZZ)\n        Category of bimodules over Rational Field on the left and Integer Ring on the right\n        sage: Bimodules(QQ, ZZ).super_categories()\n        [Category of left modules over Rational Field, Category of right modules over Integer Ring]\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of `(R,S)`-bimodules\n\n    For `R` and `S` rings, a `(R,S)`-bimodule `X` is a left `R`-module\n    and right `S`-module such that the left and right actions commute:\n    `r*(x*s) = (r*x)*s`.\n\n    EXAMPLES::\n\n        sage: Bimodules(QQ, ZZ)\n        Category of bimodules over Rational Field on the left and Integer Ring on the right\n        sage: Bimodules(QQ, ZZ).super_categories()\n        [Category of left modules over Rational Field, Category of right modules over Integer Ring]\n    ",
            "methods": {}
        },
        "name": "sage.categories.bimodules.Bimodules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.TensorProducts",
        "parent_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of modules constructed by tensor product of modules.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "FiniteDimensional",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.FiniteDimensional",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of associative and unital algebras over a given base ring.\n\n    An associative and unital algebra over a ring `R` is a module over\n    `R` which is itself a ring.\n\n    .. WARNING::\n\n        :class:`Algebras` will be eventually be replaced by\n        :class:`.magmatic_algebras.MagmaticAlgebras`\n        for consistency with e.g. :wikipedia:`Algebras` which assumes\n        neither associativity nor the existence of a unit (see\n        :trac:`15043`).\n\n    .. TODO:: Should `R` be a commutative ring?\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ)\n        Category of algebras over Integer Ring\n        sage: sorted(Algebras(ZZ).super_categories(), key=str)\n        [Category of associative algebras over Integer Ring,\n         Category of rings,\n         Category of unital algebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.rings.Rings",
            "sage.categories.associative_algebras.AssociativeAlgebras",
            "sage.categories.unital_algebras.UnitalAlgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of associative and unital algebras over a given base ring.\n\n    An associative and unital algebra over a ring `R` is a module over\n    `R` which is itself a ring.\n\n    .. WARNING::\n\n        :class:`Algebras` will be eventually be replaced by\n        :class:`.magmatic_algebras.MagmaticAlgebras`\n        for consistency with e.g. :wikipedia:`Algebras` which assumes\n        neither associativity nor the existence of a unit (see\n        :trac:`15043`).\n\n    .. TODO:: Should `R` be a commutative ring?\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ)\n        Category of algebras over Integer Ring\n        sage: sorted(Algebras(ZZ).super_categories(), key=str)\n        [Category of associative algebras over Integer Ring,\n         Category of rings,\n         Category of unital algebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras",
        "parent_class": {
            "__doc__": "\n    The category of associative and unital algebras over a given base ring.\n\n    An associative and unital algebra over a ring `R` is a module over\n    `R` which is itself a ring.\n\n    .. WARNING::\n\n        :class:`Algebras` will be eventually be replaced by\n        :class:`.magmatic_algebras.MagmaticAlgebras`\n        for consistency with e.g. :wikipedia:`Algebras` which assumes\n        neither associativity nor the existence of a unit (see\n        :trac:`15043`).\n\n    .. TODO:: Should `R` be a commutative ring?\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ)\n        Category of algebras over Integer Ring\n        sage: sorted(Algebras(ZZ).super_categories(), key=str)\n        [Category of associative algebras over Integer Ring,\n         Category of rings,\n         Category of unital algebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "mmt.AdditiveSemigroups.GAP",
            "mmt.AdditiveUnital.GAP",
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.Modules.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Distributive",
            "AdditiveAssociative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas",
            "sage.categories.additive_semigroups.AdditiveSemigroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of super modules.\n\n    An `R`-*super module* (where `R` is a ring) is an `R`-module `M` equipped\n    with a decomposition `M = M_0 \\oplus M_1` into two `R`-submodules\n    `M_0` and `M_1` (called the *even part* and the *odd part* of `M`,\n    respectively).\n\n    Thus, an `R`-super module automatically becomes a `\\ZZ / 2 \\ZZ`-graded\n    `R`-module, with `M_0` being the degree-`0` component and `M_1` being the\n    degree-`1` component.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Super()\n        Category of super modules over Integer Ring\n        sage: Modules(ZZ).Super().super_categories()\n        [Category of graded modules over Integer Ring]\n\n    The category of super modules defines the super structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Super().additional_structure()\n        Category of super modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Super()).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "is_even": {
                    "__doc__": "\n            Return if ``self`` is an even element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even()\n                False\n                sage: C.basis()[2,2].is_even()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_even_odd": {
                    "__doc__": "\n            Return ``0`` if ``self`` is an even element or ``1``\n            if an odd element.\n\n            .. NOTE::\n\n                The default implementation assumes that the even/odd is\n                determined by the parity of :meth:`degree`.\n\n                Overwrite this method if the even/odd behavior is desired\n                to be independent.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even_odd()\n                1\n                sage: C.basis()[2,2].is_even_odd()\n                0\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_odd": {
                    "__doc__": "\n            Return if ``self`` is an odd element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_odd()\n                True\n                sage: C.basis()[2,2].is_odd()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.graded_modules.GradedModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of super modules.\n\n    An `R`-*super module* (where `R` is a ring) is an `R`-module `M` equipped\n    with a decomposition `M = M_0 \\oplus M_1` into two `R`-submodules\n    `M_0` and `M_1` (called the *even part* and the *odd part* of `M`,\n    respectively).\n\n    Thus, an `R`-super module automatically becomes a `\\ZZ / 2 \\ZZ`-graded\n    `R`-module, with `M_0` being the degree-`0` component and `M_1` being the\n    degree-`1` component.\n\n    EXAMPLES::\n\n        sage: Modules(ZZ).Super()\n        Category of super modules over Integer Ring\n        sage: Modules(ZZ).Super().super_categories()\n        [Category of graded modules over Integer Ring]\n\n    The category of super modules defines the super structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Super().additional_structure()\n        Category of super modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Modules(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.super_modules.SuperModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "is_even": {
                    "__doc__": "\n            Return if ``self`` is an even element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even()\n                False\n                sage: C.basis()[2,2].is_even()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_even_odd": {
                    "__doc__": "\n            Return ``0`` if ``self`` is an even element or ``1``\n            if an odd element.\n\n            .. NOTE::\n\n                The default implementation assumes that the even/odd is\n                determined by the parity of :meth:`degree`.\n\n                Overwrite this method if the even/odd behavior is desired\n                to be independent.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_even_odd()\n                1\n                sage: C.basis()[2,2].is_even_odd()\n                0\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_odd": {
                    "__doc__": "\n            Return if ``self`` is an odd element.\n\n            EXAMPLES::\n\n                sage: cat = Algebras(QQ).WithBasis().Super()\n                sage: C = CombinatorialFreeModule(QQ, Partitions(), category=cat)\n                sage: C.degree_on_basis = sum\n                sage: C.basis()[2,2,1].is_odd()\n                True\n                sage: C.basis()[2,2].is_odd()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces.WithBasis",
            "sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts",
            "sage.categories.vector_spaces.VectorSpaces.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.WithBasis.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded modules.\n\n    We consider every graded module `M = \\bigoplus_i M_i` as a\n    filtered module under the (natural) filtration given by\n\n    .. MATH::\n\n        F_i = \\bigoplus_{j < i} M_j.\n\n    EXAMPLES::\n\n        sage: GradedModules(ZZ)\n        Category of graded modules over Integer Ring\n        sage: GradedModules(ZZ).super_categories()\n        [Category of filtered modules over Integer Ring]\n\n    The category of graded modules defines the graded structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Graded().additional_structure()\n        Category of graded modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(GradedModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded modules.\n\n    We consider every graded module `M = \\bigoplus_i M_i` as a\n    filtered module under the (natural) filtration given by\n\n    .. MATH::\n\n        F_i = \\bigoplus_{j < i} M_j.\n\n    EXAMPLES::\n\n        sage: GradedModules(ZZ)\n        Category of graded modules over Integer Ring\n        sage: GradedModules(ZZ).super_categories()\n        [Category of filtered modules over Integer Ring]\n\n    The category of graded modules defines the graded structure which\n    shall be preserved by morphisms::\n\n        sage: Modules(ZZ).Graded().additional_structure()\n        Category of graded modules over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(GradedModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_modules.GradedModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts",
            "sage.categories.vector_spaces.VectorSpaces.WithBasis",
            "sage.categories.vector_spaces.VectorSpaces.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.vector_spaces.VectorSpaces.WithBasis.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of sets `(S,+,*)` with an additive operation '+' and\n    a multiplicative operation `*`\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmas_and_additive_magmas import MagmasAndAdditiveMagmas\n        sage: C = MagmasAndAdditiveMagmas(); C\n        Category of magmas and additive magmas\n\n    This is the base category for the categories of rings and their variants::\n\n        sage: C.Distributive()\n        Category of distributive magmas and additive magmas\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse()\n        Category of rngs\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().Unital()\n        Category of semirings\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse().Unital()\n        Category of rings\n\n    This category is really meant to represent the intersection of the\n    categories of :class:`Magmas` and :class:`AdditiveMagmas`; however\n    Sage's infrastructure does not allow yet to model this::\n\n        sage: Magmas() & AdditiveMagmas()\n        Join of Category of magmas and Category of additive magmas\n\n        sage: Magmas() & AdditiveMagmas()        # todo: not implemented\n        Category of magmas and additive magmas\n\n    TESTS::\n\n        sage: TestSuite(MagmasAndAdditiveMagmas()).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    The category of sets `(S,+,*)` with an additive operation '+' and\n    a multiplicative operation `*`\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmas_and_additive_magmas import MagmasAndAdditiveMagmas\n        sage: C = MagmasAndAdditiveMagmas(); C\n        Category of magmas and additive magmas\n\n    This is the base category for the categories of rings and their variants::\n\n        sage: C.Distributive()\n        Category of distributive magmas and additive magmas\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse()\n        Category of rngs\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().Unital()\n        Category of semirings\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse().Unital()\n        Category of rings\n\n    This category is really meant to represent the intersection of the\n    categories of :class:`Magmas` and :class:`AdditiveMagmas`; however\n    Sage's infrastructure does not allow yet to model this::\n\n        sage: Magmas() & AdditiveMagmas()\n        Join of Category of magmas and Category of additive magmas\n\n        sage: Magmas() & AdditiveMagmas()        # todo: not implemented\n        Category of magmas and additive magmas\n\n    TESTS::\n\n        sage: TestSuite(MagmasAndAdditiveMagmas()).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of sets `(S,+,*)` with an additive operation '+' and\n    a multiplicative operation `*`\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmas_and_additive_magmas import MagmasAndAdditiveMagmas\n        sage: C = MagmasAndAdditiveMagmas(); C\n        Category of magmas and additive magmas\n\n    This is the base category for the categories of rings and their variants::\n\n        sage: C.Distributive()\n        Category of distributive magmas and additive magmas\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse()\n        Category of rngs\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().Unital()\n        Category of semirings\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse().Unital()\n        Category of rings\n\n    This category is really meant to represent the intersection of the\n    categories of :class:`Magmas` and :class:`AdditiveMagmas`; however\n    Sage's infrastructure does not allow yet to model this::\n\n        sage: Magmas() & AdditiveMagmas()\n        Join of Category of magmas and Category of additive magmas\n\n        sage: Magmas() & AdditiveMagmas()        # todo: not implemented\n        Category of magmas and additive magmas\n\n    TESTS::\n\n        sage: TestSuite(MagmasAndAdditiveMagmas()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.magmas_and_additive_magmas.MagmasAndAdditiveMagmas",
        "parent_class": {
            "__doc__": "\n    The category of sets `(S,+,*)` with an additive operation '+' and\n    a multiplicative operation `*`\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmas_and_additive_magmas import MagmasAndAdditiveMagmas\n        sage: C = MagmasAndAdditiveMagmas(); C\n        Category of magmas and additive magmas\n\n    This is the base category for the categories of rings and their variants::\n\n        sage: C.Distributive()\n        Category of distributive magmas and additive magmas\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse()\n        Category of rngs\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().Unital()\n        Category of semirings\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse().Unital()\n        Category of rings\n\n    This category is really meant to represent the intersection of the\n    categories of :class:`Magmas` and :class:`AdditiveMagmas`; however\n    Sage's infrastructure does not allow yet to model this::\n\n        sage: Magmas() & AdditiveMagmas()\n        Join of Category of magmas and Category of additive magmas\n\n        sage: Magmas() & AdditiveMagmas()        # todo: not implemented\n        Category of magmas and additive magmas\n\n    TESTS::\n\n        sage: TestSuite(MagmasAndAdditiveMagmas()).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of sets `(S,+,*)` with an additive operation '+' and\n    a multiplicative operation `*`\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmas_and_additive_magmas import MagmasAndAdditiveMagmas\n        sage: C = MagmasAndAdditiveMagmas(); C\n        Category of magmas and additive magmas\n\n    This is the base category for the categories of rings and their variants::\n\n        sage: C.Distributive()\n        Category of distributive magmas and additive magmas\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse()\n        Category of rngs\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().Unital()\n        Category of semirings\n        sage: C.Distributive().Associative().AdditiveAssociative().AdditiveCommutative().AdditiveUnital().AdditiveInverse().Unital()\n        Category of rings\n\n    This category is really meant to represent the intersection of the\n    categories of :class:`Magmas` and :class:`AdditiveMagmas`; however\n    Sage's infrastructure does not allow yet to model this::\n\n        sage: Magmas() & AdditiveMagmas()\n        Join of Category of magmas and Category of additive magmas\n\n        sage: Magmas() & AdditiveMagmas()        # todo: not implemented\n        Category of magmas and additive magmas\n\n    TESTS::\n\n        sage: TestSuite(MagmasAndAdditiveMagmas()).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite complex reflection groups.\n\n    See :class:`ComplexReflectionGroups` for the definition of complex\n    reflection group. In the finite case, most of the information\n    about the group can be recovered from its *degrees* and\n    *codegrees*, and to a lesser extent to the explicit realization as\n    subgroup of `GL(V)`. Hence the most important optional methods to\n    implement are:\n\n    - :meth:`ComplexReflectionGroups.Finite.ParentMethods.degrees`,\n    - :meth:`ComplexReflectionGroups.Finite.ParentMethods.codegrees`,\n    - :meth:`ComplexReflectionGroups.Finite.ElementMethods.to_matrix`.\n\n    Finite complex reflection groups are completely classified. In\n    particular, if the group is irreducible, then it's uniquely\n    determined by its degrees and codegrees and whether it's\n    reflection representation is *primitive* or not (see [LT2009]_\n    Chapter 2.1 for the definition of primitive).\n\n    .. SEEALSO:: :wikipedia:`Complex_reflection_groups`\n\n    EXAMPLES::\n\n        sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n        sage: ComplexReflectionGroups().Finite()\n        Category of finite complex reflection groups\n        sage: ComplexReflectionGroups().Finite().super_categories()\n        [Category of complex reflection groups,\n         Category of finite groups,\n         Category of finite finitely generated semigroups]\n\n    An example of a finite reflection group::\n\n        sage: W = ComplexReflectionGroups().Finite().example(); W       # optional - gap3\n        Reducible real reflection group of rank 4 and type A2 x B2\n\n        sage: W.reflections()                              # optional - gap3\n        Finite family {1: (1,8)(2,5)(9,12), 2: (1,5)(2,9)(8,12),\n                       3: (3,10)(4,7)(11,14), 4: (3,6)(4,11)(10,13),\n                       5: (1,9)(2,8)(5,12), 6: (4,14)(6,13)(7,11),\n                       7: (3,13)(6,10)(7,14)}\n\n    ``W`` is in the category of complex reflection groups::\n\n        sage: W in ComplexReflectionGroups().Finite()      # optional - gap3\n        True\n    ",
        "axioms": [
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Unital",
            "Finite",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "_matrix_": {
                    "__doc__": "\n            Return ``self`` as a matrix.\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,3))         # optional - gap3\n                sage: [matrix(t) for t in W]               # optional - gap3\n                [\n                [1 0]  [ 1  1]  [-1  0]  [-1 -1]  [ 0  1]  [ 0 -1]\n                [0 1], [ 0 -1], [ 1  1], [ 1  0], [-1 -1], [-1  0]\n                ]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "character_value": {
                    "__doc__": "\n            Return the value at ``self`` of the character of the\n            reflection representation given by :meth:`to_matrix`.\n\n            EXAMPLES::\n\n                sage: W = ColoredPermutations(1,3); W\n                1-colored permutations of size 3\n                sage: [t.character_value() for t in W]\n                [3, 1, 1, 0, 0, 1]\n\n            Note that this could be a different (faithful)\n            representation than that given by the corresponding root\n            system::\n\n                sage: W = ReflectionGroup((1,1,3)); W      # optional - gap3\n                Irreducible real reflection group of rank 2 and type A2\n                sage: [t.character_value() for t in W]     # optional - gap3\n                [2, 0, 0, -1, -1, 0]\n\n                sage: W = ColoredPermutations(2,2); W\n                2-colored permutations of size 2\n                sage: [t.character_value() for t in W]\n                [2, 0, 0, -2, 0, 0, 0, 0]\n\n                sage: W = ColoredPermutations(3,1); W\n                3-colored permutations of size 1\n                sage: [t.character_value() for t in W]\n                [1, zeta3, -zeta3 - 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "to_matrix": {
                    "__doc__": "\n            Return the matrix presentation of ``self`` acting on a\n            vector space `V`.\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,3))         # optional - gap3\n                sage: [t.to_matrix() for t in W]           # optional - gap3\n                [\n                [1 0]  [ 1  1]  [-1  0]  [-1 -1]  [ 0  1]  [ 0 -1]\n                [0 1], [ 0 -1], [ 1  1], [ 1  0], [-1 -1], [-1  0]\n                ]\n\n                sage: W = ColoredPermutations(1,3)\n                sage: [t.to_matrix() for t in W]\n                [\n                [1 0 0]  [1 0 0]  [0 1 0]  [0 0 1]  [0 1 0]  [0 0 1]\n                [0 1 0]  [0 0 1]  [1 0 0]  [1 0 0]  [0 0 1]  [0 1 0]\n                [0 0 1], [0 1 0], [0 0 1], [0 1 0], [1 0 0], [1 0 0]\n                ]\n\n            A different representation is given by the\n            colored permutations::\n\n                sage: W = ColoredPermutations(3, 1)\n                sage: [t.to_matrix() for t in W]\n                [[1], [zeta3], [-zeta3 - 1]]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.complex_reflection_groups.ComplexReflectionGroups",
            "sage.categories.finite_groups.FiniteGroups",
            "sage.categories.finitely_generated_semigroups.FinitelyGeneratedSemigroups.Finite"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite complex reflection groups.\n\n    See :class:`ComplexReflectionGroups` for the definition of complex\n    reflection group. In the finite case, most of the information\n    about the group can be recovered from its *degrees* and\n    *codegrees*, and to a lesser extent to the explicit realization as\n    subgroup of `GL(V)`. Hence the most important optional methods to\n    implement are:\n\n    - :meth:`ComplexReflectionGroups.Finite.ParentMethods.degrees`,\n    - :meth:`ComplexReflectionGroups.Finite.ParentMethods.codegrees`,\n    - :meth:`ComplexReflectionGroups.Finite.ElementMethods.to_matrix`.\n\n    Finite complex reflection groups are completely classified. In\n    particular, if the group is irreducible, then it's uniquely\n    determined by its degrees and codegrees and whether it's\n    reflection representation is *primitive* or not (see [LT2009]_\n    Chapter 2.1 for the definition of primitive).\n\n    .. SEEALSO:: :wikipedia:`Complex_reflection_groups`\n\n    EXAMPLES::\n\n        sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n        sage: ComplexReflectionGroups().Finite()\n        Category of finite complex reflection groups\n        sage: ComplexReflectionGroups().Finite().super_categories()\n        [Category of complex reflection groups,\n         Category of finite groups,\n         Category of finite finitely generated semigroups]\n\n    An example of a finite reflection group::\n\n        sage: W = ComplexReflectionGroups().Finite().example(); W       # optional - gap3\n        Reducible real reflection group of rank 4 and type A2 x B2\n\n        sage: W.reflections()                              # optional - gap3\n        Finite family {1: (1,8)(2,5)(9,12), 2: (1,5)(2,9)(8,12),\n                       3: (3,10)(4,7)(11,14), 4: (3,6)(4,11)(10,13),\n                       5: (1,9)(2,8)(5,12), 6: (4,14)(6,13)(7,11),\n                       7: (3,13)(6,10)(7,14)}\n\n    ``W`` is in the category of complex reflection groups::\n\n        sage: W in ComplexReflectionGroups().Finite()      # optional - gap3\n        True\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_complex_reflection_groups.FiniteComplexReflectionGroups",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_test_codegrees": {
                    "__doc__": "\n            Test the method :meth:`degrees`.\n\n            INPUT:\n\n            - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n            EXAMPLES:\n\n                sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n                sage: W = ComplexReflectionGroups().Finite().example(); W   # optional - gap3\n                Reducible real reflection group of rank 4 and type A2 x B2\n                sage: W._test_codegrees()                  # optional - gap3\n\n                sage: W = SymmetricGroup(5)\n                sage: W._test_codegrees()\n\n            We now break the implementation of W.degrees and check that this is caught::\n\n                sage: W.codegrees = lambda: (1/1,5)\n                sage: W._test_codegrees()\n                Traceback (most recent call last):\n                ...\n                AssertionError: the codegrees should be integers\n\n                sage: W.codegrees = lambda: (2,1,-1)\n                sage: W._test_codegrees()\n                Traceback (most recent call last):\n                ...\n                AssertionError: the codegrees should be nonnegative\n\n            We restore W to its normal state::\n\n                sage: del W.codegrees\n                sage: W._test_codegrees()\n\n            See the documentation for :class:`TestSuite` for more information.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "_test_degrees": {
                    "__doc__": "\n            Test the method :meth:`degrees`.\n\n            INPUT:\n\n            - ``options`` -- any keyword arguments accepted by :meth:`_tester`\n\n            EXAMPLES:\n\n                sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n                sage: W = ComplexReflectionGroups().Finite().example(); W   # optional - gap3\n                Reducible real reflection group of rank 4 and type A2 x B2\n                sage: W._test_degrees()                    # optional - gap3\n\n                sage: W = SymmetricGroup(5)\n                sage: W._test_degrees()\n\n            We now break the implementation of W.degrees and check that this is caught::\n\n                sage: W.degrees = lambda: (1/1,5)\n                sage: W._test_degrees()\n                Traceback (most recent call last):\n                ...\n                AssertionError: the degrees should be integers\n\n                sage: W.degrees = lambda: (1,2,3)\n                sage: W._test_degrees()\n                Traceback (most recent call last):\n                ...\n                AssertionError: the degrees should be larger than 2\n\n            We restore W to its normal state::\n\n                sage: del W.degrees\n                sage: W._test_degrees()\n\n            See the documentation for :class:`TestSuite` for more information.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                },
                "codegrees": {
                    "__doc__": "\n            Return the codegrees of ``self``.\n\n            OUTPUT: a tuple of Sage integers\n\n            EXAMPLES::\n\n                sage: W = ColoredPermutations(1,4)\n                sage: W.codegrees()\n                (2, 1, 0)\n\n                sage: W = ColoredPermutations(3,3)\n                sage: W.codegrees()\n                (6, 3, 0)\n\n                sage: W = ReflectionGroup(31)              # optional - gap3\n                sage: W.codegrees()                        # optional - gap3\n                (28, 16, 12, 0)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "degrees": {
                    "__doc__": "\n            Return the degrees of ``self``.\n\n            OUTPUT: a tuple of Sage integers\n\n            EXAMPLES::\n\n                sage: W = ColoredPermutations(1,4)\n                sage: W.degrees()\n                (2, 3, 4)\n\n                sage: W = ColoredPermutations(3,3)\n                sage: W.degrees()\n                (3, 6, 9)\n\n                sage: W = ReflectionGroup(31)              # optional - gap3\n                sage: W.degrees()                          # optional - gap3\n                (8, 12, 20, 24)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_real": {
                    "__doc__": "\n            Return whether ``self`` is real.\n\n            A complex reflection group is *real* if it is isomorphic\n            to a reflection group in `GL(V)` over a real vector space `V`.\n            Equivalently its character table has real entries.\n\n            This implementation uses the following statement: an\n            irreducible complex reflection group is real if and only\n            if `2` is a degree of ``self`` with multiplicity one.\n            Hence, in general we just need to compare the number of\n            occurences of `2` as degree of ``self`` and the number of\n            irreducible components.\n\n            EXAMPLES::\n\n                sage: W = ColoredPermutations(1,3)\n                sage: W.is_real()\n                True\n\n                sage: W = ColoredPermutations(4,3)\n                sage: W.is_real()\n                False\n\n            .. TODO::\n\n                 Add an example of non real finite complex reflection\n                 group that is generated by order 2 reflections.\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_well_generated": {
                    "__doc__": "\n            Return whether ``self`` is well-generated.\n\n            A finite complex reflection group is *well generated* if\n            the number of its simple reflections coincides with its rank.\n\n            .. SEEALSO:: :meth:`ComplexReflectionGroups.Finite.WellGenerated`\n\n            .. NOTE::\n\n                - All finite real reflection groups are well generated.\n                - The complex reflection groups of type `G(r,1,n)` and\n                  of type `G(r,r,n)` are well generated.\n                - The complex reflection groups of type `G(r,p,n)`\n                  with `1 < p < r` are *not* well generated.\n\n                - The direct product of two well generated finite\n                  complex reflection group is still well generated.\n\n            EXAMPLES::\n\n                sage: W = ColoredPermutations(1,3)\n                sage: W.is_well_generated()\n                True\n\n                sage: W = ColoredPermutations(4,3)\n                sage: W.is_well_generated()\n                True\n\n                sage: W = ReflectionGroup((4,2,3))         # optional - gap3\n                sage: W.is_well_generated()                # optional - gap3\n                False\n\n                sage: W = ReflectionGroup((4,4,3))         # optional - gap3\n                sage: W.is_well_generated()                # optional - gap3\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "number_of_reflection_hyperplanes": {
                    "__doc__": "\n            Return the number of reflection hyperplanes of ``self``.\n\n            This is also the number of distinguished reflections.  For\n            real groups, this coincides with the number of\n            reflections.\n\n            This implementation uses that it is given by the sum of\n            the codegrees of ``self`` plus its rank.\n\n            .. SEEALSO:: :meth:`number_of_reflections`\n\n            EXAMPLES::\n\n                sage: W = ColoredPermutations(1,3)\n                sage: W.number_of_reflection_hyperplanes()\n                3\n                sage: W = ColoredPermutations(2,3)\n                sage: W.number_of_reflection_hyperplanes()\n                9\n                sage: W = ColoredPermutations(4,3)\n                sage: W.number_of_reflection_hyperplanes()\n                15\n                sage: W = ReflectionGroup((4,2,3))          # optional - gap3\n                sage: W.number_of_reflection_hyperplanes()  # optional - gap3\n                15\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "number_of_reflections": {
                    "__doc__": "\n            Return the number of reflections of ``self``.\n\n            For real groups, this coincides with the number of\n            reflection hyperplanes.\n\n            This implementation uses that it is given by the sum of\n            the degrees of ``self`` minus its rank.\n\n            .. SEEALSO:: :meth:`number_of_reflection_hyperplanes`\n\n            EXAMPLES::\n\n                sage: [SymmetricGroup(i).number_of_reflections() for i in range(int(8))]\n                [0, 0, 1, 3, 6, 10, 15, 21]\n\n                sage: W = ColoredPermutations(1,3)\n                sage: W.number_of_reflections()\n                3\n                sage: W = ColoredPermutations(2,3)\n                sage: W.number_of_reflections()\n                9\n                sage: W = ColoredPermutations(4,3)\n                sage: W.number_of_reflections()\n                21\n                sage: W = ReflectionGroup((4,2,3))         # optional - gap3\n                sage: W.number_of_reflections()            # optional - gap3\n                15\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "_matrix_": {
                    "__doc__": "\n            Return ``self`` as a matrix.\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,3))         # optional - gap3\n                sage: [matrix(t) for t in W]               # optional - gap3\n                [\n                [1 0]  [ 1  1]  [-1  0]  [-1 -1]  [ 0  1]  [ 0 -1]\n                [0 1], [ 0 -1], [ 1  1], [ 1  0], [-1 -1], [-1  0]\n                ]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "character_value": {
                    "__doc__": "\n            Return the value at ``self`` of the character of the\n            reflection representation given by :meth:`to_matrix`.\n\n            EXAMPLES::\n\n                sage: W = ColoredPermutations(1,3); W\n                1-colored permutations of size 3\n                sage: [t.character_value() for t in W]\n                [3, 1, 1, 0, 0, 1]\n\n            Note that this could be a different (faithful)\n            representation than that given by the corresponding root\n            system::\n\n                sage: W = ReflectionGroup((1,1,3)); W      # optional - gap3\n                Irreducible real reflection group of rank 2 and type A2\n                sage: [t.character_value() for t in W]     # optional - gap3\n                [2, 0, 0, -1, -1, 0]\n\n                sage: W = ColoredPermutations(2,2); W\n                2-colored permutations of size 2\n                sage: [t.character_value() for t in W]\n                [2, 0, 0, -2, 0, 0, 0, 0]\n\n                sage: W = ColoredPermutations(3,1); W\n                3-colored permutations of size 1\n                sage: [t.character_value() for t in W]\n                [1, zeta3, -zeta3 - 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "to_matrix": {
                    "__doc__": "\n            Return the matrix presentation of ``self`` acting on a\n            vector space `V`.\n\n            EXAMPLES::\n\n                sage: W = ReflectionGroup((1,1,3))         # optional - gap3\n                sage: [t.to_matrix() for t in W]           # optional - gap3\n                [\n                [1 0]  [ 1  1]  [-1  0]  [-1 -1]  [ 0  1]  [ 0 -1]\n                [0 1], [ 0 -1], [ 1  1], [ 1  0], [-1 -1], [-1  0]\n                ]\n\n                sage: W = ColoredPermutations(1,3)\n                sage: [t.to_matrix() for t in W]\n                [\n                [1 0 0]  [1 0 0]  [0 1 0]  [0 0 1]  [0 1 0]  [0 0 1]\n                [0 1 0]  [0 0 1]  [1 0 0]  [1 0 0]  [0 0 1]  [0 1 0]\n                [0 0 1], [0 1 0], [0 0 1], [0 1 0], [1 0 0], [1 0 0]\n                ]\n\n            A different representation is given by the\n            colored permutations::\n\n                sage: W = ColoredPermutations(3, 1)\n                sage: [t.to_matrix() for t in W]\n                [[1], [zeta3], [-zeta3 - 1]]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "Connected",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.filtered_modules.FilteredModules.Connected",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
        "axioms": [],
        "element_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.homsets.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.homsets.HomsetsOf",
        "parent_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.homsets.Homsets",
            "sage.categories.homsets.HomsetsOf",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n    Default class for homsets of a category.\n\n    This is used when a category `C` defines some additional structure\n    but not a homset category of its own. Indeed, unlike for covariant\n    functorial constructions, we cannot represent the homset category\n    of `C` by just the join of the homset categories of its super\n    categories.\n\n    EXAMPLES::\n\n        sage: C = (Magmas() & Posets()).Homsets(); C\n        Category of homsets of magmas and posets\n        sage: type(C)\n        <class 'sage.categories.homsets.HomsetsOf_with_category'>\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C = Rings().Homsets()\n        sage: TestSuite(C).run(skip=['_test_category_graph'])\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "mmt.Modules.GAP"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.WithBasis.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.modules.Modules.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of modules with basis constructed by Cartesian products\n        of modules with basis.\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite dimensional modules with a distinguished basis\n\n    EXAMPLES::\n\n      sage: C = FiniteDimensionalModulesWithBasis(ZZ); C\n      Category of finite dimensional modules with basis over Integer Ring\n      sage: sorted(C.super_categories(), key=str)\n      [Category of finite dimensional modules over Integer Ring,\n       Category of modules with basis over Integer Ring]\n      sage: C is Modules(ZZ).WithBasis().FiniteDimensional()\n      True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "FiniteDimensional"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "dense_coefficient_list": {
                    "__doc__": "\n            Return a list of *all* coefficients of ``self``.\n\n            By default, this list is ordered in the same way as the\n            indexing set of the basis of the parent of ``self``.\n\n            INPUT:\n\n            - ``order`` -- (optional) an ordering of the basis indexing set\n\n            EXAMPLES::\n\n                sage: v = vector([0, -1, -3])\n                sage: v.dense_coefficient_list()\n                [0, -1, -3]\n                sage: v.dense_coefficient_list([2,1,0])\n                [-3, -1, 0]\n                sage: sorted(v.coefficients())\n                [-3, -1]\n            ",
                    "args": [
                        "self",
                        "order"
                    ],
                    "argspec": [
                        [
                            "self",
                            "order"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "gap": "IsFiniteDimensional",
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.modules.Modules.FiniteDimensional"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {
                "image": {
                    "__doc__": "\n            Return the image of ``self`` as a submodule of the codomain.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: f.image()\n                Free module generated by {0, 1, 2} over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "image_basis": {
                    "__doc__": "\n            Return a basis for the image of ``self`` in echelon form.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: f.image_basis()\n                ([1, 2, 3], [2, 3, 1], [3, 1, 2])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "kernel": {
                    "__doc__": "\n            Return the kernel of ``self`` as a submodule of the domain.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: K = f.kernel()\n                sage: K\n                Free module generated by {0, 1, 2} over Rational Field\n                sage: K.ambient()\n                Symmetric group algebra of order 3 over Rational Field\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "kernel_basis": {
                    "__doc__": "\n            Return a basis of the kernel of ``self`` in echelon form.\n\n            EXAMPLES::\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: f = SGA.module_morphism(lambda x: SGA(x**2), codomain=SGA)\n                sage: f.kernel_basis()\n                ([1, 2, 3] - [3, 2, 1], [1, 3, 2] - [3, 2, 1], [2, 1, 3] - [3, 2, 1])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "matrix": {
                    "__doc__": "\n            Return the matrix of this morphism in the distinguished\n            bases of the domain and codomain.\n\n            INPUT:\n\n            - ``base_ring`` -- a ring (default: ``None``, meaning the\n              base ring of the codomain)\n\n            - ``side`` -- \"left\" or \"right\" (default: \"left\")\n\n            If ``side`` is \"left\", this morphism is considered as\n            acting on the left; i.e. each column of the matrix\n            represents the image of an element of the basis of the\n            domain.\n\n            The order of the rows and columns matches with the order\n            in which the bases are enumerated.\n\n            .. SEEALSO:: :func:`Modules.WithBasis.ParentMethods.module_morphism`\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(ZZ, [1,2]); x = X.basis()\n                sage: Y = CombinatorialFreeModule(ZZ, [3,4]); y = Y.basis()\n                sage: phi = X.module_morphism(on_basis = {1: y[3] + 3*y[4], 2: 2*y[3] + 5*y[4]}.__getitem__,\n                ...                           codomain = Y)\n                sage: phi.matrix()\n                [1 2]\n                [3 5]\n                sage: phi.matrix(side=\"right\")\n                [1 3]\n                [2 5]\n\n                sage: phi.matrix().parent()\n                Full MatrixSpace of 2 by 2 dense matrices over Integer Ring\n                sage: phi.matrix(QQ).parent()\n                Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n\n            The resulting matrix is immutable::\n\n                sage: phi.matrix().is_mutable()\n                False\n\n            The zero morphism has a zero matrix::\n\n                sage: Hom(X,Y).zero().matrix()\n                [0 0]\n                [0 0]\n\n            .. TODO::\n\n                Add support for morphisms where the codomain has a\n                different base ring than the domain::\n\n                    sage: Y = CombinatorialFreeModule(QQ, [3,4]); y = Y.basis()\n                    sage: phi = X.module_morphism(on_basis = {1: y[3] + 3*y[4], 2: 2*y[3] + 5/2*y[4]}.__getitem__,\n                    ...                           codomain = Y)\n                    sage: phi.matrix().parent()          # todo: not implemented\n                    Full MatrixSpace of 2 by 2 dense matrices over Rational Field\n\n                This currently does not work because, in this case,\n                the morphism is just in the category of commutative\n                additive groups (i.e. the intersection of the\n                categories of modules over `\\ZZ` and over `\\QQ`)::\n\n                    sage: phi.parent().homset_category()\n                    Category of commutative additive semigroups\n                    sage: phi.parent().homset_category() # todo: not implemented\n                    Category of finite dimensional modules with basis over Integer Ring\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "left"
                        ]
                    ]
                }
            }
        },
        "name": "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "annihilator": {
                    "__doc__": "\n            Return the annihilator of a finite set.\n\n            INPUT:\n\n            - ``S`` -- a finite set\n\n            - ``action`` -- a function (default: :obj:`operator.mul`)\n\n            - ``side`` -- 'left' or 'right' (default: 'right')\n\n            - ``category`` -- a category\n\n            Assumptions:\n\n            - ``action`` takes elements of ``self`` as first argument\n              and elements of ``S`` as second argument;\n\n            - The codomain is any vector space, and ``action`` is\n              linear on its first argument; typically it is bilinear;\n\n            - If ``side`` is 'left', this is reversed.\n\n            OUTPUT:\n\n            The subspace of the elements `x` of ``self`` such that\n            ``action(x,s) = 0`` for all `s\\in S`. If ``side`` is\n            'left' replace the above equation by ``action(s,x) = 0``.\n\n            If ``self`` is a ring, ``action`` an action of ``self`` on\n            a module `M` and `S` is a subset of `M`, we recover the\n            :Wikipedia:`Annihilator_%28ring_theory%29`. Similarly this\n            can be used to compute torsion or orthogonals.\n\n            .. SEEALSO:: :meth:`annihilator_basis` for lots of examples.\n\n            EXAMPLES::\n\n                sage: F = FiniteDimensionalAlgebrasWithBasis(QQ).example(); F\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: x,y,a,b = F.basis()\n                sage: A = F.annihilator([a + 3*b + 2*y]); A\n                Free module generated by {0} over Rational Field\n                sage: [b.lift() for b in A.basis()]\n                [-1/2*a - 3/2*b + x]\n\n            The category can be used to specify other properties of\n            this subspace, like that this is a subalgebra::\n\n                sage: center = F.annihilator(F.basis(), F.bracket,\n                ....:                        category=Algebras(QQ).Subobjects())\n                sage: (e,) = center.basis()\n                sage: e.lift()\n                x + y\n                sage: e * e == e\n                True\n\n            Taking annihilator is order reversing for inclusion::\n\n                sage: A   = F.annihilator([]);    A  .rename(\"A\")\n                sage: Ax  = F.annihilator([x]);   Ax .rename(\"Ax\")\n                sage: Ay  = F.annihilator([y]);   Ay .rename(\"Ay\")\n                sage: Axy = F.annihilator([x,y]); Axy.rename(\"Axy\")\n                sage: P = Poset(([A, Ax, Ay, Axy], attrcall(\"is_submodule\")))\n                sage: sorted(P.cover_relations(), key=str)\n                [[Ax, A], [Axy, Ax], [Axy, Ay], [Ay, A]]\n            ",
                    "args": [
                        "self",
                        "S",
                        "action",
                        "side",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S",
                            "action",
                            "side",
                            "category"
                        ],
                        null,
                        null,
                        [
                            "<built-in function mul>",
                            "right",
                            null
                        ]
                    ]
                },
                "annihilator_basis": {
                    "__doc__": "\n            Return a basis of the annihilator of a finite set of elements.\n\n            INPUT:\n\n            - ``S`` -- a finite set of objects\n\n            - ``action`` -- a function (default: :obj:`operator.mul`)\n\n            - ``side`` -- 'left' or 'right' (default: 'right'):\n              on which side of ``self`` the elements of `S` acts.\n\n            See :meth:`annihilator` for the assumptions and definition\n            of the annihilator.\n\n            EXAMPLES:\n\n            By default, the action is the standard `*` operation. So\n            our first example is about an algebra::\n\n                sage: F = FiniteDimensionalAlgebrasWithBasis(QQ).example(); F\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: x,y,a,b = F.basis()\n\n            In this algebra, multiplication on the right by `x`\n            annihilates all basis elements but `x`::\n\n                sage: x*x, y*x, a*x, b*x\n                (x, 0, 0, 0)\n\n            So the annihilator is the subspace spanned by `y`, `a`, and `b`::\n\n                sage: F.annihilator_basis([x])\n                (y, a, b)\n\n            The same holds for `a` and `b`::\n\n                sage: x*a, y*a, a*a, b*a\n                (a, 0, 0, 0)\n                sage: F.annihilator_basis([a])\n                (y, a, b)\n\n            On the other hand, `y` annihilates only `x`::\n\n                sage: F.annihilator_basis([y])\n                (x,)\n\n            Here is a non trivial annihilator::\n\n                sage: F.annihilator_basis([a + 3*b + 2*y])\n                (-1/2*a - 3/2*b + x,)\n\n            Let's check it::\n\n                sage: (-1/2*a - 3/2*b + x) * (a + 3*b + 2*y)\n                0\n\n            Doing the same calculations on the left exchanges the\n            roles of `x` and `y`::\n\n                sage: F.annihilator_basis([y], side=\"left\")\n                (x, a, b)\n                sage: F.annihilator_basis([a], side=\"left\")\n                (x, a, b)\n                sage: F.annihilator_basis([b], side=\"left\")\n                (x, a, b)\n                sage: F.annihilator_basis([x], side=\"left\")\n                (y,)\n                sage: F.annihilator_basis([a+3*b+2*x], side=\"left\")\n                (-1/2*a - 3/2*b + y,)\n\n            By specifying an inner product, this method can be used to\n            compute the orthogonal of a subspace::\n\n                sage: x,y,a,b = F.basis()\n                sage: def scalar(u,v): return vector([sum(u[i]*v[i] for i in F.basis().keys())])\n                sage: F.annihilator_basis([x+y, a+b], scalar)\n                (x - y, a - b)\n\n            By specifying the standard Lie bracket as action, one can\n            compute the commutator of a subspace of `F`::\n\n                sage: F.annihilator_basis([a+b], action=F.bracket)\n                (x + y, a, b)\n\n            In particular one can compute a basis of the center of the\n            algebra. In our example, it is reduced to the identity::\n\n                sage: F.annihilator_basis(F.algebra_generators(), action=F.bracket)\n                (x + y,)\n\n            But see also\n            :meth:`FiniteDimensionalAlgebrasWithBasis.ParentMethods.center_basis`.\n            ",
                    "args": [
                        "self",
                        "S",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "S",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "<built-in function mul>",
                            "right"
                        ]
                    ]
                },
                "dimension": {
                    "__doc__": null,
                    "__imfunc__": "<abstract method dimension at 0x7fe375ebb758>",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ],
                    "codomain": "sage",
                    "gap_name": "Dimension",
                    "mmt_name": null
                },
                "quotient_module": {
                    "__doc__": "\n            Construct the quotient module ``self``/``submodule``.\n\n            INPUT:\n\n            - ``submodule`` -- a submodule with basis of ``self``, or\n              something that can be turned into one via\n              ``self.submodule(submodule)``.\n\n            - ``check``, ``already_echelonized`` -- passed down to\n              :meth:`ModulesWithBasis.ParentMethods.submodule`.\n\n            .. WARNING::\n\n                At this point, this only supports quotients by free\n                submodules admitting a basis in unitriangular echelon\n                form. In this case, the quotient is also a free\n                module, with a basis consisting of the retract of a\n                subset of the basis of ``self``.\n\n            EXAMPLES::\n\n                sage: X = CombinatorialFreeModule(QQ, range(3), prefix=\"x\")\n                sage: x = X.basis()\n                sage: Y = X.quotient_module([x[0]-x[1], x[1]-x[2]], already_echelonized=True)\n                sage: Y.print_options(prefix='y'); Y\n                Free module generated by {2} over Rational Field\n                sage: y = Y.basis()\n                sage: y[2]\n                y[2]\n                sage: y[2].lift()\n                x[2]\n                sage: Y.retract(x[0]+2*x[1])\n                3*y[2]\n\n                sage: R.<a,b> = QQ[]\n                sage: C = CombinatorialFreeModule(R, range(3), prefix='x')\n                sage: x = C.basis()\n                sage: gens = [x[0] - x[1], 2*x[1] - 2*x[2], x[0] - x[2]]\n                sage: Y = X.quotient_module(gens)\n\n            .. SEEALSO::\n\n                 - :meth:`Modules.WithBasis.ParentMethods.submodule`\n                 - :meth:`Rings.ParentMethods.quotient`\n                 - :class:`sage.modules.with_basis.subquotient.QuotientModuleWithBasis`\n            ",
                    "args": [
                        "self",
                        "submodule",
                        "check",
                        "already_echelonized",
                        "category"
                    ],
                    "argspec": [
                        [
                            "self",
                            "submodule",
                            "check",
                            "already_echelonized",
                            "category"
                        ],
                        null,
                        null,
                        [
                            true,
                            false,
                            null
                        ]
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "dense_coefficient_list": {
                    "__doc__": "\n            Return a list of *all* coefficients of ``self``.\n\n            By default, this list is ordered in the same way as the\n            indexing set of the basis of the parent of ``self``.\n\n            INPUT:\n\n            - ``order`` -- (optional) an ordering of the basis indexing set\n\n            EXAMPLES::\n\n                sage: v = vector([0, -1, -3])\n                sage: v.dense_coefficient_list()\n                [0, -1, -3]\n                sage: v.dense_coefficient_list([2,1,0])\n                [-3, -1, 0]\n                sage: sorted(v.coefficients())\n                [-3, -1]\n            ",
                    "args": [
                        "self",
                        "order"
                    ],
                    "argspec": [
                        [
                            "self",
                            "order"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.Homsets",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "__call_on_basis__": {
                    "__doc__": "\n                Construct a morphism in this homset from a function defined\n                on the basis.\n\n                INPUT:\n\n                - ``on_basis`` -- a function from the indices of the\n                  basis of the domain of ``self`` to the codomain of\n                  ``self``\n\n                This method simply delegates the work to\n                :meth:`ModulesWithBasis.ParentMethods.module_morphism`. It\n                is used by :meth:`Homset.__call__` to handle the\n                ``on_basis`` argument, and will disapear as soon as\n                the logic will be generalized.\n\n                EXAMPLES::\n\n                    sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                    sage: H = Hom(X, Y)\n                    sage: x = X.basis()\n\n                    sage: phi = H(on_basis = lambda i: Y.monomial(i) + 2*Y.monomial(i+1)) # indirect doctest\n                    sage: phi\n                    Generic morphism:\n                    From: X\n                    To:   Y\n                    sage: phi(x[1] + x[3])\n                    B[1] + 2*B[2] + B[3] + 2*B[4]\n\n                Diagonal functions can be constructed using the ``diagonal`` option::\n\n                    sage: X = CombinatorialFreeModule(QQ, [1,2,3,4]); X.rename(\"X\")\n                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4], key=\"Y\"); Y.rename(\"Y\")\n                    sage: H = Hom(X, Y)\n                    sage: x = X.basis()\n                    sage: phi = H(diagonal = lambda x: x^2)\n                    sage: phi(x[1] + x[2] + x[3])\n                    B[1] + 4*B[2] + 9*B[3]\n\n                TESTS::\n\n                As for usual homsets, the argument can be a Python function::\n\n                    sage: phi = H(lambda x: Y.zero())\n                    sage: phi\n                    Generic morphism:\n                      From: X\n                      To:   Y\n                    sage: phi(x[1] + x[3])\n                    0\n\n               We check that the homset category is properly set up::\n\n                    sage: X = CombinatorialFreeModule(QQ, [1,2,3]);   X.rename(\"X\")\n                    sage: Y = CombinatorialFreeModule(QQ, [1,2,3,4]); Y.rename(\"Y\")\n                    sage: H = Hom(X, Y)\n                    sage: H.zero().category_for()\n                    Category of finite dimensional vector spaces with basis over Rational Field\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        "options",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.homsets.Homsets",
            "sage.categories.homsets.HomsetsOf",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.modules_with_basis.ModulesWithBasis.Homsets",
            "sage.categories.sets_cat.Sets",
            "sage.categories.modules.Modules.Homsets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of associative algebras over a given base ring.\n\n    An associative algebra over a ring `R` is a module over `R` which\n    is also a not necessarily unital ring.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`AssociativeAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.associative_algebras import AssociativeAlgebras\n        sage: C = AssociativeAlgebras(ZZ); C\n        Category of associative algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Associative()\n        True\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        An abstract class for elements of an associative algebra.\n\n        .. NOTE::\n\n            ``Magmas.Element.__mul__`` is preferable to\n            ``Modules.Element.__mul__`` since the later does not\n            handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.rngs.Rngs",
            "sage.categories.magmatic_algebras.MagmaticAlgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of associative algebras over a given base ring.\n\n    An associative algebra over a ring `R` is a module over `R` which\n    is also a not necessarily unital ring.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`AssociativeAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.associative_algebras import AssociativeAlgebras\n        sage: C = AssociativeAlgebras(ZZ); C\n        Category of associative algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Associative()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.associative_algebras.AssociativeAlgebras",
        "parent_class": {
            "__doc__": "\n    The category of associative algebras over a given base ring.\n\n    An associative algebra over a ring `R` is a module over `R` which\n    is also a not necessarily unital ring.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`AssociativeAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.associative_algebras import AssociativeAlgebras\n        sage: C = AssociativeAlgebras(ZZ); C\n        Category of associative algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Associative()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n        An abstract class for elements of an associative algebra.\n\n        .. NOTE::\n\n            ``Magmas.Element.__mul__`` is preferable to\n            ``Modules.Element.__mul__`` since the later does not\n            handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded modules with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "degree_negation": {
                    "__doc__": "\n            Return the image of ``self`` under the degree negation\n            automorphism of the graded module to which ``self`` belongs.\n\n            The degree negation is the module automorphism which scales\n            every homogeneous element of degree `k` by `(-1)^k` (for all\n            `k`). This assumes that the module to which ``self`` belongs\n            (that is, the module ``self.parent()``) is `\\ZZ`-graded.\n\n            EXAMPLES::\n\n                sage: E.<a,b> = ExteriorAlgebra(QQ)\n                sage: ((1 + a) * (1 + b)).degree_negation()\n                a^b - a - b + 1\n                sage: E.zero().degree_negation()\n                0\n\n                sage: P = GradedModulesWithBasis(ZZ).example(); P\n                An example of a graded module with basis: the free module on partitions over Integer Ring\n                sage: pbp = lambda x: P.basis()[Partition(list(x))]\n                sage: p = pbp([3,1]) - 2 * pbp([2]) + 4 * pbp([1])\n                sage: p.degree_negation()\n                -4*P[1] - 2*P[2] + P[3, 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis",
            "sage.categories.graded_modules.GradedModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded modules with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_modules_with_basis.GradedModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "degree_negation": {
                    "__doc__": "\n            Return the image of ``element`` under the degree negation\n            automorphism of the graded module ``self``.\n\n            The degree negation is the module automorphism which scales\n            every homogeneous element of degree `k` by `(-1)^k` (for all\n            `k`). This assumes that the module ``self`` is `\\ZZ`-graded.\n\n            INPUT:\n\n            - ``element`` -- element of the module ``self``\n\n            EXAMPLES::\n\n                sage: E.<a,b> = ExteriorAlgebra(QQ)\n                sage: E.degree_negation((1 + a) * (1 + b))\n                a^b - a - b + 1\n                sage: E.degree_negation(E.zero())\n                0\n\n                sage: P = GradedModulesWithBasis(ZZ).example(); P\n                An example of a graded module with basis: the free module on partitions over Integer Ring\n                sage: pbp = lambda x: P.basis()[Partition(list(x))]\n                sage: p = pbp([3,1]) - 2 * pbp([2]) + 4 * pbp([1])\n                sage: P.degree_negation(p)\n                -4*P[1] - 2*P[2] + P[3, 1]\n            ",
                    "args": [
                        "self",
                        "element"
                    ],
                    "argspec": [
                        [
                            "self",
                            "element"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "degree_negation": {
                    "__doc__": "\n            Return the image of ``self`` under the degree negation\n            automorphism of the graded module to which ``self`` belongs.\n\n            The degree negation is the module automorphism which scales\n            every homogeneous element of degree `k` by `(-1)^k` (for all\n            `k`). This assumes that the module to which ``self`` belongs\n            (that is, the module ``self.parent()``) is `\\ZZ`-graded.\n\n            EXAMPLES::\n\n                sage: E.<a,b> = ExteriorAlgebra(QQ)\n                sage: ((1 + a) * (1 + b)).degree_negation()\n                a^b - a - b + 1\n                sage: E.zero().degree_negation()\n                0\n\n                sage: P = GradedModulesWithBasis(ZZ).example(); P\n                An example of a graded module with basis: the free module on partitions over Integer Ring\n                sage: pbp = lambda x: P.basis()[Partition(list(x))]\n                sage: p = pbp([3,1]) - 2 * pbp([2]) + 4 * pbp([1])\n                sage: p.degree_negation()\n                -4*P[1] - 2*P[2] + P[3, 1]\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered modules with a distinguished basis.\n\n    A *filtered module with basis* over a ring `R` means\n    (for the purpose of this code) a filtered `R`-module `M`\n    with filtration `(F_i)_{i \\in I}` (typically `I = \\NN`)\n    endowed with a basis `(b_j)_{j \\in J}` of `M` and a partition\n    `J = \\bigsqcup_{i \\in I} J_i` of the set `J` (it is allowed\n    that some `J_i` are empty) such that for every `n \\in I`,\n    the subfamily `(b_j)_{j \\in U_n}`, where\n    `U_n = \\bigcup_{i \\leq n} J_i`, is a basis of the\n    `R`-submodule `F_n`.\n\n    For every `i \\in I`, the `R`-submodule of `M` spanned by\n    `(b_j)_{j \\in J_i}` is called the `i`-*th graded component*\n    (aka the `i`-*th homogeneous component*) of the filtered\n    module with basis `M`; the elements of this submodule are\n    referred to as *homogeneous elements of degree* `i`.\n    The `R`-module `M` is the direct sum of its `i`-th graded\n    components over all `i \\in I`, and thus becomes a graded\n    `R`-module with basis.\n    Conversely, any graded `R`-module with basis canonically\n    becomes a filtered `R`-module with basis (by defining\n    `F_n = \\bigoplus_{i \\leq n} G_i` where `G_i` is the `i`-th\n    graded component, and defining `J_i` as the indexing set\n    of the basis of the `i`-th graded component). Hence, the\n    notion of a filtered `R`-module with basis is equivalent\n    to the notion of a graded `R`-module with basis.\n\n    However, the *category* of filtered `R`-modules with basis is not\n    the category of graded `R`-modules with basis. Indeed, the *morphisms*\n    of filtered `R`-modules with basis are defined to be morphisms of\n    `R`-modules which send each `F_n` of the domain to the corresponding\n    `F_n` of the target; in contrast, the morphisms of graded `R`-modules\n    with basis must preserve each homogeneous component. Also,\n    the notion of a filtered algebra with basis differs from\n    that of a graded algebra with basis.\n\n    .. NOTE::\n\n        Currently, to make use of the functionality of this class,\n        an instance of ``FilteredModulesWithBasis`` should fulfill\n        the contract of a :class:`CombinatorialFreeModule` (most\n        likely by inheriting from it). It should also have the\n        indexing set `J` encoded as its ``_indices`` attribute,\n        and ``_indices.subset(size=i)`` should yield the subset\n        `J_i` (as an iterable). If the latter conditions are not\n        satisfied, then :meth:`basis` must be overridden.\n\n    .. NOTE::\n\n        One should implement a ``degree_on_basis`` method in the parent\n        class in order to fully utilize the methods of this category.\n        This might become a required abstract method in the future.\n\n    EXAMPLES::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered(); C\n        Category of filtered modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules over Integer Ring,\n         Category of modules with basis over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Filtered()\n        True\n\n    TESTS::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered()\n        sage: TestSuite(C).run()\n        sage: C = ModulesWithBasis(QQ).Filtered()\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "degree_on_basis": {
                    "__doc__": "\n            Return the degree of the basis element indexed by ``m``\n            in ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(QQ).example()\n                sage: A.degree_on_basis(Partition((2,1)))\n                3\n                sage: A.degree_on_basis(Partition((4,2,1,1,1,1)))\n                10\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component": {
                    "__doc__": "\n            Return the homogeneous component of degree ``n`` of the\n            element ``self``.\n\n            Let `m` be an element of a filtered `R`-module `M` with\n            basis. Then, `m` can be uniquely written in the form\n            `m = \\sum_{i \\in I} m_i`, where each `m_i` is a\n            homogeneous element of degree `i`. For `n \\in I`, we\n            define the homogeneous component of degree `n` of the\n            element `m` to be `m_n`.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.homogeneous_component(-1)\n                0\n                sage: g.homogeneous_component(0)\n                1\n                sage: g.homogeneous_component(2)\n                -2*U['x']*U['y']\n                sage: g.homogeneous_component(5)\n                0\n                sage: g.homogeneous_component(7)\n                U['x']^2*U['y']^2*U['z']^3\n                sage: g.homogeneous_component(8)\n                0\n\n            TESTS:\n\n            Check that this really returns ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.homogeneous_component(3).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_homogeneous": {
                    "__doc__": "\n            Return whether the element ``self`` is homogeneous.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x=A(Partition((3,2,1)))\n                sage: y=A(Partition((4,4,1)))\n                sage: z=A(Partition((2,2,2)))\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x - y).is_homogeneous()\n                False\n                sage: (x+2*z).is_homogeneous()\n                True\n\n            Here is an example with a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x^3 - y^2).is_homogeneous()\n                True\n                sage: ((x + y)^2).is_homogeneous()\n                False\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis, or at least on a definition of homogeneous\n            components)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).is_homogeneous()\n                True\n                sage: (y*x).is_homogeneous()\n                False\n                sage: A.one().is_homogeneous()\n                True\n                sage: A.zero().is_homogeneous()\n                True\n                sage: (A.one()+x).is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "maximal_degree": {
                    "__doc__": "\n            The maximum of the degrees of the homogeneous components\n            of ``self``.\n\n            This is also the smallest `i` such that ``self`` belongs\n            to `F_i`. Hence, it does not depend on the basis of the\n            parent of ``self``.\n\n            .. SEEALSO:: :meth:`homogeneous_degree`\n\n            EXAMPLES:\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.maximal_degree()\n                6\n                sage: (x + 2*z).maximal_degree()\n                6\n                sage: (y - x).maximal_degree()\n                9\n                sage: (3*z).maximal_degree()\n                6\n\n            Now, we test this on a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.maximal_degree()\n                2\n                sage: (x^3 + 4*y^2).maximal_degree()\n                6\n                sage: ((1 + x)^3).maximal_degree()\n                6\n\n            Let us now test a filtered algebra::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).maximal_degree()\n                2\n                sage: (y*x).maximal_degree()\n                2\n                sage: A.one().maximal_degree()\n                0\n                sage: A.zero().maximal_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n                sage: (A.one()+x).maximal_degree()\n                1\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "truncate": {
                    "__doc__": "\n            Return the sum of the homogeneous components of degree\n            strictly less than ``n`` of ``self``.\n\n            See :meth:`homogeneous_component` for the notion of a\n            homogeneous component.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(-1)\n                0\n                sage: g.truncate(0)\n                0\n                sage: g.truncate(2)\n                2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(3)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(5)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(7)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(8)\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.truncate(0).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces.WithBasis",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered modules with a distinguished basis.\n\n    A *filtered module with basis* over a ring `R` means\n    (for the purpose of this code) a filtered `R`-module `M`\n    with filtration `(F_i)_{i \\in I}` (typically `I = \\NN`)\n    endowed with a basis `(b_j)_{j \\in J}` of `M` and a partition\n    `J = \\bigsqcup_{i \\in I} J_i` of the set `J` (it is allowed\n    that some `J_i` are empty) such that for every `n \\in I`,\n    the subfamily `(b_j)_{j \\in U_n}`, where\n    `U_n = \\bigcup_{i \\leq n} J_i`, is a basis of the\n    `R`-submodule `F_n`.\n\n    For every `i \\in I`, the `R`-submodule of `M` spanned by\n    `(b_j)_{j \\in J_i}` is called the `i`-*th graded component*\n    (aka the `i`-*th homogeneous component*) of the filtered\n    module with basis `M`; the elements of this submodule are\n    referred to as *homogeneous elements of degree* `i`.\n    The `R`-module `M` is the direct sum of its `i`-th graded\n    components over all `i \\in I`, and thus becomes a graded\n    `R`-module with basis.\n    Conversely, any graded `R`-module with basis canonically\n    becomes a filtered `R`-module with basis (by defining\n    `F_n = \\bigoplus_{i \\leq n} G_i` where `G_i` is the `i`-th\n    graded component, and defining `J_i` as the indexing set\n    of the basis of the `i`-th graded component). Hence, the\n    notion of a filtered `R`-module with basis is equivalent\n    to the notion of a graded `R`-module with basis.\n\n    However, the *category* of filtered `R`-modules with basis is not\n    the category of graded `R`-modules with basis. Indeed, the *morphisms*\n    of filtered `R`-modules with basis are defined to be morphisms of\n    `R`-modules which send each `F_n` of the domain to the corresponding\n    `F_n` of the target; in contrast, the morphisms of graded `R`-modules\n    with basis must preserve each homogeneous component. Also,\n    the notion of a filtered algebra with basis differs from\n    that of a graded algebra with basis.\n\n    .. NOTE::\n\n        Currently, to make use of the functionality of this class,\n        an instance of ``FilteredModulesWithBasis`` should fulfill\n        the contract of a :class:`CombinatorialFreeModule` (most\n        likely by inheriting from it). It should also have the\n        indexing set `J` encoded as its ``_indices`` attribute,\n        and ``_indices.subset(size=i)`` should yield the subset\n        `J_i` (as an iterable). If the latter conditions are not\n        satisfied, then :meth:`basis` must be overridden.\n\n    .. NOTE::\n\n        One should implement a ``degree_on_basis`` method in the parent\n        class in order to fully utilize the methods of this category.\n        This might become a required abstract method in the future.\n\n    EXAMPLES::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered(); C\n        Category of filtered modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules over Integer Ring,\n         Category of modules with basis over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Filtered()\n        True\n\n    TESTS::\n\n        sage: C = ModulesWithBasis(ZZ).Filtered()\n        sage: TestSuite(C).run()\n        sage: C = ModulesWithBasis(QQ).Filtered()\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "from_graded_conversion": {
                    "__doc__": "\n            Return the inverse of the canonical `R`-module isomorphism\n            `A \\to \\operatorname{gr} A` induced by the basis of `A`\n            (where `A = ` ``self``). This inverse is an isomorphism\n            `\\operatorname{gr} A \\to A`.\n\n            This is an isomorphism of `R`-modules. See\n            the class documentation :class:`AssociatedGradedAlgebra`.\n\n            .. SEEALSO::\n\n                :meth:`to_graded_conversion`\n\n            EXAMPLES::\n\n                sage: A = Modules(QQ).WithBasis().Filtered().example()\n                sage: p = -2 * A.an_element(); p\n                -4*P[] - 4*P[1] - 6*P[2]\n                sage: q = A.to_graded_conversion()(p); q\n                -4*Bbar[[]] - 4*Bbar[[1]] - 6*Bbar[[2]]\n                sage: A.from_graded_conversion()(q) == p\n                True\n                sage: q.parent() is A.graded_algebra()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "graded_algebra": {
                    "__doc__": "\n            Return the associated graded module to ``self``.\n\n            See :class:`~sage.algebras.associated_graded.AssociatedGradedAlgebra`\n            for the definition and the properties of this.\n\n            If the filtered module ``self`` with basis is called `A`,\n            then this method returns `\\operatorname{gr} A`. The method\n            :meth:`to_graded_conversion` returns the canonical\n            `R`-module isomorphism `A \\to \\operatorname{gr} A` induced\n            by the basis of `A`, and the method\n            :meth:`from_graded_conversion` returns the inverse of this\n            isomorphism. The method :meth:`projection` projects\n            elements of `A` onto `\\operatorname{gr} A` according to\n            their place in the filtration on `A`.\n\n            .. WARNING::\n\n                When not overridden, this method returns the default\n                implementation of an associated graded module --\n                namely, ``AssociatedGradedAlgebra(self)``, where\n                ``AssociatedGradedAlgebra`` is\n                :class:`~sage.algebras.associated_graded.AssociatedGradedAlgebra`.\n                But some instances of :class:`FilteredModulesWithBasis`\n                override this method, as the associated graded module\n                often is (isomorphic) to a simpler object (for instance,\n                the associated graded module of a graded module can be\n                identified with the graded module itself). Generic code\n                that uses associated graded modules (such as the code\n                of the :meth:`induced_graded_map` method below) should\n                make sure to only communicate with them via the\n                :meth:`to_graded_conversion`,\n                :meth:`from_graded_conversion` and\n                :meth:`projection` methods (in particular,\n                do not expect there to be a conversion from ``self``\n                to ``self.graded_algebra()``; this currently does not\n                work for Clifford algebras). Similarly, when\n                overriding :meth:`graded_algebra`, make sure to\n                accordingly redefine these three methods, unless their\n                definitions below still apply to your case (this will\n                happen whenever the basis of your :meth:`graded_algebra`\n                has the same indexing set as ``self``, and the partition\n                of this indexing set according to degree is the same as\n                for ``self``).\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: A.graded_algebra()\n                Graded Module of An example of a filtered module with basis:\n                 the free module on partitions over Integer Ring\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component": {
                    "__doc__": "\n            Return the ``d``-th homogeneous component of ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(ZZ).example()\n                sage: A.homogeneous_component(4)\n                Degree 4 homogeneous component of An example of a graded module\n                 with basis: the free module on partitions over Integer Ring\n            ",
                    "args": [
                        "self",
                        "d"
                    ],
                    "argspec": [
                        [
                            "self",
                            "d"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component_basis": {
                    "__doc__": "\n            Return a basis for the ``d``-th homogeneous component of ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(ZZ).example()\n                sage: A.homogeneous_component_basis(4)\n                Lazy family (Term map from Partitions to An example of a graded module with basis:\n                             the free module on partitions over Integer Ring(i))_{i in Partitions of the integer 4}\n\n                sage: cat = GradedModulesWithBasis(ZZ)\n                sage: C = CombinatorialFreeModule(ZZ, ['a', 'b'], category=cat)\n                sage: C.degree_on_basis = lambda x: 1 if x == 'a' else 2\n                sage: C.homogeneous_component_basis(1)\n                Finite family {'a': B['a']}\n                sage: C.homogeneous_component_basis(2)\n                Finite family {'b': B['b']}\n            ",
                    "args": [
                        "self",
                        "d"
                    ],
                    "argspec": [
                        [
                            "self",
                            "d"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "induced_graded_map": {
                    "__doc__": "\n            Return the graded linear map between the associated graded\n            modules of ``self`` and ``other`` canonically induced by\n            the filtration-preserving map ``f : self -> other``.\n\n            Let `A` and `B` be two filtered modules with basis, and let\n            `(F_i)_{i \\in I}` and `(G_i)_{i \\in I}` be their\n            filtrations. Let `f : A \\to B` be a linear map which\n            preserves the filtration (i.e., satisfies `f(F_i) \\subseteq\n            G_i` for all `i \\in I`). Then, there is a canonically\n            defined graded linear map\n            `\\operatorname{gr} f : \\operatorname{gr} A \\to\n            \\operatorname{gr} B` which satisfies\n\n            .. MATH::\n\n                (\\operatorname{gr} f) (p_i(a)) = p_i(f(a))\n                \\qquad \\text{for all } i \\in I \\text{ and } a \\in F_i ,\n\n            where the `p_i` on the left hand side is the canonical\n            projection from `F_i` onto the `i`-th graded component\n            of `\\operatorname{gr} A`, while the `p_i` on the right\n            hand side is the canonical projection from `G_i` onto\n            the `i`-th graded component of `\\operatorname{gr} B`.\n\n            INPUT:\n\n            - ``other`` -- a filtered algebra with basis\n\n            - ``f`` -- a filtration-preserving linear map from ``self``\n              to ``other`` (can be given as a morphism or as a function)\n\n            OUTPUT:\n\n            The graded linear map `\\operatorname{gr} f`.\n\n            EXAMPLES:\n\n            **Example 1.**\n\n            We start with the free `\\QQ`-module with basis the set of all\n            partitions::\n\n                sage: A = Modules(QQ).WithBasis().Filtered().example(); A\n                An example of a filtered module with basis: the free module\n                 on partitions over Rational Field\n                sage: M = A.indices(); M\n                Partitions\n                sage: p1, p2, p21, p321 = [A.basis()[Partition(i)] for i in [[1], [2], [2,1], [3,2,1]]]\n\n            Let us define a map from ``A`` to itself which acts on the\n            basis by sending every partition `\\lambda` to the sum of\n            the conjugates of all partitions `\\mu` for which\n            `\\lambda / \\mu` is a horizontal strip::\n\n                sage: def map_on_basis(lam):\n                ....:     return A.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = A.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=A)\n                sage: f(p1)\n                P[] + P[1]\n                sage: f(p2)\n                P[] + P[1] + P[1, 1]\n                sage: f(p21)\n                P[1] + P[1, 1] + P[2] + P[2, 1]\n                sage: f(p21 - p1)\n                -P[] + P[1, 1] + P[2] + P[2, 1]\n                sage: f(p321)\n                P[2, 1] + P[2, 1, 1] + P[2, 2] + P[2, 2, 1]\n                 + P[3, 1] + P[3, 1, 1] + P[3, 2] + P[3, 2, 1]\n\n            We now compute `\\operatorname{gr} f` ::\n\n                sage: grA = A.graded_algebra(); grA\n                Graded Module of An example of a filtered module with basis:\n                 the free module on partitions over Rational Field\n                sage: pp1, pp2, pp21, pp321 = [A.to_graded_conversion()(i) for i in [p1, p2, p21, p321]]\n                sage: pp2 + 4 * pp21\n                Bbar[[2]] + 4*Bbar[[2, 1]]\n                sage: grf = A.induced_graded_map(A, f); grf\n                Generic endomorphism of Graded Module of An example of a\n                 filtered module with basis:\n                 the free module on partitions over Rational Field\n                sage: grf(pp1)\n                Bbar[[1]]\n                sage: grf(pp2 + 4 * pp21)\n                Bbar[[1, 1]] + 4*Bbar[[2, 1]]\n\n            **Example 2.**\n\n            We shall now construct `\\operatorname{gr} f` for a\n            different map `f` out of the same ``A``; the new map\n            `f` will lead into a graded algebra already, namely into\n            the algebra of symmetric functions::\n\n                sage: h = SymmetricFunctions(QQ).h()\n                sage: def map_on_basis(lam):  # redefining map_on_basis\n                ....:     return h.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = A.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=h)  # redefining f\n                sage: f(p1)\n                h[] + h[1]\n                sage: f(p2)\n                h[] + h[1] + h[1, 1]\n                sage: f(A.zero())\n                0\n                sage: f(p2 - 3*p1)\n                -2*h[] - 2*h[1] + h[1, 1]\n\n            The algebra ``h`` of symmetric functions in the `h`-basis\n            is already graded, so its associated graded algebra is\n            implemented as itself::\n\n                sage: grh = h.graded_algebra(); grh is h\n                True\n                sage: grf = A.induced_graded_map(h, f); grf\n                Generic morphism:\n                  From: Graded Module of An example of a filtered\n                   module with basis: the free module on partitions\n                   over Rational Field\n                  To:   Symmetric Functions over Rational Field\n                   in the homogeneous basis\n                sage: grf(pp1)\n                h[1]\n                sage: grf(pp2)\n                h[1, 1]\n                sage: grf(pp321)\n                h[3, 2, 1]\n                sage: grf(pp2 - 3*pp1)\n                -3*h[1] + h[1, 1]\n                sage: grf(pp21)\n                h[2, 1]\n                sage: grf(grA.zero())\n                0\n\n            **Example 3.**\n\n            After having had a graded module as the codomain, let us try to\n            have one as the domain instead. Our new ``f`` will go from ``h``\n            to ``A``::\n\n                sage: def map_on_basis(lam):  # redefining map_on_basis\n                ....:     return A.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = h.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=A)  # redefining f\n                sage: f(h[1])\n                P[] + P[1]\n                sage: f(h[2])\n                P[] + P[1] + P[1, 1]\n                sage: f(h[1, 1])\n                P[1] + P[2]\n                sage: f(h[2, 2])\n                P[1, 1] + P[2, 1] + P[2, 2]\n                sage: f(h[3, 2, 1])\n                P[2, 1] + P[2, 1, 1] + P[2, 2] + P[2, 2, 1]\n                 + P[3, 1] + P[3, 1, 1] + P[3, 2] + P[3, 2, 1]\n                sage: f(h.one())\n                P[]\n                sage: grf = h.induced_graded_map(A, f); grf\n                Generic morphism:\n                  From: Symmetric Functions over Rational Field\n                   in the homogeneous basis\n                  To:   Graded Module of An example of a filtered\n                   module with basis: the free module on partitions\n                   over Rational Field\n                sage: grf(h[1])\n                Bbar[[1]]\n                sage: grf(h[2])\n                Bbar[[1, 1]]\n                sage: grf(h[1, 1])\n                Bbar[[2]]\n                sage: grf(h[2, 2])\n                Bbar[[2, 2]]\n                sage: grf(h[3, 2, 1])\n                Bbar[[3, 2, 1]]\n                sage: grf(h.one())\n                Bbar[[]]\n\n            **Example 4.**\n\n            The construct `\\operatorname{gr} f` also makes sense when `f`\n            is a filtration-preserving map between graded modules. ::\n\n                sage: def map_on_basis(lam):  # redefining map_on_basis\n                ....:     return h.sum_of_monomials([Partition(mu).conjugate() for k in range(sum(lam) + 1)\n                ....:                                for mu in lam.remove_horizontal_border_strip(k)])\n                sage: f = h.module_morphism(on_basis=map_on_basis,\n                ....:                       codomain=h)  # redefining f\n                sage: f(h[1])\n                h[] + h[1]\n                sage: f(h[2])\n                h[] + h[1] + h[1, 1]\n                sage: f(h[1, 1])\n                h[1] + h[2]\n                sage: f(h[2, 1])\n                h[1] + h[1, 1] + h[2] + h[2, 1]\n                sage: f(h.one())\n                h[]\n                sage: grf = h.induced_graded_map(h, f); grf\n                Generic endomorphism of Symmetric Functions over Rational\n                 Field in the homogeneous basis\n                sage: grf(h[1])\n                h[1]\n                sage: grf(h[2])\n                h[1, 1]\n                sage: grf(h[1, 1])\n                h[2]\n                sage: grf(h[2, 1])\n                h[2, 1]\n                sage: grf(h.one())\n                h[]\n            ",
                    "args": [
                        "self",
                        "other",
                        "f"
                    ],
                    "argspec": [
                        [
                            "self",
                            "other",
                            "f"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "projection": {
                    "__doc__": "\n            Return the `i`-th projection `p_i : F_i \\to G_i` (in the\n            notations of the class documentation\n            :class:`AssociatedGradedAlgebra`, where `A = ` ``self``).\n\n            This method actually does not return the map `p_i` itself,\n            but an extension of `p_i` to the whole `R`-module `A`.\n            This extension is the composition of the `R`-module\n            isomorphism `A \\to \\operatorname{gr} A` with the canonical\n            projection of the graded `R`-module `\\operatorname{gr} A`\n            onto its `i`-th graded component `G_i`. The codomain of\n            this map is `\\operatorname{gr} A`, although its actual\n            image is `G_i`. The map `p_i` is obtained from this map\n            by restricting its domain to `F_i` and its image to `G_i`.\n\n            EXAMPLES::\n\n                sage: A = Modules(ZZ).WithBasis().Filtered().example()\n                sage: p = -2 * A.an_element(); p\n                -4*P[] - 4*P[1] - 6*P[2]\n                sage: q = A.projection(2)(p); q\n                -6*Bbar[[2]]\n                sage: q.parent() is A.graded_algebra()\n                True\n                sage: A.projection(3)(p)\n                0\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "to_graded_conversion": {
                    "__doc__": "\n            Return the canonical `R`-module isomorphism\n            `A \\to \\operatorname{gr} A` induced by the basis of `A`\n            (where `A = ` ``self``).\n\n            This is an isomorphism of `R`-modules. See\n            the class documentation :class:`AssociatedGradedAlgebra`.\n\n            .. SEEALSO::\n\n                :meth:`from_graded_conversion`\n\n            EXAMPLES::\n\n                sage: A = Modules(QQ).WithBasis().Filtered().example()\n                sage: p = -2 * A.an_element(); p\n                -4*P[] - 4*P[1] - 6*P[2]\n                sage: q = A.to_graded_conversion()(p); q\n                -4*Bbar[[]] - 4*Bbar[[1]] - 6*Bbar[[2]]\n                sage: q.parent() is A.graded_algebra()\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "degree_on_basis": {
                    "__doc__": "\n            Return the degree of the basis element indexed by ``m``\n            in ``self``.\n\n            EXAMPLES::\n\n                sage: A = GradedModulesWithBasis(QQ).example()\n                sage: A.degree_on_basis(Partition((2,1)))\n                3\n                sage: A.degree_on_basis(Partition((4,2,1,1,1,1)))\n                10\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_component": {
                    "__doc__": "\n            Return the homogeneous component of degree ``n`` of the\n            element ``self``.\n\n            Let `m` be an element of a filtered `R`-module `M` with\n            basis. Then, `m` can be uniquely written in the form\n            `m = \\sum_{i \\in I} m_i`, where each `m_i` is a\n            homogeneous element of degree `i`. For `n \\in I`, we\n            define the homogeneous component of degree `n` of the\n            element `m` to be `m_n`.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.homogeneous_component(-1)\n                0\n                sage: x.homogeneous_component(0)\n                2*P[]\n                sage: x.homogeneous_component(1)\n                2*P[1]\n                sage: x.homogeneous_component(2)\n                3*P[2]\n                sage: x.homogeneous_component(3)\n                0\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.homogeneous_component(-1)\n                0\n                sage: g.homogeneous_component(0)\n                1\n                sage: g.homogeneous_component(2)\n                -2*U['x']*U['y']\n                sage: g.homogeneous_component(5)\n                0\n                sage: g.homogeneous_component(7)\n                U['x']^2*U['y']^2*U['z']^3\n                sage: g.homogeneous_component(8)\n                0\n\n            TESTS:\n\n            Check that this really returns ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.homogeneous_component(3).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "homogeneous_degree": {
                    "__doc__": "\n            The degree of a nonzero homogeneous element ``self`` in the\n            filtered module.\n\n            .. NOTE::\n\n                This raises an error if the element is not homogeneous.\n                To compute the maximum of the degrees of the homogeneous\n                summands of a (not necessarily homogeneous) element, use\n                :meth:`maximal_degree` instead.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.degree()\n                6\n                sage: (x + 2*z).degree()\n                6\n                sage: (y - x).degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            An example in a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.homogeneous_degree()\n                2\n                sage: (x^3 + 4*y^2).homogeneous_degree()\n                6\n                sage: ((1 + x)^3).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).homogeneous_degree()\n                2\n                sage: (y*x).homogeneous_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: element is not homogeneous\n                sage: A.one().homogeneous_degree()\n                0\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_homogeneous": {
                    "__doc__": "\n            Return whether the element ``self`` is homogeneous.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x=A(Partition((3,2,1)))\n                sage: y=A(Partition((4,4,1)))\n                sage: z=A(Partition((2,2,2)))\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x - y).is_homogeneous()\n                False\n                sage: (x+2*z).is_homogeneous()\n                True\n\n            Here is an example with a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: (3*x).is_homogeneous()\n                True\n                sage: (x^3 - y^2).is_homogeneous()\n                True\n                sage: ((x + y)^2).is_homogeneous()\n                False\n\n            Let us now test a filtered algebra (but remember that the\n            notion of homogeneity now depends on the choice of a\n            basis, or at least on a definition of homogeneous\n            components)::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).is_homogeneous()\n                True\n                sage: (y*x).is_homogeneous()\n                False\n                sage: A.one().is_homogeneous()\n                True\n                sage: A.zero().is_homogeneous()\n                True\n                sage: (A.one()+x).is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "maximal_degree": {
                    "__doc__": "\n            The maximum of the degrees of the homogeneous components\n            of ``self``.\n\n            This is also the smallest `i` such that ``self`` belongs\n            to `F_i`. Hence, it does not depend on the basis of the\n            parent of ``self``.\n\n            .. SEEALSO:: :meth:`homogeneous_degree`\n\n            EXAMPLES:\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A(Partition((3,2,1)))\n                sage: y = A(Partition((4,4,1)))\n                sage: z = A(Partition((2,2,2)))\n                sage: x.maximal_degree()\n                6\n                sage: (x + 2*z).maximal_degree()\n                6\n                sage: (y - x).maximal_degree()\n                9\n                sage: (3*z).maximal_degree()\n                6\n\n            Now, we test this on a graded algebra::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: (x, y) = (S[2], S[3])\n                sage: x.maximal_degree()\n                2\n                sage: (x^3 + 4*y^2).maximal_degree()\n                6\n                sage: ((1 + x)^3).maximal_degree()\n                6\n\n            Let us now test a filtered algebra::\n\n                sage: A = AlgebrasWithBasis(QQ).Filtered().example()\n                sage: x,y,z = A.algebra_generators()\n                sage: (x*y).maximal_degree()\n                2\n                sage: (y*x).maximal_degree()\n                2\n                sage: A.one().maximal_degree()\n                0\n                sage: A.zero().maximal_degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n                sage: (A.one()+x).maximal_degree()\n                1\n\n            TESTS::\n\n                sage: S = NonCommutativeSymmetricFunctions(QQ).S()\n                sage: S.zero().degree()\n                Traceback (most recent call last):\n                ...\n                ValueError: the zero element does not have a well-defined degree\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "truncate": {
                    "__doc__": "\n            Return the sum of the homogeneous components of degree\n            strictly less than ``n`` of ``self``.\n\n            See :meth:`homogeneous_component` for the notion of a\n            homogeneous component.\n\n            EXAMPLES::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = ModulesWithBasis(ZZ).Graded().example()\n                sage: x = A.an_element(); x\n                2*P[] + 2*P[1] + 3*P[2]\n                sage: x.truncate(0)\n                0\n                sage: x.truncate(1)\n                2*P[]\n                sage: x.truncate(2)\n                2*P[] + 2*P[1]\n                sage: x.truncate(3)\n                2*P[] + 2*P[1] + 3*P[2]\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: G = A.algebra_generators()\n                sage: g = A.an_element() - 2 * G['x'] * G['y']; g\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(-1)\n                0\n                sage: g.truncate(0)\n                0\n                sage: g.truncate(2)\n                2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(3)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(5)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(7)\n                -2*U['x']*U['y'] + 2*U['x'] + 3*U['y'] + 1\n                sage: g.truncate(8)\n                U['x']^2*U['y']^2*U['z']^3 - 2*U['x']*U['y']\n                 + 2*U['x'] + 3*U['y'] + 1\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: A = ModulesWithBasis(ZZ).Filtered().example()\n                sage: x = A.an_element()\n                sage: x.truncate(0).parent() is A\n                True\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Inverse",
            "FinitelyGeneratedAsMagma",
            "Unital",
            "Irreducible",
            "Finite",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.finite_complex_reflection_groups.FiniteComplexReflectionGroups",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups.Irreducible"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.finite_complex_reflection_groups.FiniteComplexReflectionGroups.Irreducible",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "coxeter_number": {
                    "__doc__": "\n                Return the Coxeter number of an irreducible\n                reflection group.\n\n                This is defined as `\\frac{N + N^*}{n}` where\n                `N` is the number of reflections, `N^*` is the\n                number of reflection hyperplanes, and `n` is the\n                rank of ``self``.\n\n                EXAMPLES::\n\n                    sage: W = ReflectionGroup(31)          # optional - gap3\n                    sage: W.coxeter_number()               # optional - gap3\n                    30\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.commutative_rings.CommutativeRings"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "name": "sage.categories.commutative_algebras.CommutativeAlgebras",
        "parent_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_algebras.FilteredAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "graded_algebra": {
                    "__doc__": "\n            Return the associated graded algebra to ``self``.\n\n            .. TODO::\n\n                Implement a version of the associated graded algebra\n                which does not require ``self`` to have a\n                distinguished basis.\n\n            EXAMPLES::\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: A.graded_algebra()\n                Graded Algebra of An example of a filtered algebra with basis:\n                 the universal enveloping algebra of\n                 Lie algebra of RR^3 with cross product over Integer Ring\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(QQ); C\n        Category of algebras with basis over Rational Field\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras over Rational Field,\n         Category of unital algebras with basis over Rational Field]\n\n    We construct a typical parent in this category, and do some\n    computations with it::\n\n        sage: A = C.example(); A\n        An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n\n        sage: A.category()\n        Category of algebras with basis over Rational Field\n\n        sage: A.one_basis()\n        word:\n        sage: A.one()\n        B[word: ]\n\n        sage: A.base_ring()\n        Rational Field\n        sage: A.basis().keys()\n        Finite words over {'a', 'b', 'c'}\n\n        sage: (a,b,c) = A.algebra_generators()\n        sage: a^3, b^2\n        (B[word: aaa], B[word: bb])\n        sage: a*c*b\n        B[word: acb]\n\n        sage: A.product\n        <bound method FreeAlgebra_with_category._product_from_product_on_basis_multiply of\n         An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field>\n        sage: A.product(a*b,b)\n        B[word: abb]\n\n        sage: TestSuite(A).run(verbose=True)\n        running ._test_additive_associativity() . . . pass\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_characteristic() . . . pass\n        running ._test_distributivity() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_nonzero_equal() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_zero() . . . pass\n        sage: A.__class__\n        <class 'sage.categories.examples.algebras_with_basis.FreeAlgebra_with_category'>\n        sage: A.element_class\n        <class 'sage.combinat.free_module.FreeAlgebra_with_category.element_class'>\n\n    Please see the source code of `A` (with ``A??``) for how to\n    implement other algebras with basis.\n\n    TESTS::\n\n        sage: TestSuite(AlgebrasWithBasis(QQ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.unital_algebras.UnitalAlgebras.WithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(QQ); C\n        Category of algebras with basis over Rational Field\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras over Rational Field,\n         Category of unital algebras with basis over Rational Field]\n\n    We construct a typical parent in this category, and do some\n    computations with it::\n\n        sage: A = C.example(); A\n        An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n\n        sage: A.category()\n        Category of algebras with basis over Rational Field\n\n        sage: A.one_basis()\n        word:\n        sage: A.one()\n        B[word: ]\n\n        sage: A.base_ring()\n        Rational Field\n        sage: A.basis().keys()\n        Finite words over {'a', 'b', 'c'}\n\n        sage: (a,b,c) = A.algebra_generators()\n        sage: a^3, b^2\n        (B[word: aaa], B[word: bb])\n        sage: a*c*b\n        B[word: acb]\n\n        sage: A.product\n        <bound method FreeAlgebra_with_category._product_from_product_on_basis_multiply of\n         An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field>\n        sage: A.product(a*b,b)\n        B[word: abb]\n\n        sage: TestSuite(A).run(verbose=True)\n        running ._test_additive_associativity() . . . pass\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_characteristic() . . . pass\n        running ._test_distributivity() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_nonzero_equal() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_zero() . . . pass\n        sage: A.__class__\n        <class 'sage.categories.examples.algebras_with_basis.FreeAlgebra_with_category'>\n        sage: A.element_class\n        <class 'sage.combinat.free_module.FreeAlgebra_with_category.element_class'>\n\n    Please see the source code of `A` (with ``A??``) for how to\n    implement other algebras with basis.\n\n    TESTS::\n\n        sage: TestSuite(AlgebrasWithBasis(QQ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_product_from_combinatorial_algebra_multiply": {
                    "__doc__": "\n            Returns left\\*right where left and right are elements of self.\n            product() uses either _multiply or _multiply basis to carry out\n            the actual multiplication.\n\n            EXAMPLES::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2])\n                sage: s._product_from_combinatorial_algebra_multiply(a,a)\n                s[2, 2] + s[3, 1] + s[4]\n                sage: s.product(a,a)\n                s[2, 2] + s[3, 1] + s[4]\n            ",
                    "args": [
                        "self",
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "hochschild_complex": {
                    "__doc__": "\n            Return the Hochschild complex of ``self`` with coefficients\n            in ``M``.\n\n            .. SEEALSO::\n\n                :class:`~sage.homology.hochschild_complex.HochschildComplex`\n\n            EXAMPLES::\n\n                sage: R.<x> = QQ[]\n                sage: A = algebras.DifferentialWeyl(R)\n                sage: H = A.hochschild_complex(A)\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: T = SGA.trivial_representation()\n                sage: H = SGA.hochschild_complex(T)\n            ",
                    "args": [
                        "self",
                        "M"
                    ],
                    "argspec": [
                        [
                            "self",
                            "M"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded algebras\n\n    EXAMPLES::\n\n        sage: GradedAlgebras(ZZ)\n        Category of graded algebras over Integer Ring\n        sage: GradedAlgebras(ZZ).super_categories()\n        [Category of filtered algebras over Integer Ring,\n         Category of graded modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(GradedAlgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_algebras.FilteredAlgebras",
            "sage.categories.graded_modules.GradedModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded algebras\n\n    EXAMPLES::\n\n        sage: GradedAlgebras(ZZ)\n        Category of graded algebras over Integer Ring\n        sage: GradedAlgebras(ZZ).super_categories()\n        [Category of filtered algebras over Integer Ring,\n         Category of graded modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(GradedAlgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_algebras.GradedAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.graded_algebras.GradedAlgebras",
            "sage.categories.super_modules.SuperModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.super_algebras.SuperAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.modules.Modules.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of complex reflection groups.\n\n    Let `V` be a complex vector space. A *complex reflection* is an\n    element of `\\operatorname{GL}(V)` fixing an hyperplane pointwise\n    and acting by multiplication by a root of unity on a complementary\n    line.\n\n    A *complex reflection group* is a group `W` that is (isomorphic\n    to) a subgroup of some general linear group `\\operatorname{GL}(V)`\n    generated by a distinguished set of complex reflections.\n\n    The dimension of `V` is the *rank* of `W`.\n\n    For a comprehensive treatment of complex reflection groups and\n    many definitions and theorems used here, we refer to [LT2009]_.\n    See also :wikipedia:`Reflection_group`.\n\n    .. SEEALSO::\n\n        :func:`ReflectionGroup` for usage examples of this category.\n\n    REFERENCES:\n\n    .. [LT2009] G.I. Lehrer and D.E. Taylor. *Unitary reflection groups*.\n       Australian Mathematical Society Lecture Series, 2009.\n\n    EXAMPLES::\n\n        sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n        sage: ComplexReflectionGroups()\n        Category of complex reflection groups\n        sage: ComplexReflectionGroups().super_categories()\n        [Category of complex reflection or generalized coxeter groups]\n        sage: ComplexReflectionGroups().all_super_categories()\n        [Category of complex reflection groups,\n         Category of complex reflection or generalized coxeter groups,\n         Category of groups,\n         Category of monoids,\n         Category of finitely generated semigroups,\n         Category of semigroups,\n         Category of finitely generated magmas,\n         Category of inverse unital magmas,\n         Category of unital magmas,\n         Category of magmas,\n         Category of enumerated sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    An example of a reflection group::\n\n        sage: W = ComplexReflectionGroups().example(); W\n        5-colored permutations of size 3\n\n    ``W`` is in the category of complex reflection groups::\n\n        sage: W in ComplexReflectionGroups()\n        True\n\n    TESTS::\n\n        sage: TestSuite(W).run()\n        sage: TestSuite(ComplexReflectionGroups()).run()\n    ",
        "axioms": [
            "Inverse",
            "Associative",
            "FinitelyGeneratedAsMagma",
            "Unital"
        ],
        "element_class": {
            "__doc__": "\n    The category of complex reflection groups.\n\n    Let `V` be a complex vector space. A *complex reflection* is an\n    element of `\\operatorname{GL}(V)` fixing an hyperplane pointwise\n    and acting by multiplication by a root of unity on a complementary\n    line.\n\n    A *complex reflection group* is a group `W` that is (isomorphic\n    to) a subgroup of some general linear group `\\operatorname{GL}(V)`\n    generated by a distinguished set of complex reflections.\n\n    The dimension of `V` is the *rank* of `W`.\n\n    For a comprehensive treatment of complex reflection groups and\n    many definitions and theorems used here, we refer to [LT2009]_.\n    See also :wikipedia:`Reflection_group`.\n\n    .. SEEALSO::\n\n        :func:`ReflectionGroup` for usage examples of this category.\n\n    REFERENCES:\n\n    .. [LT2009] G.I. Lehrer and D.E. Taylor. *Unitary reflection groups*.\n       Australian Mathematical Society Lecture Series, 2009.\n\n    EXAMPLES::\n\n        sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n        sage: ComplexReflectionGroups()\n        Category of complex reflection groups\n        sage: ComplexReflectionGroups().super_categories()\n        [Category of complex reflection or generalized coxeter groups]\n        sage: ComplexReflectionGroups().all_super_categories()\n        [Category of complex reflection groups,\n         Category of complex reflection or generalized coxeter groups,\n         Category of groups,\n         Category of monoids,\n         Category of finitely generated semigroups,\n         Category of semigroups,\n         Category of finitely generated magmas,\n         Category of inverse unital magmas,\n         Category of unital magmas,\n         Category of magmas,\n         Category of enumerated sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    An example of a reflection group::\n\n        sage: W = ComplexReflectionGroups().example(); W\n        5-colored permutations of size 3\n\n    ``W`` is in the category of complex reflection groups::\n\n        sage: W in ComplexReflectionGroups()\n        True\n\n    TESTS::\n\n        sage: TestSuite(W).run()\n        sage: TestSuite(ComplexReflectionGroups()).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of complex reflection groups.\n\n    Let `V` be a complex vector space. A *complex reflection* is an\n    element of `\\operatorname{GL}(V)` fixing an hyperplane pointwise\n    and acting by multiplication by a root of unity on a complementary\n    line.\n\n    A *complex reflection group* is a group `W` that is (isomorphic\n    to) a subgroup of some general linear group `\\operatorname{GL}(V)`\n    generated by a distinguished set of complex reflections.\n\n    The dimension of `V` is the *rank* of `W`.\n\n    For a comprehensive treatment of complex reflection groups and\n    many definitions and theorems used here, we refer to [LT2009]_.\n    See also :wikipedia:`Reflection_group`.\n\n    .. SEEALSO::\n\n        :func:`ReflectionGroup` for usage examples of this category.\n\n    REFERENCES:\n\n    .. [LT2009] G.I. Lehrer and D.E. Taylor. *Unitary reflection groups*.\n       Australian Mathematical Society Lecture Series, 2009.\n\n    EXAMPLES::\n\n        sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n        sage: ComplexReflectionGroups()\n        Category of complex reflection groups\n        sage: ComplexReflectionGroups().super_categories()\n        [Category of complex reflection or generalized coxeter groups]\n        sage: ComplexReflectionGroups().all_super_categories()\n        [Category of complex reflection groups,\n         Category of complex reflection or generalized coxeter groups,\n         Category of groups,\n         Category of monoids,\n         Category of finitely generated semigroups,\n         Category of semigroups,\n         Category of finitely generated magmas,\n         Category of inverse unital magmas,\n         Category of unital magmas,\n         Category of magmas,\n         Category of enumerated sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    An example of a reflection group::\n\n        sage: W = ComplexReflectionGroups().example(); W\n        5-colored permutations of size 3\n\n    ``W`` is in the category of complex reflection groups::\n\n        sage: W in ComplexReflectionGroups()\n        True\n\n    TESTS::\n\n        sage: TestSuite(W).run()\n        sage: TestSuite(ComplexReflectionGroups()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.complex_reflection_groups.ComplexReflectionGroups",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.complex_reflection_or_generalized_coxeter_groups.ComplexReflectionOrGeneralizedCoxeterGroups"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of complex reflection groups.\n\n    Let `V` be a complex vector space. A *complex reflection* is an\n    element of `\\operatorname{GL}(V)` fixing an hyperplane pointwise\n    and acting by multiplication by a root of unity on a complementary\n    line.\n\n    A *complex reflection group* is a group `W` that is (isomorphic\n    to) a subgroup of some general linear group `\\operatorname{GL}(V)`\n    generated by a distinguished set of complex reflections.\n\n    The dimension of `V` is the *rank* of `W`.\n\n    For a comprehensive treatment of complex reflection groups and\n    many definitions and theorems used here, we refer to [LT2009]_.\n    See also :wikipedia:`Reflection_group`.\n\n    .. SEEALSO::\n\n        :func:`ReflectionGroup` for usage examples of this category.\n\n    REFERENCES:\n\n    .. [LT2009] G.I. Lehrer and D.E. Taylor. *Unitary reflection groups*.\n       Australian Mathematical Society Lecture Series, 2009.\n\n    EXAMPLES::\n\n        sage: from sage.categories.complex_reflection_groups import ComplexReflectionGroups\n        sage: ComplexReflectionGroups()\n        Category of complex reflection groups\n        sage: ComplexReflectionGroups().super_categories()\n        [Category of complex reflection or generalized coxeter groups]\n        sage: ComplexReflectionGroups().all_super_categories()\n        [Category of complex reflection groups,\n         Category of complex reflection or generalized coxeter groups,\n         Category of groups,\n         Category of monoids,\n         Category of finitely generated semigroups,\n         Category of semigroups,\n         Category of finitely generated magmas,\n         Category of inverse unital magmas,\n         Category of unital magmas,\n         Category of magmas,\n         Category of enumerated sets,\n         Category of sets,\n         Category of sets with partial maps,\n         Category of objects]\n\n    An example of a reflection group::\n\n        sage: W = ComplexReflectionGroups().example(); W\n        5-colored permutations of size 3\n\n    ``W`` is in the category of complex reflection groups::\n\n        sage: W in ComplexReflectionGroups()\n        True\n\n    TESTS::\n\n        sage: TestSuite(W).run()\n        sage: TestSuite(ComplexReflectionGroups()).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.DualObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Endset",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.homsets.Homsets.Endset",
            "sage.categories.modules.Modules.Homsets"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "name": "sage.categories.modules.Modules.Homsets.Endset",
        "parent_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.homsets.Homsets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.homsets.HomsetsOf",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.modules.Modules.Homsets"
        ],
        "subcategory_class": {
            "__doc__": "\n            The category of endomorphism sets `End(X)` for `X`\n            a module (this is not used yet)\n            ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of non-associative algebras over a given base ring.\n\n    A non-associative algebra over a ring `R` is a module over `R`\n    which s also a unital magma.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`UnitalAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.unital_algebras import UnitalAlgebras\n        sage: C = UnitalAlgebras(ZZ); C\n        Category of unital algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Unital()\n        True\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "Distributive"
        ],
        "element_class": {
            "__doc__": "\n        ``Magmas.Element.__mul__`` is preferable to ``Modules.Element.__mul__``\n        since the later does not handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of non-associative algebras over a given base ring.\n\n    A non-associative algebra over a ring `R` is a module over `R`\n    which s also a unital magma.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`UnitalAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.unital_algebras import UnitalAlgebras\n        sage: C = UnitalAlgebras(ZZ); C\n        Category of unital algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Unital()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.unital_algebras.UnitalAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "from_base_ring": {
                    "__doc__": "\n            Return the canonical embedding of ``r`` into ``self``.\n\n            INPUT:\n\n            - ``r`` -- an element of ``self.base_ring()``\n\n            EXAMPLES::\n\n                sage: A = AlgebrasWithBasis(QQ).example(); A\n                An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n                sage: A.from_base_ring(1)\n                B[word: ]\n            ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": "\n        ``Magmas.Element.__mul__`` is preferable to ``Modules.Element.__mul__``\n        since the later does not handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of modules with basis constructed by tensor product of\n        modules with basis.\n        ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of modules\n            with basis.\n            ",
            "methods": {
                "apply_multilinear_morphism": {
                    "__doc__": "\n                Return the result of applying the morphism induced by ``f``\n                to ``self``.\n\n                INPUT:\n\n                - ``f`` -- a multilinear morphism from the component\n                  modules of the parent tensor product to any module\n\n                - ``codomain`` -- the codomain of ``f`` (optional)\n\n                By the universal property of the tensor product, ``f``\n                induces a linear morphism from `self.parent()` to the\n                target module. Returns the result of applying that\n                morphism to ``self``.\n\n                The codomain is used for optimizations purposes\n                only. If it's not provided, it's recovered by calling\n                ``f`` on the zero input.\n\n                EXAMPLES:\n\n                We start with simple (admittedly not so interesting)\n                examples, with two modules `A` and `B`::\n\n                    sage: A = CombinatorialFreeModule(ZZ, [1,2], prefix=\"A\"); A.rename(\"A\")\n                    sage: B = CombinatorialFreeModule(ZZ, [3,4], prefix=\"B\"); B.rename(\"B\")\n\n                and `f` the bilinear morphism `(a,b) \\mapsto b \\otimes a`\n                from `A \\times B` to `B \\otimes A`::\n\n                    sage: def f(a,b):\n                    ....:     return tensor([b,a])\n\n                Now, calling applying `f` on `a \\otimes b` returns the same\n                as `f(a,b)`::\n\n                    sage: a = A.monomial(1) + 2 * A.monomial(2); a\n                    A[1] + 2*A[2]\n                    sage: b = B.monomial(3) - 2 * B.monomial(4); b\n                    B[3] - 2*B[4]\n                    sage: f(a,b)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n\n                `f` may be a bilinear morphism to any module over the\n                base ring of `A` and `B`. Here the codomain is `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients(), 0) * sum(b.coefficients(), 0)\n                    sage: f(a,b)\n                    -3\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    -3\n\n                Mind the `0` in the sums above; otherwise `f` would\n                not return `0` in `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients()) * sum(b.coefficients())\n                    sage: type(f(A.zero(), B.zero()))\n                    <type 'int'>\n\n                Which would be wrong and break this method::\n\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    Traceback (most recent call last):\n                    ...\n                    AttributeError: 'int' object has no attribute 'parent'\n\n                Here we consider an example where the codomain is a\n                module with basis with a different base ring::\n\n                    sage: C = CombinatorialFreeModule(QQ, [(1,3),(2,4)], prefix=\"C\"); C.rename(\"C\")\n                    sage: def f(a,b):\n                    ....:     return C.sum_of_terms( [((1,3), QQ(a[1]*b[3])), ((2,4), QQ(a[2]*b[4]))] )\n                    sage: f(a,b)\n                    C[(1, 3)] - 4*C[(2, 4)]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    C[(1, 3)] - 4*C[(2, 4)]\n\n                 We conclude with a real life application, where we\n                 check that the antipode of the Hopf algebra of\n                 Symmetric functions on the Schur basis satisfies its\n                 defining formula::\n\n                    sage: Sym = SymmetricFunctions(QQ)\n                    sage: s = Sym.schur()\n                    sage: def f(a,b): return a*b.antipode()\n                    sage: x = 4*s.an_element(); x\n                    8*s[] + 8*s[1] + 12*s[2]\n                    sage: x.coproduct().apply_multilinear_morphism(f)\n                    8*s[]\n                    sage: x.coproduct().apply_multilinear_morphism(f) == x.counit()\n                    True\n\n                We recover the constant term of `x`, as desired.\n\n                .. TODO::\n\n                    Extract a method to linearize a multilinear\n                    morphism, and delegate the work there.\n                ",
                    "args": [
                        "self",
                        "f",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "codomain"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.modules.Modules.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of modules with basis constructed by tensor product of\n        modules with basis.\n        ",
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts",
        "parent_class": {
            "__doc__": "\n            Implements operations on tensor products of modules with basis.\n            ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.additive_magmas.AdditiveMagmas"
        ],
        "subcategory_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of modules\n            with basis.\n            ",
            "methods": {
                "apply_multilinear_morphism": {
                    "__doc__": "\n                Return the result of applying the morphism induced by ``f``\n                to ``self``.\n\n                INPUT:\n\n                - ``f`` -- a multilinear morphism from the component\n                  modules of the parent tensor product to any module\n\n                - ``codomain`` -- the codomain of ``f`` (optional)\n\n                By the universal property of the tensor product, ``f``\n                induces a linear morphism from `self.parent()` to the\n                target module. Returns the result of applying that\n                morphism to ``self``.\n\n                The codomain is used for optimizations purposes\n                only. If it's not provided, it's recovered by calling\n                ``f`` on the zero input.\n\n                EXAMPLES:\n\n                We start with simple (admittedly not so interesting)\n                examples, with two modules `A` and `B`::\n\n                    sage: A = CombinatorialFreeModule(ZZ, [1,2], prefix=\"A\"); A.rename(\"A\")\n                    sage: B = CombinatorialFreeModule(ZZ, [3,4], prefix=\"B\"); B.rename(\"B\")\n\n                and `f` the bilinear morphism `(a,b) \\mapsto b \\otimes a`\n                from `A \\times B` to `B \\otimes A`::\n\n                    sage: def f(a,b):\n                    ....:     return tensor([b,a])\n\n                Now, calling applying `f` on `a \\otimes b` returns the same\n                as `f(a,b)`::\n\n                    sage: a = A.monomial(1) + 2 * A.monomial(2); a\n                    A[1] + 2*A[2]\n                    sage: b = B.monomial(3) - 2 * B.monomial(4); b\n                    B[3] - 2*B[4]\n                    sage: f(a,b)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    B[3] # A[1] + 2*B[3] # A[2] - 2*B[4] # A[1] - 4*B[4] # A[2]\n\n                `f` may be a bilinear morphism to any module over the\n                base ring of `A` and `B`. Here the codomain is `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients(), 0) * sum(b.coefficients(), 0)\n                    sage: f(a,b)\n                    -3\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    -3\n\n                Mind the `0` in the sums above; otherwise `f` would\n                not return `0` in `\\ZZ`::\n\n                    sage: def f(a,b):\n                    ....:     return sum(a.coefficients()) * sum(b.coefficients())\n                    sage: type(f(A.zero(), B.zero()))\n                    <type 'int'>\n\n                Which would be wrong and break this method::\n\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    Traceback (most recent call last):\n                    ...\n                    AttributeError: 'int' object has no attribute 'parent'\n\n                Here we consider an example where the codomain is a\n                module with basis with a different base ring::\n\n                    sage: C = CombinatorialFreeModule(QQ, [(1,3),(2,4)], prefix=\"C\"); C.rename(\"C\")\n                    sage: def f(a,b):\n                    ....:     return C.sum_of_terms( [((1,3), QQ(a[1]*b[3])), ((2,4), QQ(a[2]*b[4]))] )\n                    sage: f(a,b)\n                    C[(1, 3)] - 4*C[(2, 4)]\n                    sage: tensor([a,b]).apply_multilinear_morphism(f)\n                    C[(1, 3)] - 4*C[(2, 4)]\n\n                 We conclude with a real life application, where we\n                 check that the antipode of the Hopf algebra of\n                 Symmetric functions on the Schur basis satisfies its\n                 defining formula::\n\n                    sage: Sym = SymmetricFunctions(QQ)\n                    sage: s = Sym.schur()\n                    sage: def f(a,b): return a*b.antipode()\n                    sage: x = 4*s.an_element(); x\n                    8*s[] + 8*s[1] + 12*s[2]\n                    sage: x.coproduct().apply_multilinear_morphism(f)\n                    8*s[]\n                    sage: x.coproduct().apply_multilinear_morphism(f) == x.counit()\n                    True\n\n                We recover the constant term of `x`, as desired.\n\n                .. TODO::\n\n                    Extract a method to linearize a multilinear\n                    morphism, and delegate the work there.\n                ",
                    "args": [
                        "self",
                        "f",
                        "codomain"
                    ],
                    "argspec": [
                        [
                            "self",
                            "f",
                            "codomain"
                        ],
                        null,
                        null,
                        [
                            null
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.modules_with_basis.ModulesWithBasis.DualObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.CartesianProducts",
            "sage.categories.monoids.Monoids.CartesianProducts",
            "sage.categories.modules.Modules.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.CartesianProducts",
        "parent_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.monoids.Monoids.Subquotients",
            "sage.categories.semigroups.Semigroups.Quotients"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.Quotients",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets.Quotients",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of right modules\n    right modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with right multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: RightModules(QQ)\n        Category of right modules over Rational Field\n        sage: RightModules(QQ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(RightModules(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.commutative_additive_groups.CommutativeAdditiveGroups"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of right modules\n    right modules over an rng (ring not necessarily with unit), i.e.\n    an abelian group with right multiplation by elements of the rng\n\n    EXAMPLES::\n\n        sage: RightModules(QQ)\n        Category of right modules over Rational Field\n        sage: RightModules(QQ).super_categories()\n        [Category of commutative additive groups]\n\n    TESTS::\n\n        sage: TestSuite(RightModules(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.right_modules.RightModules",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of super modules with a distinguished basis.\n\n    An `R`-*super module with a distinguished basis* is an\n    `R`-super module equipped with an `R`-module basis whose elements are\n    homogeneous.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "even_component": {
                    "__doc__": "\n            Return the even component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.even_component()\n                x*y + 4\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x + y\n                sage: a.even_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_super_homogeneous": {
                    "__doc__": "\n            Return whether this element is homogeneous, in the sense\n            of a super module (i.e., is even or odd).\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x + y\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + x - 3*y + 4\n                sage: a.is_super_homogeneous()\n                False\n\n            The exterior algebra has a `\\ZZ` grading, which induces the\n            `\\ZZ / 2\\ZZ` grading. However the definition of homogeneous\n            elements differs because of the different gradings::\n\n                sage: E.<x,y> = ExteriorAlgebra(QQ)\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a.is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "odd_component": {
                    "__doc__": "\n            Return the odd component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.odd_component()\n                x - 3*y\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x*y\n                sage: a.odd_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces.WithBasis",
            "sage.categories.super_modules.SuperModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of super modules with a distinguished basis.\n\n    An `R`-*super module with a distinguished basis* is an\n    `R`-super module equipped with an `R`-module basis whose elements are\n    homogeneous.\n\n    EXAMPLES::\n\n        sage: C = GradedModulesWithBasis(ZZ); C\n        Category of graded modules with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered modules with basis over Integer Ring,\n         Category of graded modules over Integer Ring]\n        sage: C is ModulesWithBasis(ZZ).Graded()\n        True\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.super_modules_with_basis.SuperModulesWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_even_odd_on_basis": {
                    "__doc__": "\n            Return the parity of the basis element indexed by ``m``.\n\n            OUTPUT:\n\n            ``0`` if ``m`` is for an even element or ``1`` if ``m``\n            is for an odd element.\n\n            .. NOTE::\n\n                The default implementation assumes that the even/odd is\n                determined by the parity of :meth:`degree`.\n\n                Overwrite this method if the even/odd behavior is desired\n                to be independent.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: C._even_odd_on_basis((0,))\n                1\n                sage: C._even_odd_on_basis((0,1))\n                0\n            ",
                    "args": [
                        "self",
                        "m"
                    ],
                    "argspec": [
                        [
                            "self",
                            "m"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "even_component": {
                    "__doc__": "\n            Return the even component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.even_component()\n                x*y + 4\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x + y\n                sage: a.even_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_super_homogeneous": {
                    "__doc__": "\n            Return whether this element is homogeneous, in the sense\n            of a super module (i.e., is even or odd).\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x + y\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a = x*y + x - 3*y + 4\n                sage: a.is_super_homogeneous()\n                False\n\n            The exterior algebra has a `\\ZZ` grading, which induces the\n            `\\ZZ / 2\\ZZ` grading. However the definition of homogeneous\n            elements differs because of the different gradings::\n\n                sage: E.<x,y> = ExteriorAlgebra(QQ)\n                sage: a = x*y + 4\n                sage: a.is_super_homogeneous()\n                True\n                sage: a.is_homogeneous()\n                False\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "odd_component": {
                    "__doc__": "\n            Return the odd component of ``self``.\n\n            EXAMPLES::\n\n                sage: Q = QuadraticForm(QQ, 2, [1,2,3])\n                sage: C.<x,y> = CliffordAlgebra(Q)\n                sage: a = x*y + x - 3*y + 4\n                sage: a.odd_component()\n                x - 3*y\n\n            TESTS:\n\n            Check that this really return ``A.zero()`` and not a plain ``0``::\n\n                sage: a = x*y\n                sage: a.odd_component().parent() is C\n                True\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "FiniteDimensional",
            "GAP"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "mmt.WithBasis.GAP",
            "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "mmt.FiniteDimensional.GAP",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis",
            "sage.categories.unital_algebras.UnitalAlgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.unital_algebras.UnitalAlgebras.WithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "from_base_ring_from_one_basis": {
                    "__doc__": "\n                Implement the canonical embeding from the ground ring.\n\n                INPUT:\n\n                - ``r`` -- an element of the coefficient ring\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example()\n                    sage: A.from_base_ring_from_one_basis(3)\n                    3*B[word: ]\n                    sage: A.from_base_ring(3)\n                    3*B[word: ]\n                    sage: A(3)\n                    3*B[word: ]\n                ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "one_basis": {
                    "__doc__": "\n                When the one of an algebra with basis is an element of\n                this basis, this optional method can return the index of\n                this element. This is used to provide a default\n                implementation of :meth:`.one`, and an optimized default\n                implementation of :meth:`.from_base_ring`.\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example()\n                    sage: A.one_basis()\n                    word: \n                    sage: A.one()\n                    B[word: ]\n                    sage: A.from_base_ring(4)\n                    4*B[word: ]\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "one_from_one_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite dimensional algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = FiniteDimensionalAlgebrasWithBasis(QQ); C\n        Category of finite dimensional algebras with basis over Rational Field\n        sage: C.super_categories()\n        [Category of algebras with basis over Rational Field,\n         Category of finite dimensional modules with basis over Rational Field]\n        sage: C.example()\n        An example of a finite dimensional algebra with basis:\n        the path algebra of the Kronecker quiver\n        (containing the arrows a:x->y and b:x->y) over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Algebras(QQ).FiniteDimensional().WithBasis()\n        True\n        sage: C is Algebras(QQ).WithBasis().FiniteDimensional()\n        True\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "FiniteDimensional",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "_matrix_": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "on_left_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "to_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite dimensional algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = FiniteDimensionalAlgebrasWithBasis(QQ); C\n        Category of finite dimensional algebras with basis over Rational Field\n        sage: C.super_categories()\n        [Category of algebras with basis over Rational Field,\n         Category of finite dimensional modules with basis over Rational Field]\n        sage: C.example()\n        An example of a finite dimensional algebra with basis:\n        the path algebra of the Kronecker quiver\n        (containing the arrows a:x->y and b:x->y) over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Algebras(QQ).FiniteDimensional().WithBasis()\n        True\n        sage: C is Algebras(QQ).WithBasis().FiniteDimensional()\n        True\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_dimensional_algebras_with_basis.FiniteDimensionalAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "cartan_invariants_matrix": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "center": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "center_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "idempotent_lift": {
                    "__doc__": "\n            Lift an idempotent of the semisimple quotient into an idempotent of ``self``.\n\n            Let `A` be this finite dimensional algebra and `\\pi` be\n            the projection `A \\rightarrow \\overline{A}` on its\n            semisimple quotient. Let `\\overline{x}` be an idempotent\n            of `\\overline A`, and `x` any lift thereof in `A`. This\n            returns an idempotent `e` of `A` such that `\\pi(e)=\\pi(x)`\n            and `e` is a polynomial in `x`.\n\n            INPUT:\n\n            - `x` -- an element of `A` that projects on an idempotent\n              `\\overline x` of the semisimple quotient of `A`.\n              Alternatively one may give as input the idempotent\n              `\\overline{x}`, in which case some lift thereof will be\n              taken for `x`.\n\n            OUTPUT: the idempotent `e` of ``self``\n\n            ALGORITHM:\n\n            Iterate the formula `1 - (1 - x^2)^2` until having an\n            idempotent.\n\n            See [CR62]_ for correctness and termination proofs.\n\n            EXAMPLES::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example()\n                sage: S = A.semisimple_quotient()\n                sage: A.idempotent_lift(S.basis()['x'])\n                x\n                sage: A.idempotent_lift(A.basis()['y'])\n                y\n\n            .. TODO::\n\n                Add some non trivial example\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_commutative": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "is_identity_decomposition_into_orthogonal_idempotents": {
                    "__doc__": "\n            Return whether ``l`` is a decomposition of the identity\n            into orthogonal idempotents.\n\n            INPUT:\n\n            - ``l`` -- a list or iterable of elements of ``self``\n\n            EXAMPLES::\n\n                sage: A = FiniteDimensionalAlgebrasWithBasis(QQ).example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n\n                sage: x,y,a,b = A.algebra_generators(); x,y,a,b\n                (x, y, a, b)\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([A.one()])\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([x,y])\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([x+a, y-a])\n                True\n\n            Here the idempotents do not sum up to `1`::\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([x])\n                False\n\n            Here `1+x` and `-x` are neither idempotent nor orthogonal::\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([1+x,-x])\n                False\n\n            With the algebra of the `0`-Hecke monoid::\n\n                sage: from sage.monoids.hecke_monoid import HeckeMonoid\n                sage: A = HeckeMonoid(SymmetricGroup(4)).algebra(QQ)\n                sage: idempotents = A.orthogonal_idempotents_central_mod_radical()\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents(idempotents)\n                True\n\n            Here are some more counterexamples:\n\n            1. Some orthogonal elements summing to `1` but not being\n            idempotent::\n\n                sage: class PQAlgebra(CombinatorialFreeModule):\n                ....:     def __init__(self, F, p):\n                ....:         # Construct the quotient algebra F[x] / p,\n                ....:         # where p is a univariate polynomial.\n                ....:         R = parent(p); x = R.gen()\n                ....:         I = R.ideal(p)\n                ....:         self._xbar = R.quotient(I).gen()\n                ....:         basis_keys = [self._xbar**i for i in range(p.degree())]\n                ....:         CombinatorialFreeModule.__init__(self, F, basis_keys,\n                ....:                 category=Algebras(F).FiniteDimensional().WithBasis())\n                ....:     def x(self):\n                ....:         return self(self._xbar)\n                ....:     def one(self):\n                ....:         return self.basis()[self.base_ring().one()]\n                ....:     def product_on_basis(self, w1, w2):\n                ....:         return self.from_vector(vector(w1*w2))\n                sage: R.<x> = PolynomialRing(QQ)\n                sage: A = PQAlgebra(QQ, x**3 - x**2 + x + 1); y = A.x()\n                sage: a, b = y, 1-y\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, b))\n                False\n\n            For comparison::\n\n                sage: A = PQAlgebra(QQ, x**2 - x); y = A.x()\n                sage: a, b = y, 1-y\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, b))\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, A.zero(), b))\n                True\n                sage: A = PQAlgebra(QQ, x**3 - x**2 + x - 1); y = A.x()\n                sage: a = (y**2 + 1) / 2\n                sage: b = 1 - a\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, b))\n                True\n\n            2. Some idempotents summing to 1 but not orthogonal::\n\n                sage: R.<x> = PolynomialRing(GF(2))\n                sage: A = PQAlgebra(GF(2), x)\n                sage: a = A.one()\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a,))\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, a, a))\n                False\n\n            3. Some orthogonal idempotents not summing to the identity::\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a,a))\n                False\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents(())\n                False\n            ",
                    "args": [
                        "self",
                        "l"
                    ],
                    "argspec": [
                        [
                            "self",
                            "l"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "isotypic_projective_modules": {
                    "__doc__": "\n            Return the isotypic projective ``side`` ``self``-modules.\n\n            Let `P_i` be representatives of the indecomposable\n            projective ``side``-modules of this finite dimensional\n            algebra `A`, and `S_i` be the associated simple modules.\n\n            The regular ``side`` representation of `A` can be\n            decomposed as a direct sum `A = \\bigoplus_i Q_i` where\n            each `Q_i` is an isotypic projective module; namely `Q_i`\n            is the direct sum of `\\dim S_i` copies of the\n            indecomposable projective module `P_i`. This decomposition\n            is not unique.\n\n            The isotypic projective modules are constructed as\n            `Q_i=e_iA`, where the `(e_i)_i` is the decomposition of\n            the identity into orthogonal idempotents obtained by\n            lifting the central orthogonal idempotents of the\n            semisimple quotient of `A`.\n\n            INPUT:\n\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            OUTPUT: a list of subspaces of ``self``.\n\n            EXAMPLES::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: Q = A.isotypic_projective_modules(side=\"left\"); Q\n                [Free module generated by {0} over Rational Field,\n                 Free module generated by {0, 1, 2} over Rational Field]\n                sage: [[x.lift() for x in Qi.basis()]\n                ....:  for Qi in Q]\n                [[x],\n                 [y, a, b]]\n\n            We check that the sum of the dimensions of the isotypic\n            projective modules is the dimension of ``self``::\n\n                sage: sum([Qi.dimension() for Qi in Q]) == A.dimension()\n                True\n\n            .. SEEALSO::\n\n                - :meth:`orthogonal_idempotents_central_mod_radical`\n                - :meth:`peirce_decomposition`\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "left"
                        ]
                    ]
                },
                "orthogonal_idempotents_central_mod_radical": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "peirce_decomposition": {
                    "__doc__": "\n            Return a Peirce decomposition of ``self``.\n\n            Let `(e_i)_i` be a collection of orthogonal idempotents of\n            `A` with sum `1`. The *Peirce decomposition* of `A` is the\n            decomposition of `A` into the direct sum of the subspaces\n            `e_i A e_j`.\n\n            With the default collection of orthogonal idempotents, one has\n\n            .. MATH::\n\n                \\dim e_i A e_j = C_{i,j} \\dim S_i \\dim S_j\n\n            where `(S_i)_i` are the simple modules of `A` and\n            `(C_{i,j})_{i, j}` is the Cartan invariants matrix.\n\n            INPUT:\n\n            - ``idempotents`` -- a list of orthogonal idempotents\n              `(e_i)_{i=0,\\ldots,n}` of the algebra that sum to `1`\n              (default: the idempotents returned by\n              :meth:`orthogonal_idempotents_central_mod_radical`)\n\n            - ``check`` -- (default: ``True``) whether to check that the\n              idempotents are indeed orthogonal and idempotent and\n              sum to `1`\n\n            OUTPUT:\n\n            A list of lists `l` such that ``l[i][j]`` is the subspace\n            `e_i A e_j`.\n\n            .. SEEALSO::\n\n                - :meth:`orthogonal_idempotents_central_mod_radical`\n                - :meth:`cartan_invariants_matrix`\n\n            EXAMPLES::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: A.orthogonal_idempotents_central_mod_radical()\n                (x, y)\n                sage: decomposition = A.peirce_decomposition(); decomposition\n                [[Free module generated by {0} over Rational Field,\n                  Free module generated by {0, 1} over Rational Field],\n                 [Free module generated by {} over Rational Field,\n                  Free module generated by {0} over Rational Field]]\n                sage: [ [[x.lift() for x in decomposition[i][j].basis()]\n                ....:    for j in range(2)]\n                ....:   for i in range(2)]\n                [[[x], [a, b]],\n                 [[], [y]]]\n\n            We recover that the group algebra of the symmetric group\n            `S_4` is a block matrix algebra::\n\n                sage: A = SymmetricGroup(4).algebra(QQ)\n                sage: decomposition = A.peirce_decomposition()   # long time\n                sage: [[decomposition[i][j].dimension()          # long time (4s)\n                ....:   for j in range(len(decomposition))]\n                ....:  for i in range(len(decomposition))]\n                [[1, 0, 0, 0, 0],\n                 [0, 9, 0, 0, 0],\n                 [0, 0, 4, 0, 0],\n                 [0, 0, 0, 9, 0],\n                 [0, 0, 0, 0, 1]]\n\n            The dimension of each block is `d^2`, where `d` is the\n            dimension of the corresponding simple module of `S_4`. The\n            latter are given by::\n\n                sage: [p.standard_tableaux().cardinality() for p in Partitions(4)]\n                [1, 3, 2, 3, 1]\n            ",
                    "args": [
                        "self",
                        "idempotents",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "idempotents",
                            "check"
                        ],
                        null,
                        null,
                        [
                            null,
                            true
                        ]
                    ]
                },
                "peirce_summand": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "principal_ideal": {
                    "__doc__": "\n            Construct the ``side`` principal ideal generated by ``a``.\n\n            EXAMPLES:\n\n            In order to highlight the difference between left and\n            right principal ideals, our first example deals with a non\n            commutative algebra::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: x, y, a, b = A.basis()\n\n            In this algebra, multiplication on the right by `x`\n            annihilates all basis elements but `x`::\n\n                sage: x*x, y*x, a*x, b*x\n                (x, 0, 0, 0)\n\n            so the left ideal generated by `x` is one-dimensional::\n\n                sage: Ax = A.principal_ideal(x, side='left'); Ax\n                Free module generated by {0} over Rational Field\n                sage: [B.lift() for B in Ax.basis()]\n                [x]\n\n            Multiplication on the left by `x` annihilates\n            only `x` and fixes the other basis elements::\n\n                sage: x*x, x*y, x*a, x*b\n                (x, 0, a, b)\n\n            so the right ideal generated by `x` is 3-dimensional::\n\n                sage: xA = A.principal_ideal(x, side='right'); xA\n                Free module generated by {0, 1, 2} over Rational Field\n                sage: [B.lift() for B in xA.basis()]\n                [x, a, b]\n\n            .. SEEALSO::\n\n                - :meth:`peirce_summand`\n            ",
                    "args": [
                        "self",
                        "a",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "a",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "left"
                        ]
                    ]
                },
                "radical": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "radical_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "semisimple_quotient": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "_matrix_": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "on_left_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "to_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded algebras with a distinguished basis\n\n    EXAMPLES::\n\n        sage: C = GradedAlgebrasWithBasis(ZZ); C\n        Category of graded algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered algebras with basis over Integer Ring,\n         Category of graded algebras over Integer Ring,\n         Category of graded modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_algebras_with_basis.FilteredAlgebrasWithBasis",
            "sage.categories.graded_algebras.GradedAlgebras",
            "sage.categories.graded_modules_with_basis.GradedModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded algebras with a distinguished basis\n\n    EXAMPLES::\n\n        sage: C = GradedAlgebrasWithBasis(ZZ); C\n        Category of graded algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered algebras with basis over Integer Ring,\n         Category of graded algebras over Integer Ring,\n         Category of graded modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_algebras_with_basis.GradedAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.algebras.Algebras.CartesianProducts",
            "sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
            "methods": {}
        },
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "one_from_cartesian_product_of_one_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras with basis constructed by tensor product of algebras with basis\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of algebras with basis\n            ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.algebras.Algebras.TensorProducts",
            "sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of algebras with basis constructed by tensor product of algebras with basis\n        ",
            "methods": {}
        },
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis.TensorProducts",
        "parent_class": {
            "__doc__": "\n            implements operations on tensor products of algebras with basis\n            ",
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of algebras with basis\n            ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "Distributive",
            "AdditiveUnital",
            "AdditiveAssociative",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital",
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.magmatic_algebras.MagmaticAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "algebra_generators": {
                    "__doc__": "\n            Return a family of generators of this algebra.\n\n            EXAMPLES::\n\n                sage: F = AlgebrasWithBasis(QQ).example(); F\n                An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n                sage: F.algebra_generators()\n                Family (B[word: a], B[word: b], B[word: c])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of coalgebras\n\n    EXAMPLES::\n\n        sage: Coalgebras(QQ)\n        Category of coalgebras over Rational Field\n        sage: Coalgebras(QQ).super_categories()\n        [Category of vector spaces over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(Coalgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "coproduct": {
                    "__doc__": "\n            Returns the coproduct of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.coproduct()\n                (B[(1,2,3)], B[(1,2,3)] # B[(1,2,3)])\n                sage: b, b.coproduct()\n                (B[(1,3)], B[(1,3)] # B[(1,3)])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit": {
                    "__doc__": "\n            Returns the counit of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.counit()\n                (B[(1,2,3)], 1)\n                sage: b, b.counit()\n                (B[(1,3)], 1)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules.Modules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of coalgebras\n\n    EXAMPLES::\n\n        sage: Coalgebras(QQ)\n        Category of coalgebras over Rational Field\n        sage: Coalgebras(QQ).super_categories()\n        [Category of vector spaces over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(Coalgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "coproduct": {
                    "__doc__": "\n            Returns the coproduct of x.\n\n            Eventually, there will be a default implementation,\n            delegating to the overloading mechanism and forcing the\n            conversion back\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, A.coproduct(a)\n                (B[(1,2,3)], B[(1,2,3)] # B[(1,2,3)])\n                sage: b, A.coproduct(b)\n                (B[(1,3)], B[(1,3)] # B[(1,3)])\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit": {
                    "__doc__": "\n            Returns the counit of x.\n\n            Eventually, there will be a default implementation,\n            delegating to the overloading mechanism and forcing the\n            conversion back\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, A.counit(a)\n                (B[(1,2,3)], 1)\n                sage: b, A.counit(b)\n                (B[(1,3)], 1)\n\n            TODO: implement some tests of the axioms of coalgebras, bialgebras\n            and Hopf algebras using the counit.\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "coproduct": {
                    "__doc__": "\n            Returns the coproduct of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.coproduct()\n                (B[(1,2,3)], B[(1,2,3)] # B[(1,2,3)])\n                sage: b, b.coproduct()\n                (B[(1,3)], B[(1,3)] # B[(1,3)])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit": {
                    "__doc__": "\n            Returns the counit of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.counit()\n                (B[(1,2,3)], 1)\n                sage: b, b.counit()\n                (B[(1,3)], 1)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of associative and unital algebras over a given base ring.\n\n    An associative and unital algebra over a ring `R` is a module over\n    `R` which is itself a ring.\n\n    .. WARNING::\n\n        :class:`Algebras` will be eventually be replaced by\n        :class:`.magmatic_algebras.MagmaticAlgebras`\n        for consistency with e.g. :wikipedia:`Algebras` which assumes\n        neither associativity nor the existence of a unit (see\n        :trac:`15043`).\n\n    .. TODO:: Should `R` be a commutative ring?\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ)\n        Category of algebras over Integer Ring\n        sage: sorted(Algebras(ZZ).super_categories(), key=str)\n        [Category of associative algebras over Integer Ring,\n         Category of rings,\n         Category of unital algebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.rings.Rings",
            "sage.categories.associative_algebras.AssociativeAlgebras",
            "sage.categories.unital_algebras.UnitalAlgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of associative and unital algebras over a given base ring.\n\n    An associative and unital algebra over a ring `R` is a module over\n    `R` which is itself a ring.\n\n    .. WARNING::\n\n        :class:`Algebras` will be eventually be replaced by\n        :class:`.magmatic_algebras.MagmaticAlgebras`\n        for consistency with e.g. :wikipedia:`Algebras` which assumes\n        neither associativity nor the existence of a unit (see\n        :trac:`15043`).\n\n    .. TODO:: Should `R` be a commutative ring?\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ)\n        Category of algebras over Integer Ring\n        sage: sorted(Algebras(ZZ).super_categories(), key=str)\n        [Category of associative algebras over Integer Ring,\n         Category of rings,\n         Category of unital algebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras",
        "parent_class": {
            "__doc__": "\n    The category of associative and unital algebras over a given base ring.\n\n    An associative and unital algebra over a ring `R` is a module over\n    `R` which is itself a ring.\n\n    .. WARNING::\n\n        :class:`Algebras` will be eventually be replaced by\n        :class:`.magmatic_algebras.MagmaticAlgebras`\n        for consistency with e.g. :wikipedia:`Algebras` which assumes\n        neither associativity nor the existence of a unit (see\n        :trac:`15043`).\n\n    .. TODO:: Should `R` be a commutative ring?\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ)\n        Category of algebras over Integer Ring\n        sage: sorted(Algebras(ZZ).super_categories(), key=str)\n        [Category of associative algebras over Integer Ring,\n         Category of rings,\n         Category of unital algebras over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered algebras with a distinguished\n    homogeneous basis.\n\n    A filtered algebra with basis over a commutative ring `R`\n    is a filtered algebra over `R` endowed with the structure\n    of a filtered module with basis (with the same underlying\n    filtered-module structure). See\n    :class:`~sage.categories.filtered_algebras.FilteredAlgebras` and\n    :class:`~sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis`\n    for these two notions.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(ZZ).Filtered(); C\n        Category of filtered algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras with basis over Integer Ring,\n         Category of filtered algebras over Integer Ring,\n         Category of filtered modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.filtered_algebras.FilteredAlgebras",
            "sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered algebras with a distinguished\n    homogeneous basis.\n\n    A filtered algebra with basis over a commutative ring `R`\n    is a filtered algebra over `R` endowed with the structure\n    of a filtered module with basis (with the same underlying\n    filtered-module structure). See\n    :class:`~sage.categories.filtered_algebras.FilteredAlgebras` and\n    :class:`~sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis`\n    for these two notions.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(ZZ).Filtered(); C\n        Category of filtered algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras with basis over Integer Ring,\n         Category of filtered algebras over Integer Ring,\n         Category of filtered modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_algebras_with_basis.FilteredAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(QQ); C\n        Category of algebras with basis over Rational Field\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras over Rational Field,\n         Category of unital algebras with basis over Rational Field]\n\n    We construct a typical parent in this category, and do some\n    computations with it::\n\n        sage: A = C.example(); A\n        An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n\n        sage: A.category()\n        Category of algebras with basis over Rational Field\n\n        sage: A.one_basis()\n        word:\n        sage: A.one()\n        B[word: ]\n\n        sage: A.base_ring()\n        Rational Field\n        sage: A.basis().keys()\n        Finite words over {'a', 'b', 'c'}\n\n        sage: (a,b,c) = A.algebra_generators()\n        sage: a^3, b^2\n        (B[word: aaa], B[word: bb])\n        sage: a*c*b\n        B[word: acb]\n\n        sage: A.product\n        <bound method FreeAlgebra_with_category._product_from_product_on_basis_multiply of\n         An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field>\n        sage: A.product(a*b,b)\n        B[word: abb]\n\n        sage: TestSuite(A).run(verbose=True)\n        running ._test_additive_associativity() . . . pass\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_characteristic() . . . pass\n        running ._test_distributivity() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_nonzero_equal() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_zero() . . . pass\n        sage: A.__class__\n        <class 'sage.categories.examples.algebras_with_basis.FreeAlgebra_with_category'>\n        sage: A.element_class\n        <class 'sage.combinat.free_module.FreeAlgebra_with_category.element_class'>\n\n    Please see the source code of `A` (with ``A??``) for how to\n    implement other algebras with basis.\n\n    TESTS::\n\n        sage: TestSuite(AlgebrasWithBasis(QQ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.unital_algebras.UnitalAlgebras.WithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(QQ); C\n        Category of algebras with basis over Rational Field\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras over Rational Field,\n         Category of unital algebras with basis over Rational Field]\n\n    We construct a typical parent in this category, and do some\n    computations with it::\n\n        sage: A = C.example(); A\n        An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n\n        sage: A.category()\n        Category of algebras with basis over Rational Field\n\n        sage: A.one_basis()\n        word:\n        sage: A.one()\n        B[word: ]\n\n        sage: A.base_ring()\n        Rational Field\n        sage: A.basis().keys()\n        Finite words over {'a', 'b', 'c'}\n\n        sage: (a,b,c) = A.algebra_generators()\n        sage: a^3, b^2\n        (B[word: aaa], B[word: bb])\n        sage: a*c*b\n        B[word: acb]\n\n        sage: A.product\n        <bound method FreeAlgebra_with_category._product_from_product_on_basis_multiply of\n         An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field>\n        sage: A.product(a*b,b)\n        B[word: abb]\n\n        sage: TestSuite(A).run(verbose=True)\n        running ._test_additive_associativity() . . . pass\n        running ._test_an_element() . . . pass\n        running ._test_associativity() . . . pass\n        running ._test_cardinality() . . . pass\n        running ._test_category() . . . pass\n        running ._test_characteristic() . . . pass\n        running ._test_distributivity() . . . pass\n        running ._test_elements() . . .\n          Running the test suite of self.an_element()\n          running ._test_category() . . . pass\n          running ._test_eq() . . . pass\n          running ._test_nonzero_equal() . . . pass\n          running ._test_not_implemented_methods() . . . pass\n          running ._test_pickling() . . . pass\n          pass\n        running ._test_elements_eq_reflexive() . . . pass\n        running ._test_elements_eq_symmetric() . . . pass\n        running ._test_elements_eq_transitive() . . . pass\n        running ._test_elements_neq() . . . pass\n        running ._test_eq() . . . pass\n        running ._test_not_implemented_methods() . . . pass\n        running ._test_one() . . . pass\n        running ._test_pickling() . . . pass\n        running ._test_prod() . . . pass\n        running ._test_some_elements() . . . pass\n        running ._test_zero() . . . pass\n        sage: A.__class__\n        <class 'sage.categories.examples.algebras_with_basis.FreeAlgebra_with_category'>\n        sage: A.element_class\n        <class 'sage.combinat.free_module.FreeAlgebra_with_category.element_class'>\n\n    Please see the source code of `A` (with ``A??``) for how to\n    implement other algebras with basis.\n\n    TESTS::\n\n        sage: TestSuite(AlgebrasWithBasis(QQ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_product_from_combinatorial_algebra_multiply": {
                    "__doc__": "\n            Returns left\\*right where left and right are elements of self.\n            product() uses either _multiply or _multiply basis to carry out\n            the actual multiplication.\n\n            EXAMPLES::\n\n                sage: s = SymmetricFunctions(QQ).schur()\n                sage: a = s([2])\n                sage: s._product_from_combinatorial_algebra_multiply(a,a)\n                s[2, 2] + s[3, 1] + s[4]\n                sage: s.product(a,a)\n                s[2, 2] + s[3, 1] + s[4]\n            ",
                    "args": [
                        "self",
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "hochschild_complex": {
                    "__doc__": "\n            Return the Hochschild complex of ``self`` with coefficients\n            in ``M``.\n\n            .. SEEALSO::\n\n                :class:`~sage.homology.hochschild_complex.HochschildComplex`\n\n            EXAMPLES::\n\n                sage: R.<x> = QQ[]\n                sage: A = algebras.DifferentialWeyl(R)\n                sage: H = A.hochschild_complex(A)\n\n                sage: SGA = SymmetricGroupAlgebra(QQ, 3)\n                sage: T = SGA.trivial_representation()\n                sage: H = SGA.hochschild_complex(T)\n            ",
                    "args": [
                        "self",
                        "M"
                    ],
                    "argspec": [
                        [
                            "self",
                            "M"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.CartesianProducts",
            "sage.categories.monoids.Monoids.CartesianProducts",
            "sage.categories.vector_spaces.VectorSpaces.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.CartesianProducts",
        "parent_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of algebras constructed as Cartesian products of algebras\n\n        This construction gives the direct product of algebras. See\n        discussion on:\n\n         - http://groups.google.fr/group/sage-devel/browse_thread/thread/35a72b1d0a2fc77a/348f42ae77a66d16#348f42ae77a66d16\n         - http://en.wikipedia.org/wiki/Direct_product\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade",
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.WithRealizations",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.WithRealizations",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.vector_spaces.VectorSpaces.DualObjects"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.DualObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.graded_algebras.GradedAlgebras",
            "sage.categories.super_modules.SuperModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.super_algebras.SuperAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of super algebras.\n\n    An `R`-*super algebra* is an `R`-super module `A` endowed with an\n    `R`-algebra structure satisfying\n\n    .. MATH::\n\n        A_0 A_0 \\subseteq A_0, \\qquad\n        A_0 A_1 \\subseteq A_1, \\qquad\n        A_1 A_0 \\subseteq A_1, \\qquad\n        A_1 A_1 \\subseteq A_0\n\n    and `1 \\in A_0`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Super()\n        Category of super algebras over Integer Ring\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Super()).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras",
            "sage.categories.modules_with_basis.ModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_product_from_product_on_basis_multiply": {
                    "__doc__": "\n                Computes the product of two elements by extending\n                bilinearly the method :meth:`product_on_basis`.\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example(); A\n                    An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n                    sage: (a,b,c) = A.algebra_generators()\n                    sage: A._product_from_product_on_basis_multiply(a*b + 2*c, a - b)\n                    B[word: aba] - B[word: abb] + 2*B[word: ca] - 2*B[word: cb]\n\n                ",
                    "args": [
                        "self",
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "product_on_basis": {
                    "__doc__": "\n                The product of the algebra on the basis (optional).\n\n                INPUT:\n\n                - ``i``, ``j`` -- the indices of two elements of the\n                  basis of ``self``\n\n                Return the product of the two corresponding basis elements\n                indexed by ``i`` and ``j``.\n\n                If implemented, :meth:`product` is defined from\n                it by bilinearity.\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example()\n                    sage: Word = A.basis().keys()\n                    sage: A.product_on_basis(Word(\"abc\"),Word(\"cba\"))\n                    B[word: abccba]\n                ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.monoids.Monoids.Subquotients",
            "sage.categories.semigroups.Semigroups.Quotients"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.Quotients",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets.Quotients",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets.Subquotients",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.super_modules.SuperModules",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.Super",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of non-associative algebras over a given base ring.\n\n    A non-associative algebra over a ring `R` is a module over `R`\n    which s also a unital magma.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`UnitalAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.unital_algebras import UnitalAlgebras\n        sage: C = UnitalAlgebras(ZZ); C\n        Category of unital algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Unital()\n        True\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "Distributive"
        ],
        "element_class": {
            "__doc__": "\n        ``Magmas.Element.__mul__`` is preferable to ``Modules.Element.__mul__``\n        since the later does not handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras",
            "sage.categories.magmas.Magmas.Unital"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of non-associative algebras over a given base ring.\n\n    A non-associative algebra over a ring `R` is a module over `R`\n    which s also a unital magma.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`UnitalAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.unital_algebras import UnitalAlgebras\n        sage: C = UnitalAlgebras(ZZ); C\n        Category of unital algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Unital()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.unital_algebras.UnitalAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "from_base_ring": {
                    "__doc__": "\n            Return the canonical embedding of ``r`` into ``self``.\n\n            INPUT:\n\n            - ``r`` -- an element of ``self.base_ring()``\n\n            EXAMPLES::\n\n                sage: A = AlgebrasWithBasis(QQ).example(); A\n                An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n                sage: A.from_base_ring(1)\n                B[word: ]\n            ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": "\n        ``Magmas.Element.__mul__`` is preferable to ``Modules.Element.__mul__``\n        since the later does not handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.vector_spaces.VectorSpaces.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.algebras.Algebras.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.DualObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.magmas.Magmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded algebras\n\n    EXAMPLES::\n\n        sage: GradedAlgebras(ZZ)\n        Category of graded algebras over Integer Ring\n        sage: GradedAlgebras(ZZ).super_categories()\n        [Category of filtered algebras over Integer Ring,\n         Category of graded modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(GradedAlgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_algebras.FilteredAlgebras",
            "sage.categories.graded_modules.GradedModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded algebras\n\n    EXAMPLES::\n\n        sage: GradedAlgebras(ZZ)\n        Category of graded algebras over Integer Ring\n        sage: GradedAlgebras(ZZ).super_categories()\n        [Category of filtered algebras over Integer Ring,\n         Category of graded modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(GradedAlgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_algebras.GradedAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
        "axioms": [
            "AdditiveUnital",
            "Commutative",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.commutative_rings.CommutativeRings"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "name": "sage.categories.commutative_algebras.CommutativeAlgebras",
        "parent_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of commutative algebras with unit over a given base ring.\n\n    EXAMPLES::\n\n        sage: M = CommutativeAlgebras(GF(19))\n        sage: M\n        Category of commutative algebras over Finite Field of size 19\n        sage: CommutativeAlgebras(QQ).super_categories()\n        [Category of algebras over Rational Field, Category of commutative rings]\n\n    This is just a shortcut for::\n\n        sage: Algebras(QQ).Commutative()\n        Category of commutative algebras over Rational Field\n\n    TESTS::\n\n        sage: Algebras(QQ).Commutative() is CommutativeAlgebras(QQ)\n        True\n        sage: TestSuite(CommutativeAlgebras(ZZ)).run()\n\n    Todo:\n\n     - product   ( = Cartesian product)\n     - coproduct ( = tensor product over base ring)\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.sets_cat.Sets.Realizations"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.Realizations",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "coproduct_by_coercion": {
                    "__doc__": "\n                Return the coproduct by coercion if ``coproduct_by_basis``\n                is not implemented.\n\n                EXAMPLES::\n\n                    sage: Sym = SymmetricFunctions(QQ)\n                    sage: m = Sym.monomial()\n                    sage: f = m[2,1]\n                    sage: f.coproduct.__module__\n                    'sage.categories.coalgebras'\n                    sage: m.coproduct_on_basis\n                    NotImplemented\n                    sage: m.coproduct == m.coproduct_by_coercion\n                    True\n                    sage: f.coproduct()\n                    m[] # m[2, 1] + m[1] # m[2] + m[2] # m[1] + m[2, 1] # m[]\n\n                ::\n\n                    sage: N = NonCommutativeSymmetricFunctions(QQ)\n                    sage: R = N.ribbon()\n                    sage: R.coproduct_by_coercion.__module__\n                    'sage.categories.coalgebras'\n                    sage: R.coproduct_on_basis\n                    NotImplemented\n                    sage: R.coproduct == R.coproduct_by_coercion\n                    True\n                    sage: R[1].coproduct()\n                    R[] # R[1] + R[1] # R[]\n                ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit_by_coercion": {
                    "__doc__": "\n                Return the counit of ``x`` if ``counit_by_basis`` is\n                not implemented.\n\n                EXAMPLES::\n\n                    sage: sp = SymmetricFunctions(QQ).sp()\n                    sage: sp.an_element()\n                    2*sp[] + 2*sp[1] + 3*sp[2]\n                    sage: sp.counit(sp.an_element())\n                    2\n\n                    sage: o = SymmetricFunctions(QQ).o()\n                    sage: o.an_element()\n                    2*o[] + 2*o[1] + 3*o[2]\n                    sage: o.counit(o.an_element())\n                    -1\n                ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of coalgebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: CoalgebrasWithBasis(ZZ)\n        Category of coalgebras with basis over Integer Ring\n        sage: sorted(CoalgebrasWithBasis(ZZ).super_categories(), key=str)\n        [Category of coalgebras over Integer Ring,\n         Category of modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(CoalgebrasWithBasis(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "coproduct_iterated": {
                    "__doc__": "\n            Apply ``n`` coproducts to ``self``.\n\n            .. TODO::\n\n                Remove dependency on ``modules_with_basis`` methods.\n\n            EXAMPLES::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(2)\n                Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[2, 2] # Psi[] + 2*Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[2] # Psi[2] # Psi[] + Psi[2, 2] # Psi[] # Psi[]\n\n            TESTS::\n\n                sage: p = SymmetricFunctions(QQ).p()\n                sage: p[5,2,2].coproduct_iterated()\n                p[] # p[5, 2, 2] + 2*p[2] # p[5, 2] + p[2, 2] # p[5]\n                 + p[5] # p[2, 2] + 2*p[5, 2] # p[2] + p[5, 2, 2] # p[]\n                sage: p([]).coproduct_iterated(3)\n                p[] # p[] # p[] # p[]\n\n            ::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(3)\n                Psi[] # Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[] # Psi[2, 2] # Psi[] + 2*Psi[] # Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[] # Psi[2] # Psi[2] # Psi[] + Psi[] # Psi[2, 2] # Psi[] # Psi[]\n                 + 2*Psi[2] # Psi[] # Psi[] # Psi[2] + 2*Psi[2] # Psi[] # Psi[2] # Psi[]\n                 + 2*Psi[2] # Psi[2] # Psi[] # Psi[] + Psi[2, 2] # Psi[] # Psi[] # Psi[]\n\n            ::\n\n                sage: m = SymmetricFunctionsNonCommutingVariables(QQ).m()\n                sage: m[[1,3],[2]].coproduct_iterated(2)\n                m{} # m{} # m{{1, 3}, {2}} + m{} # m{{1}} # m{{1, 2}}\n                 + m{} # m{{1, 2}} # m{{1}} + m{} # m{{1, 3}, {2}} # m{}\n                 + m{{1}} # m{} # m{{1, 2}} + m{{1}} # m{{1, 2}} # m{}\n                 + m{{1, 2}} # m{} # m{{1}} + m{{1, 2}} # m{{1}} # m{}\n                 + m{{1, 3}, {2}} # m{} # m{}\n                sage: m[[]].coproduct_iterated(3), m[[1,3],[2]].coproduct_iterated(0)\n                (m{} # m{} # m{} # m{}, m{{1, 3}, {2}})\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        [
                            1
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.modules_with_basis.ModulesWithBasis",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of coalgebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: CoalgebrasWithBasis(ZZ)\n        Category of coalgebras with basis over Integer Ring\n        sage: sorted(CoalgebrasWithBasis(ZZ).super_categories(), key=str)\n        [Category of coalgebras over Integer Ring,\n         Category of modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(CoalgebrasWithBasis(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "coproduct_on_basis": {
                    "__doc__": "\n            The coproduct of the algebra on the basis (optional).\n\n            INPUT:\n\n            - ``i`` -- the indices of an element of the basis of ``self``\n\n            Returns the coproduct of the corresponding basis elements\n            If implemented, the coproduct of the algebra is defined\n            from it by linearity.\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: (a, b) = A._group.gens()\n                sage: A.coproduct_on_basis(a)\n                B[(1,2,3)] # B[(1,2,3)]\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit_on_basis": {
                    "__doc__": "\n            The counit of the algebra on the basis (optional).\n\n            INPUT:\n\n            - ``i`` -- the indices of an element of the basis of ``self``\n\n            Returns the counit of the corresponding basis elements\n            If implemented, the counit of the algebra is defined\n            from it by linearity.\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: (a, b) = A._group.gens()\n                sage: A.counit_on_basis(a)\n                1\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "coproduct_iterated": {
                    "__doc__": "\n            Apply ``n`` coproducts to ``self``.\n\n            .. TODO::\n\n                Remove dependency on ``modules_with_basis`` methods.\n\n            EXAMPLES::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(2)\n                Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[2, 2] # Psi[] + 2*Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[2] # Psi[2] # Psi[] + Psi[2, 2] # Psi[] # Psi[]\n\n            TESTS::\n\n                sage: p = SymmetricFunctions(QQ).p()\n                sage: p[5,2,2].coproduct_iterated()\n                p[] # p[5, 2, 2] + 2*p[2] # p[5, 2] + p[2, 2] # p[5]\n                 + p[5] # p[2, 2] + 2*p[5, 2] # p[2] + p[5, 2, 2] # p[]\n                sage: p([]).coproduct_iterated(3)\n                p[] # p[] # p[] # p[]\n\n            ::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(3)\n                Psi[] # Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[] # Psi[2, 2] # Psi[] + 2*Psi[] # Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[] # Psi[2] # Psi[2] # Psi[] + Psi[] # Psi[2, 2] # Psi[] # Psi[]\n                 + 2*Psi[2] # Psi[] # Psi[] # Psi[2] + 2*Psi[2] # Psi[] # Psi[2] # Psi[]\n                 + 2*Psi[2] # Psi[2] # Psi[] # Psi[] + Psi[2, 2] # Psi[] # Psi[] # Psi[]\n\n            ::\n\n                sage: m = SymmetricFunctionsNonCommutingVariables(QQ).m()\n                sage: m[[1,3],[2]].coproduct_iterated(2)\n                m{} # m{} # m{{1, 3}, {2}} + m{} # m{{1}} # m{{1, 2}}\n                 + m{} # m{{1, 2}} # m{{1}} + m{} # m{{1, 3}, {2}} # m{}\n                 + m{{1}} # m{} # m{{1, 2}} + m{{1}} # m{{1, 2}} # m{}\n                 + m{{1, 2}} # m{} # m{{1}} + m{{1, 2}} # m{{1}} # m{}\n                 + m{{1, 3}, {2}} # m{} # m{}\n                sage: m[[]].coproduct_iterated(3), m[[1,3],[2]].coproduct_iterated(0)\n                (m{} # m{} # m{} # m{}, m{{1, 3}, {2}})\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        [
                            1
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.filtered_modules.FilteredModules"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_algebras.FilteredAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "graded_algebra": {
                    "__doc__": "\n            Return the associated graded algebra to ``self``.\n\n            .. TODO::\n\n                Implement a version of the associated graded algebra\n                which does not require ``self`` to have a\n                distinguished basis.\n\n            EXAMPLES::\n\n                sage: A = AlgebrasWithBasis(ZZ).Filtered().example()\n                sage: A.graded_algebra()\n                Graded Algebra of An example of a filtered algebra with basis:\n                 the universal enveloping algebra of\n                 Lie algebra of RR^3 with cross product over Integer Ring\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of filtered algebras.\n\n    An algebra `A` over a commutative ring `R` is *filtered* if\n    `A` is endowed with a structure of a filtered `R`-module\n    (whose underlying `R`-module structure is identical with\n    that of the `R`-algebra `A`) such that the indexing set `I`\n    (typically `I = \\NN`) is also an additive abelian monoid,\n    the unity `1` of `A` belongs to `F_0`, and we have\n    `F_i \\cdot F_j \\subseteq F_{i+j}` for all `i, j \\in I`.\n\n    EXAMPLES::\n\n        sage: Algebras(ZZ).Filtered()\n        Category of filtered algebras over Integer Ring\n        sage: Algebras(ZZ).Filtered().super_categories()\n        [Category of algebras over Integer Ring,\n         Category of filtered modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(Algebras(ZZ).Filtered()).run()\n\n    REFERENCES:\n\n    - :wikipedia:`Filtered_algebra`\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.modules.Modules.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.sets_cat.Sets",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of associative algebras over a given base ring.\n\n    An associative algebra over a ring `R` is a module over `R` which\n    is also a not necessarily unital ring.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`AssociativeAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.associative_algebras import AssociativeAlgebras\n        sage: C = AssociativeAlgebras(ZZ); C\n        Category of associative algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Associative()\n        True\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        An abstract class for elements of an associative algebra.\n\n        .. NOTE::\n\n            ``Magmas.Element.__mul__`` is preferable to\n            ``Modules.Element.__mul__`` since the later does not\n            handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.rngs.Rngs",
            "sage.categories.magmatic_algebras.MagmaticAlgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of associative algebras over a given base ring.\n\n    An associative algebra over a ring `R` is a module over `R` which\n    is also a not necessarily unital ring.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`AssociativeAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.associative_algebras import AssociativeAlgebras\n        sage: C = AssociativeAlgebras(ZZ); C\n        Category of associative algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Associative()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.associative_algebras.AssociativeAlgebras",
        "parent_class": {
            "__doc__": "\n    The category of associative algebras over a given base ring.\n\n    An associative algebra over a ring `R` is a module over `R` which\n    is also a not necessarily unital ring.\n\n    .. WARNING::\n\n        Until :trac:`15043` is implemented, :class:`Algebras` is the\n        category of associative unital algebras; thus, unlike the name\n        suggests, :class:`AssociativeAlgebras` is not a subcategory of\n        :class:`Algebras` but of\n        :class:`~.magmatic_algebras.MagmaticAlgebras`.\n\n    EXAMPLES::\n\n        sage: from sage.categories.associative_algebras import AssociativeAlgebras\n        sage: C = AssociativeAlgebras(ZZ); C\n        Category of associative algebras over Integer Ring\n\n    TESTS::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C is MagmaticAlgebras(ZZ).Associative()\n        True\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": "\n        An abstract class for elements of an associative algebra.\n\n        .. NOTE::\n\n            ``Magmas.Element.__mul__`` is preferable to\n            ``Modules.Element.__mul__`` since the later does not\n            handle products of two elements of ``self``.\n\n        TESTS::\n\n            sage: A = AlgebrasWithBasis(QQ).example(); A\n            An example of an algebra with basis: the free algebra\n            on the generators ('a', 'b', 'c') over Rational Field\n            sage: x = A.an_element()\n            sage: x\n            B[word: ] + 2*B[word: a] + 3*B[word: b] + B[word: bab]\n            sage: x.__mul__(x)\n            B[word: ] + 4*B[word: a] + 4*B[word: aa] + 6*B[word: ab]\n            + 2*B[word: abab] + 6*B[word: b] + 6*B[word: ba]\n            + 2*B[word: bab] + 2*B[word: baba] + 3*B[word: babb]\n            + B[word: babbab] + 9*B[word: bb] + 3*B[word: bbab]\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras with basis constructed by tensor product of algebras with basis\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of algebras with basis\n            ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.algebras.Algebras.TensorProducts",
            "sage.categories.vector_spaces.VectorSpaces.WithBasis.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of algebras with basis constructed by tensor product of algebras with basis\n        ",
            "methods": {}
        },
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis.TensorProducts",
        "parent_class": {
            "__doc__": "\n            implements operations on tensor products of algebras with basis\n            ",
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n            Implements operations on elements of tensor products of algebras with basis\n            ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis",
            "sage.categories.unital_algebras.UnitalAlgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.unital_algebras.UnitalAlgebras.WithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "from_base_ring_from_one_basis": {
                    "__doc__": "\n                Implement the canonical embeding from the ground ring.\n\n                INPUT:\n\n                - ``r`` -- an element of the coefficient ring\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example()\n                    sage: A.from_base_ring_from_one_basis(3)\n                    3*B[word: ]\n                    sage: A.from_base_ring(3)\n                    3*B[word: ]\n                    sage: A(3)\n                    3*B[word: ]\n                ",
                    "args": [
                        "self",
                        "r"
                    ],
                    "argspec": [
                        [
                            "self",
                            "r"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "one_basis": {
                    "__doc__": "\n                When the one of an algebra with basis is an element of\n                this basis, this optional method can return the index of\n                this element. This is used to provide a default\n                implementation of :meth:`.one`, and an optimized default\n                implementation of :meth:`.from_base_ring`.\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example()\n                    sage: A.one_basis()\n                    word: \n                    sage: A.one()\n                    B[word: ]\n                    sage: A.from_base_ring(4)\n                    4*B[word: ]\n                ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "one_from_one_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.magmas.Magmas"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of graded algebras with a distinguished basis\n\n    EXAMPLES::\n\n        sage: C = GradedAlgebrasWithBasis(ZZ); C\n        Category of graded algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered algebras with basis over Integer Ring,\n         Category of graded algebras over Integer Ring,\n         Category of graded modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.filtered_algebras_with_basis.FilteredAlgebrasWithBasis",
            "sage.categories.graded_algebras.GradedAlgebras",
            "sage.categories.graded_modules_with_basis.GradedModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of graded algebras with a distinguished basis\n\n    EXAMPLES::\n\n        sage: C = GradedAlgebrasWithBasis(ZZ); C\n        Category of graded algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of filtered algebras with basis over Integer Ring,\n         Category of graded algebras over Integer Ring,\n         Category of graded modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.graded_algebras_with_basis.GradedAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of filtered algebras with a distinguished\n    homogeneous basis.\n\n    A filtered algebra with basis over a commutative ring `R`\n    is a filtered algebra over `R` endowed with the structure\n    of a filtered module with basis (with the same underlying\n    filtered-module structure). See\n    :class:`~sage.categories.filtered_algebras.FilteredAlgebras` and\n    :class:`~sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis`\n    for these two notions.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(ZZ).Filtered(); C\n        Category of filtered algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras with basis over Integer Ring,\n         Category of filtered algebras over Integer Ring,\n         Category of filtered modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.filtered_algebras.FilteredAlgebras",
            "sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of filtered algebras with a distinguished\n    homogeneous basis.\n\n    A filtered algebra with basis over a commutative ring `R`\n    is a filtered algebra over `R` endowed with the structure\n    of a filtered module with basis (with the same underlying\n    filtered-module structure). See\n    :class:`~sage.categories.filtered_algebras.FilteredAlgebras` and\n    :class:`~sage.categories.filtered_modules_with_basis.FilteredModulesWithBasis`\n    for these two notions.\n\n    EXAMPLES::\n\n        sage: C = AlgebrasWithBasis(ZZ).Filtered(); C\n        Category of filtered algebras with basis over Integer Ring\n        sage: sorted(C.super_categories(), key=str)\n        [Category of algebras with basis over Integer Ring,\n         Category of filtered algebras over Integer Ring,\n         Category of filtered modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.filtered_algebras_with_basis.FilteredAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of finite dimensional algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = FiniteDimensionalAlgebrasWithBasis(QQ); C\n        Category of finite dimensional algebras with basis over Rational Field\n        sage: C.super_categories()\n        [Category of algebras with basis over Rational Field,\n         Category of finite dimensional modules with basis over Rational Field]\n        sage: C.example()\n        An example of a finite dimensional algebra with basis:\n        the path algebra of the Kronecker quiver\n        (containing the arrows a:x->y and b:x->y) over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Algebras(QQ).FiniteDimensional().WithBasis()\n        True\n        sage: C is Algebras(QQ).WithBasis().FiniteDimensional()\n        True\n    ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "FiniteDimensional",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "_matrix_": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "on_left_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "to_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of finite dimensional algebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: C = FiniteDimensionalAlgebrasWithBasis(QQ); C\n        Category of finite dimensional algebras with basis over Rational Field\n        sage: C.super_categories()\n        [Category of algebras with basis over Rational Field,\n         Category of finite dimensional modules with basis over Rational Field]\n        sage: C.example()\n        An example of a finite dimensional algebra with basis:\n        the path algebra of the Kronecker quiver\n        (containing the arrows a:x->y and b:x->y) over Rational Field\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n        sage: C is Algebras(QQ).FiniteDimensional().WithBasis()\n        True\n        sage: C is Algebras(QQ).WithBasis().FiniteDimensional()\n        True\n    ",
            "methods": {}
        },
        "name": "sage.categories.finite_dimensional_algebras_with_basis.FiniteDimensionalAlgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "cartan_invariants_matrix": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "center": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "center_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "idempotent_lift": {
                    "__doc__": "\n            Lift an idempotent of the semisimple quotient into an idempotent of ``self``.\n\n            Let `A` be this finite dimensional algebra and `\\pi` be\n            the projection `A \\rightarrow \\overline{A}` on its\n            semisimple quotient. Let `\\overline{x}` be an idempotent\n            of `\\overline A`, and `x` any lift thereof in `A`. This\n            returns an idempotent `e` of `A` such that `\\pi(e)=\\pi(x)`\n            and `e` is a polynomial in `x`.\n\n            INPUT:\n\n            - `x` -- an element of `A` that projects on an idempotent\n              `\\overline x` of the semisimple quotient of `A`.\n              Alternatively one may give as input the idempotent\n              `\\overline{x}`, in which case some lift thereof will be\n              taken for `x`.\n\n            OUTPUT: the idempotent `e` of ``self``\n\n            ALGORITHM:\n\n            Iterate the formula `1 - (1 - x^2)^2` until having an\n            idempotent.\n\n            See [CR62]_ for correctness and termination proofs.\n\n            EXAMPLES::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example()\n                sage: S = A.semisimple_quotient()\n                sage: A.idempotent_lift(S.basis()['x'])\n                x\n                sage: A.idempotent_lift(A.basis()['y'])\n                y\n\n            .. TODO::\n\n                Add some non trivial example\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "is_commutative": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "is_identity_decomposition_into_orthogonal_idempotents": {
                    "__doc__": "\n            Return whether ``l`` is a decomposition of the identity\n            into orthogonal idempotents.\n\n            INPUT:\n\n            - ``l`` -- a list or iterable of elements of ``self``\n\n            EXAMPLES::\n\n                sage: A = FiniteDimensionalAlgebrasWithBasis(QQ).example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n\n                sage: x,y,a,b = A.algebra_generators(); x,y,a,b\n                (x, y, a, b)\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([A.one()])\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([x,y])\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([x+a, y-a])\n                True\n\n            Here the idempotents do not sum up to `1`::\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([x])\n                False\n\n            Here `1+x` and `-x` are neither idempotent nor orthogonal::\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents([1+x,-x])\n                False\n\n            With the algebra of the `0`-Hecke monoid::\n\n                sage: from sage.monoids.hecke_monoid import HeckeMonoid\n                sage: A = HeckeMonoid(SymmetricGroup(4)).algebra(QQ)\n                sage: idempotents = A.orthogonal_idempotents_central_mod_radical()\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents(idempotents)\n                True\n\n            Here are some more counterexamples:\n\n            1. Some orthogonal elements summing to `1` but not being\n            idempotent::\n\n                sage: class PQAlgebra(CombinatorialFreeModule):\n                ....:     def __init__(self, F, p):\n                ....:         # Construct the quotient algebra F[x] / p,\n                ....:         # where p is a univariate polynomial.\n                ....:         R = parent(p); x = R.gen()\n                ....:         I = R.ideal(p)\n                ....:         self._xbar = R.quotient(I).gen()\n                ....:         basis_keys = [self._xbar**i for i in range(p.degree())]\n                ....:         CombinatorialFreeModule.__init__(self, F, basis_keys,\n                ....:                 category=Algebras(F).FiniteDimensional().WithBasis())\n                ....:     def x(self):\n                ....:         return self(self._xbar)\n                ....:     def one(self):\n                ....:         return self.basis()[self.base_ring().one()]\n                ....:     def product_on_basis(self, w1, w2):\n                ....:         return self.from_vector(vector(w1*w2))\n                sage: R.<x> = PolynomialRing(QQ)\n                sage: A = PQAlgebra(QQ, x**3 - x**2 + x + 1); y = A.x()\n                sage: a, b = y, 1-y\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, b))\n                False\n\n            For comparison::\n\n                sage: A = PQAlgebra(QQ, x**2 - x); y = A.x()\n                sage: a, b = y, 1-y\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, b))\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, A.zero(), b))\n                True\n                sage: A = PQAlgebra(QQ, x**3 - x**2 + x - 1); y = A.x()\n                sage: a = (y**2 + 1) / 2\n                sage: b = 1 - a\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, b))\n                True\n\n            2. Some idempotents summing to 1 but not orthogonal::\n\n                sage: R.<x> = PolynomialRing(GF(2))\n                sage: A = PQAlgebra(GF(2), x)\n                sage: a = A.one()\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a,))\n                True\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a, a, a))\n                False\n\n            3. Some orthogonal idempotents not summing to the identity::\n\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents((a,a))\n                False\n                sage: A.is_identity_decomposition_into_orthogonal_idempotents(())\n                False\n            ",
                    "args": [
                        "self",
                        "l"
                    ],
                    "argspec": [
                        [
                            "self",
                            "l"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "isotypic_projective_modules": {
                    "__doc__": "\n            Return the isotypic projective ``side`` ``self``-modules.\n\n            Let `P_i` be representatives of the indecomposable\n            projective ``side``-modules of this finite dimensional\n            algebra `A`, and `S_i` be the associated simple modules.\n\n            The regular ``side`` representation of `A` can be\n            decomposed as a direct sum `A = \\bigoplus_i Q_i` where\n            each `Q_i` is an isotypic projective module; namely `Q_i`\n            is the direct sum of `\\dim S_i` copies of the\n            indecomposable projective module `P_i`. This decomposition\n            is not unique.\n\n            The isotypic projective modules are constructed as\n            `Q_i=e_iA`, where the `(e_i)_i` is the decomposition of\n            the identity into orthogonal idempotents obtained by\n            lifting the central orthogonal idempotents of the\n            semisimple quotient of `A`.\n\n            INPUT:\n\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            OUTPUT: a list of subspaces of ``self``.\n\n            EXAMPLES::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: Q = A.isotypic_projective_modules(side=\"left\"); Q\n                [Free module generated by {0} over Rational Field,\n                 Free module generated by {0, 1, 2} over Rational Field]\n                sage: [[x.lift() for x in Qi.basis()]\n                ....:  for Qi in Q]\n                [[x],\n                 [y, a, b]]\n\n            We check that the sum of the dimensions of the isotypic\n            projective modules is the dimension of ``self``::\n\n                sage: sum([Qi.dimension() for Qi in Q]) == A.dimension()\n                True\n\n            .. SEEALSO::\n\n                - :meth:`orthogonal_idempotents_central_mod_radical`\n                - :meth:`peirce_decomposition`\n            ",
                    "args": [
                        "self",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "left"
                        ]
                    ]
                },
                "orthogonal_idempotents_central_mod_radical": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "peirce_decomposition": {
                    "__doc__": "\n            Return a Peirce decomposition of ``self``.\n\n            Let `(e_i)_i` be a collection of orthogonal idempotents of\n            `A` with sum `1`. The *Peirce decomposition* of `A` is the\n            decomposition of `A` into the direct sum of the subspaces\n            `e_i A e_j`.\n\n            With the default collection of orthogonal idempotents, one has\n\n            .. MATH::\n\n                \\dim e_i A e_j = C_{i,j} \\dim S_i \\dim S_j\n\n            where `(S_i)_i` are the simple modules of `A` and\n            `(C_{i,j})_{i, j}` is the Cartan invariants matrix.\n\n            INPUT:\n\n            - ``idempotents`` -- a list of orthogonal idempotents\n              `(e_i)_{i=0,\\ldots,n}` of the algebra that sum to `1`\n              (default: the idempotents returned by\n              :meth:`orthogonal_idempotents_central_mod_radical`)\n\n            - ``check`` -- (default: ``True``) whether to check that the\n              idempotents are indeed orthogonal and idempotent and\n              sum to `1`\n\n            OUTPUT:\n\n            A list of lists `l` such that ``l[i][j]`` is the subspace\n            `e_i A e_j`.\n\n            .. SEEALSO::\n\n                - :meth:`orthogonal_idempotents_central_mod_radical`\n                - :meth:`cartan_invariants_matrix`\n\n            EXAMPLES::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: A.orthogonal_idempotents_central_mod_radical()\n                (x, y)\n                sage: decomposition = A.peirce_decomposition(); decomposition\n                [[Free module generated by {0} over Rational Field,\n                  Free module generated by {0, 1} over Rational Field],\n                 [Free module generated by {} over Rational Field,\n                  Free module generated by {0} over Rational Field]]\n                sage: [ [[x.lift() for x in decomposition[i][j].basis()]\n                ....:    for j in range(2)]\n                ....:   for i in range(2)]\n                [[[x], [a, b]],\n                 [[], [y]]]\n\n            We recover that the group algebra of the symmetric group\n            `S_4` is a block matrix algebra::\n\n                sage: A = SymmetricGroup(4).algebra(QQ)\n                sage: decomposition = A.peirce_decomposition()   # long time\n                sage: [[decomposition[i][j].dimension()          # long time (4s)\n                ....:   for j in range(len(decomposition))]\n                ....:  for i in range(len(decomposition))]\n                [[1, 0, 0, 0, 0],\n                 [0, 9, 0, 0, 0],\n                 [0, 0, 4, 0, 0],\n                 [0, 0, 0, 9, 0],\n                 [0, 0, 0, 0, 1]]\n\n            The dimension of each block is `d^2`, where `d` is the\n            dimension of the corresponding simple module of `S_4`. The\n            latter are given by::\n\n                sage: [p.standard_tableaux().cardinality() for p in Partitions(4)]\n                [1, 3, 2, 3, 1]\n            ",
                    "args": [
                        "self",
                        "idempotents",
                        "check"
                    ],
                    "argspec": [
                        [
                            "self",
                            "idempotents",
                            "check"
                        ],
                        null,
                        null,
                        [
                            null,
                            true
                        ]
                    ]
                },
                "peirce_summand": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "principal_ideal": {
                    "__doc__": "\n            Construct the ``side`` principal ideal generated by ``a``.\n\n            EXAMPLES:\n\n            In order to highlight the difference between left and\n            right principal ideals, our first example deals with a non\n            commutative algebra::\n\n                sage: A = Algebras(QQ).FiniteDimensional().WithBasis().example(); A\n                An example of a finite dimensional algebra with basis:\n                the path algebra of the Kronecker quiver\n                (containing the arrows a:x->y and b:x->y) over Rational Field\n                sage: x, y, a, b = A.basis()\n\n            In this algebra, multiplication on the right by `x`\n            annihilates all basis elements but `x`::\n\n                sage: x*x, y*x, a*x, b*x\n                (x, 0, 0, 0)\n\n            so the left ideal generated by `x` is one-dimensional::\n\n                sage: Ax = A.principal_ideal(x, side='left'); Ax\n                Free module generated by {0} over Rational Field\n                sage: [B.lift() for B in Ax.basis()]\n                [x]\n\n            Multiplication on the left by `x` annihilates\n            only `x` and fixes the other basis elements::\n\n                sage: x*x, x*y, x*a, x*b\n                (x, 0, a, b)\n\n            so the right ideal generated by `x` is 3-dimensional::\n\n                sage: xA = A.principal_ideal(x, side='right'); xA\n                Free module generated by {0, 1, 2} over Rational Field\n                sage: [B.lift() for B in xA.basis()]\n                [x, a, b]\n\n            .. SEEALSO::\n\n                - :meth:`peirce_summand`\n            ",
                    "args": [
                        "self",
                        "a",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "a",
                            "side"
                        ],
                        null,
                        null,
                        [
                            "left"
                        ]
                    ]
                },
                "radical": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "radical_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                },
                "semisimple_quotient": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "_matrix_": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "on_left_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                },
                "to_matrix": {
                    "__doc__": "\n            Return the matrix of the action of ``self`` on the algebra.\n\n            INPUT:\n\n            - ``base_ring`` -- the base ring for the matrix to be constructed\n            - ``action`` -- a bivariate function (default: :func:`operator.mul`)\n            - ``side`` -- 'left' or 'right' (default: 'left')\n\n            EXAMPLES::\n\n                sage: QS3 = SymmetricGroupAlgebra(QQ, 3)\n                sage: a = QS3([2,1,3])\n                sage: a.to_matrix(side='left')\n                [0 0 1 0 0 0]\n                [0 0 0 0 1 0]\n                [1 0 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 1 0 0 0 0]\n                [0 0 0 1 0 0]\n                sage: a.to_matrix(side='right')\n                [0 0 1 0 0 0]\n                [0 0 0 1 0 0]\n                [1 0 0 0 0 0]\n                [0 1 0 0 0 0]\n                [0 0 0 0 0 1]\n                [0 0 0 0 1 0]\n                sage: a.to_matrix(base_ring=RDF, side=\"left\")\n                [0.0 0.0 1.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 1.0 0.0]\n                [1.0 0.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 0.0 0.0 1.0]\n                [0.0 1.0 0.0 0.0 0.0 0.0]\n                [0.0 0.0 0.0 1.0 0.0 0.0]\n\n            AUTHORS: Mike Hansen, ...\n            ",
                    "args": [
                        "self",
                        "base_ring",
                        "action",
                        "side"
                    ],
                    "argspec": [
                        [
                            "self",
                            "base_ring",
                            "action",
                            "side"
                        ],
                        null,
                        null,
                        [
                            null,
                            "<built-in function mul>",
                            "left"
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "Distributive",
            "AdditiveUnital",
            "AdditiveAssociative",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital",
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.magmatic_algebras.MagmaticAlgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "algebra_generators": {
                    "__doc__": "\n            Return a family of generators of this algebra.\n\n            EXAMPLES::\n\n                sage: F = AlgebrasWithBasis(QQ).example(); F\n                An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n                sage: F.algebra_generators()\n                Family (B[word: a], B[word: b], B[word: c])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": "\n    The category of algebras over a given base ring.\n\n    An algebra over a ring `R` is a module over `R` endowed with a\n    bilinear multiplication.\n\n    .. WARNING::\n\n        :class:`MagmaticAlgebras` will eventually replace the current\n        :class:`Algebras` for consistency with\n        e.g. :wikipedia:`Algebras` which assumes neither associativity\n        nor the existence of a unit (see :trac:`15043`).\n\n    EXAMPLES::\n\n        sage: from sage.categories.magmatic_algebras import MagmaticAlgebras\n        sage: C = MagmaticAlgebras(ZZ); C\n        Category of magmatic algebras over Integer Ring\n        sage: C.super_categories()\n        [Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n         Category of modules over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(C).run()\n    ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.super_modules_with_basis.SuperModulesWithBasis",
            "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis",
            "sage.categories.coalgebras.Coalgebras.Super"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis.Super",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
        "axioms": [
            "AdditiveUnital",
            "Unital",
            "AdditiveAssociative",
            "AdditiveInverse",
            "AdditiveCommutative",
            "WithBasis",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras_with_basis.AlgebrasWithBasis",
            "sage.categories.algebras.Algebras.CartesianProducts",
            "sage.categories.vector_spaces.VectorSpaces.WithBasis.CartesianProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
            "methods": {}
        },
        "name": "sage.categories.algebras_with_basis.AlgebrasWithBasis.CartesianProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "one_from_cartesian_product_of_one_basis": {
                    "__doc__": "CachedMethod(f, name=None, key=None)\nFile: sage/misc/cachefunc.pyx (starting at line 2442)\n\n    A decorator that creates a cached version of an instance\n    method of a class.\n\n    .. NOTE::\n\n        For proper behavior, the method must be a pure function (no side\n        effects). Arguments to the method must be hashable or transformed into\n        something hashable using ``key`` or they must define\n        :meth:`sage.structure.sage_object.SageObject._cache_key`.\n\n    EXAMPLES::\n\n        sage: class Foo(object):\n        ....:     @cached_method\n        ....:     def f(self, t, x=2):\n        ....:         print('computing')\n        ....:         return t**x\n        sage: a = Foo()\n\n    The example shows that the actual computation\n    takes place only once, and that the result is\n    identical for equivalent input::\n\n        sage: res = a.f(3, 2); res\n        computing\n        9\n        sage: a.f(t = 3, x = 2) is res\n        True\n        sage: a.f(3) is res\n        True\n\n    Note, however, that the :class:`CachedMethod` is replaced by a\n    :class:`CachedMethodCaller` or :class:`CachedMethodCallerNoArgs`\n    as soon as it is bound to an instance or class::\n\n        sage: P.<a,b,c,d> = QQ[]\n        sage: I = P*[a,b]\n        sage: type(I.__class__.gens)\n        <type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\n\n    So, you would hardly ever see an instance of this class alive.\n\n    The parameter ``key`` can be used to pass a function which creates a\n    custom cache key for inputs. In the following example, this parameter is\n    used to ignore the ``algorithm`` keyword for caching::\n\n        sage: class A(object):\n        ....:     def _f_normalize(self, x, algorithm): return x\n        ....:     @cached_method(key=_f_normalize)\n        ....:     def f(self, x, algorithm='default'): return x\n        sage: a = A()\n        sage: a.f(1, algorithm=\"default\") is a.f(1) is a.f(1, algorithm=\"algorithm\")\n        True\n\n    Cached methods can not be copied like usual methods, see :trac:`12603`.\n    Copying them can lead to very surprising results::\n\n        sage: class A:\n        ....:     @cached_method\n        ....:     def f(self):\n        ....:         return 1\n        sage: class B:\n        ....:     g=A.f\n        ....:     def f(self):\n        ....:         return 2\n\n        sage: b=B()\n        sage: b.f()\n        2\n        sage: b.g()\n        1\n        sage: b.f()\n        1\n\n    ",
                    "args": [
                        "self",
                        "inst"
                    ],
                    "argspec": [
                        [
                            "self",
                            "inst"
                        ],
                        "args",
                        "kwds",
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.sets_cat.Sets",
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.sets_cat.Sets.CartesianProducts",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": "\n        The category of algebras with basis, constructed as Cartesian\n        products of algebras with basis.\n\n        Note: this construction give the direct products of algebras with basis.\n        See comment in :class:`Algebras.CartesianProducts\n        <sage.categories.algebras.Algebras.CartesianProducts>`\n        ",
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of coalgebras\n\n    EXAMPLES::\n\n        sage: Coalgebras(QQ)\n        Category of coalgebras over Rational Field\n        sage: Coalgebras(QQ).super_categories()\n        [Category of vector spaces over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(Coalgebras(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "coproduct": {
                    "__doc__": "\n            Returns the coproduct of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.coproduct()\n                (B[(1,2,3)], B[(1,2,3)] # B[(1,2,3)])\n                sage: b, b.coproduct()\n                (B[(1,3)], B[(1,3)] # B[(1,3)])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit": {
                    "__doc__": "\n            Returns the counit of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.counit()\n                (B[(1,2,3)], 1)\n                sage: b, b.counit()\n                (B[(1,3)], 1)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of coalgebras\n\n    EXAMPLES::\n\n        sage: Coalgebras(QQ)\n        Category of coalgebras over Rational Field\n        sage: Coalgebras(QQ).super_categories()\n        [Category of vector spaces over Rational Field]\n\n    TESTS::\n\n        sage: TestSuite(Coalgebras(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "coproduct": {
                    "__doc__": "\n            Returns the coproduct of x.\n\n            Eventually, there will be a default implementation,\n            delegating to the overloading mechanism and forcing the\n            conversion back\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, A.coproduct(a)\n                (B[(1,2,3)], B[(1,2,3)] # B[(1,2,3)])\n                sage: b, A.coproduct(b)\n                (B[(1,3)], B[(1,3)] # B[(1,3)])\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit": {
                    "__doc__": "\n            Returns the counit of x.\n\n            Eventually, there will be a default implementation,\n            delegating to the overloading mechanism and forcing the\n            conversion back\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, A.counit(a)\n                (B[(1,2,3)], 1)\n                sage: b, A.counit(b)\n                (B[(1,3)], 1)\n\n            TODO: implement some tests of the axioms of coalgebras, bialgebras\n            and Hopf algebras using the counit.\n            ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "coproduct": {
                    "__doc__": "\n            Returns the coproduct of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.coproduct()\n                (B[(1,2,3)], B[(1,2,3)] # B[(1,2,3)])\n                sage: b, b.coproduct()\n                (B[(1,3)], B[(1,3)] # B[(1,3)])\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit": {
                    "__doc__": "\n            Returns the counit of ``self``\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: [a,b] = A.algebra_generators()\n                sage: a, a.counit()\n                (B[(1,2,3)], 1)\n                sage: b, b.counit()\n                (B[(1,3)], 1)\n            ",
                    "args": [
                        "self"
                    ],
                    "argspec": [
                        [
                            "self"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.super_modules.SuperModules",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.Super",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": "\n    The category of coalgebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: CoalgebrasWithBasis(ZZ)\n        Category of coalgebras with basis over Integer Ring\n        sage: sorted(CoalgebrasWithBasis(ZZ).super_categories(), key=str)\n        [Category of coalgebras over Integer Ring,\n         Category of modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(CoalgebrasWithBasis(ZZ)).run()\n    ",
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {
                "coproduct_iterated": {
                    "__doc__": "\n            Apply ``n`` coproducts to ``self``.\n\n            .. TODO::\n\n                Remove dependency on ``modules_with_basis`` methods.\n\n            EXAMPLES::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(2)\n                Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[2, 2] # Psi[] + 2*Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[2] # Psi[2] # Psi[] + Psi[2, 2] # Psi[] # Psi[]\n\n            TESTS::\n\n                sage: p = SymmetricFunctions(QQ).p()\n                sage: p[5,2,2].coproduct_iterated()\n                p[] # p[5, 2, 2] + 2*p[2] # p[5, 2] + p[2, 2] # p[5]\n                 + p[5] # p[2, 2] + 2*p[5, 2] # p[2] + p[5, 2, 2] # p[]\n                sage: p([]).coproduct_iterated(3)\n                p[] # p[] # p[] # p[]\n\n            ::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(3)\n                Psi[] # Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[] # Psi[2, 2] # Psi[] + 2*Psi[] # Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[] # Psi[2] # Psi[2] # Psi[] + Psi[] # Psi[2, 2] # Psi[] # Psi[]\n                 + 2*Psi[2] # Psi[] # Psi[] # Psi[2] + 2*Psi[2] # Psi[] # Psi[2] # Psi[]\n                 + 2*Psi[2] # Psi[2] # Psi[] # Psi[] + Psi[2, 2] # Psi[] # Psi[] # Psi[]\n\n            ::\n\n                sage: m = SymmetricFunctionsNonCommutingVariables(QQ).m()\n                sage: m[[1,3],[2]].coproduct_iterated(2)\n                m{} # m{} # m{{1, 3}, {2}} + m{} # m{{1}} # m{{1, 2}}\n                 + m{} # m{{1, 2}} # m{{1}} + m{} # m{{1, 3}, {2}} # m{}\n                 + m{{1}} # m{} # m{{1, 2}} + m{{1}} # m{{1, 2}} # m{}\n                 + m{{1, 2}} # m{} # m{{1}} + m{{1, 2}} # m{{1}} # m{}\n                 + m{{1, 3}, {2}} # m{} # m{}\n                sage: m[[]].coproduct_iterated(3), m[[1,3],[2]].coproduct_iterated(0)\n                (m{} # m{} # m{} # m{}, m{{1, 3}, {2}})\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        [
                            1
                        ]
                    ]
                }
            }
        },
        "gap": null,
        "implied": [
            "sage.categories.vector_spaces.VectorSpaces.WithBasis",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": "\n    The category of coalgebras with a distinguished basis.\n\n    EXAMPLES::\n\n        sage: CoalgebrasWithBasis(ZZ)\n        Category of coalgebras with basis over Integer Ring\n        sage: sorted(CoalgebrasWithBasis(ZZ).super_categories(), key=str)\n        [Category of coalgebras over Integer Ring,\n         Category of modules with basis over Integer Ring]\n\n    TESTS::\n\n        sage: TestSuite(CoalgebrasWithBasis(ZZ)).run()\n    ",
            "methods": {}
        },
        "name": "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "coproduct_on_basis": {
                    "__doc__": "\n            The coproduct of the algebra on the basis (optional).\n\n            INPUT:\n\n            - ``i`` -- the indices of an element of the basis of ``self``\n\n            Returns the coproduct of the corresponding basis elements\n            If implemented, the coproduct of the algebra is defined\n            from it by linearity.\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: (a, b) = A._group.gens()\n                sage: A.coproduct_on_basis(a)\n                B[(1,2,3)] # B[(1,2,3)]\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit_on_basis": {
                    "__doc__": "\n            The counit of the algebra on the basis (optional).\n\n            INPUT:\n\n            - ``i`` -- the indices of an element of the basis of ``self``\n\n            Returns the counit of the corresponding basis elements\n            If implemented, the counit of the algebra is defined\n            from it by linearity.\n\n            EXAMPLES::\n\n                sage: A = HopfAlgebrasWithBasis(QQ).example(); A\n                An example of Hopf algebra with basis: the group algebra of the Dihedral group of order 6 as a permutation group over Rational Field\n                sage: (a, b) = A._group.gens()\n                sage: A.counit_on_basis(a)\n                1\n            ",
                    "args": [
                        "self",
                        "i"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {
                "coproduct_iterated": {
                    "__doc__": "\n            Apply ``n`` coproducts to ``self``.\n\n            .. TODO::\n\n                Remove dependency on ``modules_with_basis`` methods.\n\n            EXAMPLES::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(2)\n                Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[2, 2] # Psi[] + 2*Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[2] # Psi[2] # Psi[] + Psi[2, 2] # Psi[] # Psi[]\n\n            TESTS::\n\n                sage: p = SymmetricFunctions(QQ).p()\n                sage: p[5,2,2].coproduct_iterated()\n                p[] # p[5, 2, 2] + 2*p[2] # p[5, 2] + p[2, 2] # p[5]\n                 + p[5] # p[2, 2] + 2*p[5, 2] # p[2] + p[5, 2, 2] # p[]\n                sage: p([]).coproduct_iterated(3)\n                p[] # p[] # p[] # p[]\n\n            ::\n\n                sage: Psi = NonCommutativeSymmetricFunctions(QQ).Psi()\n                sage: Psi[2,2].coproduct_iterated(0)\n                Psi[2, 2]\n                sage: Psi[2,2].coproduct_iterated(3)\n                Psi[] # Psi[] # Psi[] # Psi[2, 2] + 2*Psi[] # Psi[] # Psi[2] # Psi[2]\n                 + Psi[] # Psi[] # Psi[2, 2] # Psi[] + 2*Psi[] # Psi[2] # Psi[] # Psi[2]\n                 + 2*Psi[] # Psi[2] # Psi[2] # Psi[] + Psi[] # Psi[2, 2] # Psi[] # Psi[]\n                 + 2*Psi[2] # Psi[] # Psi[] # Psi[2] + 2*Psi[2] # Psi[] # Psi[2] # Psi[]\n                 + 2*Psi[2] # Psi[2] # Psi[] # Psi[] + Psi[2, 2] # Psi[] # Psi[] # Psi[]\n\n            ::\n\n                sage: m = SymmetricFunctionsNonCommutingVariables(QQ).m()\n                sage: m[[1,3],[2]].coproduct_iterated(2)\n                m{} # m{} # m{{1, 3}, {2}} + m{} # m{{1}} # m{{1, 2}}\n                 + m{} # m{{1, 2}} # m{{1}} + m{} # m{{1, 3}, {2}} # m{}\n                 + m{{1}} # m{} # m{{1, 2}} + m{{1}} # m{{1, 2}} # m{}\n                 + m{{1, 2}} # m{} # m{{1}} + m{{1, 2}} # m{{1}} # m{}\n                 + m{{1, 3}, {2}} # m{} # m{}\n                sage: m[[]].coproduct_iterated(3), m[[1,3],[2]].coproduct_iterated(0)\n                (m{} # m{} # m{} # m{}, m{{1, 3}, {2}})\n            ",
                    "args": [
                        "self",
                        "n"
                    ],
                    "argspec": [
                        [
                            "self",
                            "n"
                        ],
                        null,
                        null,
                        [
                            1
                        ]
                    ]
                }
            }
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "Facade",
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.WithRealizations",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.WithRealizations",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "WithBasis",
            "Distributive"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.magmatic_algebras.MagmaticAlgebras",
            "sage.categories.vector_spaces.VectorSpaces.WithBasis"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "_product_from_product_on_basis_multiply": {
                    "__doc__": "\n                Computes the product of two elements by extending\n                bilinearly the method :meth:`product_on_basis`.\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example(); A\n                    An example of an algebra with basis: the free algebra on the generators ('a', 'b', 'c') over Rational Field\n                    sage: (a,b,c) = A.algebra_generators()\n                    sage: A._product_from_product_on_basis_multiply(a*b + 2*c, a - b)\n                    B[word: aba] - B[word: abb] + 2*B[word: ca] - 2*B[word: cb]\n\n                ",
                    "args": [
                        "self",
                        "left",
                        "right"
                    ],
                    "argspec": [
                        [
                            "self",
                            "left",
                            "right"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "product_on_basis": {
                    "__doc__": "\n                The product of the algebra on the basis (optional).\n\n                INPUT:\n\n                - ``i``, ``j`` -- the indices of two elements of the\n                  basis of ``self``\n\n                Return the product of the two corresponding basis elements\n                indexed by ``i`` and ``j``.\n\n                If implemented, :meth:`product` is defined from\n                it by bilinearity.\n\n                EXAMPLES::\n\n                    sage: A = AlgebrasWithBasis(QQ).example()\n                    sage: Word = A.basis().keys()\n                    sage: A.product_on_basis(Word(\"abc\"),Word(\"cba\"))\n                    B[word: abccba]\n                ",
                    "args": [
                        "self",
                        "i",
                        "j"
                    ],
                    "argspec": [
                        [
                            "self",
                            "i",
                            "j"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.magmas.Magmas",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.left_modules.LeftModules"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.vector_spaces.VectorSpaces.TensorProducts"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.TensorProducts",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.modules.Modules.TensorProducts",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.sets_cat.Sets",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.sets_cat.Sets.Realizations"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.Realizations",
        "parent_class": {
            "__doc__": null,
            "methods": {
                "coproduct_by_coercion": {
                    "__doc__": "\n                Return the coproduct by coercion if ``coproduct_by_basis``\n                is not implemented.\n\n                EXAMPLES::\n\n                    sage: Sym = SymmetricFunctions(QQ)\n                    sage: m = Sym.monomial()\n                    sage: f = m[2,1]\n                    sage: f.coproduct.__module__\n                    'sage.categories.coalgebras'\n                    sage: m.coproduct_on_basis\n                    NotImplemented\n                    sage: m.coproduct == m.coproduct_by_coercion\n                    True\n                    sage: f.coproduct()\n                    m[] # m[2, 1] + m[1] # m[2] + m[2] # m[1] + m[2, 1] # m[]\n\n                ::\n\n                    sage: N = NonCommutativeSymmetricFunctions(QQ)\n                    sage: R = N.ribbon()\n                    sage: R.coproduct_by_coercion.__module__\n                    'sage.categories.coalgebras'\n                    sage: R.coproduct_on_basis\n                    NotImplemented\n                    sage: R.coproduct == R.coproduct_by_coercion\n                    True\n                    sage: R[1].coproduct()\n                    R[] # R[1] + R[1] # R[]\n                ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                },
                "counit_by_coercion": {
                    "__doc__": "\n                Return the counit of ``x`` if ``counit_by_basis`` is\n                not implemented.\n\n                EXAMPLES::\n\n                    sage: sp = SymmetricFunctions(QQ).sp()\n                    sage: sp.an_element()\n                    2*sp[] + 2*sp[1] + 3*sp[2]\n                    sage: sp.counit(sp.an_element())\n                    2\n\n                    sage: o = SymmetricFunctions(QQ).o()\n                    sage: o.an_element()\n                    2*o[] + 2*o[1] + 3*o[2]\n                    sage: o.counit(o.an_element())\n                    -1\n                ",
                    "args": [
                        "self",
                        "x"
                    ],
                    "argspec": [
                        [
                            "self",
                            "x"
                        ],
                        null,
                        null,
                        null
                    ]
                }
            }
        },
        "structure": [
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.right_modules.RightModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.coalgebras.Coalgebras",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveUnital",
            "AdditiveInverse",
            "AdditiveAssociative",
            "Unital",
            "AdditiveCommutative",
            "Distributive",
            "Associative"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.algebras.Algebras",
            "sage.categories.vector_spaces.VectorSpaces.DualObjects"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras.Coalgebras.DualObjects",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.magmas.Magmas",
            "sage.categories.magmas.Magmas.Unital",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.right_modules.RightModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    },
    {
        "__doc__": null,
        "axioms": [
            "AdditiveCommutative",
            "AdditiveAssociative",
            "AdditiveUnital",
            "WithBasis",
            "AdditiveInverse"
        ],
        "element_class": {
            "__doc__": null,
            "methods": {}
        },
        "gap": null,
        "implied": [
            "sage.categories.super_modules_with_basis.SuperModulesWithBasis",
            "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis",
            "sage.categories.coalgebras.Coalgebras.Super"
        ],
        "mmt": null,
        "morphism_class": {
            "__doc__": null,
            "methods": {}
        },
        "name": "sage.categories.coalgebras_with_basis.CoalgebrasWithBasis.Super",
        "parent_class": {
            "__doc__": null,
            "methods": {}
        },
        "structure": [
            "sage.categories.sets_with_partial_maps.SetsWithPartialMaps",
            "sage.categories.right_modules.RightModules",
            "sage.categories.super_modules.SuperModules",
            "sage.categories.additive_magmas.AdditiveMagmas",
            "sage.categories.sets_cat.Sets",
            "sage.categories.filtered_modules.FilteredModules",
            "sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital",
            "sage.categories.graded_modules.GradedModules",
            "sage.categories.left_modules.LeftModules",
            "sage.categories.coalgebras.Coalgebras"
        ],
        "subcategory_class": {
            "__doc__": null,
            "methods": {}
        },
        "type": "Sage_Category"
    }
]